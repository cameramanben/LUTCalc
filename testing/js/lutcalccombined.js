/* splash.js
* Changes Javascript warning into a splash screen in the LUTCalc Web App.
* Also creates browser feature test and global data objects
* 17th March 2017
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
/************************* LUTInputs *************************/
/*********** Data available globally within LUTCalc **********/
function LUTInputs() {
	this.ready = [true,
		false, // 1 - camerabox
		false, // 2 - gammabox
		false, // 3 - tweaksbox
		false, // 4 - lutbox
		false, // 5 - generatebox
		false, // 6 - infobox
		false, // 7 - LUTAnalyst
		false, // 8 - preview
		false, // 9 - twkHG
		false, // 10 - twkLA
	];
	this.isMobile = false; // Assume not on a mobile until proven otherwise
}
LUTInputs.prototype.addInput = function(inputName,inputValue) {
	try {
		this[inputName] = inputValue;
		return true;
	} catch(err) {
		return false;
	}
};
LUTInputs.prototype.isReady = function(ui) {
	var ready = true;
	var m = this.ready.length;
	for (var j=0; j<m ; j++) {
		if (!this.ready[j]) {
			ready = false;
			break;
		}
	}
	if (ready) { // protect against double responses from message
		return false;
	}
	this.ready[ui] = true;
	ready = true;
	for (var j=0; j<m ; j++) {
		if (!this.ready[j]) {
			ready = false;
			break;
		}
	}
	return ready;
};
/************************** LUTTests *************************/
/******************* Browser feature tests *******************/
function LUTTests(inputs) {
	this.inputs = inputs;
	this.inputs.addInput('isTrans',false);
	this.runTests();
}
LUTTests.prototype.runTests = function() {
	this.isAppTest();
	this.isChromeAppTest();
	this.blobWorkersTest();
	this.canNotifyTest();
	this.isLETest();
};
LUTTests.prototype.isAppTest = function() { // Test for native app bridges
	if (typeof window.webkit !== 'undefined' && window.webkit && window.webkit.messageHandlers) {
        lutInputs.addInput('appleApp',true);
    	lutInputs.addInput('isApp',true);
	} else if (typeof window.lutCalcApp !== 'undefined') {
    	lutInputs.addInput('appleApp',false);
    	lutInputs.addInput('isApp',true);
	} else {
    	lutInputs.addInput('appleApp',false);
    	lutInputs.addInput('isApp',false);
	}
};
LUTTests.prototype.isChromeAppTest = function() { // Test for Google Chrome app
	if (typeof chrome !== 'undefined' && typeof chrome.fileSystem !== 'undefined' && typeof chrome.fileSystem.chooseEntry !== 'undefined') {
    	lutInputs.addInput('isChromeApp',true);
	} else {
    	lutInputs.addInput('isChromeApp',false);
	}
};
LUTTests.prototype.blobWorkersTest = function() {
    lutInputs.addInput('blobWorkers',false);
	if (window.Blob && (window.URL || window.webkitURL)) {
		this.inputs.blobWorkers = true;
		var windowURL = window.URL || window.webkitURL;
		var workerString = "addEventListener('message', function(e) { postMessage({blobWorkers:e.data.test}); }, false);";
		workerString = workerString.replace('"use strict";', '');
		try {
			var _this = this;
			var gammaWorkerBlob = new Blob([ workerString ], { type: 'text/javascript' } );
			var blobURL = windowURL.createObjectURL(gammaWorkerBlob);
			this.testWorker = new Worker(blobURL);
			URL.revokeObjectURL(blobURL);
	  		this.testWorker.terminate();
			this.inputs.blobWorkers = true;
/*
			this.testWorker.addEventListener('message', function(e) {
	  			_this.inputs.blobWorkers = e.data.blobWorkers;
	  			_this.testWorker.terminate();
			}, false);
			this.testWorker.postMessage({test:true});
*/
		} catch (e) {
			this.inputs.blobWorkers = false;
		}
	}
};
LUTTests.prototype.canNotifyTest = function() { // Test for HTML5 / Chrome Notifications
	if (typeof chrome !== 'undefined' && typeof chrome.notifications !== 'undefined') {
    	lutInputs.addInput('canChromeNotify',true);
    } else {
    	lutInputs.addInput('canChromeNotify',false);
	}
};
LUTTests.prototype.isLETest = function() { // Test system endianness
	if ((new Int8Array(new Int16Array([1]).buffer)[0]) > 0) {
		lutInputs.addInput('isLE', true);
	} else {
		lutInputs.addInput('isLE', false);
	}
};
LUTTests.prototype.isTransTest = function(worker) { // Test that web workers can use transferrable objects
	var trans;
	try {
		var test = new ArrayBuffer(1);
		worker.postMessage(test, [test]);
		trans = (test.byteLength === 0);
	} catch(error) {
		trans = false;
	}
	this.inputs.isTrans = trans;
};
/******* Modal box to freeze all UI buttons and inputs *******/
var modalBox = document.createElement('div');
modalBox.className = 'modalbox-hide';
modalBox.onclick = function(here){ return function(){
	// Do nothing - stops anything else from happening whilst the modal box is active.
};}(this);
/********************* Splash screen code ********************/
function splashStart() {
	document.getElementById('titlebar').className = 'titlebar-hide';
	document.getElementById('lutcalcform').className = 'lutcalcform-hide';
	document.getElementById('footer').className = 'footer-hide';
	var splash = document.getElementById('javascriptwarning');
	splash.removeChild(splash.firstChild);
	splash.className = 'splash';
	splashTxt(splash);
	return splash;
}
var splashInterval = false;
function splashTxt(splash) {
	var splashText = document.createElement('div');
	var splashTitle =  document.createElement('h1');
	splashTitle.innerHTML = 'LUTCalc ' + lutInputs.version;
	splashText.appendChild(splashTitle);
	splashText.appendChild(document.createElement('br'));
	var splashCredit =  document.createElement('h5');
	splashCredit.innerHTML = 'Ben Turley ' + lutInputs.date;
	splashText.appendChild(splashCredit);
	splash.appendChild(splashText);
	lutInputs.addInput('splashProgress',document.createElement('span'));
	lutInputs.addInput('splashPer',0);
	var progressBox = document.createElement('span');
	progressBox.id = 'splash-progress-box';
	lutInputs.splashProgress.id = 'splash-progress';
	lutInputs.splashProgress.style.width = lutInputs.splashPer.toString() + '%';
	progressBox.appendChild(lutInputs.splashProgress);
	splash.appendChild(progressBox);
	splashInterval = setInterval(updateSplash,10);
}
function splashProg(step) {
	var s;
	if (typeof step === 'undefined') {
		s = 0.25;
	} else {
		s = step;
	}
	lutInputs.splashPer += s;
}
function updateSplash() {
	if (lutInputs.splashPer <= 100) {
		lutInputs.splashProgress.style.width = Math.round(lutInputs.splashPer).toString() + '%';
	} else {
		clearInterval(splashInterval);
		return;
	}
}

/********************** Start things up **********************/
var lutInputs = new LUTInputs();
lutInputs.addInput('version','v4.09');
lutInputs.addInput('versionNum', 4.09);
lutInputs.addInput('date','February 2025');
var splash = splashStart();
var lutTests = new LUTTests(lutInputs);
/* gamma.js
* Transfer functions (gamma) web worker object for the LUTCalc Web App.
* 27th June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTGamma() {
	this.lutMaker = new LUTs();
	this.nul = false;
	this.gammas = [];
	this.isTrans = false;
	this.ver = 0;
	this.curIn = 0;
	this.curOut = 0;
	this.eiMult = 1;
	this.stopShift = 0;
	this.inL = false;
	this.outL = true;
	this.clip = true;
	this.clipB = true;
	this.clipW = false;
	this.clipL = true;
	
	this.sIn = false;
	this.sMin = 0;
	this.sMax = 1;

	this.bClip = 0;
	this.mClip = 67025937;

	this.linList = [];
	this.inList = [];	
	this.outList = [];
	this.disList = [];
	this.catList = [];
	this.subNames = [];
	this.gammaSub = [];
	this.gammaDat = [];
	this.gammaExt = [];

	this.kSmooth = 1;

	this.doBlkHi = false;
	this.doASCCDL = false;
	this.doBlkGam = false;
	this.doDisplay = false;
	
	this.blkGamLStop = -1.5;
	this.blkGamFStop = 2;
	this.blkGamUL = 0.1;
	this.blkGamLL = 0.09;
	this.blkGamF = this.blkGamUL-this.blkGamLL;
	this.blkGamP = 1;
	this.blkGamR = 0.1;

	this.gts = [];
	this.disGts = [];
	this.disM = new Float64Array([1,0,0, 0,1,0, 0,0,1]);
	this.disInM = [];
	this.disOutM = [];
	this.displayCSMatrices();
	this.dispInGt = 0;
	this.dispOutGt = 0;

	this.camClip = 11.52;

	this.hdrOut = false;

	this.al = 1;
	this.bl = 0;
	this.ad = 1;
	this.bd = 0;
	this.highRef = 0.9;
	this.asc = new Float64Array([
		1,1,1,	// s - Slope / Gain
		0,0,0,	// o - Offset / Lift
		1,1,1,	// p - Power / Gamma
		1		// sat - Saturation
	]);
	this.gammaList();
}
// Prepare transfer functions
LUTGamma.prototype.subIdx = function(cat) {
	switch (cat) {
		case 'Sony': return 0;
		case 'ARRI': return 1;
		case 'Canon': return 2;
		case 'Apple': return 3;
		case 'Panasonic': return 4;
		case 'RED': return 5;
		case 'GoPro': return 6;
		case 'Panavision': return 7;
		case 'Blackmagic': return 8;
		case 'Bolex': return 9;
		case 'Fujifilm': return 10;
		case 'Nikon': return 11;
		case 'DJI': return 12;
		case 'Log': return 13;
		case 'Display': return 14;
		case 'HDR Display': return 15;
		case 'Linear / γ': return 16;
	}
	return false;
};
LUTGamma.prototype.gammaList = function() {
	this.subNames = [	'Sony',
						'ARRI',
						'Canon',
						'Apple',
						'Panasonic',
						'RED',
						'GoPro',
						'Panavision',
						'Blackmagic',
						'Bolex',
						'Fujifilm',
						'Nikon',
						'DJI',
						'Log',
						'Display',
						'HDR Display',
						'Linear / γ',
						'All'
	];
	this.SL3Idx = 0;
	this.gammas.push(new LUTGammaLog(
		'S-Log3', [ 0.1677922920,-0.0155818840, 0.2556207230, 4.7368421060,10.0000000000, 0.4105571850, 0.0526315790, 0.1673609920, 0.0125000000 ]));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Log')]);
	this.gts.push('Sony S-Gamut3.cine');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'S-Log2', [ 0.330000000129966,-0.0291229262672453,0.3705223107287920,0.7077625570776260,10,0.6162444730868150,0.0375840001141552,0.0879765396,0 ]));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Log')]);
	this.gts.push('Sony S-Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'S-Log', [ 0.3241960136,-0.0286107171, 0.3705223110, 1,10.0000000000, 0.6162444740, 0.0375840000, 0.0882900450, 0.000000000000001 ]));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Log')]);
	this.gts.push('Sony S-Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);

/*
	this.gammas.push(new LUTGammaLog2('LOGCalc Scaler', 7.46633, -0.0411526));
	this.gammaSub.push(this.subIdx(['Log']));
	this.gts.push('Sony S-Gamut3.cine');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
*/
	this.arriIdxList = [this.gammas.length];
	this.gammas.push(new LUTGammaLogC4(
		'LogC4'));
	this.gammaSub.push([this.subIdx('ARRI'),this.subIdx('Log')]);
	this.gts.push('ARRI Wide Gamut 4');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	
	this.arriIdxList.push(this.gammas.length);
	this.gammas.push(new LUTGammaArri(
		'LogC (Sup 3.x & 4.x)',3));
	this.gammaSub.push([this.subIdx('ARRI'),this.subIdx('Log')]);
	this.gts.push('Alexa Wide Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaArri(
		'LogC (Sup 2.x)',2));
	this.gammaSub.push([this.subIdx('ARRI'),this.subIdx('Log')]);
	this.gts.push('Alexa Wide Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Canon C-Log2', [ 0.045164984,-0.006747091156,0.241360772,87.09937546,10,0.092864125,1,0,-0.006747091156 ]));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Log')]);
	this.gts.push('Canon Cinema Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaCLog3(
		'Canon C-Log3'));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Log')]);
	this.gts.push('Canon Cinema Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'C-Log', [ 0.3734467748,-0.0467265867, 0.45310179472141, 10.1596, 10, 0.1251224801564, 1, 0.00391002619746, -0.0452664 ]));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Log')]);
	this.gts.push('Rec709');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaAppleLog(
		'Apple Log'));
	this.gammaSub.push([this.subIdx('Apple'),this.subIdx('Log')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(true);
	this.gammaExt.push(true);

	this.gammas.push(new LUTGammaCineon(
		'Cineon', {cv:1023, bp:95, wp: 685, nGamma: 0.6, cv2d:0.002}));
	this.gammaSub.push([this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Panasonic V-Log', [ 0.198412698,-0.024801587, 0.241514, 0.9, 10, 0.598206, 0.00873, 0.181, 0.009 ]));
	this.gammaSub.push([this.subIdx('Panasonic'),this.subIdx('Log')]);
	this.gts.push('Panasonic V-Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Fujifilm F-Log2', [ 0.12627036, -0.011725971, 0.245281, 5.0000004, 10, 0.384316, 0.064829, 0.100686685, 0.000987778 ]));
	this.gammaSub.push([this.subIdx('Fujifilm'),this.subIdx('Log')]);
	this.gts.push('Fujifilm F-Log Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Fujifilm F-Log', [ 0.1144737, -0.010630486, 0.344676, 0.5000004, 10, 0.790453, 0.009468, 0.100537775, 0.000988889 ]));
	this.gammaSub.push([this.subIdx('Fujifilm'),this.subIdx('Log')]);
	this.gts.push('Fujifilm F-Log Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaCineon(
		'REDLogFilm', {cv:1023, bp:95, wp: 685, nGamma: 0.6, cv2d:0.002}));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLogLog(
		'RED Log3G10', [ 0.224282,155.975327,0.01 ]));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);

	this.gammas.push(new LUTGammaLog(
		'BMDFilm Gen5', [ 0.156642493, -0.022202504, 0.074437531, 0.9, 2.718281828, 0.516414159, 0.005494072, 0.177206446, 0.005555556 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('Blackmagic Wide Gamut');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaDaVinci('DaVinci Intermediate'));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('DaVinci Wide Gamut');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaLog(
		'BMD Pocket Film', [ 0.195367159 / 0.9, -0.014273567 / 0.9, 0.36274758, 1.05345192 * 0.9, 10, 0.63659829, 0.027616437, 0.096214896, 0.004523664 * 0.9 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'BMD Film', [ 0.261115778 * 0.9, -0.024248528 * 0.9, 0.367608577, 0.86786483 / 0.9, 10, 0.644065346, 0.03135747, 0.114002127, 0.005519226 / 0.9 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'BMD Film4k', [ 0.37237694 * 0.9, -0.034580801 * 0.9, 0.582240088, 2.617961052 / 0.9, 10, 0.461883884, 0.231964429, 0.10772883, 0.005534931 / 0.9 ]));
//		'BMD Film4k', [ 0.37237694, -0.034580801, 0.582240088, 2.617961052, 10, 0.461883884, 0.231964429, 0.10772883, 0.005534931 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
/*
	this.gammas.push(new LUTGammaLog(
		'BMD Film4.6k', [ 0.195367159, -0.014273567, 0.36274758, 1.05345192, 10, 0.63659829, 0.027616437, 0.096214896, 0.004523664 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
*/
	this.gammas.push(new LUTGammaLog(
		'BMD Film4.6k', [ 0.195367159 / 0.9, -0.014273567 / 0.9, 0.36274758, 1.05345192 * 0.9, 10, 0.63659829, 0.027616437, 0.096214896, 0.004523664 * 0.9 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Bolex Log', [ 1/(5.9861078*0.9), -0.0625265/(0.9*5.9861078), 0.2756705, 5, 10, 0.4150634, 0.0280665, 0.1520070, 0.014948/0.9 ]));
	this.gammaSub.push([this.subIdx('Bolex'),this.subIdx('Log')]);
	this.gts.push('Bolex Wide Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Panalog', [ 0.324196014, -0.020278938, 0.434198361, 0.956463747, 10, 0.665276427, 0.040913561, 0.088290045, 0 ]));
	this.gammaSub.push([this.subIdx('Panavision'),this.subIdx('Log')]);
	this.gts.push('Rec709');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Protune', [ 0,0, 876/1023, 53.39427221, 113, 64/1023, 1, 0, 0 ]));
	this.gammaSub.push([this.subIdx('GoPro'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaLog(
		'DJI X5/X7/X9 DLog', [ 1/(6.025*0.9), -0.0929/(6.025*0.9), 0.256663, 0.9892 * 0.9, 10, 0.584555, 0.0108, 0.14, 0.0078 * 0.9 ]));
	this.gammaSub.push([this.subIdx('DJI'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.DLogM = this.gammas.length;
	this.gammas.push(new LUTGammaDLog('DJI DLog-M'));
	this.gammaSub.push([this.subIdx('DJI'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaLogClip(
		'DJI X3 DLog', [ 0.188272019, -0.011778504, 0.473218054, 6.086793376, 10, 0.419294419, 0.169033387, 0.095812746, 0.00625, 0.902863937, 1.59668525, 22.90700861, -17.39462704 ]));
	this.gammaSub.push([this.subIdx('DJI'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaIOLUT(
		'DJI Mini 2',
		{
			rec: {
				lut: new Float64Array([
					0.02513830, 0.03474122, 0.04434413, 0.05394705, 0.06354996, 0.07315288, 0.08274788, 0.09241272,
					0.10271576, 0.11311513, 0.12351429, 0.13391345, 0.14431261, 0.15471177, 0.16513320, 0.17361913,
					0.18110689, 0.18812930, 0.19473345, 0.20096606, 0.20686704, 0.21247143, 0.21780622, 0.22289498,
					0.22776349, 0.23220360, 0.23715250, 0.24470811, 0.25063847, 0.25650566, 0.26230818, 0.26802904,
					0.27366776, 0.27922389, 0.28469820, 0.29009155, 0.29540394, 0.30063666, 0.30579119, 0.31086787,
					0.31586840, 0.32079436, 0.32564634, 0.33042651, 0.33513583, 0.33977568, 0.34434806, 0.34885353,
					0.35329444, 0.35767138, 0.36198634, 0.36624039, 0.37043494, 0.37457151, 0.37865104, 0.38267530,
					0.38664498, 0.39056190, 0.39442666, 0.39824102, 0.40200558, 0.40572187, 0.40939073, 0.41301326,
					0.41659065, 0.42012350, 0.42361340, 0.42706051, 0.43046663, 0.43383182, 0.43715761, 0.44044453,
					0.44369326, 0.44690512, 0.45008015, 0.45321988, 0.45632454, 0.45939486, 0.46243198, 0.46543587,
					0.46840787, 0.47134835, 0.47422700, 0.47702901, 0.47995529, 0.48316779, 0.48666135, 0.49065065,
					0.49522288, 0.49965819, 0.50408629, 0.50851850, 0.51295463, 0.51739460, 0.52183816, 0.52628528,
					0.53073572, 0.53518944, 0.53964626, 0.54410607, 0.54856878, 0.55303423, 0.55750237, 0.56197304,
					0.56644619, 0.57092168, 0.57539945, 0.57987941, 0.58436144, 0.58884551, 0.59333149, 0.59781936,
					0.60230899, 0.60680034, 0.61129335, 0.61578793, 0.62028405, 0.62478161, 0.62928058, 0.63378090,
					0.63828252, 0.64278538, 0.64728943, 0.65179464, 0.65630094, 0.66080831, 0.66531669, 0.66982604
				])
			},
			out: {
				lut: new Float64Array([
					-0.020612427,-0.014156041,-0.007699656,-0.00124327, 0.005213115, 0.011669500, 0.018125886, 0.024582271,
					0.031038657, 0.037495042, 0.043951427, 0.050407813, 0.056762235, 0.062724266, 0.068686298, 0.074648329,
					0.080610361, 0.086572392, 0.092534424, 0.098496455, 0.104458487, 0.110420518, 0.117722628, 0.125979289,
					0.134842844, 0.144357903, 0.154572353, 0.165537602, 0.177308837, 0.189945300, 0.203510588, 0.211860347,
					0.222265361, 0.232860935, 0.243661342, 0.254680420, 0.265931684, 0.277428413, 0.289183731, 0.301210667,
					0.313522213, 0.326131374, 0.339051208, 0.352294865, 0.365875622, 0.379806912, 0.394102353, 0.408775777,
					0.423841250, 0.439313096, 0.455205924, 0.471534640, 0.488314476, 0.505561005, 0.523290160, 0.541518256,
					0.560262004, 0.579538537, 0.599365420, 0.619760673, 0.640742792, 0.662330762, 0.680356837, 0.694388877,
					0.708396075, 0.722380208, 0.736342926, 0.750285754, 0.764210104, 0.778117286, 0.792008513, 0.805884910,
					0.819747522, 0.833597316, 0.847435193, 0.861261986, 0.875078470, 0.888885365, 0.902683339, 0.916473014,
					0.930254967, 0.944029734, 0.957797814, 0.971559671, 0.985315736, 0.999066410, 1.012812066, 1.026553051,
					1.040289687, 1.054022275, 1.067751094, 1.081476404, 1.095198446, 1.108917447, 1.122633615, 1.136347145,
					1.150058220, 1.163767007, 1.177473664, 1.191178339, 1.204881166, 1.218582273, 1.232281778, 1.245979791,
					1.259676414, 1.273371744, 1.287065868, 1.300758869, 1.314450825, 1.328141808, 1.341831883, 1.355521113,
					1.369209557, 1.382897268, 1.396584296, 1.410270688, 1.423956488, 1.437641737, 1.451326471, 1.465010727,
					1.478694537, 1.492377932, 1.506060940, 1.519743588, 1.533425900, 1.547107899, 1.560789607, 1.574471044
				])
			}
		}));
	this.gammaSub.push([this.subIdx('DJI'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);


	this.gammas.push(new LUTGammaACEScc(
		'ACEScc', {}));
	this.gammaSub.push([this.subIdx('Log')]);
	this.gts.push('ACES AP0');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaACESProxy(
		'ACESproxy10', 10));
	this.gammaSub.push([this.subIdx('Log')]);
	this.gts.push('ACEScg AP1');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaACESProxy(
		'ACESproxy12', 12));
	this.gammaSub.push([this.subIdx('Log')]);
	this.gts.push('ACEScg AP1');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'Amira709',
		new Float64Array(
				[ 0.0629449254, 0.0638344316, 0.0652122451, 0.0671149365, 0.0696389939, 0.0727578155, 0.0765583221, 0.0810732533,
				  0.0863050714, 0.0923235097, 0.0991202854, 0.1071573521, 0.1173890946, 0.1289127766, 0.1418248775, 0.1563577288,
				  0.1727759907, 0.1909101927, 0.2109039553, 0.2321740755, 0.2540878735, 0.2767513785, 0.3000392795, 0.3239141187,
				  0.3482661335, 0.3730445064, 0.3981118279, 0.4233801358, 0.4484330041, 0.4733441630, 0.4980799790, 0.5226516916,
				  0.5470832745, 0.5713748957, 0.5955474508, 0.6196006037, 0.6435589843, 0.6674248274, 0.6912186286, 0.7150335873,
				  0.7380830785, 0.7604458639, 0.7808803039, 0.7989996910, 0.8151693266, 0.8293147178, 0.8419315718, 0.8532432154,
				  0.8632844800, 0.8721146308, 0.8798286573, 0.8865081114, 0.8922250204, 0.8970825043, 0.9011319655, 0.9044962896,
				  0.9072088251, 0.9094085307, 0.9111140581, 0.9124771261, 0.9135050778, 0.9143603587, 0.9150416855, 0.9157172449,
				  0.9163807382 ]
		)
	));
	this.gammaSub.push([this.subIdx('ARRI'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'Alexa-X-2',
		new Float64Array(
				[ 0.0591392525, 0.0597741050, 0.0612907229, 0.0636891061, 0.0670061726, 0.0713627697, 0.0766277967, 0.0826389777,
				  0.0892340370, 0.0962854910, 0.1039625761, 0.1129939936, 0.1252220091, 0.1381401480, 0.1513807635, 0.1651563807,
				  0.1799534361, 0.1962251040, 0.2139885968, 0.2330129188, 0.2532175057, 0.2745268479, 0.2973340978, 0.3215684734,
				  0.3464667648, 0.3712822467, 0.3957529493, 0.4204032336, 0.4450817523, 0.4696146868, 0.4938866713, 0.5180413154,
				  0.5420558969, 0.5658776148, 0.5894644299, 0.6129189039, 0.6361895435, 0.6591598802, 0.6817136956, 0.7042566286,
				  0.7267405614, 0.7484349074, 0.7686102390, 0.7868717883, 0.8037179215, 0.8191567127, 0.8331581208, 0.8456621871,
				  0.8565103390, 0.8659197184, 0.8741749179, 0.8815532343, 0.8878611055, 0.8930654735, 0.8974118356, 0.9011455804,
				  0.9042495877, 0.9065156533, 0.9082180048, 0.9096408106, 0.9109571560, 0.9118628170, 0.9125228715, 0.9131824676,
				  0.9140666658 ]
		)
	));
	this.gammaSub.push([this.subIdx('ARRI'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaIOLUT(
		's709',
		{
			rec: {
				lut: new Float64Array([
					-0.128429281, -0.087857693, -0.047286105, -0.006714517, 0.033857071, 0.074428659, 0.109404416, 0.142251149,
					0.169103206, 0.191383375, 0.211313326, 0.22941725, 0.246207651, 0.261136216, 0.27457494, 0.286937936,
					0.298350035, 0.309228929, 0.319721904, 0.329938595, 0.339920481, 0.349708889, 0.35935577, 0.368893896,
					0.378339425, 0.387726702, 0.39709087, 0.406494373, 0.415959965, 0.425504727, 0.435091864, 0.444721031,
					0.454388469, 0.464097425, 0.473848584, 0.483636782, 0.493448049, 0.503261998, 0.5130866, 0.522936843,
					0.532878688, 0.542918355, 0.553067402, 0.56328643, 0.57360374, 0.58404873, 0.594627852, 0.605423139,
					0.61654015, 0.6284926, 0.64151266, 0.6558432, 0.671742369, 0.689757007, 0.710737854, 0.736194343,
					0.770900272, 0.831346604, 1.079267818, 2.077062181, 3.074856545, 4.072650908, 5.070445272, 6.068239635
				])
			},
			out: {
				lut: new Float64Array([
					0.05040000, 0.05652381, 0.06269047, 0.06866184, 0.07493765, 0.08147611, 0.08894732, 0.09601165,
					0.10345157, 0.11143212, 0.12031592, 0.13072851, 0.14217459, 0.1545754, 0.16823161, 0.18258277,
					0.19847487, 0.21647519, 0.23646249, 0.25861883, 0.28225966, 0.30694373, 0.33251343, 0.35871242,
					0.38535787, 0.41224989, 0.43899291, 0.46540198, 0.49160841, 0.51763835, 0.54348663, 0.5691883,
					0.59485339, 0.62044621, 0.64569807, 0.67053983, 0.69508328, 0.71918342, 0.74276274, 0.76534268,
					0.78580574, 0.80409842, 0.8205254, 0.83516611, 0.84814976, 0.85956961, 0.86957328, 0.8781925,
					0.88538127, 0.89133381, 0.89630257, 0.90038219, 0.9036953, 0.90632778, 0.90827715, 0.90984446,
					0.91135117, 0.91290709, 0.91514511, 0.917036, 0.91794384, 0.91884742, 0.91911605, 0.91937392
				])
			}
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);


	this.gammas.push(new LUTGammaLUTSL3(
		'LC709A',
		new Float64Array(
				[ 0.0690751760484848,0.0728297103786901,0.0769850051182796,0.0815808343707722,0.0864978758256109,0.0915715413065494,0.0969774025141740,0.1028781916478983,
				  0.1091478390349951,0.1155131300480449,0.1225782317505376,0.1309263253436461,0.1403471537869012,0.1508689079248778,0.1623594253036168,0.1746108013986315,
				  0.1878784532660801,0.2022370183965786,0.2180209309622678,0.2356278321531769,0.2549427384062561,0.2761380900003911,0.2987492565998045,0.3224798721943793,
				  0.3469975840860214,0.3719286248248777,0.3971008726561094,0.4222027128650537,0.4472788568813294,0.4722718767181329,0.4971765759100684,0.5219774783500978,
				  0.5466479949763440,0.5711842754669599,0.5955026274948191,0.6197116512439393,0.6432306188590422,0.6651852019544967,0.6865648023053763,0.7082626223616812,
				  0.7296929317130010,0.7507956301978983,0.7708870295194525,0.7891859348525904,0.8059247656203324,0.8210325331867545,0.8346382669036169,0.8468258306587488,
				  0.8576597322080157,0.8672077039163734,0.8755439358443793,0.8827308391279569,0.8888714829059629,0.8940610364006844,0.8983856104977517,0.9019299878681326,
				  0.9047933223781036,0.9070732102109482,0.9088591070866080,0.9102383165201858,0.9113148913094820,0.9121898344043498,0.9129595988637339,0.9137217752193059,
				  0.9145739540027369 ]
		)
	));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'LC709',
		new Float64Array(
				[ 0.0681458330432062,0.0691434801575758,0.0705829599217986,0.0724372206445259,0.0747874173998045,0.0776429161732649,0.0811920325388074,0.0855419981338221,
				  0.0909454307534702,0.0976690797726784,0.1057777820895406,0.1155958029012708,0.1266116066854350,0.1383486226503910,0.1510262218009775,0.1646815963955523,
				  0.1793847118819159,0.1951918111528836,0.2121812541317693,0.2304357320288367,0.2499984938760508,0.2709281624411535,0.2932613077270772,0.3170617964918866,
				  0.3423063612379277,0.3695615137341154,0.3971217829388074,0.4231725001074290,0.4486077701176930,0.4736812772283969,0.4984996145517106,0.5232706256325024,
				  0.5479442434314760,0.5725367356025903,0.5970569416109482,0.6215751675531770,0.6459232811886606,0.6699759671530302,0.6936750809141740,0.7170080478474583,
				  0.7397128428660801,0.7617580170455522,0.7824392672742913,0.8009083916954056,0.8175656376203322,0.8324964241259040,0.8457970340590418,0.8575570277373410,
				  0.8678819918256108,0.8768748757833822,0.8846331515440858,0.8912549486405668,0.8968412437341152,0.9014929560172531,0.9053083874291300,0.9083859090127075,
				  0.9108262326490713,0.9127307504679862,0.9141957927663734,0.9153135383675464,0.9161978338220919,0.9170093433528834,0.9176997927663735,0.9182731424731183,
				  0.9187333528836756 ]
		)
	));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'Sony Cine+709',
		new Float64Array(
				[ 0.09536,0.095478,0.095477,0.095487,0.096065,0.098802,0.100993,0.103192,
				  0.105328,0.107778,0.110405,0.113748,0.118809,0.125443,0.134203,0.14799,
				  0.163574,0.182266,0.204615,0.230647,0.259499,0.291063,0.326191,0.363425,
				  0.402596,0.443342,0.484945,0.526625,0.566841,0.604381,0.640827,0.67481,
				  0.707318,0.737661,0.766663,0.792151,0.814736,0.836382,0.85493,0.870464,
				  0.883507,0.895957,0.90574,0.913164,0.920182,0.927134,0.933985,0.940772,
				  0.94755,0.954329,0.961108,0.967887,0.974666,0.981445,0.988224,0.995003,
				  1.001782,1.008561,1.01534,1.022119,1.028898,1.035677,1.042456,1.049235 ]
		)
	));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'Varicam V709',
		new Float64Array(
				[ 0.03093963,0.03517715,0.03975096,0.04459771,0.0498902,0.05557408,0.06190443,0.06897675,
				  0.07677725,0.08537468,0.09473446,0.10541067,0.11868528,0.13311738,0.1487007,0.16548566,
				  0.1835071,0.20262917,0.22283545,0.24403145,0.26617877,0.28925105,0.31327642,0.33809209,
				  0.3635757,0.3896826,0.41631627,0.44341889,0.47081168,0.49848151,0.52623353,0.55406649,
				  0.58169329,0.60913806,0.63624608,0.66303621,0.68930935,0.71517113,0.73981736,0.76273104,
				  0.78514678,0.80792983,0.82988348,0.85024823,0.86926131,0.88683223,0.90300653,0.91783703,
				  0.93129966,0.94331701,0.95391642,0.96327691,0.97138937,0.97818037,0.98361305,0.98799011,
				  0.99133483,0.9937684,0.9951962,0.99614917,0.99691692,0.9975211,0.99811777,0.99867865,
				  0.9992434 ]
		)
	));
	this.gammaSub.push([this.subIdx('Panasonic'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSL3(
		'REDGamma',
		new Float64Array(
				[
					0.122209, 0.122628, 0.123047, 0.123466, 0.123864, 0.124153, 0.124373, 0.126399,
					0.132256, 0.139311, 0.144668, 0.150222, 0.157654, 0.166187, 0.175914, 0.18672,
					0.198454, 0.211823, 0.226955, 0.244314, 0.2638, 0.284623, 0.307611, 0.333972,
					0.363098, 0.394923, 0.4287, 0.464298, 0.501315, 0.539313, 0.576918, 0.614116,
					0.650874, 0.685866, 0.718698, 0.749114, 0.777078, 0.80297, 0.825409, 0.842033,
					0.854127, 0.861731, 0.867448, 0.871675, 0.875699, 0.879379, 0.882654, 0.885762,
					0.888901, 0.891917, 0.894805, 0.897616, 0.900351, 0.903046, 0.905325, 0.906683,
					0.907624, 0.908566, 0.909507, 0.910449, 0.91139, 0.912332, 0.913273, 0.914215 ]
		)
	));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'REDGamma2',
		new Float64Array(
				[
					0.108361, 0.109008, 0.109654, 0.110301, 0.110914, 0.111361, 0.113363, 0.117263,
					0.12595, 0.13667, 0.145798, 0.155437, 0.166925, 0.17921, 0.192282, 0.206362,
					0.221594, 0.237788, 0.2549, 0.272774, 0.291467, 0.311447, 0.332405, 0.353942,
					0.37623, 0.399321, 0.423152, 0.447735, 0.473302, 0.499739, 0.526754, 0.554079,
					0.581395, 0.608528, 0.635397, 0.661888, 0.687921, 0.713102, 0.737264, 0.760012,
					0.781281, 0.800987, 0.818704, 0.834386, 0.848327, 0.860566, 0.871203, 0.880394,
					0.888265, 0.894957, 0.90053, 0.904801, 0.907617, 0.908281, 0.908509, 0.908737,
					0.908965, 0.909193, 0.909421, 0.909649, 0.909877, 0.910105, 0.910333, 0.910561 ]
		)
	));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'REDGamma3',
		new Float64Array(
				[ -0.03714517,-0.00423269,0.0286798,0.06159228,0.08210614,0.08742128,0.09352044,0.10024791,0.10760079,0.11612612,
				  0.12508897,0.13477347,0.14708845,0.16039003,0.17473353,0.19047034,0.20764301,0.22600144,0.24574689,0.26695764,
				  0.28923082,0.31230737,0.33598015,0.36085173,0.3858281,0.41159915,0.43762202,0.46412136,0.49040391,0.51679063,
				  0.54330912,0.56927544,0.59476868,0.61927984,0.64375537,0.66689702,0.68910742,0.71075087,0.73073736,0.74993632,
				  0.76768928,0.78399945,0.79911844,0.81328213,0.82578649,0.8370763,0.84742981,0.85645727,0.86438563,0.87143002,
				  0.87786935,0.88346431,0.88841647,0.89282182,0.89677137,0.9002692,0.90328175,0.90617316,0.90922153,0.91226993,
				  0.91531834,0.91836678,0.92141523,0.92446369,0.92751216 ]
		)
	));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'REDGamma4',
		new Float64Array(
				[
					0.053893,0.056375,0.058856,0.061338,0.063694,0.066402,0.071655,0.078517,
					0.086253,0.094471,0.102953,0.112794,0.125421,0.139898,0.156136,0.174021,
					0.193439,0.214284,0.236454,0.259851,0.284385,0.309967,0.336515,0.363952,
					0.392203,0.421199,0.450864,0.481018,0.511437,0.541908,0.572226,0.602196,
					0.63163,0.660345,0.688159,0.714896,0.740381,0.764439,0.786892,0.807565,
					0.826276,0.842863,0.857382,0.870007,0.880892,0.890167,0.897948,0.904337,
					0.909429,0.913312,0.916075,0.917816,0.918669,0.918866,0.918866,0.918866,
					0.918866,0.918866,0.918866,0.918866,0.918866,0.918866,0.918866,0.918866 ]
		)
	));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Rec709 (800%)',
		{
			rec: {
				lut: new Float64Array([
					-0.0446421313,	-0.0204893067,	0.0036635180,	0.0278163427,	0.0519691674,	0.0761219921,	0.1002707756,	0.1244698215,	0.1486224622,	0.1716290677,
					0.1906642455,	0.2085204718,	0.2254012975,	0.2413982532,	0.2565166388,	0.2708530435,	0.2844393079,	0.2973183908,	0.3096854620,	0.3215533433,
					0.3328146131,	0.3436401143,	0.3540168103,	0.3639875695,	0.3735997301,	0.3828629905,	0.3917793547,	0.4004128911,	0.4088059207,	0.4169027148,
					0.4247147130,	0.4322985725,	0.4396753339,	0.4468468853,	0.4538127938,	0.4605775118,	0.4671640916,	0.4735878362,	0.4798545760,	0.4860006009,
					0.4920048747,	0.4977093585,	0.5038431061,	0.5116567043,	0.5181791292,	0.5247650308,	0.5315938853,	0.5385493314,	0.5456541485,	0.5530263072,
					0.5606487371,	0.5686002240,	0.5768926044,	0.5855586010,	0.5948269850,	0.6046748461,	0.6152549633,	0.6269138470,	0.6396734938,	0.6541629455,
					0.6710471506,	0.6915209719,	0.7181498682,	0.7574674791,	0.8445913579
				])
			},
			out: {
				lut: new Float64Array([
					0.0289066996,	0.0390080746,	0.0491133029,	0.0592146779,	0.0693160529,	0.0794212813,	0.0895274289,	0.0996411169,	0.1097173681,	0.1197901614,
					0.1300004174,	0.1408247747,	0.1535938980,	0.1670471322,	0.1812353271,	0.1961807539,	0.2118897750,	0.2285885784,	0.2462546509,	0.2650729108,
					0.2848894628,	0.3059138202,	0.3282876301,	0.3520647492,	0.3773249255,	0.4041951748,	0.4326924843,	0.4630104118,	0.4953512291,	0.5296917198,
					0.5663211163,	0.6052213632,	0.6468385483,	0.6811695613,	0.7179664821,	0.7526207094,	0.7849335846,	0.8147522501,	0.8419881738,	0.8664954100,
					0.8881412487,	0.9073422173,	0.9239607990,	0.9381992542,	0.9503103153,	0.9605564777,	0.9690464375,	0.9762167750,	0.9819309464,	0.9867203043,
					0.9904006942,	0.9934500190,	0.9956787345,	0.9979577502,	0.9998967591,	1.0018141003,	1.0037311922,	1.0056480668,	1.0075647537,	1.0094812760,
					1.0113976563,	1.0133139134,	1.0152300629,	1.0171461197,	1.0190620951
				])
			}
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'EOS Standard',
		{
			clip: 3.7455,
			loggy: 0.01197,
			lut: new Float64Array(
				[	0.062561095,0.074860431,0.092233233,0.113525362,
					0.148197424,0.190542723,0.248921196,0.320439745,
					0.417441612,0.518356119,0.637094759,0.739691491,
					0.833001228,0.904285437,0.955849432,0.986588392,
					0.997301612 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'EOS Standard (Legal)',
		{
			clip: 3.7455,
			loggy: 0.01197,
			lut: new Float64Array(
				[	0.062561095,0.073828375,0.089743398,0.109248871,
					0.141011547,0.179803585,0.23328343,0.298800746,
					0.387663035,0.480109649,0.588884745,0.682872425,
					0.768352397,0.833655037,0.880892217,0.909051823,
					0.91886608 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Canon Normal 1',
		{
			clip: 4.9166,
			loggy: 0.002377,
			lut: new Float64Array(
				[	0.082111437,0.090584133,0.102121123,0.117689768,
					0.140853869,0.179297916,0.229246771,0.288545875,
					0.355002175,0.443743628,0.567289457,0.709945913,
					0.855432239,0.912823502,0.973847336,1.053094692,
					1.344984113 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Canon Normal 2',
		{
			clip: 3.6795,
			loggy: 0.010815,
			lut: new Float64Array(
				[	0.082111437,0.097513279,0.113845203,0.134727251,
					0.167041692,0.204979095,0.252646999,0.299167176,
					0.354210924,0.42337854,0.51044802,0.608850484,
					0.724959368,0.850680674,0.89267391,0.933266716,
					0.982099746 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Canon Normal 3',
		{
			clip: 3.675,
			loggy: 0.011418,
			lut: new Float64Array(
				[	0.082111437,0.09988293,0.119699608,0.143422866,
					0.178649187,0.214574932,0.258160103,0.305496005,
					0.366356945,0.432842236,0.517627699,0.615737774,
					0.729766182,0.852693579,0.891819699,0.933451248,
					0.982740453 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Canon Normal 4',
		{
			clip: 3.70456,
			loggy: 0.0093,
			lut: new Float64Array(
				[	0.082111437,0.098467583,0.117300597,0.140493024,
					0.176093124,0.219716004,0.271868112,0.32123868,
					0.36749718,0.427104487,0.506362752,0.603335607,
					0.716870955,0.848059317,0.893373102,0.934937886,
					0.983834278 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaNLog('Nikon N-Log'));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Log')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(true);
	this.gammaExt.push(true);


	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Standard',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090182450305,
						0.114844812055, 0.147037855967, 0.170190534243, 0.182505160319, 0.195266314669, 0.203853784990, 0.211095737876, 0.219221792780, 0.227999341155,
						0.236282183331, 0.243254666213, 0.249799997985, 0.256337363135, 0.262712725704, 0.268527439248, 0.273815628826, 0.278801564019, 0.283644789095,
						0.288392421002, 0.293133710416, 0.297755513447, 0.302175617216, 0.306502426672, 0.310752741262, 0.314959622924, 0.319114515832, 0.323165229840,
						0.327112045597, 0.330908933709, 0.334586176331, 0.338175148420, 0.341680833810, 0.345139426450, 0.348544714039, 0.351947325653, 0.355371475627,
						0.358794773339, 0.362214961661, 0.365622412467, 0.368960430415, 0.372229078201, 0.375549771636, 0.378978477443, 0.382437665513, 0.385876364569,
						0.389311177226, 0.392717070632, 0.396099211847, 0.399596228751, 0.403257717617, 0.406948529183, 0.410631822241, 0.414307485422, 0.417949748127,
						0.421597747322, 0.425300362807, 0.429011956465, 0.432665489009, 0.436293179570, 0.439950131174, 0.443618495668, 0.447217356045, 0.450752752428,
						0.454308147167, 0.457896600163, 0.461486503027, 0.465077971802, 0.468649625500, 0.472179139518, 0.475681843863, 0.479172398173, 0.482643830686,
						0.486071715900, 0.489456560345, 0.492829660552, 0.496199806504, 0.499557029186, 0.502883973225, 0.506202425833, 0.509583182445, 0.513027270364,
						0.516439758293, 0.519795229070, 0.523139387370, 0.526486431936, 0.529841782722, 0.533239406650, 0.536673918577, 0.540201395758, 0.543843468628,
						0.547563839344, 0.551365664452, 0.555211858630, 0.559065206970, 0.562987330755, 0.567008663481, 0.571141048171, 0.575388384633, 0.579852755032,
						0.584596219521, 0.589656886066, 0.595013785817, 0.600608182746, 0.606593136633, 0.612862738119, 0.619558115806, 0.627134629835, 0.635771882841,
						0.646090898198, 0.702378530367, 0.761472498521, 0.820637751415, 0.879845357987, 0.939077825206, 0.998324880860, 1.057576659021, 1.116828424985,
						1.176080190950, 1.235331956914, 1.294583722879  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063440922871, 0.065939828995, 0.068461377294, 0.071083719271, 0.073457071312, 0.075178362835,
						0.076926716563, 0.078377767373, 0.079774496126, 0.082090196935, 0.087053858463, 0.091985226944, 0.096851206605, 0.101597266466, 0.108640869604,
						0.117026469673, 0.124564288309, 0.131532001666, 0.138653050872, 0.147207407755, 0.156488919267, 0.165859362460, 0.175652722265, 0.186927260407,
						0.199243267088, 0.212044116616, 0.225041844751, 0.238895615805, 0.253240133306, 0.267917983908, 0.283304261071, 0.299792645427, 0.317160501155,
						0.335057795993, 0.352889810206, 0.370819575819, 0.389352213885, 0.407101174185, 0.424871237485, 0.442772100713, 0.459451481748, 0.476039712868,
						0.492777153962, 0.509246934718, 0.526027527985, 0.542712928580, 0.559913284646, 0.576928975938, 0.593971033204, 0.611344689037, 0.628930013031,
						0.646950916067, 0.665096433879, 0.683435767729, 0.701243173150, 0.719444395779, 0.737622227049, 0.755320491138, 0.772001056736, 0.787997434894,
						0.803729034995, 0.818764033383, 0.832972783544, 0.845877373044, 0.857555748351, 0.868473696665, 0.878489111063, 0.887958347868, 0.896363952038,
						0.903591827347, 0.910315723114, 0.915372062462, 0.918298748293, 0.918941618409, 0.918972202977, 0.919075471565, 0.919879717190, 0.920939802190,
						0.921973664508, 0.923007251183, 0.924040581079, 0.925073671761, 0.926106539583, 0.927139199777, 0.928171666527, 0.929203953044, 0.930236071632,
						0.931268033751, 0.932299850078, 0.933331530557, 0.934363084451, 0.935394520390, 0.936425846414, 0.937457070013, 0.938488198167, 0.939519237376,
						0.940550193699, 0.941581072781, 0.942611879880, 0.943642619897, 0.944673297399, 0.945703916640, 0.946734481587, 0.947764995932, 0.948795463120,
						0.949825886359, 0.950856268638, 0.951886612744, 0.952916921275, 0.953947196648, 0.954977441120, 0.956007656792, 0.957037845623, 0.958068009437,
						0.959098149936, 0.960128268706, 0.961158367223  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Neutral',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090370277129,
						0.111261816878, 0.130837070772, 0.154724281799, 0.167748578657, 0.175153042048, 0.183813600540, 0.193613893606, 0.201845384547, 0.208862712809,
						0.216240385882, 0.223891266282, 0.231266341219, 0.238137235412, 0.244526657912, 0.250600574579, 0.256676156574, 0.262573904298, 0.268179682113,
						0.273510523045, 0.278725079401, 0.283798074261, 0.288755859858, 0.293711495514, 0.298540024556, 0.303202660636, 0.307723722115, 0.312136686485,
						0.316510929668, 0.320823103675, 0.325061599754, 0.329250845847, 0.333404903584, 0.337481786689, 0.341478003981, 0.345410076747, 0.349276802698,
						0.353155050352, 0.357055174830, 0.360924326908, 0.364761909620, 0.368534160768, 0.372219561935, 0.375965970561, 0.379837133354, 0.383697823226,
						0.387509788827, 0.391294383841, 0.395027283063, 0.398805761668, 0.402714808096, 0.406648722824, 0.410557207556, 0.414440514338, 0.418281270173,
						0.422101311085, 0.425921487535, 0.429708258188, 0.433414855526, 0.437113588260, 0.440894188305, 0.444702269231, 0.448484157653, 0.452247923518,
						0.455979626530, 0.459680464278, 0.463339649468, 0.466960507431, 0.470544248238, 0.474091256304, 0.477614456193, 0.481114289829, 0.484597025237,
						0.488049600937, 0.491511604916, 0.495056838882, 0.498638495167, 0.502143788814, 0.505593447821, 0.509025317989, 0.512445400947, 0.515831817485,
						0.519169669140, 0.522481361650, 0.525786987556, 0.529082557203, 0.532387937393, 0.535693607451, 0.539042131765, 0.542445907579, 0.545931580767,
						0.549599723684, 0.553417839780, 0.557224827183, 0.561055098051, 0.564975986003, 0.568990380621, 0.573121964995, 0.577399927778, 0.581947100667,
						0.586726717568, 0.591716948652, 0.596740236407, 0.601900927218, 0.607552931270, 0.614097227575, 0.621247444919, 0.628629296746, 0.636894410971,
						0.647118201427, 0.701473594388, 0.759117452800, 0.816827933730, 0.874580070648, 0.932356983196, 0.990148625585, 1.047946225923, 1.105743851253,
						1.163541476583, 1.221339101914, 1.279136727244  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063424532172, 0.066451860312, 0.069540979037, 0.072767011953, 0.075906919979, 0.078853518191,
						0.081631137728, 0.084115161140, 0.086479804114, 0.090146659344, 0.098326897931, 0.105813214308, 0.112411325511, 0.118632105327, 0.126340654717,
						0.135121024858, 0.143188481435, 0.151214506061, 0.159704595685, 0.168946154075, 0.178917743693, 0.188988933153, 0.199496185802, 0.210829472801,
						0.222607262009, 0.234859080761, 0.247268132837, 0.260349232373, 0.274083476359, 0.288130112770, 0.302582467828, 0.317331828344, 0.332620806037,
						0.348365834915, 0.364049610993, 0.379997823816, 0.396454197491, 0.412256458371, 0.428299584401, 0.444563625444, 0.460140581966, 0.475797913493,
						0.491724507182, 0.507769291577, 0.524243967159, 0.540321153567, 0.556518544281, 0.572986274856, 0.589827764317, 0.607037655073, 0.624500979893,
						0.642132788801, 0.659260502589, 0.676925684511, 0.694832172329, 0.713193903044, 0.731687117698, 0.750046927552, 0.767681303891, 0.783847467497,
						0.799775652757, 0.815021702518, 0.829406565570, 0.842479215886, 0.854706468324, 0.866698387523, 0.877330903455, 0.886205655894, 0.894607432632,
						0.902626621574, 0.909273722489, 0.914867761327, 0.918285650651, 0.918940220570, 0.918992912762, 0.919122306060, 0.919952578245, 0.921038681814,
						0.922098555256, 0.923158146120, 0.924217473745, 0.925276556137, 0.926335410063, 0.927394051136, 0.928452493899, 0.929510751894, 0.930568837735,
						0.931626763171, 0.932684539147, 0.933742175856, 0.934799682795, 0.935857068813, 0.936914342150, 0.937971510485, 0.939028580973, 0.940085560280,
						0.941142454614, 0.942199269764, 0.943256011120, 0.944312683707, 0.945369292206, 0.946425840978, 0.947482334089, 0.948538775326, 0.949595168219,
						0.950651516058, 0.951707821906, 0.952764088621, 0.953820318865, 0.954876515118, 0.955932679692, 0.956988814742, 0.958044922274, 0.959101004161,
						0.960157062147, 0.961213097856, 0.962269112803  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Vivid',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090022266287,
						0.124983618100, 0.174358067479, 0.200885292861, 0.210394128231, 0.219679538515, 0.229782588225, 0.237527072241, 0.243640168554, 0.250127754776,
						0.257349865517, 0.264748252859, 0.270564224518, 0.275807100363, 0.280794974454, 0.285678082679, 0.290496609151, 0.295301613189, 0.299695171061,
						0.303797972903, 0.307751983351, 0.311586237919, 0.315404817492, 0.319170201075, 0.322828977424, 0.326392115832, 0.329816995605, 0.333116458736,
						0.336347797973, 0.339521970675, 0.342645003881, 0.345727309828, 0.348765618565, 0.351808171675, 0.354882352416, 0.357954246165, 0.360988936855,
						0.363995548567, 0.366968530013, 0.369872023109, 0.372746601324, 0.375718615365, 0.378835757890, 0.382015542918, 0.385197001913, 0.388398496231,
						0.391560845343, 0.394665368289, 0.397769976495, 0.400928640905, 0.404115357104, 0.407272557992, 0.410397071901, 0.413502895037, 0.416589818624,
						0.419660824008, 0.422740719992, 0.425840284669, 0.428929810665, 0.431975923618, 0.434993999602, 0.438037471593, 0.441136068781, 0.444236363145,
						0.447275819442, 0.450270537122, 0.453286432626, 0.456347163141, 0.459436026617, 0.462554221976, 0.465705641406, 0.468868557494, 0.472022133151,
						0.475193176007, 0.478429604773, 0.481730408691, 0.485010213005, 0.488233925164, 0.491463556240, 0.494758069364, 0.498091267968, 0.501401033442,
						0.504676474735, 0.507998529829, 0.511426279031, 0.514894259405, 0.518319250205, 0.521742852369, 0.525265607959, 0.528889614943, 0.532532949141,
						0.536178537282, 0.539893166950, 0.543690024018, 0.547605615691, 0.551688497347, 0.555854084117, 0.560050009191, 0.564521264881, 0.569347955800,
						0.574322784361, 0.579510092645, 0.584961457677, 0.590754171202, 0.597105965002, 0.604106477697, 0.611752014152, 0.620589041280, 0.630734397016,
						0.641901685999, 0.704513814536, 0.767045464082, 0.829654095144, 0.892306570909, 0.954983997519, 1.017675103286, 1.080368518869, 1.143061934456,
						1.205755350042, 1.268448765629, 1.331142181216  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063422106433, 0.065166902090, 0.066857240455, 0.068727634913, 0.070315430976, 0.071522246881,
						0.072621736604, 0.073632345620, 0.074546172578, 0.075767169852, 0.077558928054, 0.079330994587, 0.081062569715, 0.082816923899, 0.087517230265,
						0.094217660090, 0.100822872848, 0.106844083563, 0.113466488200, 0.123209893266, 0.132666302326, 0.141121837628, 0.149492480790, 0.160487736691,
						0.172594382415, 0.185184084790, 0.198017570112, 0.212665734218, 0.228431904394, 0.244606313346, 0.261721930295, 0.280252238739, 0.299659730327,
						0.319685136453, 0.339583171500, 0.359954596243, 0.380963884464, 0.400400861762, 0.419544431276, 0.439164017255, 0.458393958826, 0.477973742903,
						0.497810160738, 0.517555133739, 0.537693887480, 0.557430697093, 0.577710884416, 0.597523047859, 0.616894400479, 0.636145035402, 0.654723587302,
						0.673606897408, 0.691989257762, 0.710506630240, 0.728218016286, 0.745983563913, 0.762868835952, 0.779520832114, 0.795442039283, 0.810311738796,
						0.824686064119, 0.837470043276, 0.849512612712, 0.860724908386, 0.870992043119, 0.880028241330, 0.888298577234, 0.895604283736, 0.901898605243,
						0.907772519766, 0.913241598575, 0.917684640033, 0.918890180731, 0.918814825701, 0.918933210545, 0.918973452193, 0.919720908703, 0.920724222029,
						0.921701328915, 0.922678175291, 0.923654778984, 0.924631156594, 0.925607323580, 0.926583294335, 0.927559082266, 0.928534699858, 0.929510158739,
						0.930485469742, 0.931460642955, 0.932435687778, 0.933410612965, 0.934385426672, 0.935360136499, 0.936334749524, 0.937309272342, 0.938283711099,
						0.939258071520, 0.940232358939, 0.941206578328, 0.942180734318, 0.943154831224, 0.944128873068, 0.945102863597, 0.946076806303, 0.947050704440,
						0.948024561041, 0.948998378932, 0.949972160744, 0.950945908934, 0.951919625787, 0.952893313435, 0.953866973864, 0.954840608925, 0.955814220343,
						0.956787809726, 0.957761378572, 0.958734928277  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Monochrome',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090129558931,
						0.118513428992, 0.161557439104, 0.183585697405, 0.200093975652, 0.208057578622, 0.215970131333, 0.225002608116, 0.233879495392, 0.240662071274,
						0.247338185443, 0.254230227189, 0.261105306305, 0.267394020451, 0.272873708978, 0.278074662081, 0.283101734765, 0.288019832776, 0.292944821742,
						0.297672426491, 0.302032614613, 0.306221352992, 0.310269266663, 0.314275256213, 0.318250784779, 0.322119607870, 0.325888885467, 0.329541475946,
						0.333079047674, 0.336554832203, 0.339984067915, 0.343360976958, 0.346693108790, 0.349974270211, 0.353182034904, 0.356320329348, 0.359418720617,
						0.362492160458, 0.365529954410, 0.368516385984, 0.371436781625, 0.374369295393, 0.377384246411, 0.380449869114, 0.383514484285, 0.386579658573,
						0.389634808054, 0.392647838871, 0.395627110133, 0.398638883870, 0.401722968051, 0.404834439823, 0.407921483765, 0.410994007883, 0.414057208753,
						0.417103783757, 0.420145602950, 0.423212741133, 0.426311460699, 0.429399300683, 0.432442612510, 0.435466396352, 0.438510650641, 0.441585590904,
						0.444654826762, 0.447678826870, 0.450678493363, 0.453724102095, 0.456831012284, 0.459983753466, 0.463189922895, 0.466448049052, 0.469692451023,
						0.472914434645, 0.476132751775, 0.479351891463, 0.482571917094, 0.485795265077, 0.489003126931, 0.492300997063, 0.495805683520, 0.499380185386,
						0.502849518582, 0.506282440542, 0.509735949913, 0.513204774156, 0.516641723170, 0.520030088579, 0.523424396172, 0.526834100575, 0.530287729731,
						0.533858145421, 0.537543411008, 0.541400840406, 0.545443580335, 0.549638874781, 0.553990299209, 0.558400834273, 0.562991914893, 0.567987937632,
						0.572992749012, 0.578023423534, 0.583389324988, 0.589449547730, 0.596237282899, 0.603370029808, 0.610812834357, 0.618810651619, 0.628449397199,
						0.641209364072, 0.656079610743, 0.670851711888, 0.685633413195, 0.700423865429, 0.715221980601, 0.730026806070, 0.744837506804, 0.759653351062,
						0.774473698233, 0.789297986894, 0.804125719542  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063411298637, 0.065473225005, 0.067709381852, 0.069944812343, 0.071995254172, 0.073304162528,
						0.074720219671, 0.076007169791, 0.077253960239, 0.078699062445, 0.081546572735, 0.084481566293, 0.087397030027, 0.090312742629, 0.096416171392,
						0.104602992261, 0.111880792294, 0.118525378827, 0.125502768452, 0.134622916852, 0.143692343699, 0.152481137891, 0.161711453810, 0.172700686416,
						0.184604076215, 0.196978236277, 0.209564548601, 0.223672279297, 0.238726919005, 0.254134628935, 0.270374429331, 0.287668992396, 0.305595138142,
						0.324155748053, 0.343639382930, 0.363686479761, 0.384465305893, 0.404456370194, 0.424425227873, 0.444796339648, 0.464510678743, 0.484388513840,
						0.504418236358, 0.524172308005, 0.544292886223, 0.564185830752, 0.584416939007, 0.603905098281, 0.622720493201, 0.641667395658, 0.660613507070,
						0.679425795473, 0.696693040387, 0.714409322616, 0.732049896563, 0.750029943547, 0.767754182324, 0.784375558828, 0.799577226262, 0.813738486503,
						0.827318392881, 0.839525636331, 0.851714184079, 0.862831025734, 0.872171976419, 0.880858961930, 0.889141803850, 0.896959604445, 0.903627190101,
						0.909264232179, 0.913744505556, 0.917827820241, 0.921965195577, 0.926097506034, 0.930228497746, 0.934358028270, 0.938486197832, 0.942613099722,
						0.946738820786, 0.950863441875, 0.954987038264, 0.959109680045, 0.963231432487, 0.967352356368, 0.971472508295, 0.975591940984, 0.979710703538,
						0.983828841690, 0.987946398044, 0.992063412282, 0.996179921373, 1.000295959754, 1.004411559510, 1.008526750532, 1.012641560668, 1.016756015863,
						1.020870140294, 1.024983956485, 1.029097485424, 1.033210746667, 1.037323758437, 1.041436537713, 1.045549100319, 1.049661460998, 1.053773633490,
						1.057885630599, 1.061997464257, 1.066109145582, 1.070220684937, 1.074332091976, 1.078443375701, 1.082554544497, 1.086665606179, 1.090776568032,
						1.094887436845, 1.098998218942, 1.103108920220  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Portrait',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090377297204,
						0.111226442710, 0.130633567550, 0.154389555468, 0.167484430608, 0.174839594233, 0.183469996634, 0.193294111001, 0.201590147870, 0.208632209126,
						0.215987405560, 0.223629338832, 0.231017469096, 0.237919995757, 0.244328495635, 0.250389900549, 0.256464961207, 0.262363127247, 0.267986335890,
						0.273335963136, 0.278548689567, 0.283619640858, 0.288574227782, 0.293525082167, 0.298362229115, 0.303041988045, 0.307568668181, 0.311976904229,
						0.316346477308, 0.320656949316, 0.324898573361, 0.329092080323, 0.333253752423, 0.337335390357, 0.341329550890, 0.345261031804, 0.349127299667,
						0.353006646136, 0.356915623834, 0.360789759371, 0.364625604109, 0.368397738648, 0.372080006233, 0.375820505631, 0.379695767711, 0.383563170183,
						0.387373448545, 0.391156890498, 0.394891149850, 0.398666495274, 0.402574220925, 0.406510206401, 0.410414856020, 0.414296056300, 0.418138859891,
						0.421960984406, 0.425782809615, 0.429572667473, 0.433281562063, 0.436977734201, 0.440756156341, 0.444565180033, 0.448345285966, 0.452106942345,
						0.455840644695, 0.459545962435, 0.463207496528, 0.466829072947, 0.470414623672, 0.473964223990, 0.477488781828, 0.480988569456, 0.484470908978,
						0.487924337343, 0.491384406479, 0.494925495146, 0.498507119369, 0.502014399827, 0.505463972776, 0.508895331480, 0.512316255254, 0.515704743895,
						0.519044770981, 0.522357771953, 0.525665262942, 0.528962750745, 0.532271028161, 0.535581223979, 0.538931946024, 0.542336228199, 0.545819335767,
						0.549487438103, 0.553313651701, 0.557125889811, 0.560955468698, 0.564878349439, 0.568897239861, 0.573033256488, 0.577313495907, 0.581857451013,
						0.586635041242, 0.591627926730, 0.596657408025, 0.601816456841, 0.607467824225, 0.614007423583, 0.621166374566, 0.628556362922, 0.636811644190,
						0.647065080028, 0.699367091432, 0.753605174839, 0.807897396769, 0.862229480648, 0.916586008425, 0.970957527998, 1.025337298823, 1.079717878082,
						1.134098457344, 1.188479036605, 1.242859615866  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063423136263, 0.066462881746, 0.069554089606, 0.072792511194, 0.075979139105, 0.078932975596,
						0.081758133236, 0.084242338721, 0.086596467332, 0.090414496703, 0.098632787117, 0.106105448010, 0.112691707091, 0.118886717045, 0.126607307194,
						0.135381970506, 0.143446256435, 0.151488012869, 0.159970471694, 0.169194405121, 0.179186968869, 0.189265265898, 0.199781372605, 0.211087600159,
						0.222882010816, 0.235146602782, 0.247564852184, 0.260618796978, 0.274368775975, 0.288433493799, 0.302881118328, 0.317614474157, 0.332918076574,
						0.348667044053, 0.364322697224, 0.380282324822, 0.396752589681, 0.412531634149, 0.428585041949, 0.444846606680, 0.460417216218, 0.476090075277,
						0.492011628887, 0.508051391505, 0.524528209215, 0.540603806442, 0.556812950525, 0.573270231981, 0.590112805234, 0.607317141768, 0.624784484757,
						0.642417689555, 0.659550111550, 0.677221493533, 0.695127386540, 0.713484669929, 0.731966315749, 0.750300629233, 0.767925373457, 0.784054829694,
						0.799974605754, 0.815195868133, 0.829558770206, 0.842627040471, 0.854840162809, 0.866820716862, 0.877438793785, 0.886299046904, 0.894688794916,
						0.902697672504, 0.909338504065, 0.914892130237, 0.918231731742, 0.918915083032, 0.919043476065, 0.919239149469, 0.920136059151, 0.921288779755,
						0.922415251170, 0.923541422251, 0.924667313553, 0.925792944212, 0.926918332049, 0.928043493659, 0.929168444498, 0.930293198958, 0.931417770448,
						0.932542171453, 0.933666413606, 0.934790507742, 0.935914463954, 0.937038291645, 0.938161999576, 0.939285595908, 0.940409088244, 0.941532483668,
						0.942655788782, 0.943779009735, 0.944902152257, 0.946025221689, 0.947148223006, 0.948271160844, 0.949394039523, 0.950516863068, 0.951639635232,
						0.952762359509, 0.953885039159, 0.955007677216, 0.956130276510, 0.957252839678, 0.958375369175, 0.959497867293, 0.960620336166, 0.961742777781,
						0.962865193993, 0.963987586528, 0.965109956997  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Landscape',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090014281627,
						0.125262756783, 0.175394871323, 0.201468245826, 0.210914156758, 0.220255090663, 0.230320004433, 0.237899490783, 0.244037210321, 0.250534903571,
						0.257758397707, 0.265125636355, 0.270861063964, 0.276088839523, 0.281077811268, 0.285962815933, 0.290792094924, 0.295589187329, 0.299952875638,
						0.304038876382, 0.307985999261, 0.311823369684, 0.315647582100, 0.319412786133, 0.323068235362, 0.326624111035, 0.330039441071, 0.333332259731,
						0.336562154474, 0.339737539911, 0.342863954371, 0.345947530923, 0.348988934054, 0.352034941511, 0.355105612192, 0.358169762222, 0.361200953136,
						0.364207980690, 0.367181171002, 0.370081303694, 0.372961364740, 0.375946473112, 0.379070635127, 0.382250836990, 0.385437951772, 0.388644687165,
						0.391806775547, 0.394912899124, 0.398023732258, 0.401189225678, 0.404377387650, 0.407533994910, 0.410661186470, 0.413769752051, 0.416856569741,
						0.419928375398, 0.423011688238, 0.426113673928, 0.429202840995, 0.432247581554, 0.435269097809, 0.438320205573, 0.441423089653, 0.444521471455,
						0.447557800230, 0.450556342802, 0.453581499220, 0.456648032790, 0.459742607442, 0.462868813548, 0.466028335421, 0.469195953395, 0.472352862884,
						0.475531499554, 0.478780564930, 0.482087135150, 0.485363351397, 0.488586918940, 0.491824446382, 0.495130114255, 0.498468340983, 0.501777107483,
						0.505058400010, 0.508397188549, 0.511840110704, 0.515312142846, 0.518738499960, 0.522176040842, 0.525720612003, 0.529356285838, 0.532997521466,
						0.536642367114, 0.540365200664, 0.544175285378, 0.548107328251, 0.552192349558, 0.556349227616, 0.560560482382, 0.565069214291, 0.569899347725,
						0.574871037285, 0.580070468084, 0.585551663364, 0.591351930507, 0.597726675336, 0.604734853205, 0.612436678142, 0.621316593050, 0.631412155268,
						0.642407361803, 0.705185166051, 0.768799223484, 0.832491771003, 0.896228587957, 0.959990352659, 1.023765329935, 1.087542056186, 1.151318782440,
						1.215095508694, 1.278872234948, 1.342648961202  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063424602387, 0.065158719093, 0.066844337216, 0.068684208620, 0.070266797005, 0.071428317343,
						0.072543802315, 0.073565478875, 0.074487180884, 0.075615127884, 0.077358107033, 0.079057203638, 0.080785142809, 0.082568609461, 0.087086590075,
						0.093769852277, 0.100367927146, 0.106434856177, 0.113007625398, 0.122717469882, 0.132201743401, 0.140683305794, 0.149045991690, 0.160057857913,
						0.172146745702, 0.184714602362, 0.197531016229, 0.212198748641, 0.227944458602, 0.244092918950, 0.261202823820, 0.279731408185, 0.299105025428,
						0.319106165979, 0.339034794480, 0.359391749047, 0.380382823923, 0.399821157211, 0.418933430124, 0.438529485049, 0.457746216431, 0.477300192906,
						0.497127504497, 0.516859464506, 0.536977578582, 0.556704529271, 0.576955897034, 0.596747644730, 0.616086030400, 0.635316040970, 0.653874499813,
						0.672741331452, 0.691099597289, 0.709588441640, 0.727270882484, 0.745001904949, 0.761868035665, 0.778540245167, 0.794460294454, 0.809377586481,
						0.823762555425, 0.836596499610, 0.848686298910, 0.859908326372, 0.870238967260, 0.879342623248, 0.887630917192, 0.894981327227, 0.901356587391,
						0.907285193365, 0.912856265123, 0.917595172338, 0.918922145184, 0.918818251367, 0.918920088871, 0.918943684746, 0.919674534281, 0.920661245730,
						0.921621755491, 0.922582009166, 0.923542024281, 0.924501817154, 0.925461402979, 0.926420795907, 0.927380009116, 0.928339054879, 0.929297944628,
						0.930256689010, 0.931215297944, 0.932173780667, 0.933132145787, 0.934090401321, 0.935048554738, 0.936006612998, 0.936964582584, 0.937922469536,
						0.938880279483, 0.939838017669, 0.940795688979, 0.941753297967, 0.942710848875, 0.943668345656, 0.944625791994, 0.945583191322, 0.946540546837,
						0.947497861522, 0.948455138154, 0.949412379321, 0.950369587435, 0.951326764746, 0.952283913348, 0.953241035193, 0.954198132101, 0.955155205767,
						0.956112257773, 0.957069289591, 0.958026302593  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
//
	this.pqOOTF = new LUTGammaOOTFPQ('Display PQ OOTF (nits)', {Lw: 10000, scale: 'nits'});
	this.hlgOOTF = new LUTGammaOOTFHLG('Display HLG OOTF (nits)', {Lw: 1000, Lb: 0, scale: 'nits'});
	this.pqNoOOTF = new LUTGammaOOTFNone('Scene Linear (nits)', {Lw: 10000});
	this.pqOOTFNorm = new LUTGammaOOTFPQ('Display PQ OOTF (Normalised)', {Lw: 10000, scale: 'normalised'});
	this.hlgOOTFNorm = new LUTGammaOOTFHLG('Display HLG OOTF (Normalised)', {Lw: 1000, Lb: 0, scale: 'normalised'});
//
	this.PQ = this.gammas.length;
	this.gammas.push(new LUTGammaPQ(
		'Rec2100 PQ (PQ OOTF)', this.pqOOTF));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaPQ(
		'Rec2100 PQ (HLG OOTF)', this.hlgOOTF));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.HLG = this.gammas.length;
	this.gammas.push(new LUTGammaHLG(
		'Rec2100 HLG', {a: 0.17883277, b: 0.28466892, c: 0.55991073}));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.pqEOTFIdx = this.gammas.length;
	this.gammas.push(new LUTGammaPQ(
		'PQ (EOTF Only)', this.pqNoOOTF));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
//
	this.gammas.push(new LUTGammaLUTSimple(
		'HG3250G36 (HG1)',
		{
			clip: 4.607,
			loggy: 0.00896,
			lut: new Float64Array(
				[	0.08797654,0.10544838,0.130894073,0.167872574,
					0.194834348,0.226358779,0.266268941,0.31582866,
					0.377990009,0.453504879,0.541509091,0.636928684,
					0.731022684,0.813771264,0.877502171,0.919831827,
					0.936196343 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG4600G30 (HG2)',
		{
			clip: 5.471,
			loggy: 0.00491,
			lut: new Float64Array(
				[	0.08797654,0.104192531,0.126464534,0.15295782,
					0.176615948,0.205826206,0.243989699,0.292906636,
					0.356424356,0.436709059,0.533166639,0.639815303,
					0.74453493,0.833365445,0.8969974,0.934175897,
					0.946701781 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG3259G40 (HG3)',
		{
			clip: 5.424,
			loggy: 0.00527,
			lut: new Float64Array(
				[	0.08797654,0.106966953,0.136197387,0.179217692,
					0.211658973,0.251242869,0.302925063,0.368355366,
					0.451618812,0.552562868,0.666187509,0.780975438,
					0.881914932,0.95753893,1.005027748,1.027378519,
					1.032819393 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG4609G33 (HG4)',
		{
			clip: 4.987,
			loggy: 0.0129,
			lut: new Float64Array(
				[	0.08797654,0.116808731,0.151974786,0.180100256,
					0.210030322,0.24682835,0.291407476,0.346545743,
					0.414273303,0.495344317,0.588468737,0.688544076,
					0.787019889,0.874636069,0.942887027,0.991399694,
					1.011271456 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG8000G36 (HG5)',
		{
			clip: 5.8,
			loggy: 0.033475,
			lut: new Float64Array(
				[	0.086897445,0.174053304,0.226750469,0.282647061,
					0.346604743,0.419397456,0.499103345,0.58154343,
					0.661222354,0.732765443,0.792295168,0.838670413,
					0.872336124,0.895357636,0.910092389,0.919082976,
					0.922720436 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG8000G30 (HG6)',
		{
			clip: 6.3,
			loggy: 0.0184378,
			lut: new Float64Array(
				[	0.086897445,0.158925131,0.199263137,0.241244264,
					0.290010228,0.348221239,0.417126792,0.496076175,
					0.581700745,0.667766242,0.746717346,0.812590251,
					0.86214621,0.895831084,0.91668667,0.927087485,
					0.930959367 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG8009G40 (HG7)',
		{
			clip: 6.324,
			loggy: 0.0072,
			lut: new Float64Array(
				[	0.08797654,0.128135647,0.186195571,0.226012647,
					0.274212921,0.335341074,0.412483511,0.505912502,
					0.61090837,0.717257525,0.81246933,0.887758829,
					0.940377098,0.973389141,0.991844955,1.001278468,
					1.004289649 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG8009G33 (HG8)',
		{
			clip: 5.568,
			loggy: 0.0114,
			lut: new Float64Array(
				[	0.08797654,0.122144207,0.163936124,0.193789797,
					0.228638656,0.271257909,0.324762115,0.391105031,
					0.471722516,0.564565892,0.663932304,0.76057611,
					0.844909521,0.911004616,0.956498789,0.986149734,
					0.997564399 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'Cinegamma1',
		{
			clip: 4.987,
			loggy: 0.0129,
			lut: new Float64Array(
				[	0.08797654,0.116808731,0.151974786,0.180100256,
					0.210030322,0.24682835,0.291407476,0.346545743,
					0.414273303,0.495344317,0.588468737,0.688544076,
					0.787019889,0.874636069,0.942887027,0.991399694,
					1.011271456 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'Cinegamma2',
		{
			clip: 5.471,
			loggy: 0.00491,
			lut: new Float64Array(
				[	0.08797654,0.104192531,0.126464534,0.15295782,
					0.176615948,0.205826206,0.243989699,0.292906636,
					0.356424356,0.436709059,0.533166639,0.639815303,
					0.74453493,0.833365445,0.8969974,0.934175897,
					0.946701781 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Cinegamma3',
		{
			clip: 4.1,
			loggy: 0.01,
			lut: new Float64Array(
				[	0.078131789,0.09920475,0.122162118,0.151981053,
					0.181906428,0.220375167,0.267387627,0.325563795,
					0.394207316,0.484397908,0.591913512,0.681441253,
					0.753396056,0.817388645,0.879105528,0.936594209,
					0.994314701 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'Cinegamma4',
		{
			clip: 4.5,
			loggy: 0.01,
			lut: new Float64Array(
				[	0.077769272,0.095397854,0.120450392,0.156824535,
					0.196163068,0.242764534,0.297417162,0.357887286,
					0.430140946,0.515413669,0.618592194,0.705057939,
					0.771271414,0.832072263,0.885754684,0.936822309,
					0.987590161 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD1',
		{
			clip: 4,
			loggy: 0.017629,
			lut: new Float64Array(
				[	0.08797654,0.102779743,0.123103793,0.15204128,
					0.192300409,0.24825427,0.324632702,0.399870573,
					0.47660843,0.556285815,0.644181507,0.735266384,
					0.810806802,0.866443347,0.90467502,0.941259156,
					0.988794595 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD2 - x4.5',
		{
			clip: 4,
			loggy: 0.008254,
			lut: new Float64Array(
				[	0.08797654,0.098622061,0.114272152,0.137276217,
					0.171038737,0.220119176,0.274837007,0.33335793,
					0.399208497,0.472934824,0.558776425,0.660553828,
					0.764298918,0.842427286,0.893359663,0.933816378,
					0.985740801 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD3 - x3.5',
		{
			clip: 4,
			loggy: 0.020241,
			lut: new Float64Array(
				[	0.08797654,0.10445177,0.126912437,0.158425349,
					0.201870238,0.255736464,0.311556741,0.372989109,
					0.44362902,0.523307566,0.615503441,0.718323954,
					0.802280114,0.862208212,0.90256618,0.937483433,
					0.982351386 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD4 - SMPTE240M',
		{
			clip: 4,
			loggy: 0.019905,
			lut: new Float64Array(
				[	0.08797654,0.109381233,0.138901447,0.176210165,
					0.216932275,0.263165877,0.315600146,0.375268835,
					0.445421661,0.524947756,0.617187794,0.719160107,
					0.802696756,0.862488014,0.902446754,0.93785016,
					0.983542491 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD5 - Rec709',
		{
			clip: 4,
			loggy: 0.0203,
			lut: new Float64Array(
				[	0.08797654,0.112246952,0.145387857,0.183126966,
					0.224110408,0.270392689,0.323005008,0.382133984,
					0.451705404,0.530572659,0.621946987,0.722476974,
					0.804668815,0.863536358,0.903322935,0.938810956,
					0.984511672 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD6 - x5',
		{
			clip: 4,
			loggy: 0.019855,
			lut: new Float64Array(
				[	0.08797654,0.115025696,0.15175495,0.201870505,
					0.251515315,0.301256018,0.354820624,0.413032596,
					0.480142153,0.554913856,0.640879024,0.733933755,
					0.810921922,0.866540067,0.904779871,0.940303144,
					0.98630421 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
/*
	this.gammas.push(new LUTGammaGen(
		'Canon WideDR',
		{
			blk: [ 4.143864904, 0.062733691 ],
			bot: [ 4.143864904, 0.062733691 ],
			low: [ 1.123724397, 0.023399556, 0.725329449, 1.793298155, 1.618753622, 1.512604528, 0.010239171 ],
			mid: [ 1.175009007, -0.889534156, 0.366778059, 1.74451447, 0.920944271, 0.662662566, 0.200816705 ],
			high: [ 1.075984367, 0.080088043, 0.54850957, 1.222465712, 1.162090342, 1.216780039, 1.001012923 ],
			top: [ 1.184590585, 0.32981997, 0.381916345, 1.047595142, 1.356034214, 1.40672617, 3.213458281 ]
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gammaDat.push(false);
	this.gammaExt.push(true);
*/
	this.gammas.push(new LUTGammaLUTSimple(
		'Canon WideDR',
		{
			clip: 6,
			loggy: 0.003936,
			lut: new Float64Array(
				[	0.062561095,0.083588769,0.114009387,0.15660632,
					0.208062502,0.270138527,0.344705558,0.433179626,
					0.533196849,0.625617722,0.710704057,0.787648239,
					0.854327941,0.909579605,0.954325784,0.993866446,
					1.028803 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.rec709 = this.gammas.length;
	this.gammas.push(new LUTGammaGam(
		'Rec709', [ 1/0.45, 4.50000000, 0.09900000, 0.01800000, 0.08100000, 1.9 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'Rec2020 12-bit', [ 1/0.45, 4.50000000, 0.09930000, 0.01810000, 0.08145000, 1.9 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'sRGB', [ 2.40000000,12.92000000, 0.05500000, 0.00313080, 0.04015966, 2.2 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('sRGB');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'DCI', [ 2.6,1, 0, 0.0000001, 0.0000001, 2.6 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLin(
		'Scene Linear IRE', 0.2));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLin(
		'Scene Reflectance', 0.18));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaGam(
		'CIE L*', [ 3.0,24389.0 / 2700.0, 0.16, 216.0 / 24389.0 , 216.0 / 2700.0, 2.45 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('sRGB');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaBBCGam(
		'BBC 0.4', [ 0.4,5, -0.02262, 0.037703, Math.pow((0.037703-0.02262)/(1-0.02262),0.4), false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaBBCGam(
		'BBC 0.5', [ 0.5,5, -0.01011, 0.020202, Math.pow((0.020202-0.01011)/(1-0.01011),0.5), false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaBBCGam(
		'BBC 0.6', [ 0.6,5, -0.00334, 0.008857, Math.pow((0.008857-0.00334)/(1-0.00334),0.6), false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'ProPhoto / ROMM', [ 1.8,16, 0, Math.pow(16,1.8/-0.8), Math.pow(Math.pow(16,1.8/-0.8),1/1.8), 1.8 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('ProPhoto RGB');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ1.5', [ 1.5,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ1.6', [ 1.6,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ1.7', [ 1.7,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ1.8', [ 1.8,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ1.9', [ 1.9,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.0', [ 2.0,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.1', [ 2.1,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.2', [ 2.2,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.3', [ 2.3,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.4', [ 2.4,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.5', [ 2.5,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.6', [ 2.6,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
//
	this.pqOOTFIdx = this.gammas.length;
	this.gammas.push(this.pqOOTF);
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(this.pqOOTFNorm);
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.hlgOOTFIdx = this.gammas.length;
	this.gammas.push(this.hlgOOTF);
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(this.hlgOOTFNorm);
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
//
	this.gammas.push(new LUTGammaITUProp(
		'ITU Proposal (400%)', {m: 0.12314858 }));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaITUProp(
		'ITU Proposal (800%)', {m: 0.083822216783 }));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaBBC283(
		'BBC WHP283 (400%)', {m: 0.139401137752}));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaBBC283(
		'BBC WHP283 (800%)', {m: 0.097401889128}));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.LA = this.gammas.length;
	this.gammas.push(new LUTGammaLA(
		'LA', this.lutMaker));
	this.gammaSub.push([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaNull(
		'Null'));
	this.gammaSub.push([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(false);
	var max = this.gammas.length;
	var logList = [], linList = [], genList = [], hdrList = [], ioList = [];
	var firstLin = false;
	var disList = [];
	for (var i=0; i < max; i++) {
		if (i === this.LA) {
			this.inList.push({name: 'Linear / γ', idx: 9999});
			this.outList.push({name: 'Linear / γ', idx: 9999});
		}
		this.catList[i] = this.gammas[i].cat;
		switch(this.gammas[i].cat) {
			case 0: logList.push({name: this.gammas[i].name, idx: i});
					this.inList.push({name: this.gammas[i].name, idx: i});
					this.outList.push({name: this.gammas[i].name, idx: i});
					break;
			case 1: /* if (!firstLin) {
						this.inList.push({name: 'Linear / γ', idx: 9999});
						this.outList.push({name: 'Linear / γ', idx: 9999});
						firstLin = true;
					} */
					if (this.gammas[i].gamma !== '') {
						this.linList.push({name: this.gammas[i].name + ' - ' + this.gammas[i].gamma, idx: i});
					} else {
						this.linList.push({name: this.gammas[i].name, idx: i});
					}
					if (this.gammas[i].name.indexOf('DCI') !== -1) {
						this.disList.push({name: 'DCI-P3', idx: i});
						this.disGts.push('P3 - DCI');
						this.disList.push({name: 'DCI-D60', idx: i});
						this.disGts.push('P3 - D60');
						this.disList.push({name: 'DCI-D65', idx: i});
						this.disGts.push('P3 - D65');
					} else if (this.gammas[i].name.indexOf('OOTF') === -1) {
						this.disList.push({name: this.gammas[i].name, idx: i});
						this.disGts.push(this.gts[i]);
					}
					this.dispInIdx = this.rec709;
					this.dispOutIdx = this.rec709;
/*
					// This allows HDR OOTFs to be on both the main list and the linear sublist
					if (this.gammas[i].hdrOOTF) {
						hdrList.push({name: this.gammas[i].name, idx: i});
						this.inList.push({name: this.gammas[i].name, idx: i});
						this.outList.push({name: this.gammas[i].name, idx: i});					}
*/
					break;

			case 2: genList.push({name: this.gammas[i].name, idx: i});
					this.outList.push({name: this.gammas[i].name, idx: i});
					break;
			case 3: this.outList.push({name: this.gammas[i].name, idx: i});
					break;
			case 5:
			case 7: hdrList.push({name: this.gammas[i].name, idx: i});
					this.inList.push({name: this.gammas[i].name, idx: i});
					this.outList.push({name: this.gammas[i].name, idx: i});
					if (this.gammas[i].name.indexOf('Rec2100') !== -1 || this.gammas[i].name.indexOf('PQ') !== -1) {
						disList.push({name: this.gammas[i].name, idx: i});
					}
					break;
			case 6: ioList.push({name: this.gammas[i].name, idx: i});
					this.inList.push({name: this.gammas[i].name, idx: i});
					this.outList.push({name: this.gammas[i].name, idx: i});
					break;
			default: break;
		}
	}
	max = disList.length;
	for (var i=0; i<max; i++) {
		this.disList.push(disList[i]);
		this.disGts.push(this.gts[disList[i].idx]);
	}
};
LUTGamma.prototype.displayCSMatrices = function() {
	// Rec709 toSys
	this.disInM.push(new Float64Array([0.6456794776099916, 0.25911454699971487, 0.09520597539029335, 0.08752999151186006, 0.7596995625540708, 0.1527704459340693, 0.03695741988752366, 0.12928090476633824, 0.8337616753461381]));
	// Rec2020 toSys
	this.disInM.push(new Float64Array([1.038144061903922, -0.0954526919638479, 0.0573086300599257, 0.047948922098344345, 0.7938618492737212, 0.15818922862793428, 0.030132054285551286, 0.040885792893120027, 0.9289821528213285]));
	// sRGB toSys
	this.disInM.push(new Float64Array([0.6456794776099916, 0.25911454699971487, 0.09520597539029335, 0.08752999151186006, 0.7596995625540708, 0.1527704459340693, 0.03695741988752366, 0.12928090476633824, 0.8337616753461381]));
	// DCI-P3 toSys
	this.disInM.push(new Float64Array([0.7284052217293149, 0.16972007915418877, 0.10187469911649552, 0.06583664487264183, 0.7683322228321781, 0.16583113229518043, 0.022366516069157787, 0.07128319107748499, 0.9063502928533571]));
	// DCI-D60 toSys
	this.disInM.push(new Float64Array([0.7946914170629898, 0.1026408043822886, 0.10266777855472128, 0.07452398482107307, 0.758588312905917, 0.16688770227300992, 0.024364185140024742, 0.06406449308408323, 0.9115713217758921]));
	// DCI-P65 toSys
	this.disInM.push(new Float64Array([0.7781515518174815, 0.1172862388356883, 0.10456220934682967, 0.07226831516524734, 0.7599479371836014, 0.16778374765115117, 0.023460426860374018, 0.0608411362976594, 0.9156984368419665]));
	// ProPhotoRGB toSys
	this.disInM.push(new Float64Array([1.2555250198288999, -0.17208107153730076, -0.0834439482915996, 0.005084768090106999, 0.8440643991075522, 0.15085083280234088, 0.03723287615234582, 0.018430596881984247, 0.9443365269656698]));
	// Rec709 fromSys
	this.disOutM.push(new Float64Array([1.626947409729081, -0.5401385388696355, -0.08680887085944519, -0.1785155271148767, 1.4179409274640788, -0.23942540034920257, -0.04443611500929754, -0.19591996617201543, 1.240356081181313]));
	// Rec2020 fromSys
	this.disOutM.push(new Float64Array([0.960046343810585, 0.11953297884015643, -0.07957932265074112, -0.052239479550917664, 1.2643057472387877, -0.21206626768786963, -0.028840506704261047, -0.05952096816347168, 1.088361474867733]));
	// sRGB fromSys
	this.disOutM.push(new Float64Array([1.626947409729081, -0.5401385388696355, -0.08680887085944519, -0.1785155271148767, 1.4179409274640788, -0.23942540034920257, -0.04443611500929754, -0.19591996617201543, 1.240356081181313]));
	// DCI-P3 fromSys
	this.disOutM.push(new Float64Array([1.4031705894567847, -0.30041923567015294, -0.10275135378663051, -0.11470806752635113, 1.3485540776963754, -0.23384601017002465, -0.025605199914686478, -0.09864828978558927, 1.124253489700276]));
	// DCI-D60 fromSys
	this.disOutM.push(new Float64Array([1.2771466836937062, -0.16317957410992093, -0.11396710958378524, -0.1198100995203766, 1.3542477763440348, -0.23443767682365865, -0.02571500923777254, -0.0908140240587726, 1.116529033296545]));
	// DCI-P65 fromSys
	this.disOutM.push(new Float64Array([1.306409074362619, -0.19250496531591546, -0.11390410904670316, -0.11858463137123738, 1.3529440482926134, -0.23435941692137607, -0.025591493745000585, -0.08496072664984984, 1.1105522203948506]));
	// ProPhotoRGB fromSys
	this.disOutM.push(new Float64Array([0.7945082685980932, 0.16100660920522486, 0.04448512219668231, 0.0008150912135569344, 1.1890558318454256, -0.18987092305898276, -0.031341423040583696, -0.029554874825018167, 1.060896297865602]));
};
// Matrix operations
LUTGamma.prototype.mInverse = function(M) {
	var det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
				(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
				(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	if (det === 0) {
		return false;
	}
	return new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
LUTGamma.prototype.mMult = function(m1,m2) {
	if (m1.length !== 9) {
		return false;
	}
	var len = m2.length;
	if (len === 3) {
		var out = new Float64Array(3);
		out[0] = (m1[0]*m2[0]) + (m1[1]*m2[1]) + (m1[2]*m2[2]);
		out[1] = (m1[3]*m2[0]) + (m1[4]*m2[1]) + (m1[5]*m2[2]);
		out[2] = (m1[6]*m2[0]) + (m1[7]*m2[1]) + (m1[8]*m2[2]);
		return out;
	} else if (len === 9) {
		var out = new Float64Array(9);
		out[0] = (m1[0]*m2[0]) + (m1[1]*m2[3]) + (m1[2]*m2[6]);
		out[1] = (m1[0]*m2[1]) + (m1[1]*m2[4]) + (m1[2]*m2[7]);
		out[2] = (m1[0]*m2[2]) + (m1[1]*m2[5]) + (m1[2]*m2[8]);
		out[3] = (m1[3]*m2[0]) + (m1[4]*m2[3]) + (m1[5]*m2[6]);
		out[4] = (m1[3]*m2[1]) + (m1[4]*m2[4]) + (m1[5]*m2[7]);
		out[5] = (m1[3]*m2[2]) + (m1[4]*m2[5]) + (m1[5]*m2[8]);
		out[6] = (m1[6]*m2[0]) + (m1[7]*m2[3]) + (m1[8]*m2[6]);
		out[7] = (m1[6]*m2[1]) + (m1[7]*m2[4]) + (m1[8]*m2[7]);
		out[8] = (m1[6]*m2[2]) + (m1[7]*m2[5]) + (m1[8]*m2[8]);
		return out;
	} else {
		return false;
	}
};
// Parameter setting functions
LUTGamma.prototype.setASCCDL = function(params) {
	var out = {};
	this.doASCCDL = false;
	this.changedASCCDL = false;
	if (this.tweaks && typeof params.twkASCCDL !== 'undefined') {
		var p = params.twkASCCDL;
		if (typeof p.doASCCDL === 'boolean') {
			var didASCCDL = this.doASCCDL;
			this.doASCCDL = p.doASCCDL;	
			if (didASCCDL && !this.doASCCDL) {
				this.changedASCCDL = true;
			}
		}
		if (typeof p.cdl !== 'undefined') {
			var newCDL = new Float64Array(p.cdl);
			for (var j=0; j<10; j++) {
				if (newCDL[j] !== this.asc[j]) {
					this.asc = newCDL;
					if (j < 9) {
						this.changedASCCDL = true;
					}
					break;
				}
			}
		}
	}
	out.doASCCDL = this.doASCCDL;
	return out;
};
LUTGamma.prototype.setKnee = function(params) {
	var out = {};
	this.doKnee = false;
	if (this.tweaks && typeof params.twkKnee !== 'undefined') {
		var p = params.twkKnee;
		if (typeof p.doKnee === 'boolean') {
			this.doKnee = p.doKnee;	
		}
		var legal = true;
		if (typeof p.legal === 'boolean') {
			legal = p.legal;
		}
		var max = false;
		for (var j=8; j>0; j -= 0.1) {
			if (this.f(j) <= 0.95) {
				max = j;
				break;
			}
		}
		out.max = max;
		if (typeof p.smoothness === 'number') {
			this.kSmooth = p.smoothness;
		}
		if (typeof p.kneeStart !== 'number' || typeof p.kneeClip !== 'number' || typeof p.clipSlope !== 'number') {
			this.doKnee = false;
		} else {
			this.kS = p.kneeStart;
			if (this.kS > max) {
				this.kS = max;
				out.kneeStart = this.kS;
			}
			this.kL = Math.pow(2,this.kS)*0.2;
			this.kC = p.kneeClip;
			if (this.doASCCDL) {
				var kC = Math.pow(2,this.kC)*0.2;
				var rA,gA,bA;
				rA = (kC*this.asc[0])+this.asc[3];
				rA = 0.2126*((rA<0)?rA:Math.pow(rA,this.asc[6]));
				gA = (kC*this.asc[1])+this.asc[4];
				gA = 0.7152*((gA<0)?gA:Math.pow(gA,this.asc[7]));
				bA = (kC*this.asc[2])+this.asc[5];
				bA = 0.0722*((bA<0)?bA:Math.pow(bA,this.asc[8]));
				kC = ((isNaN(rA)?0:rA)+(isNaN(gA)?0:gA)+(isNaN(bA)?0:bA));	// if ASCCDL ends up pushing highlights higher, change kCl, if not leave as is
				this.kC = Math.log(kC/0.2)/Math.LN2;
			}
			this.kR = this.kC - this.kS;
			this.kp0 = this.f(this.kS);
			if (legal) {
				this.kp2 = 0.99;
			} else {
				this.kp2 = (959/876)-0.01;
			}
			this.kd0 = (this.f(this.kS+0.001)-this.f(this.kS-0.001))*this.kR/0.002;
			this.kD2 = p.clipSlope/100;
			this.kd2 = this.kD2*this.kR;

			var a = (2 * this.kp0) + this.kd0 - (2 * this.kp2) + this.kd2;
			var b = - (3 * this.kp0) - (2 * this.kd0) + (3 * this.kp2) - this.kd2;
			var c = this.kd0;
			var d = this.kp0;
			this.ks = 0.5;
			this.kp1 = ((((((a * this.ks) + b) * this.ks) + c) * this.ks) + d);
			this.kd1 = ((((((a * (this.ks+0.001)) + b) * (this.ks+0.001)) + c) * (this.ks+0.001))-(((((a * (this.ks-0.001)) + b) * (this.ks-0.001)) + c) * (this.ks-0.001)))/0.002;

			this.kd0 /= 2;
			this.kd1 /= 2;
			this.kd2 /= 2;
			if (this.kd0 < 0) {
				this.doKnee = false;
				out.doKnee = false;
			} else {
				var a0,b0,c0,sqr0,sqrt0,r0p,r0m;
				var a1,b1,c1,sqr1,sqrt1,r1p,r1m;
				var rat;
				var kd0,kd1a,kd1b,kd2;
				var kp1 = this.kp1;
				var kd1 = this.kd1;

				this.kp1 = Math.min(this.kp1,(0.1*this.kp0)+((0.9)*this.kp2));
				this.kd1 = Math.max(this.kd1,(this.kp2-this.kp1)/0.9);

				kd0 = this.kd0 / (2*(1-this.ks));
				kd1a = this.kd1 / (2*(1-this.ks));
				kd1b = this.kd1 / (2*this.ks);
				kd2 = this.kd2 / (2*this.ks);

				a0 = (2 * this.kp0) + kd0 - (2 * this.kp1) + kd1a;
				b0 = - (3 * this.kp0) - (2 * kd0) + (3 * this.kp1) - kd1a;
				c0 = kd0;
				sqr0 = (b0*b0) - (3*a0*c0);
				a1 = (2 * this.kp1) + kd1b - (2 * this.kp2) + kd2;
				b1 = - (3 * this.kp1) - (2 * kd1b) + (3 * this.kp2) - kd2;
				c1 = kd1b;
				sqr1 = (b1*b1) - (3*a1*c1);

				if (sqr0 >=0 || sqr1 >= 0) { // real roots
					sqrt0 = Math.pow(sqr0,0.5);
					r0p = (- b0 + sqrt0)/(3*a0);
					r0m = (- b0 - sqrt0)/(3*a0);
//					sqrt1 = Math.pow(sqr1,0.5);
//					r1p = (- b1 + sqrt1)/(3*a1);
//					r1m = (- b1 - sqrt1)/(3*a1);
					if (!isNaN(sqrt0) && ((r0p>0 && r0p<1) || (r0m>0 && r0m<1))) { // the knee is not monotonic
						this.kp1 = (0.1*this.kp0)+((0.9)*this.kp2);
						this.kd1 = (this.kp1 - this.kp0)*1.29/6.59;
						this.ks = ((10.89*this.kd1)/(1.29*this.kd0));
					}
				}
			}
		}
	}
	return out;
};
LUTGamma.prototype.setBlkHi = function(params) {
	var out = {};
	this.al = 1;
	this.bl = 0;
	this.ad = 1;
	this.bd = 0;
	this.doBlkHi = false;
	if (this.tweaks && typeof params.twkBlkHi !== 'undefined') {
		var p = params.twkBlkHi;
		var changedRef = false;
		if (typeof p.highRef === 'number') {
			if (this.highRef !== p.highRef) {
				changedRef = true;
			}
			this.highRef = p.highRef;
		} else {
			this.highRef = 0.9;
		}
		var bhDef = new Float64Array([ 0,this.highRef/0.9 ]);
		this.getLumVals(bhDef.buffer);
		var blackDefault = bhDef[0];
		var highDefault = bhDef[1];
		var blackLock = false;
		if (typeof p.blackLock === 'boolean') {
			blackLock = p.blackLock;
		}
		var highLock = false;
		if (typeof p.highLock === 'boolean') {
			highLock = p.highLock;
		}
		var blackMap;
		if (typeof p.blackLevel === 'number') {
			if (blackLock || (Math.abs(blackDefault-p.blackLevel)>0.0001 && !this.changedOut && !this.changedASCCDL && !this.changedHDR)) {
				blackMap = p.blackLevel;
			} else {
				blackMap = blackDefault;
			}
		} else {
			blackMap = blackDefault;
		}
		var highMap;
		if (typeof p.highMap === 'number') {
			if (highLock || (Math.abs(highDefault-p.highMap)>0.0001 && !this.changedOut && !changedRef && !this.changedASCCDL && !this.changedHDR)) {
				highMap = p.highMap;
			} else {
				highMap = highDefault;
			}
		} else {
			highMap = highDefault;
		}
		out.blackDef = blackDefault;
		out.blackLevel = blackMap;
		out.highRef = this.highRef;
		out.highDef = highDefault;
		out.high709 = this.gammas[this.rec709].linToLegal(this.highRef/0.9);
		out.highMap = highMap;
		out.hmmm=p;
		if (typeof p.doBlkHi === 'boolean' && p.doBlkHi) {
			if (!p.doBlack) {
				blackMap = blackDefault;
			}
			if (!p.doHigh) {
				highMap = highDefault;
			}
			if (!this.nul && (p.doBlack || p.doHigh)) {
				this.al = (highMap - blackMap)/(highDefault - blackDefault);
				this.bl = blackMap - (blackDefault * this.al);
				this.ad = this.al;
				this.bd = ((876*(blackMap - (this.al*blackDefault))) + (64*(1- this.al)))/1023;
				this.doBlkHi = true;
			}
		}
	} else {
		var bhDef = new Float64Array([ 0,this.highRef/0.9 ]);
		this.getLumVals(bhDef.buffer);
		var blackDefault = bhDef[0];
		var highDefault = bhDef[1];
		out.blackDef = blackDefault;
		out.blackLevel = blackDefault;
		out.highRef = 0.9;
		out.highDef = highDefault;
		out.high709 = this.gammas[this.rec709].linToLegal(this.highRef/0.9);
		out.highMap = highDefault;
	}
	if (this.gammas[this.curOut].cat === 3){
		this.doBlkHi = false;
	}
	out.doBlkHi = this.doBlkHi;
	return out;
};
LUTGamma.prototype.setBlkGam = function(params) {
	var out = {};
	this.doBlkGam = false;
	if (this.tweaks && typeof params.twkBlkGam !== 'undefined') {
		var p = params.twkBlkGam;
		if (typeof p.doBlkGam === 'boolean') {
			this.doBlkGam = p.doBlkGam;	
		}
		if (typeof p.upperLim === 'number') {
			this.blkGamLStop = p.upperLim;
		}
		if (typeof p.feather === 'number') {
			this.blkGamFStop = p.feather;
		}
		if (typeof p.power === 'number') {
			this.blkGamP = p.power;
		}
	}
	var vals = new Float64Array([
		0,
		Math.pow(2,this.blkGamLStop)*0.2,
		Math.pow(2,this.blkGamLStop - this.blkGamFStop)*0.2
	]);
	this.getLumVals(vals.buffer);
	if (this.doBlkHi) {
		this.blkLevel = (vals[0]*this.al)+this.bl;
		this.blkGamUL = (vals[1]*this.al)+this.bl;
		this.blkGamLL = (vals[2]*this.al)+this.bl;
	} else {
		this.blkLevel = vals[0];
		this.blkGamUL = vals[1];
		this.blkGamLL = vals[2];
	}
	this.blkGamF = this.blkGamUL - this.blkGamLL;
/*
	this.blkGamLL = this.blkGamUL-this.blkGamF;
	out.doBlkGam = this.doBlkGam;
	var blk = new Float64Array([ 0 ]);
	this.getLumVals(blk.buffer);
	if (this.doBlkHi) {
		this.blkLevel = (blk[0]*this.al)+this.bl;

	} else {
		this.blkLevel = blk[0];
	}
*/
	this.blkGamR = this.blkGamUL-this.blkLevel;
	out.blkLevel = this.blkLevel;
	return out;
};
LUTGamma.prototype.setDisplay = function(params) {
	var out = {};
	this.doDisplay = false;
	if (this.tweaks && typeof params.twkDisplay !== 'undefined') {
		var p = params.twkDisplay;
		if (typeof p.doDisplay === 'boolean') {
			this.doDisplay = p.doDisplay;	
		}
		if (typeof p.inIdx === 'number') {
			this.dispInIdx = p.inIdx;
		}
		if (typeof p.outIdx === 'number') {
			this.dispOutIdx = p.outIdx;
		}
		if (typeof p.inGt === 'number') {
			this.dispInGt = p.inGt;
		}
		if (typeof p.outGt === 'number') {
			this.dispOutGt = p.outGt;
		}
		if (this.doDisplay) {
			this.disM = this.mMult(this.disOutM[this.dispOutGt], this.disInM[this.dispInGt]);
		}
	}
	return out;
};
// Adjustment functions
LUTGamma.prototype.f = function(x) {
	x = Math.pow(2,x)/5;
	if (this.nul) {
		return x;
	} else {
		var out = x;
		return this.gammas[this.curOut].linToLegal(out);
	}
};
LUTGamma.prototype.getLumVals = function(linBuff, p) {
	var lin = new Float64Array(linBuff);
	var m = lin.length;
	var vals = new Float64Array(m*3);
	var buff = vals.buffer;
	for (var j=0; j<m; j++) {
		vals[ (j*3) ] = lin[j];
		vals[(j*3)+1] = lin[j];
		vals[(j*3)+2] = lin[j];
	}
	if (p) {
		if (this.doASCCDL) {
			this.ASCCDLOut(buff, p)
		}
		if (this.doKnee) {
			this.kneeOut(buff, p);
		} else {
			this.gammas[this.curOut].linToL(buff, p);
		}
	} else {
		if (this.doASCCDL) {
			this.ASCCDLOut(buff)
		}
		if (this.doKnee) {
			this.kneeOut(buff);
		} else {
			this.gammas[this.curOut].linToL(buff);
		}
	}
	for (var j=0; j<m; j++) {
		lin[j] =  (0.2126*vals[ (j*3) ]) + (0.7152*vals[(j*3)+1]) + (0.0722*vals[(j*3)+2]);
	}
};
LUTGamma.prototype.kneeVal = function(lin) {
	var out = lin;
	out = this.gammas[this.curOut].linToLegal(out);
	if (lin >= this.kL) {
		var s = Math.log(lin/0.2)/Math.LN2;
		var s,s2;
		var kd0,kd1,kd2;
		var a,b,c,d;
		if (s < this.kC) {
			s = (s - this.kS) / (this.kC - this.kS);
			if (s < this.ks) {
				kd0 = this.kd0 / (2*(1-this.ks));
				kd1 = this.kd1 / (2*(1-this.ks));
				s2 = s/this.ks;
				a = (2 * this.kp0) + kd0 - (2 * this.kp1) + kd1;
				b = - (3 * this.kp0) - (2 * kd0) + (3 * this.kp1) - kd1;
				c = kd0;
				d = this.kp0;
			} else {
				kd1 = this.kd1 / (2*this.ks);
				kd2 = this.kd2 / (2*this.ks);
				s2 = (s-this.ks)/(1-this.ks);
				a = (2 * this.kp1) + kd1 - (2 * this.kp2) + kd2;
				b = - (3 * this.kp1) - (2 * kd1) + (3 * this.kp2) - kd2;
				c = kd1;
				d = this.kp1;
			}
			out = (((((((a * s2) + b) * s2) + c) * s2) + d)*this.kSmooth) + (((this.kp0*(1-s))+(this.kp2*s))*(1-this.kSmooth));
		} else {
			out = this.kp2 + ((s - this.kC)*this.kD2);
		}
	}
	return out;
};
LUTGamma.prototype.ASCCDLOut = function(buff) {
	var vals = new Float64Array(buff);
	var m = vals.length;
	var l;
	for (var j=0; j<m; j += 3) {
		// Red
		l = vals[ j ];
		l = (l*this.asc[0])+this.asc[3];
		l = ((l<0)?l:Math.pow(l,this.asc[6]));
		vals[ j ] = (isNaN(l)?0:l);
		// Green
		l = vals[j+1];
		l = (l*this.asc[1])+this.asc[4];
		l = ((l<0)?l:Math.pow(l,this.asc[7]));
		vals[j+1] = (isNaN(l)?0:l);
		// Blue
		l = vals[j+2];
		l = (l*this.asc[2])+this.asc[5];
		l = ((l<0)?l:Math.pow(l,this.asc[8]));
		vals[j+2] = (isNaN(l)?0:l);
	}
};
LUTGamma.prototype.kneeOut = function(buff, p) {
	var lin = new Float64Array(buff.slice(0));
	var out = new Float64Array(buff);
	if (p) {
		this.gammas[this.curOut].linToL(buff,p);
	} else {
		this.gammas[this.curOut].linToL(buff);
	}
	var m = out.length;
	var s,s2;
	var kd0,kd1,kd2;
	var a,b,c,d;
	for (var j=0; j<m; j++) {
		if (lin[j] >= this.kL) {
			s = Math.log(lin[j]/0.2)/Math.LN2;
			if (s < this.kC) {
				s = (s - this.kS) / (this.kC - this.kS);
				if (s < this.ks) {
					kd0 = this.kd0 / (2*(1-this.ks));
					kd1 = this.kd1 / (2*(1-this.ks));
					s2 = s/this.ks;
					a = (2 * this.kp0) + kd0 - (2 * this.kp1) + kd1;
					b = - (3 * this.kp0) - (2 * kd0) + (3 * this.kp1) - kd1;
					c = kd0;
					d = this.kp0;
				} else {
					kd1 = this.kd1 / (2*this.ks);
					kd2 = this.kd2 / (2*this.ks);
					s2 = (s-this.ks)/(1-this.ks);
					a = (2 * this.kp1) + kd1 - (2 * this.kp2) + kd2;
					b = - (3 * this.kp1) - (2 * kd1) + (3 * this.kp2) - kd2;
					c = kd1;
					d = this.kp1;
				}
				out[j] = (((((((a * s2) + b) * s2) + c) * s2) + d)*this.kSmooth) + (((this.kp0*(1-s))+(this.kp2*s))*(1-this.kSmooth));
			} else {
				out[j] = this.kp2 + ((s - this.kC)*this.kD2);
			}
		}
	}
};
LUTGamma.prototype.blkHiOut = function(buff) {
	var out = new Float64Array(buff);
	var m = out.length;
	for (var j=0; j<m; j++) {
		out[j] = (out[j]*this.al)+this.bl;
	}
};
LUTGamma.prototype.blkGamOut = function(buff) {
	var out = new Float64Array(buff);
	var m = out.length;
	var r,bg;
	for (var j=0; j<m; j++) {
		if (out[j] > this.blkLevel && out[j] <= this.blkGamUL) {
			if (out[j] > this.blkGamLL) {
				bg = (Math.pow((out[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
				if (out[j] <= bg) {
					out[j] = bg;
				} else {
					r = (out[j]-this.blkGamLL)/this.blkGamF;
					r *= r;
					out[j] = (r*out[j]) + ((1-r)*bg);
				}
			} else {
				out[j] = (Math.pow((out[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
			}
		}
	}
};
LUTGamma.prototype.gamutLimOut = function(buff, gY, gL, ogb, gLimB) {
	var o = new Float64Array(buff);
	var m = o.length;
	var gMX, gMN, gSat, og;
	if (typeof ogb !== 'undefined') { // Protect Secondary
		// Knee
		if (this.doKnee) {
			this.kneeOut(ogb, { rgb: true });
		} else {
			this.gammas[this.curOut].linToL(ogb, { rgb: true });
		}
		// Black Level / Highlight Level
		if (this.doBlkHi) {
			this.blkHiOut(ogb);
		}
		// Black Gamma
		if (this.doBlkGam) {
			this.blkGamOut(ogb);
		}
		// Display Colourspace Conversion
		if (this.doDisplay) {
			this.displayOut(ogb, { rgb: true });
		}
		og = new Float64Array(ogb);
		if (gLimB) { // Protect Both
			for (var j=0; j<m; j += 3) {
				o[ j ] = Math.max(0, o[ j ]);
				o[j+1] = Math.max(0, o[j+1]);
				o[j+2] = Math.max(0, o[j+2]);
				var gMX2, gMN2;
				gMX = Math.max(og[ j ], og[j+1], og[j+2]);
				gMN = Math.min(og[ j ], og[j+1], og[j+2]);
				gMX2 = Math.max(o[ j ], o[j+1], o[j+2]);
				gMN2 = Math.min(o[ j ], o[j+1], o[j+2]);
				gSat = Math.max(gMX - gMN, gMX2 - gMN2)/gL;
				if (gSat > 1) {
					Y = (gY[0]*o[j])+(gY[1]*o[j+1])+(gY[2]*o[j+2]);
					o[ j ] = Y + ((o[ j ]-Y)/gSat);
					o[j+1] = Y + ((o[j+1]-Y)/gSat);
					o[j+2] = Y + ((o[j+2]-Y)/gSat);
				}
			}
		} else { // Protect Secondary
			for (var j=0; j<m; j += 3) {
				o[ j ] = Math.max(0, o[ j ]);
				o[j+1] = Math.max(0, o[j+1]);
				o[j+2] = Math.max(0, o[j+2]);
				gMX = Math.max(og[ j ], og[j+1], og[j+2]);
				gMN = Math.min(og[ j ], og[j+1], og[j+2]);
				gSat = (gMX - gMN)/gL;
				if (gSat > 1) {
					Y = (gY[0]*o[j])+(gY[1]*o[j+1])+(gY[2]*o[j+2]);
					o[ j ] = Y + ((o[ j ]-Y)/gSat);
					o[j+1] = Y + ((o[j+1]-Y)/gSat);
					o[j+2] = Y + ((o[j+2]-Y)/gSat);
				}
			}
		}
	} else { // Protect Primary
		for (var j=0; j<m; j += 3) {
			o[ j ] = Math.max(0, o[ j ]);
			o[j+1] = Math.max(0, o[j+1]);
			o[j+2] = Math.max(0, o[j+2]);
			gMX = Math.max(o[ j ], o[j+1], o[j+2]);
			if (gMX > gL) {
				gMN = Math.min(o[ j ], o[j+1], o[j+2]);
				gSat = (gMX - gMN)/gL;
				if (gSat > 1) {
					Y = (gY[0]*o[j])+(gY[1]*o[j+1])+(gY[2]*o[j+2]);
					o[ j ] = Y + ((o[ j ]-Y)/gSat);
					o[j+1] = Y + ((o[j+1]-Y)/gSat);
					o[j+2] = Y + ((o[j+2]-Y)/gSat);
				}
			}
		}
	}
};
LUTGamma.prototype.displayOut = function(buff, p) {
	if (p) {
		p.out = true;
		this.gammas[this.dispInIdx].linFromL(buff,p);
		if (p.rgb && this.dispInGt !== this.dispOutGt) {
			var c = new Float64Array(buff);
			var m = c.length;
			var M = this.disM;
			var r,g,b;
			for (var j=0; j<m; j+= 3) {
				r = c[ j ];
				g = c[j+1];
				b = c[j+2];
				c[ j ] = (M[0]*r)+(M[1]*g)+(M[2]*b);
				c[j+1] = (M[3]*r)+(M[4]*g)+(M[5]*b);
				c[j+2] = (M[6]*r)+(M[7]*g)+(M[8]*b);
			}
		}
		this.gammas[this.dispOutIdx].linToL(buff,p);
	} else {
		this.gammas[this.dispInIdx].linFromL(buff, { out: true });
		this.gammas[this.dispOutIdx].linToL(buff);
	}
};
LUTGamma.prototype.fcOut = function(fcBuff,outBuff) {
	var fc = new Uint8Array(fcBuff);
	var o = new Float64Array(outBuff);
	var m = o.length;
	var l = 0;
	for (var j=0; j<m; j+= 3) {
		switch(fc[l]) {
			case 0: o[ j ] = 0.75;	o[j+1] = 0;		o[j+2] = 0.75;	// Purple
				break;
			case 1: o[ j ] = 0;		o[j+1] = 0;		o[j+2] = 0.75;	// Blue
				break;
			case 3: o[ j ] = 0;		o[j+1] = 0.7;	o[j+2] = 0;		// Green
				break;
			case 5: o[ j ] = 0.75;	o[j+1] = 0.35;	o[j+2] = 0.35;	// Pink
				break;
			case 7: o[ j ] = 0.9;	o[j+1] = 0.45;	o[j+2] = 0;		// Orange
				break;
			case 9: o[ j ] = 0.7;	o[j+1] = 0.7;	o[j+2] = 0;		// Yellow
				break;
			case 10: o[ j ] = 0.75;	o[j+1] = 0;		o[j+2] = 0;		// Red
				break;
		}
		l++;
	}
};
LUTGamma.prototype.finalOut = function(buff,cb) {
	var out = new Float64Array(buff);
	var m = out.length;
	var cMin,cMax;
	if (this.outL) {
		if (cb) {
			cMin = 0;
		} else {
			cMin = (this.bClip - 64)/876;
		}
		cMax = (this.wClip - 64)/876;
	} else {
		if (cb) {
			cMin = 64/1023;
		} else {
			cMin = this.bClip / 1023;
		}
		cMax = this.wClip / 1023;
	}
	if (this.clip) {
		if (this.outL || !this.clipL) {
			if (this.clipB && cMin<0) {
				cMin = 0;
			}
			if (this.clipW && cMax>1) {
				cMax = 1;
			}
		} else {
			if (this.clipB && cMin<64/1023) {
				cMin = 64/1023;
			}
			if (this.clipW && cMax>959/1023) {
				cMax = 959/1023;
			}
		}
	}
	if (this.hdrOut && !this.doDisplay) {
		var mx = this.gammas[this.curOut].mxO;
		if (this.outL) {
			if (mx < cMax) {
				cMax = mx;
			}
		} else {
			mx = (mx * 0.85630498533724) + 0.06256109481916;
			if (mx < cMax) {
				cMax = mx;
			}
		}
	}
	for (var j=0; j<m; j++) {
		if (!this.outL) {
			out[j] = ((out[j]*876)+64)/1023;
		}
		out[ j ] = Math.min(cMax,Math.max(cMin,out[ j ]));
	}
};
// Transfer function calculation objects
// Generalised Log
function LUTGammaLog(name,params) {
	this.name = name;
	this.params = params;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaLog.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLog.prototype.changeContrast = function(rec,out) {
};
LUTGammaLog.prototype.changeRange = function(rec,out) {
};
LUTGammaLog.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[8]) {
			c[j] = (this.params[2] * Math.log((c[j] * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
		} else if (this.params[0] === 0) {
			c[j] = (this.params[2] * Math.log((0.000000000000001 * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
		} else {
			c[j] = (c[j] - this.params[1])/this.params[0];
		}
	}
};
LUTGammaLog.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLog.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[7]) {
			c[j] = (Math.pow(this.params[4],(c[j] - this.params[5])/this.params[2]) - this.params[6])/this.params[3];		
		} else {
			c[j] = (this.params[0]*c[j]) + this.params[1];
		}
	}
};
LUTGammaLog.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaLog.prototype.linToData = function(input) {
	if (input >= this.params[8]) {
		return (this.params[2] * Math.log((input * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
	} else if (this.params[0] === 0) {
		return (this.params[2] * Math.log((0.000000000000001 * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
	} else {
		return (input - this.params[1])/this.params[0];
	}
};
LUTGammaLog.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaLog.prototype.linFromData = function(input) {
	if (input >= this.params[7]) {
		return (Math.pow(this.params[4],(input - this.params[5])/this.params[2]) - this.params[6])/this.params[3];		
	} else {
		return (this.params[0]*input) + this.params[1];
	}
};
LUTGammaLog.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// Generalised Log with a soft clip
function LUTGammaLogClip(name,params) {
	this.name = name;
	this.params = params;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaLogClip.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLogClip.prototype.changeContrast = function(rec,out) {
};
LUTGammaLogClip.prototype.changeRange = function(rec,out) {
};
LUTGammaLogClip.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[10]) {
			c[j] = ((Math.log(c[j]/0.2)/Math.log(2)) - this.params[12])/this.params[11];
		} else if (c[j] >= this.params[8]) {
			c[j] = (this.params[2] * Math.log((c[j] * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
		} else if (this.params[0] === 0) {
			c[j] = (this.params[2] * Math.log((0.000000000000001 * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
		} else {
			c[j] = (c[j] - this.params[1])/this.params[0];
		}
	}
};
LUTGammaLogClip.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLogClip.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[9]) {
			c[j] = Math.pow(2,(this.params[11]*c[j]) + this.params[12])*0.2;
		} else if (c[j] >= this.params[7]) {
			c[j] = (Math.pow(this.params[4],(c[j] - this.params[5])/this.params[2]) - this.params[6])/this.params[3];		
		} else {
			c[j] = (this.params[0]*c[j]) + this.params[1];
		}
	}
};
LUTGammaLogClip.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaLogClip.prototype.linToData = function(input) {
	if (input >= this.params[10]) {
		return ((Math.log(input/0.2)/Math.log(2)) - this.params[12])/this.params[11];
	} else if (input >= this.params[8]) {
		return (this.params[2] * Math.log((input * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
	} else if (this.params[0] === 0) {
		return (this.params[2] * Math.log((0.000000000000001 * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
	} else {
		return (input - this.params[1])/this.params[0];
	}
};
LUTGammaLogClip.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaLogClip.prototype.linFromData = function(input) {
	if (input >= this.params[9]) {
		return Math.pow(2,(this.params[11]*input) + this.params[12])*0.2;
	} else if (input >= this.params[7]) {
		return (Math.pow(this.params[4],(input - this.params[5])/this.params[2]) - this.params[6])/this.params[3];		
	} else {
		return (this.params[0]*input) + this.params[1];
	}
};
LUTGammaLogClip.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// Cineon Variants
function LUTGammaCineon(name,params) {
	this.name = name;
	this.cv = params.cv
	this.mul = params.cv2d/params.nGamma;
	this.wp = params.wp;
	this.bl = Math.pow(10,(params.bp-this.wp)*this.mul);
	this.den = 0.9*(1 - this.bl);
	this.p0 = (Math.pow(10,-this.wp*this.mul) - this.bl)/this.den;
	this.d0 = (((Math.pow(10,((0.0001*this.cv)-this.wp)*this.mul) - this.bl)/this.den)-this.p0)/0.0001;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaCineon.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaCineon.prototype.changeContrast = function(rec,out) {
};
LUTGammaCineon.prototype.changeRange = function(rec,out) {
};
LUTGammaCineon.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < this.p0) {
			c[j] = (c[j] - this.p0)/this.d0;
		} else {
			c[j] = ((Math.log((c[j]*this.den)+this.bl)/(Math.LN10*this.mul))+this.wp)/this.cv;
		}
	}
};
LUTGammaCineon.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaCineon.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = (c[j]*this.d0) + this.p0;
		} else {
			c[j] = (Math.pow(10,((c[j]*this.cv)-this.wp)*this.mul) - this.bl)/this.den;
		}
	}
};
LUTGammaCineon.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaCineon.prototype.linToData = function(input) {
	if (input < this.p0) {
		return (input - this.p0)/this.d0;
	} else {
		return ((Math.log((input*this.den)+this.bl)/(Math.LN10*this.mul))+this.wp)/this.cv;
	}
};
LUTGammaCineon.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaCineon.prototype.linFromData = function(input) {
	if (input < 0) {
		return (input*this.d0) + this.p0;
	} else {
		return (Math.pow(10,((input*this.cv)-this.wp)*this.mul) - this.bl)/this.den;
	}
};
LUTGammaCineon.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// ARRI LogC
function LUTGammaArri(name,sup) {
	this.name = name;
	this.sup = sup;
	this.iso = 800;
	this.cat = 0;
	this.params = [];
	this.tHK = [];
	this.fHK = [];
	this.tHS = 0.0;
	this.fHS = 0.0;
	this.knee = false;
	this.xm = 0.0;
	if (this.sup === 2) {
		this.recleg = false;
		this.outleg = false;
		this.nominalEI = 400;
		this.blackSignal = 0.003907;
		this.blackOffset = 0.000977;
		this.midGraySignal = 0.01;
		this.encodingGain = 0.256598;
		this.encodingOffset = 0.391007;		
	} else {
		this.recleg = true;
		this.outleg = true;
		this.nominalEI = 400;
		this.blackSignal = 16.0 / 4095.0;
		this.blackOffset = 0.0; // unused
		this.midGraySignal = 0.01;
		this.encodingGain = (500.0 / 1023.0) * 0.525;
		this.encodingOffset = 400.0 / 1023.0;
	}
	this.changeISO(this.iso);
}
LUTGammaArri.prototype.getParams = function(ei) {
	var gain = ei / this.nominalEI;
	var out = [];
	if (this.sup === 2) {
		var encGain = (Math.log(gain)/Math.LN2 * (0.89 - 1) / 3 + 1) * this.encodingGain;
		var midGray = this.midGraySignal + this.blackOffset;
		var f16 = (Math.log((((this.blackSignal) 				- this.blackSignal) * gain + this.blackOffset) / midGray)/Math.LN10) * encGain + this.encodingOffset;
		var f17 = (Math.log((((this.blackSignal + 1.0 / 4095.0) - this.blackSignal) * gain + this.blackOffset) / midGray)/Math.LN10) * encGain + this.encodingOffset;
		out[0] = this.blackSignal;										// cut
		out[4] = this.encodingOffset;									// d
		out[3] = encGain;											// c
		out[2] = this.blackOffset / midGray;								// b
		out[1] = (gain / midGray)/(gain * (0.18 / this.midGraySignal));	// a
		out[6] = f16;												// f
		out[5] = 4095.0 * (f17-f16)/(gain*(0.18 / this.midGraySignal));	// e
		out[7] = 0.0;												// xm - not used in sup 2
		out[8] = 0.0;												// x1 - not used in sup 2
		out[9] = 0.0;												// x2 - not used in sup 2
		out[10] = 0.0;												// not used in sup 2
		out[11] = 0.0;												// not used in sup 2
		out[12] = 0.0;												// not used in sup 2
		out[13] = 0.0;												// not used in sup 2
	} else {
		out[0] = 1.0 / 9.0;											// cut
		var slope = 1.0 / (out[0] * Math.LN10);
		var offset = (Math.log(out[0]) / Math.LN10) - slope * out[0];
		var gray = this.midGraySignal / gain;
		var encGain = (Math.log(gain)/Math.LN2 * (0.89 - 1.0) / 3.0 + 1.0) * this.encodingGain;
		var encOffset = this.encodingOffset;
		var nz = 0.0;
		for (var j=0; j<3; j++) {
			nz = ((95.0 / 1023.0 - encOffset) / encGain - offset) / slope;
			encOffset = this.encodingOffset - (Math.log(1 + nz) / Math.LN10) * encGain;
		}
		var xm = (Math.log((1 - this.blackSignal) / gray + nz) / Math.LN10) * encGain + encOffset;
		out[1] = 1.0 / gray;										// a
		out[2] = nz - this.blackSignal / gray;						// b
		out[5] = slope * out[1] * encGain;							// e
		out[6] = encGain * (slope * out[2] + offset) + encOffset;	// f
		var s = 4.0 / (0.18 * ei);
		var t = this.blackSignal;
		out[2] = out[2] + out[1] * t;
		out[1] *= s;
		out[6] = out[6] + out[5] * t;
		out[5] *= s;
		out[3] = encGain;											// c
		out[4] = encOffset;											// d
		out[0] = (out[0] - out[2]) / out[1];
		out[7] = xm;												// xm
		out[8] = 0.8;												// x1
		out[9] = 1;													// x2
		out[10] = 0.8;
		out[11] = xm;
		out[12] = 1.0;
		out[13] = ((5.0 * xm) - 4.0) * ((5.0 * xm) - 4.0);
	}
	return out;
}
LUTGammaArri.prototype.setHighKnee = function(x1, x2, v1, v2, v3, v4) {
	var hk = [];
	var d3 = x2-x1;
	d3 = d3 * d3 * d3;
	// Arri adjusts the log curve with a form of highlight knee for high ISOs.
	// Whether it happens is determined by a claculation - xm being above 1.0
	// For xm values above 1.0, the cubic knee kicks in for LogC values above
	// 0.8 on a 0-1.0 data range scale
	// Arri's calculations are presented in parametric form, I've disentangled
	// things to generate four cubic coefficients when the ISO changes, for
	// fewer and simpler calculations on pixels (multiply and adds)
	// a x^3
	hk[0] =		v1 * 2.0;
	hk[0] +=	v2 * -2.0;
	hk[0] +=	v3 * (x2 - x1);
	hk[0] +=	v4 * (x2 - x1);
	hk[0] /=	d3;
	// b x^2
	hk[1] =		v1 * -3.0 * (x1 + x2);
	hk[1] +=	v2 * 3.0 * (x1 + x2);
	hk[1] +=	v3 * ((x1 * x1) + (x1 * x2) - (2.0 * x2 * x2));
	hk[1] +=	v4 * ((2.0 * x1 * x1) - (x1 * x2) - (x2 * x2));
	hk[1] /=	d3;
	// c x
	hk[2] =		v1 * 6.0 * x1 * x2;
	hk[2] +=	v2 * -6.0 * x1 * x2;
	hk[2] +=	v3 * ((-2.0 * x1 * x1 * x2) + (x1 * x2 * x2) + (x2 * x2 * x2));
	hk[2] +=	v4 * ((2.0 * x1 * x2 * x2) - (x1 * x1 * x2) - (x1 * x1 * x1));
	hk[2] /=	d3;
	// d
	hk[3] =		v1 * ((x2 * x2 * x2) - (3.0 * x1 * x2 * x2));
	hk[3] +=	v2 * ((3.0 * x1 * x1 * x2) - (x1 * x1 * x1));
	hk[3] +=	v3 * ((x1 * x1 * x2 * x2) - (x1 * x2 * x2 * x2));
	hk[3] +=	v4 * ((x1 * x1 * x1 * x2) - (x1 * x1 * x2 * x2));
	hk[3] /=	d3;
	
	// This replaces the LogC values above 0.8 BEFORE going log -> lin, but for lin -> log
	// have fun inverting arbitrary cubics. easy life is to calculate a cubic approximation
	// it's a short stretch of monotonic cubic, and we can extrapolate above 1.0
	var fd0 = 1 / ((1.92 * hk[0]) + (1.6 * hk[1]) + hk[2]);
	var fd1 = 1 / ((3 * hk[0]) + (2 * hk[1]) + hk[2]);
	var fxm = this.xm - 0.8;
	this.tHK[0] = (((fd0+fd1) * fxm) -0.4)/(fxm * fxm * fxm);
	this.tHK[2] = 1.0;
	this.tHK[3] = 0.8;
	this.tHK[1] = (fd1/(2 * fxm)) - (1.5 * fxm * this.tHK[0]) - (this.tHK[2] / (2 * fxm));
	this.tHS = (((0.6 * this.tHK[0]) + 0.4) * this.tHK[1]) + this.tHK[2];
	this.fHK[0] = hk[0];
	this.fHK[1] = hk[1];
	this.fHK[2] = hk[2];
	this.fHK[3] = hk[3];
	this.fHS = (3 * this.fHK[0]) + (2 * this.fHK[1]) + this.fHK[2];
	this.knee = true;
}
LUTGammaArri.prototype.changeISO = function(iso) {
	this.iso = iso;
	var arri = this.getParams(iso);
	this.params[0] = 1.0 / arri[5];					// lin slope
	this.params[1] = -arri[6] / arri[5];			// lin offset
	this.params[2] = arri[3];						// log slope
	this.params[3] = arri[1];						// input slope
	this.params[4] = 10;							// base
	this.params[5] = arri[4];						// log offset
	this.params[6] = arri[2];						// input offset
	this.params[7] = (arri[5] * arri[0]) + arri[6];	// log input crossover
	this.params[8] = arri[0];						// log output crossover
	// set up some reciprocal values, as multiplies are quicker than divides later on.
	this.params[9] = arri[5]; // reciprocal of p0, multiplies are faster than divides.
	this.params[10] = 1.0 / this.params[2];
	this.params[11] = 1.0 / this.params[3];
	this.params[12] = this.params[2] / Math.log(this.params[4]);
	// if superblacks are undefined, clamp before reaching NaN (hard black). Not the case here, but we're on a roll.
	this.params[13] = (this.params[12] * Math.log((0.000000000000001 * this.params[3]) + this.params[6])) + this.params[5];
	// Think-of-everything Arri have a log rolloff for high ISO - add an extra bit of complexity. Fun.
	this.xm = arri[7];
	if (this.xm > 1.0) {
		this.setHighKnee(arri[8], arri[9], arri[10], arri[11], arri[12], arri[13]);
	} else {
		this.knee = false;
	}
}
LUTGammaArri.prototype.changeContrast = function(rec,out) {
};
LUTGammaArri.prototype.changeRange = function(rec,out) {
	if (this.sup !== 2) {
		this.recleg = rec;
		this.outleg = out;
	}
};
LUTGammaArri.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = c[j] * 0.9;
		if (c[j] >= this.params[8]) {
			c[j] = (Math.log((c[j] * this.params[3]) + this.params[6]) * this.params[12]) + this.params[5];
		} else if (this.params[0] === 0.0) {
			c[j] = this.params[13];
		} else {
			c[j] = (c[j] - this.params[1]) * this.params[9];
		}
	}
	if (this.knee) {
		for (var j=0; j<m; j++) {
			if (c[j] > 0.8) {
				if (c[j] > this.xm) {
					c[j] = ((c[j] - this.xm) * this.tHS) + 1;
				} else {
					c[j] -= 0.8
					c[j] = (((((this.tHK[0] * c[j]) + this.tHK[1]) * c[j]) + this.tHK[2]) * c[j]) + this.tHK[3];
				}
			}
		}
	}
	var legal = this.outleg;
	if (p && p.rec) {
		legal = this.recleg;
	}
	if (legal) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
		}
	}
};
LUTGammaArri.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToD(buff, p);
	} else {
		this.linToD(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaArri.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (this.recleg) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
		}
	}
	if (this.knee) {
		for (var j=0; j<m; j++) {
			if (c[j] > 0.8) {
				if (c[j] > 1.0) {
					c[j] = ((c[j] - 1.0) * this.fHS) + 1.0;
				} else {
					c[j] = (((((this.fHK[0] * c[j]) + this.fHK[1]) * c[j]) + this.fHK[2]) * c[j]) + this.fHK[3];
				}
			}
		}
	}
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[7]) {
			c[j] = (Math.pow(this.params[4],(c[j] - this.params[5]) * this.params[10]) - this.params[6]) * this.params[11] / 0.9;
		} else {
			c[j] = ((c[j] * this.params[0]) + this.params[1]) / 0.9;
		}
	}
};
LUTGammaArri.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaArri.prototype.linToData = function(input, p) {
	var out;
	input *= 0.9;
	var legal = this.outleg;
	if (p && p.rec) {
		legal = this.recleg;
	}

	if (input >= this.params[8]) {
		out = (Math.log((input * this.params[3]) + this.params[6]) * this.params[12]) + this.params[5];
	} else if (this.params[0] === 0.0) {
		out = this.params[13];
	} else {
		out = (input - this.params[1]) * this.params[9];
	}
	if (this.knee) {
		if (input > 0.8) {
			if (input > this.xm) {
				out = ((input - this.xm) * this.tHS) + 1;
			} else {
				input -= 0.8;
				out = (((((this.tHK[0] * input) + this.tHK[1]) * input) + this.tHK[2]) * input) + this.tHK[3];
			}
		}
	}
	if (legal) {
		out = (out * 0.85630498533724) + 0.06256109481916;
	}
	return out;
};
LUTGammaArri.prototype.linToLegal = function(input, p) {
	if (p) {
		return (this.linToData(input, p) - 0.06256109481916) / 0.85630498533724;
	} else {
		return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
	}
	
};
LUTGammaArri.prototype.linFromData = function(input) {
	var out;
	if (this.recleg) {
		input = (input - 0.06256109481916) / 0.85630498533724;
	}
	if (this.knee) {
		if (input > 0.8) {
			if (input > 1.0) {
				input = ((input - 1.0) * this.fHS) + 1.0;
			} else {
				input = (((((this.fHK[0] * input) + this.fHK[1]) * input) + this.fHK[2]) * input) + this.fHK[3];
			}
		}
	}
	if (input >= this.params[7]) {
		return (Math.pow(this.params[4],(input - this.params[5]) * this.params[10]) - this.params[6]) * this.params[11] / 0.9;
	} else {
		return ((input * this.params[0]) + this.params[1]) / 0.9;
	}
};
LUTGammaArri.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// ARRI LogC4
function LUTGammaLogC4(name) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;
	this.recleg = true;
	this.outleg = true;
	this.a = (Math.pow(2.0, 18) - 16.0) / 117.45;
	this.oneovera = 1.0 / this.a;
	this.b = (1023.0 - 95.0) / 1023.0;
	this.c = 95.0 / 1023.0;
	this.s = 7.0 * Math.LN2 * Math.pow(2, 7 - (14 * this.c / this.b)) / (this.a * this.b);
	this.oneovers = 1.0 / this.s;
	this.t = (Math.pow(2, (-14.0 * this.c / this.b) + 6) - 64.0) / this.a;
	this.bund14 = 14.0 / this.b;
	this.bdiv14 = 1.0 / this.bund14;
}
LUTGammaLogC4.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLogC4.prototype.changeContrast = function(rec,out) {
};
LUTGammaLogC4.prototype.changeRange = function(rec,out) {
	this.recleg = rec;
	this.outleg = out;
};
LUTGammaLogC4.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = c[j] * 0.9;
		if (c[j] >= this.t) {
			c[j] = ((Math.log2((this.a * c[j]) + 64.0) - 6.0) * this.bdiv14) + this.c;
		} else {
			c[j] = (c[j] - this.t) * this.oneovers;
		}
	}
	var legal = this.outleg;
	if (p && p.rec) {
		legal = this.recleg;
	}
	if (legal) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
		}
	}
};
LUTGammaLogC4.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToD(buff, p);
	} else {
		this.linToD(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLogC4.prototype.linFromD = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	if (this.recleg) {
		for (var j=0; j<m; j++) {
			o[j] = (o[j] - 0.06256109481916) / 0.85630498533724;
		}
	}
	for (var j=0; j<m; j++) {
		if (o[j] >= 0) {
			o[j] = (Math.pow(2,(this.bund14 * (o[j] - this.c)) + 6.0) - 64.0) * this.oneovera / 0.9;
		} else {
			o[j] = ((o[j] * this.s) + this.t) / 0.9;
		}
	}
};
LUTGammaLogC4.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaLogC4.prototype.linToData = function(input, p) {
	input *= 0.9;

	var legal = this.outleg;
	if (p && p.rec) {
		legal = this.recleg;
	}
	if (legal) {
		var out;
		if (input >= this.t) {
			out = ((Math.log2((this.a * input) + 64.0) - 6.0) * this.bdiv14) + this.c;
		} else {
			out = (input - this.t) * this.oneovers;
		}
		return (out * 0.85630498533724) + 0.06256109481916;
	} else {
		if (input >= this.t) {
			return ((Math.log2((this.a * input) + 64.0) - 6.0) * this.bdiv14) + this.c;
		} else {
			return (input - this.t) * this.oneovers;
		}
	}
};
LUTGammaLogC4.prototype.linToLegal = function(input, p) {
	if (p) {
		return (this.linToData(input, p) - 0.06256109481916) / 0.85630498533724;
	} else {
		return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLogC4.prototype.linFromData = function(input) {
	if (this.recleg) {
		input = (input - 0.06256109481916) / 0.85630498533724;
	}
	if (input >= 0) {
		return (Math.pow(2,(this.bund14 * (input - this.c)) + 6.0) - 64.0) * this.oneovera / 0.9;
	} else {
		return ((input * this.s) + this.t) / 0.9;
	}
};
LUTGammaLogC4.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// Canon C-Log3
function LUTGammaCLog3(name) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaCLog3.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaCLog3.prototype.changeContrast = function(rec,out) {
};
LUTGammaCLog3.prototype.changeRange = function(rec,out) {
};
LUTGammaCLog3.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaCLog3.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < -0.014) {
			c[j] = -(Math.log((-c[j]*14.98325)+1)*0.42889912/Math.LN10)+0.07623209;
		} else if (c[j] <= 0.014) {
			c[j] = (c[j]*2.3069815)+0.073059361;
		} else {
			c[j] = (Math.log((c[j]*14.98325)+1)*0.42889912/Math.LN10)+0.069886632;
		}
	}
};
LUTGammaCLog3.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaCLog3.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < 0.04076162) {
			c[j] = -(Math.pow(10,(0.07623209-c[j])/0.42889912)-1) / (14.98325);
		} else if (c[j] <= 0.105357102) {
			c[j] = (c[j]-0.073059361) / (2.3069815);
		} else {
			c[j] = (Math.pow(10,(c[j]-0.069886632)/0.42889912)-1) / (14.98325);
		}
	}
};
LUTGammaCLog3.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaCLog3.prototype.linToLegal = function(input) {
	if (input < -0.014) {
		return -(Math.log((-input*14.98325)+1)*0.42889912/Math.LN10)+0.07623209;
	} else if (input <= 0.014) {
		return (input*2.3069815)+0.073059361;
	} else {
		return (Math.log((input*14.98325)+1)*0.42889912/Math.LN10)+0.069886632;
	}
};
LUTGammaCLog3.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaCLog3.prototype.linFromLegal = function(input) {
	if (input < 0.04076162) {
		return -(Math.pow(10,(0.07623209 - input)/0.42889912)-1) / (14.98325);
	} else if (input <= 0.105357102) {
		return (input - 0.073059361) / (2.3069815);
	} else {
		return (Math.pow(10,(input - 0.069886632)/0.42889912)-1) / (14.98325);
	}
};
// Nikon N-Log
function LUTGammaNLog(name) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;
	this.logCut = 451.7887494 / 1023;
}
LUTGammaNLog.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaNLog.prototype.changeContrast = function(rec,out) {
};
LUTGammaNLog.prototype.changeRange = function(rec,out) {
};
LUTGammaNLog.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] *= 0.9;
		if (c[j] >= 0.328) {
			c[j] = ((150 * Math.log(c[j])) + 619) / 1023;
		} else {
			c[j] = Math.cbrt(c[j] + 0.0075) * 650.1864339 / 1023;
		}
	}
};
LUTGammaNLog.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaNLog.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.logCut) {
			c[j] = Math.exp(((c[j] * 1023) - 619)/150);		
		} else {
			c[j] = Math.pow(c[j] * 1023 / 650.1864339, 3) - 0.0075;
		}
		c[j] /= 0.9;
	}
};
LUTGammaNLog.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaNLog.prototype.linToData = function(input) {
	input *= 0.9;
	if (input >= 0.328) {
		return ((150 * Math.log(input)) + 619) / 1023;
	} else {
		return Math.cbrt(input + 0.0075) * 650.1864339 / 1023;
	}
};
LUTGammaNLog.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaNLog.prototype.linFromData = function(input) {
	if (input >= this.logCut) {
		return (Math.exp(((input * 1023) - 619)/150) / 0.9);
	} else {
		return ((Math.pow(input * 1023/ 650.1864339, 3) - 0.0075) / 0.9);
	}
};
LUTGammaNLog.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// Log and Log across threshold (RED Log3G10)
function LUTGammaLogLog(name,params) {
	this.name = name;
	this.params = params;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaLogLog.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLogLog.prototype.changeContrast = function(rec,out) {
};
LUTGammaLogLog.prototype.changeRange = function(rec,out) {
};
LUTGammaLogLog.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaLogLog.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] *= 0.9;
		c[j] += this.params[2];
		if (c[j] < 0) {
			c[j] = -this.params[0]*Math.log((-c[j]*this.params[1])+1)/Math.LN10;
		} else {
			c[j] = this.params[0]*Math.log((c[j]*this.params[1])+1)/Math.LN10;
		}
	}
};
LUTGammaLogLog.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaLogLog.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = (((Math.pow(10,-c[j]/this.params[0])-1)/-this.params[1])-this.params[2])/0.9;
		} else {
			c[j] = (((Math.pow(10,c[j]/this.params[0])-1)/this.params[1])-this.params[2])/0.9;
		}
	}
};
LUTGammaLogLog.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaLogLog.prototype.linToLegal = function(input) {
	input *= 0.9;
	input += this.params[2];
	if (input < 0) {
		return -this.params[0]*Math.log((-input*this.params[1])+1)/Math.LN10;
	} else {
		return this.params[0]*Math.log((input*this.params[1])+1)/Math.LN10;
	}
};
LUTGammaLogLog.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaLogLog.prototype.linFromLegal = function(input) {
	if (input < 0) {
		return (((Math.pow(10,-input/this.params[0])-1)/-this.params[1])-this.params[2])/0.9;
	} else {
		return (((Math.pow(10,input/this.params[0])-1)/this.params[1])-this.params[2])/0.9;
	}
};
// DaVinci Intermediate
function LUTGammaDaVinci(name) {
	this.name = name;
	this.a = 0.0075;
	this.b = 7.0;
	this.c = 0.07329248;
	this.m = 10.44426855;
	this.lin_cut = 0.00262409;
	this.log_cut = 0.02740668;
	this.rescale = 1.0 / 0.9;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaDaVinci.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaDaVinci.prototype.changeContrast = function(rec,out) {
};
LUTGammaDaVinci.prototype.changeRange = function(rec,out) {
};
LUTGammaDaVinci.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaDaVinci.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] *= 0.9;
		if (c[j] > this.lin_cut) {
			c[j] = (Math.log2(c[j] + this.a) + this.b) * this.c;
		} else {
			c[j] = c[j] * this.m;
		}
	}
};
LUTGammaDaVinci.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaDaVinci.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.log_cut) {
			c[j] = Math.pow(2, (c[j] / this.c) - this.b) - this.a;
		} else {
			c[j] = c[j] / this.m;
		}
		c[j] *= this.rescale;
	}
};
LUTGammaDaVinci.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaDaVinci.prototype.linToLegal = function(input) {
	input *= 0.9;
	if (input >= this.lin_cut) {
		return (Math.log2(input + this.a) + this.b) * this.c;
	} else {
		return input * this.m;
	}
};
LUTGammaDaVinci.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaDaVinci.prototype.linFromLegal = function(input) {
	if (input >= this.log_cut) {
		return (Math.pow(2, (input / this.c) - this.b) - this.a) * this.rescale;
	} else {
		return input / this.m;
	}
};
// Apple Log
function LUTGammaAppleLog(name,params) {
	this.name = name;
	this.params = params;
	this.iso = 800;
	this.cat = 0;
	this.R0 = -0.05641088;
	this.Rt = 0.01;
	this.cc = 47.28711236;
	this.beta = 0.00964052;
	this.gamma = 0.08550479;
	this.delta = 0.69336945;
	this.Pt = this.cc * (this.Rt - this.R0) * (this.Rt - this.R0);
}
LUTGammaAppleLog.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaAppleLog.prototype.changeContrast = function(rec,out) {
};
LUTGammaAppleLog.prototype.changeRange = function(rec,out) {
};
LUTGammaAppleLog.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] *= 0.9;
		if (c[j] < this.R0) {
			c[j] = 0;
		} else if (c[j] > this.Rt) {
			c[j] = (this.gamma * Math.log2(c[j] + this.beta)) + this.delta;
		} else {
			c[j] = this.cc * (c[j] - this.R0) * (c[j] - this.R0);
		}
	}
};
LUTGammaAppleLog.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaAppleLog.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = this.R0;
		} else if (c[j] >= this.Pt) {
			c[j] = Math.pow(2, (c[j] - this.delta) / this.gamma) - this.beta;
		} else {
			c[j] = Math.sqrt(c[j] / this.cc) + this.R0;
		}
		c[j] /= 0.9;
	}
};
LUTGammaAppleLog.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaAppleLog.prototype.linToData = function(input) {
	input *= 0.9;
	if (input < this.r0) {
		return 0;
	} else if (input > this.rt) {
		return (this.gamma * Math.log2(input + this.beta)) + this.delta;
	} else {
		return this.cc * (input - this.r0) * (input - this.r0);
	}
};
LUTGammaAppleLog.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaAppleLog.prototype.linFromData = function(input) {
	if (input < 0) {
		return this.R0 / 0.9;
	} else if (input >= this.Pt) {
		return (Math.pow(2, (input - this.delta) / this.gamma) - this.beta) / 0.9;
	} else {
		return (Math.sqrt(input / this.cc) + this.R0) / 0.9;
	}
};
LUTGammaAppleLog.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// *************************************************************
// Log2 - encoding log for LOGCalc
// *************************************************************
function LUTGammaLog2(name, linearMaximum, linearMinimum) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;

	this.linMax = linearMaximum;
	this.linMin = linearMinimum;
	this.cut = 0.01125; // 0.01125;
	this.cutLog = Math.log(this.cut) / Math.LN2;
	this.stopMax = (Math.log(linearMaximum - linearMinimum + this.cut) / Math.LN2) - this.cutLog;
	this.stopVert = 1.0 / this.stopMax;
	this.rLowSlope = this.cut * Math.LN2 * this.stopMax;
	this.fLowSlope = 1.0 / this.rLowSlope;
	this.linOffset = this.cut - this.linMin;
	this.drMul = this.stopMax * Math.LN2;
	this.dfMul = 1.0 / this.drMul;
}
LUTGammaLog2.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLog2.prototype.changeContrast = function(rec,out) {
};
LUTGammaLog2.prototype.changeRange = function(rec,out) {
};
LUTGammaLog2.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] *= 0.9;
		if (c[j] <= this.linMin) {
			c[j] -= this.linMin;
			c[j] *= this.fLowSlope;
		} else {
			c[j] += this.linOffset;
			c[j] = Math.log(c[j]) / Math.LN2;
			c[j] -= this.cutLog;
			c[j] *= this.stopVert;
		}
	}
};
LUTGammaLog2.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLog2.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] <= 0) {
			c[j] *= this.rLowSlope;
			c[j] += this.linMin;
		} else {
			c[j] *= this.stopMax;
			c[j] += this.cutLog;
			c[j] = Math.pow(2, c[j]);
			c[j] -= this.linOffset;
		}
		c[j] /= 0.9;
	}
};
LUTGammaLog2.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaLog2.prototype.linToData = function(input) {
	input *= 0.9;
	if (input <= this.linMin) {
		input -= this.linMin;
		input *= this.fLowSlope;
	} else {
		input += this.linOffset;
		input = Math.log(input) / Math.LN2;
		input -= this.cutLog;
		input *= this.stopVert;
	}
	return input;
};
LUTGammaLog2.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaLog2.prototype.linFromData = function(input) {
	if (input <= 0) {
		input *= this.rLowSlope;
		input += this.linMin;
	} else {
		input *= this.stopMax;
		input += this.cutLog;
		input = Math.pow(2, input);
		input -= this.linOffset;
	}
	input /= 0.9;
	return input;
};
LUTGammaLog2.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// *************************************************************
// *************************************************************

// Conventional Gamma
function LUTGammaGam(name,params) {
	this.name = name;
	this.params = params;
	if (!params[5] && params[0] !== 1) {
		this.gamma = '';
	} else if (params[5] !== params[0]) {
		this.gamma = 'γ' + params[5].toFixed(2).toString() + ' (exp' + params[0].toFixed(2).toString() + ')';
	} else {
		this.gamma = 'γ' + params[0].toFixed(2).toString();
	}
	this.iso = 800;
	this.cat = 1;
}
LUTGammaGam.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaGam.prototype.changeContrast = function(rec,out) {
};
LUTGammaGam.prototype.changeRange = function(rec,out) {
};
LUTGammaGam.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaGam.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[3]) {
			c[j] = ((1 + this.params[2]) * Math.pow(c[j],1 / this.params[0])) - this.params[2];
		} else {
			c[j] = this.params[1] * c[j];
		}
	}
};
LUTGammaGam.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaGam.prototype.linFromL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[4]) {
			c[j] = Math.pow((c[j] + this.params[2])/(1 + this.params[2]),this.params[0]);		
		} else {
			c[j] = (c[j] / this.params[1]);
		}
	}
};
LUTGammaGam.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaGam.prototype.linToLegal = function(input) {
	if (input >= this.params[3]) {
		return ((1 + this.params[2]) * Math.pow(input,1 / this.params[0])) - this.params[2];
	} else {
		return this.params[1] * input;
	}
};
LUTGammaGam.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaGam.prototype.linFromLegal = function(input) {
	if (input >= this.params[4]) {
		return Math.pow((input + this.params[2])/(1 + this.params[2]),this.params[0]);		
	} else {
		return (input / this.params[1]);
	}
};
function LUTGammaBBCGam(name,params) {
	this.name = name;
	this.params = params;
	if (!params[5] && params[0] !== 1) {
		this.gamma = '';
	} else if (params[5] !== params[0]) {
		this.gamma = 'γ' + params[5].toFixed(2).toString() + ' (exp' + params[0].toFixed(2).toString() + ')';
	} else {
		this.gamma = 'γ' + params[0].toFixed(2).toString();
	}
	this.iso = 800;
	this.cat = 1;
}
LUTGammaBBCGam.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaBBCGam.prototype.changeContrast = function(rec,out) {
};
LUTGammaBBCGam.prototype.changeRange = function(rec,out) {
};
LUTGammaBBCGam.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaBBCGam.prototype.linToL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] > this.params[3]) {
			c[j] = Math.pow((c[j] + this.params[2])/(1 + this.params[2]),this.params[0]);		
		} else {
			c[j] = c[j] * this.params[1];
		}
	}
};
LUTGammaBBCGam.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaBBCGam.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] > this.params[4]) {
			c[j] = ((1 + this.params[2]) * Math.pow(c[j],1 / this.params[0])) - this.params[2];
		} else {
			c[j] = c[j] / this.params[1];
		}
	}
};
LUTGammaBBCGam.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaBBCGam.prototype.linToLegal = function(input) {
	if (input > this.params[3]) {
		return Math.pow((input + this.params[2])/(1 + this.params[2]),this.params[0]);		
	} else {
		return input * this.params[1];
	}
};
LUTGammaBBCGam.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaBBCGam.prototype.linFromLegal = function(input) {
	if (input >= this.params[4]) {
		return ((1 + this.params[2]) * Math.pow(input,1 / this.params[0])) - this.params[2];
	} else {
		return (input / this.params[1]);
	}
};
// Linear
function LUTGammaLin(name, zero) {
	this.name = name;
	this.iso = 800;
	this.zero = zero / 0.2;
	this.gamma = 'γ1.0 (18% Gray = ' + zero + ')';
	this.cat = 1;
}
LUTGammaLin.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLin.prototype.changeContrast = function(rec,out) {
};
LUTGammaLin.prototype.changeRange = function(rec,out) {
};
LUTGammaLin.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * this.zero * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaLin.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = c[j] * this.zero;
	}
};
LUTGammaLin.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / (0.85630498533724 * this.zero);
	}
};
LUTGammaLin.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = c[j] / this.zero;
	}
};
LUTGammaLin.prototype.linToData = function(input) {
	return (input * this.zero * 0.85630498533724) + 0.06256109481916;
};
LUTGammaLin.prototype.linToLegal = function(input) {
	return input * this.zero;
};
LUTGammaLin.prototype.linFromData = function(input) {
	return (input - 0.06256109481916) / (0.85630498533724 * this.zero);
};
LUTGammaLin.prototype.linFromLegal = function(input) {
	return input / this.zero;
};
// Rec2100 PQ
function LUTGammaPQ(name,ootf) {
	this.name = name;
	this.ootf = ootf;
	this.cat = 7;
	this.m1 = (2610/16384);
	this.m2 = (2523/4096)*128;
	this.c1 = (3424/4096);
	this.c2 = (2413/4096)*32;
	this.c3 = (2392/4096)*32;
	this.iso = 800;
	this.setLw();
}
LUTGammaPQ.prototype.setLw = function() {
	var r = Math.pow(Math.max(0,this.ootf.LwI)/10000,this.m1);
	this.mxI = Math.pow((this.c1+(this.c2*r))/(1+(this.c3*r)),this.m2);
	var r = Math.pow(Math.max(0,this.ootf.LwO)/10000,this.m1);
	this.mxO = Math.pow((this.c1+(this.c2*r))/(1+(this.c3*r)),this.m2);
};
LUTGammaPQ.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaPQ.prototype.changeContrast = function(rec,out) {
};
LUTGammaPQ.prototype.changeRange = function(rec,out) {
};
LUTGammaPQ.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToL(buff, p);
	} else {
		this.linToL(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaPQ.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var r;
	var m1 = this.m1;
	var m2 = this.m2;
	var c1 = this.c1;
	var c2 = this.c2;
	var c3 = this.c3;
	var mx;
	if (p) {
		this.ootf.linToL(buff, p);
		if (p.rec) {
			mx = this.mxI;
		} else {
			mx = this.mxO;
		}
	} else {
		this.ootf.linToL(buff);
		mx = this.mxO;
	}
	for (var j=0; j<m; j++) {
		r = Math.pow(Math.max(0,c[j])/10000,m1);
		c[j] = Math.min(mx,Math.pow((c1+(c2*r))/(1+(c3*r)),m2));
	}
};
LUTGammaPQ.prototype.linFromD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	if (p) {
		this.linFromL(buff, p);
	} else {
		this.linFromL(buff);
	}
};
LUTGammaPQ.prototype.linFromL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var r;
	var m1 = this.m1;
	var m2 = this.m2;
	var c1 = this.c1;
	var c2 = this.c2;
	var c3 = this.c3;
	var e = this.linToLegal(0);
	for (var j=0; j<m; j++) {
		if (c[j] <= e) {
			c[j] = 0;
		} else {
			r = Math.pow(c[j],1/m2);
			c[j] = Math.pow((r-c1)/(c2-(c3*r)),1/m1) * 10000;
		}
	}
	if (p) {
		this.ootf.linFromL(buff, p);
	} else {
		this.ootf.linFromL(buff);
	}
};
LUTGammaPQ.prototype.linToData = function(input, p) {
	if (p) {
		return (this.linToLegal(input,p) * 0.85630498533724) + 0.06256109481916;
	} else {
		return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaPQ.prototype.linToLegal = function(input, p) {
	var mx, r;
	if (p) {
		var r = Math.pow(Math.max(0,this.ootf.linToLegal(input, p))/10000,this.m1);
		if (p.rec) {
			mx = this.mxI;
		} else {
			mx = this.mxO;
		}
	} else {
		var r = Math.pow(Math.max(0,this.ootf.linToLegal(input))/10000,this.m1);
		mx = this.mxO;
	}
	return Math.min(mx,Math.pow((this.c1+(this.c2*r))/(1+(this.c3*r)),this.m2));
};
LUTGammaPQ.prototype.linFromData = function(input, p) {
	if (p) {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724, p);
	} else {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
	}
};
LUTGammaPQ.prototype.linFromLegal = function(input, p) {
	var r = Math.pow(input,1/this.m2);
	if (p) {
		input = this.ootf.linFromLegal(Math.pow((r-this.c1)/(this.c2-(this.c3*r)),1/this.m1) * 10000, p);
	} else {
		input = this.ootf.linFromLegal(Math.pow((r-this.c1)/(this.c2-(this.c3*r)),1/this.m1) * 10000);
	}
	if (isNaN(input)) {
		return 0;
	} else {
		return input;
	}
};
// Rec2100 Hybrid-Log Gamma (HLG)
function LUTGammaHLG(name,params) {
	this.name = name;
	this.a = params.a;
	this.b = params.b;
	this.c = params.c;
	this.cat = 5;
	this.iso = 800;
	this.nbI = 1;
	this.nbO = 1;
}
LUTGammaHLG.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaHLG.prototype.changeContrast = function(rec,out) {
};
LUTGammaHLG.prototype.changeRange = function(rec,out) {
};
LUTGammaHLG.prototype.setBBC = function(bbcIn, bbcOut) {
	if (bbcIn) {
		this.nbI = 2.821251498;
	} else {
		this.nbI = 1;
	}
	if (bbcOut) {
		this.nbO = 2.821251498;
	} else {
		this.nbO = 1;
	}
};
LUTGammaHLG.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToL(buff, p);
	} else {
		this.linToL(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaHLG.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var r;
	var nb;
	if (p && p.rec) {
		nb = this.nbI;
	} else {
		nb = this.nbO;
	}
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = 0;
		} else if (c[j] <= 1/nb) {
			c[j] = Math.pow(c[j]*nb,0.5) / 2;
		} else {
			c[j] = (this.a * Math.log((c[j]*nb) - this.b)) + this.c;
		}
	}
};
LUTGammaHLG.prototype.linFromD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	if (p) {
		this.linFromL(buff, p);
	} else {
		this.linFromL(buff);
	}
};
LUTGammaHLG.prototype.linFromL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var r;
	var nb;
	if (p && p.out) {
		nb = this.nbO;
	} else {
		nb = this.nbI;
	}
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = 0;
		} else if (c[j] <= 0.5) {
			c[j] = Math.pow(2*c[j],2)/nb;
		} else {
			c[j] = (Math.exp((c[j] - this.c)/this.a) + this.b)/nb;
		}
	}
};
LUTGammaHLG.prototype.linToData = function(input, p) {
	if (p) {
		return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
	} else {
		return (this.linToLegal(input, p) * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaHLG.prototype.linToLegal = function(input, p) {
	var nb;
	if (p && p.rec) {
		nb = this.nbI;
	} else {
		nb = this.nbO;
	}
	if (input < 0) {
		return 0;
	} else if (input <= 1/nb) {
		return Math.pow(input * nb,0.5) / 2;
	} else {
		return (this.a * Math.log((input * nb) - this.b)) + this.c;
	}
};
LUTGammaHLG.prototype.linFromData = function(input, p) {
	if (p) {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724, p);
	} else {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
	}
};
LUTGammaHLG.prototype.linFromLegal = function(input, p) {
	var nb;
	if (p && p.out) {
		nb = this.nbO;
	} else {
		nb = this.nbI;
	}
	if (input < 0) {
		return 0;
	} else if (input <= 0.5) {
		return Math.pow(2*input,2) / nb;
	} else {
		return (Math.exp((input - this.c)/this.a) + this.b) / nb;
	}
};
// Rec2100 PQ OOTF
function LUTGammaOOTFPQ(name, params) {
	this.name = name;
	if (typeof params.scale === 'string') {
		switch(params.scale.toLowerCase()) {
			case 'normalised':
				this.s = 1/100;
				break;
			case 'nits':
			default:
				this.s = 100;
				break;
		}
	} else {
		this.s = 100; // default nits
	}
	this.setLw(params.Lw, params.Lw);
	this.iso = 800;
	this.gamma = '';
	this.cat = 1;
	this.hdrOOTF = true;
}
LUTGammaOOTFPQ.prototype.setLw = function(LwIn, LwOut) {
	this.LwI = LwIn;
	var out = false;
	if (LwOut !== this.LwO) {
		out = true;
	}
	this.LwO = LwOut;
	this.eI = this.linToLegal(0, { rec: true });
	this.eO = this.linToLegal(0);
	return out;
};
LUTGammaOOTFPQ.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaOOTFPQ.prototype.changeContrast = function(rec,out) {
};
LUTGammaOOTFPQ.prototype.changeRange = function(rec,out) {
};
LUTGammaOOTFPQ.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToL(buff,p);
	} else {
		this.linToL(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFPQ.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var e, Lw;
	if (p && p.rec) {
		e = this.eI;
		Lw = this.LwI / 100;
	} else {
		e = this.eO;
		Lw = this.LwO / 100;
	}
	var s = this.s;
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = e;
		} else {
			c[j] /= 100;
			if (c[j] > 0.0003024) {
				c[j] = (1.099*Math.pow(59.5208*c[j],0.45))-0.099;
			} else {
				c[j] = 267.84*Math.max(c[j],0);
			}
			c[j] = Math.min(Lw,Math.pow(c[j],2.4))*s;
		}
	}
};
LUTGammaOOTFPQ.prototype.linFromD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	if (p) {
		this.linFromL(buff, p);
	} else {
		this.linFromL(buff);
	}
};
LUTGammaOOTFPQ.prototype.linFromL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.s;
	var e;
	if (p && p.out) {
		e = this.eO;
	} else {
		e = this.eI;
	}
	for (var j=0; j<m; j++) {
		if (c[j] <= e) {
			c[j] = 0;
		} else {
			c[j] = Math.pow(c[j]/s,1/2.4);
			if (c[j] > 0.080994816) {
				c[j] = Math.pow((c[j] + 0.099)/1.099,1/0.45)/59.5208;
			} else {
				c[j] /= 267.84;
			}
			c[j] *= 100;
		}
	}
};
LUTGammaOOTFPQ.prototype.linToData = function(input, p) {
	if (p) {
		return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
	} else {
		return (this.linToLegal(input, p) * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFPQ.prototype.linToLegal = function(input, p) {
	var e, Lw;
	if (p && p.rec) {
		e = this.eI;
		Lw = this.LwI / 100;
	} else {
		e = this.eO;
		Lw = this.LwO / 100;
	}
	if (input < 0) {
		return e;
	} else {
		input /= 100;
		if (input > 0.0003024) {
			input = (1.099*Math.pow(59.5208*input,0.45))-0.099;	
		} else {
			input = 267.84*Math.max(input,0);
		}
		return Math.min(Lw,Math.pow(input,2.4))*this.s;
	}
}
LUTGammaOOTFPQ.prototype.linFromData = function(input, p) {
	if (p) {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724, p);
	} else {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
	}
};
LUTGammaOOTFPQ.prototype.linFromLegal = function(input, p) {
	if (p && p.out) {
		e = this.eO;
	} else {
		e = this.eI;
	}
	if (input <= e) {
		return 0;
	} else {
		input = Math.pow(input/this.s,1/2.4);
		if (input > 0.080994816) {
			input = Math.pow((input + 0.099)/1.099,1/0.45)/59.5208;
		} else {
			input /= 267.84;
		}
		return input * 100;
	}
};
// Rec2100 HLG OOTF
function LUTGammaOOTFHLG(name, params) {
	this.name = name;
	if (typeof params.scale === 'string') {
		switch(params.scale.toLowerCase()) {
			case 'normalised':
				this.s = 1/1000;
				break;
			case 'nits':
			default:
				this.s = 1;
				break;
		}
	} else {
		this.s = 1; // default nits
	}
	this.setLw(params.Lw, params.Lw, params.Lb, params.Lb);
	this.nbI = 1;
	this.nbO = 1;
	this.iso = 800;
	this.gamma = '';
	this.cat = 1;
	this.hdrOOTF = true;
}
LUTGammaOOTFHLG.prototype.setBBC = function(bbcIn, bbcOut) {
	if (bbcIn) {
		this.nbI = 2.821251498;
	} else {
		this.nbI = 1;
	}
	var old = false;
	if  (this.nbO) {
		old = this.nbO;
	}
	if (bbcOut) {
		this.nbO = 2.821251498;
	} else {
		this.nbO = 1;
	}
	if (old && old !== this.nbO) {
		return true;
	} else {
		return false;
	}
};
LUTGammaOOTFHLG.prototype.setLw = function(LwIn, LwOut, LbIn, LbOut) {
	this.LwI = LwIn;
	var out = false;
	if (LwOut !== this.LwO) {
		out = true;
	}
	this.LwO = LwOut;
	if (typeof LbIn === 'number') {
		this.LbI = LbIn;
		if (typeof LbOut === 'number') {
			if (LbOut !== this.LbO) {
				out = true;
			}
			this.LbO = LbOut;
		}
	} else {
		this.LbI = 0;
		this.LbO = 0;
	}
	this.gI = (1.2 + (0.42*Math.log(this.LwI/1000)/Math.LN10));
	this.aI = (this.LwI-this.LbI)/Math.pow(12,this.gI);
	this.bI = this.LbI;
	this.gO = (1.2 + (0.42*Math.log(this.LwO/1000)/Math.LN10));
	this.aO = (this.LwO-this.LbO)/Math.pow(12,this.gO);
	this.bO = this.LbO;
	return out;
};
LUTGammaOOTFHLG.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaOOTFHLG.prototype.changeContrast = function(rec,out) {
};
LUTGammaOOTFHLG.prototype.changeRange = function(rec,out) {
};
LUTGammaOOTFHLG.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToL(buff, p);
	} else {
		this.linToL(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFHLG.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var g, a, b, nb, s, mx;
	if (p && p.rec) {
		g = this.gI;
		a = this.aI;
		b = this.bI;
		nb = this.nbI;
		s = this.s;
		mx = this.LwI * this.s;
	} else {
		g = this.gO;
		a = this.aO;
		b = this.bO;
		nb = this.nbO;
		s = this.s;
		mx = this.LwO * this.s;
	}
	if (p && p.rgb) {
		var y;
		for (var j=0; j<m; j += 3) {
			c[ j ] = Math.max(0,c[ j ]) * nb;
			c[j+1] = Math.max(0,c[j+1]) * nb;
			c[j+2] = Math.max(0,c[j+2]) * nb;
			y = (0.2627 * c[ j ]) + (0.6780 * c[j+1]) + (0.0593 * c[j+2]);
			c[ j ] = Math.min(mx,((a * Math.pow(y, g-1) * c[ j ]) + b) * s);
			c[j+1] = Math.min(mx,((a * Math.pow(y, g-1) * c[j+1]) + b) * s);
			c[j+2] = Math.min(mx,((a * Math.pow(y, g-1) * c[j+2]) + b) * s);
		}
	} else {
		for (var j=0; j<m; j++) {
			c[ j ] = Math.min(mx,((a * Math.pow(Math.max(0,c[ j ] * nb), g)) + b) * s);
		}
	}
};
LUTGammaOOTFHLG.prototype.linFromD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	if (p) {
		this.linFromL(buff, p);
	} else {
		this.linFromL(buff);
	}
};
LUTGammaOOTFHLG.prototype.linFromL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;	
	if (p && p.out) {
		g = this.gO;
		a = this.aO;
		b = this.bO;
		nb = this.nbO;
		s = this.s;
	} else {
		g = this.gI;
		a = this.aI;
		b = this.bI;
		nb = this.nbI;
		s = this.s;
	}
	if (p && p.rgb) {
		var y;
		for (var j=0; j<m; j += 3) {
			y = (0.2627 * c[ j ]) + (0.6780 * c[j+1]) + (0.0593 * c[j+2]);
			y = Math.pow(Math.max(0, (y / s) - b) / a, (1-g)/g) / (a*nb);
			c[ j ] = y * ((c[ j ] / s) - b);
			c[j+1] = y * ((c[j+1] / s) - b);
			c[j+2] = y * ((c[j+2] / s) - b);
		}
	} else {
		for (var j=0; j<m; j++) {
			c[ j ] = Math.pow(Math.max(0, (c[ j ] / s) - b)/a, 1/g)/nb;
		}
	}
};
LUTGammaOOTFHLG.prototype.linToData = function(input, p) {
	if(p) {
		return (this.linToLegal(input, p) * 0.85630498533724) + 0.06256109481916;
	} else {
		return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFHLG.prototype.linToLegal = function(input, p) {
	if (p && p.rec) {
		return Math.min(this.s*this.LwI,((this.aI * Math.pow(Math.max(0,input * this.nbI), this.gI)) + this.bI) * this.s);
	} else {
		return Math.min(this.s*this.LwO,((this.aO * Math.pow(Math.max(0,input * this.nbO), this.gO)) + this.bO) * this.s);
	}
};
LUTGammaOOTFHLG.prototype.linFromData = function(input, p) {
	if (p) {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724, p);
	} else {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
	}
};
LUTGammaOOTFHLG.prototype.linFromLegal = function(input, p) {
	if (p && p.out) {
		return Math.pow(Math.max(0, (input / this.s) - this.bO)/this.aO, 1/this.gO)/this.nbO;
	} else {
		return Math.pow(Math.max(0, (input / this.s) - this.bI)/this.aI, 1/this.gI)/this.nbI;
	}
};
// Rec2100 No OOTF (Scaled Scene Linear)
function LUTGammaOOTFNone(name, params) {
	this.setLw(params.Lw, params.Lw);
}
LUTGammaOOTFNone.prototype.setLw = function(LwIn, LwOut) {
	this.LwI = LwIn;
	var out = false;
	if (LwOut !== this.LwO) {
		out = true;
	}
	this.LwO = LwOut;
	return out;
};
LUTGammaOOTFNone.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaOOTFNone.prototype.changeContrast = function(rec,out) {
};
LUTGammaOOTFNone.prototype.changeRange = function(rec,out) {
};
LUTGammaOOTFNone.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToL(buff, p);
	} else {
		this.linToL(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFNone.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var Lw;
	if (p && p.rec) {
		Lw = this.LwI;
	} else {
		Lw = this.LwO;
	}
	for (var j=0; j<m; j++) {
		c[ j ] = Math.min(c[ j ]*100, Lw);
	}
};
LUTGammaOOTFNone.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = ((c[j]/100) - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaOOTFNone.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[ j ] = c[ j ]/100;
	}
};
LUTGammaOOTFNone.prototype.linToData = function(input, p) {
	if (p) {
		return (this.linToLegal(input, p) * 0.85630498533724) + 0.06256109481916;
	} else {
		return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFNone.prototype.linToLegal = function(input, p) {
	if (p && p.rec) {
		return Math.min(input * 100, this.LwI);
	} else {
		return Math.min(input * 100, this.LwO);
	}
};
LUTGammaOOTFNone.prototype.linFromData = function(input) {
	return this.linFromLegal(((input / 100) - 0.06256109481916) / 0.85630498533724);
};
LUTGammaOOTFNone.prototype.linFromLegal = function(input) {
	return input / 100;
};
// ITU HDR Proposal
function LUTGammaITUProp(name,params) {
	this.name = name;
	this.iso = 800;
	this.cat = 5;
	this.setM(params.m);
}
LUTGammaITUProp.prototype.setM = function(m) {
	this.m = m;
	this.n = 0.45*1.09930000*Math.pow(m,0.45);
	this.r = (1.09930000*Math.pow(m,0.45)*(1-(0.45*Math.log(m)))) - 0.09930000;
	this.e = this.linToLegal(m);
};
LUTGammaITUProp.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaITUProp.prototype.changeContrast = function(rec,out) {
};
LUTGammaITUProp.prototype.changeRange = function(rec,out) {
};
LUTGammaITUProp.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaITUProp.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] > this.m) {
			c[j] = ((this.n*Math.log(c[j])) + this.r);
		} else if (c[j] >= 0.01810000) {
			c[j] = (1.09930000 * Math.pow(c[j],0.45)) - 0.09930000;
		} else {
			c[j] = 4.5 * c[j];
		}
	}
};
LUTGammaITUProp.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaITUProp.prototype.linFromL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] > this.e) {
			c[j] = Math.exp((c[j]-this.r)/this.n);
		} else if (c[j] >= 0.08145000) {
			c[j] = Math.pow((c[j] + 0.09930000)/(1.09930000),1/0.45);		
		} else {
			c[j] = (c[j] / 4.5);
		}
	}
};
LUTGammaITUProp.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaITUProp.prototype.linToLegal = function(input) {
	if (input > this.m) {
		return ((this.n*Math.log(input)) + this.r);
	} else if (input >= 0.01810000) {
		return (1.09930000 * Math.pow(input,0.45)) - 0.09930000;
	} else {
		return 4.5 * input;
	}
};
LUTGammaITUProp.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaITUProp.prototype.linFromLegal = function(input) {
	if (input > this.e) {
		return Math.exp((input-this.r)/this.n);
	} else if (input >= 0.08145000) {
		return Math.pow((input + 0.09930000)/(1.09930000),1/0.45);		
	} else {
		return (input / 4.5);
	}
};
// BBC White Paper 283
function LUTGammaBBC283(name,params) {
	this.name = name;
	this.iso = 800;
	this.cat = 5;
	this.setM(params.m);
	this.setS(1);
}
LUTGammaBBC283.prototype.setM = function(m) {
	this.m = m;
	this.n = Math.sqrt(m)/2;
	this.r = Math.sqrt(m)*(1-Math.log(Math.sqrt(m)));
	this.e = this.linToLegal(m);
};
LUTGammaBBC283.prototype.setS = function(s) { // System Gamma
	this.s = s;
};
LUTGammaBBC283.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaBBC283.prototype.changeContrast = function(rec,out) {
};
LUTGammaBBC283.prototype.changeRange = function(rec,out) {
};
LUTGammaBBC283.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaBBC283.prototype.linToL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] > this.m) {
			c[j] = ((this.n*Math.log(c[j])) + this.r);
		} else if (c[j]>0) {
			c[j] = Math.sqrt(c[j]);
		} else {
			c[j] = 0;
		}
	}
};
LUTGammaBBC283.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaBBC283.prototype.linFromL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >this.e) {
			c[j] = Math.exp(this.s*(c[j]-this.r)/this.n);
		} else {
			c[j] = Math.pow(c[j],2*this.s);
		}
	}
};
LUTGammaBBC283.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaBBC283.prototype.linToLegal = function(input) {
	if (input > this.m) {
		return ((this.n*Math.log(input)) + this.r);
	} else if (input>0) {
		return Math.sqrt(input);
	} else {
		return 0;
	}
};
LUTGammaBBC283.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaBBC283.prototype.linFromLegal = function(input) {
	if (input >this.e) {
		return Math.exp(this.s*(input-this.r)/this.n);
	} else {
		return Math.pow(input,2*this.s);
	}
};
// ACES Log
function LUTGammaACEScc(name,params) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;
	this.low = Math.pow(2,-15);
	this.m = ((Math.log(this.low*0.5)/Math.log(2)) + 9.72)/17.52;
	this.low2 = (9.72-15)/17.52;
	this.mid = ((Math.log(65504)/Math.log(2))+9.72)/17.52;
}
LUTGammaACEScc.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaACEScc.prototype.changeContrast = function(rec,out) {
};
LUTGammaACEScc.prototype.changeRange = function(rec,out) {
};
LUTGammaACEScc.prototype.linToL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = this.m;
		} else if (c[j]<(this.low/0.9)) {
			c[j] = ((Math.log(Math.pow(2,-16) + (c[j]*0.45))/Math.log(2)) + 9.72)/17.52;
		} else {
			c[j] = ((Math.log(c[j]*0.9)/Math.log(2))+9.72)/17.52;
		}
	}
};
LUTGammaACEScc.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaACEScc.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaACEScc.prototype.linFromL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < this.low2) {
			c[j] = (Math.pow(2,(c[j]*17.52)-9.72)-Math.pow(2,-16))*2/0.9;
		} else if (c[j] < this.mid) {
			c[j] = Math.pow(2,(c[j]*17.52)-9.72)/0.9;
		} else {
			c[j] = 65504/0.9;
		}
	}
};
LUTGammaACEScc.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaACEScc.prototype.linToLegal = function(input) {
		if (input < 0) {
			return this.m;
		} else if (input<(this.low/0.9)) {
			return ((Math.log(Math.pow(2,-16) + (input*0.45))/Math.log(2)) + 9.72)/17.52;
		} else {
			return ((Math.log(input*0.9)/Math.log(2))+9.72)/17.52;
		}
};
LUTGammaACEScc.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaACEScc.prototype.linFromLegal = function(input) {
	if (input < this.low2) {
		return (Math.pow(2,(input*17.52)-9.72)-Math.pow(2,-16))*2/0.9;
	} else if (input < this.mid) {
		return Math.pow(2,(input*17.52)-9.72)/0.9;
	} else {
		return 65504/0.9;
	}
};
// ACES Log Proxy (limited bit range for SDI)
function LUTGammaACESProxy(name,params) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;
	if (params === 10) {
		this.blk = 64;
		this.mul = 50;
		this.off = 425;
		this.hi = 1023;
	} else {
		this.blk = 256;
		this.mul = 200;
		this.off = 1700;
		this.hi = 4095;
	}
	this.low = Math.pow(2,-9.72)/0.9;
}
LUTGammaACESProxy.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaACESProxy.prototype.changeContrast = function(rec,out) {
};
LUTGammaACESProxy.prototype.changeRange = function(rec,out) {
};
LUTGammaACESProxy.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] <= this.low) {
			c[j] = this.blk / this.hi;
		} else {
			c[j] = ((((Math.log(c[j]*0.9)/Math.log(2))+2.5) * this.mul) + this.off)/this.hi;
		}
	}
};
LUTGammaACESProxy.prototype.linToL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaACESProxy.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = Math.pow(2,(((c[j]*this.hi)-this.off)/this.mul)-2.5)/0.9;
	}
};
LUTGammaACESProxy.prototype.linFromL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j]*0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaACESProxy.prototype.linToData = function(input) {
	if (input <= this.low) {
		return this.blk / this.hi;
	} else {
		return ((((Math.log(input*0.9)/Math.log(2))+2.5) * this.mul) + this.off) / this.hi;
	}
};
LUTGammaACESProxy.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaACESProxy.prototype.linFromData = function(input) {
	return Math.pow(2,(((input*this.hi)-this.off)/this.mul)-2.5)/0.9;
};
LUTGammaACESProxy.prototype.linFromLegal = function(input) {
	return (this.linFromData(input)*0.85630498533724) + 0.06256109481916;
};
// General Tone Curves (four part sigmoids)
function LUTGammaGen(name,params) {
	this.name = name;
	this.params = params;
	this.iso = 800;
	this.cat = 2;
}
LUTGammaGen.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaGen.prototype.changeContrast = function(rec,out) {
};
LUTGammaGen.prototype.changeRange = function(rec,out) {
};
LUTGammaGen.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var stop;
	for (var j=0; j<m; j++) {
		stop = -300;
		if (c[j] > 0) {
			stop = Math.log(c[j] / 0.2) / Math.LN2;
		}
		if ( c[j] > this.params.top[6] ) {
			c[j] = this.params.top[1] + ((this.params.top[0] - this.params.top[1])/Math.pow(1+(this.params.top[4] * Math.exp(-this.params.top[2]*(stop - this.params.top[5]))),1/this.params.top[3]));
		} else if ( c[j] > this.params.high[6] ) {
			c[j] = this.params.high[1] + ((this.params.high[0] - this.params.high[1])/Math.pow(1+(this.params.high[4] * Math.exp(-this.params.high[2]*(stop - this.params.high[5]))),1/this.params.high[3]));
		} else if ( c[j] > this.params.mid[6] ) {
			c[j] = this.params.mid[1] + ((this.params.mid[0] - this.params.mid[1])/Math.pow(1+(this.params.mid[4] * Math.exp(-this.params.mid[2]*(stop - this.params.mid[5]))),1/this.params.mid[3]));
		} else if ( c[j] > this.params.low[6] ) {
			c[j] = this.params.low[1] + ((this.params.low[0] - this.params.low[1])/Math.pow(1+(this.params.low[4] * Math.exp(-this.params.low[2]*(stop - this.params.low[5]))),1/this.params.low[3]));
		} else if ( c[j] <=0 ) {
			c[j] = (this.params.blk[0] * c[j]) + this.params.blk[1];
		} else {
			c[j] = (this.params.bot[0] * c[j]) + this.params.bot[1];
		}
	}
};
LUTGammaGen.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaGen.prototype.linToData = function(input) {
	var stop = -300;
	if (input > 0) {
		stop = Math.log(input / 0.2) / Math.LN2;
	}
	if ( input > this.params.top[6] ) {
		return this.params.top[1] + ((this.params.top[0] - this.params.top[1])/Math.pow(1+(this.params.top[4] * Math.exp(-this.params.top[2]*(stop - this.params.top[5]))),1/this.params.top[3]));
	} else if ( input > this.params.high[6] ) {
		return this.params.high[1] + ((this.params.high[0] - this.params.high[1])/Math.pow(1+(this.params.high[4] * Math.exp(-this.params.high[2]*(stop - this.params.high[5]))),1/this.params.high[3]));
	} else if ( input > this.params.mid[6] ) {
		return this.params.mid[1] + ((this.params.mid[0] - this.params.mid[1])/Math.pow(1+(this.params.mid[4] * Math.exp(-this.params.mid[2]*(stop - this.params.mid[5]))),1/this.params.mid[3]));
	} else if ( input > this.params.low[6] ) {
		return this.params.low[1] + ((this.params.low[0] - this.params.low[1])/Math.pow(1+(this.params.low[4] * Math.exp(-this.params.low[2]*(stop - this.params.low[5]))),1/this.params.low[3]));
	} else if ( input <=0 ) {
		return (this.params.blk[0] * input) + this.params.blk[1];
	} else {
		return (this.params.bot[0] * input) + this.params.bot[1];
	}
};
LUTGammaGen.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
// General Tone Curves (S-Log3->Output LUT based)
function LUTGammaLUTSL3(name,lut) {
	this.name = name;
	this.lut = new LUTQSpline(lut.buffer);
	this.iso = 800;
	this.cat = 2;
}
LUTGammaLUTSL3.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLUTSL3.prototype.changeContrast = function(rec,out) {
};
LUTGammaLUTSL3.prototype.changeRange = function(rec,out) {
};
LUTGammaLUTSL3.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= 0.0125) {
			c[j] = (0.2556207230 * Math.log((c[j] * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850;
		} else {
			c[j] = (c[j] + 0.0155818840)/0.1677922920;
		}
	}
	this.lut.FCub(buff);
};
LUTGammaLUTSL3.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLUTSL3.prototype.linToData = function(input) {
	if (input >= 0.0125) {
		return this.lut.fCub((0.2556207230 * Math.log((input * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850);
	} else {
		return this.lut.fCub((input + 0.0155818840)/0.1677922920);
	}
};
LUTGammaLUTSL3.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
// General Tone Curves (SimpleLog->Output LUT based)
function LUTGammaLUTSimple(name,params) {
	this.name = name;
	this.log = new Float64Array(5);
	this.log[0] = 5/Math.pow(2,params.clip);
	this.log[1] = params.loggy/params.clip;
	this.log[2] = (Math.log(1 + this.log[1])-Math.log(this.log[1]))/Math.LN10;
	this.log[3] = Math.log(this.log[1])/Math.LN10;
	this.log[4] = this.log[0] / (this.log[1] * this.log[2] * Math.LN10);
	this.spline = new LUTQSpline(params.lut.buffer);
	this.iso = 800;
	this.cat = 2;
}
LUTGammaLUTSimple.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLUTSimple.prototype.changeContrast = function(rec,out) {
};
LUTGammaLUTSimple.prototype.changeRange = function(rec,out) {
};
LUTGammaLUTSimple.prototype.linToD = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	var log = this.log;
	for (var j=0; j<m; j++) {
		if (o[j] >= 0) {
			o[j] = ((Math.log((o[j] * log[0]) + log[1])/Math.LN10)-log[3])/log[2];
		} else {
			o[j] = o[j]*log[4];
		}
	}
	this.spline.FCub(buff);
};
LUTGammaLUTSimple.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLUTSimple.prototype.linToData = function(input) {
	if (input >= 0) {
		input = ((Math.log((input * this.log[0]) + this.log[1])/Math.LN10)-this.log[3])/this.log[2];
	} else {
		input = input*this.log[4];
	}
	return this.spline.f(input);
};
LUTGammaLUTSimple.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
// General Tone Curves (Invertable LUT based)
function LUTGammaIOLUT(name,params) {
	this.name = name;
	this.rec = new LUTQSpline(params.rec.lut.buffer);
	this.out = new LUTQSpline(params.out.lut.buffer);
	this.iso = 800;
	this.cat = 6;
}
LUTGammaIOLUT.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaIOLUT.prototype.changeContrast = function(rec,out) {
};
LUTGammaIOLUT.prototype.changeRange = function(rec,out) {
};
LUTGammaIOLUT.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= 0.0125) {
			c[j] = (0.2556207230 * Math.log((c[j] * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850;
		} else {
			c[j] = (c[j] + 0.0155818840)/0.1677922920;
		}
	}
	this.out.FCub(buff);
};
LUTGammaIOLUT.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaIOLUT.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.rec.FCub(buff);
	for (var j=0; j<m; j++) {
		if (c[j] >= 0.1673609920) {
			c[j] = (Math.pow(10,(c[j] - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
		} else {
			c[j] = (0.1677922920 * c[j]) - 0.0155818840;
		}
	}
};
LUTGammaIOLUT.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaIOLUT.prototype.linToData = function(input) {
	if (input >= 0.0125) {
		return this.out.f((0.2556207230 * Math.log((input * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850);
	} else {
		return this.out.f((input + 0.0155818840)/0.1677922920);
	}
};
LUTGammaIOLUT.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaIOLUT.prototype.linFromData = function(input) {
	var data = this.rec.f(input);
	if (data >= 0.1673609920) {
		return (Math.pow(10,(data - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
	} else {
		return (0.1677922920 * data) - 0.0155818840;
	}
};
LUTGammaIOLUT.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// DJI DLog-M Curves
function LUTGammaDLog(name) {
	this.name = name;
	this.iso = 800;
	this.cat = 6;
	this.clip = 4.802951742;
	this.loggy = 0.02;
	this.log = new Float64Array(6);
	this.rec = [];
	this.out = [];
	this.reccon = 3;
	this.outcon = 3;
	this.loadLUTs();
}
LUTGammaDLog.prototype.loadLUTs = function() {
	// Contrast -3
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.027013881, 0.059898339, 0.090088157, 0.118437528,
						0.145610746, 0.172169533, 0.198613763, 0.227521773, 0.262056586, 0.302175407, 0.34492969, 0.385399436,
						0.424651585, 0.467275042, 0.510407243, 0.552759914, 0.592749573, 0.629826127, 0.664057729, 0.695758476,
						0.725291386, 0.752991781, 0.779146345, 0.803993306, 0.827729079, 0.850515908, 0.872488687, 0.893760574,
						0.914427454  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.12885289, 0.15885059, 0.19144138, 0.226199875, 0.262466189, 0.299384828, 0.334847065,
						0.364688823, 0.390416782, 0.413838603, 0.436630643, 0.46037471, 0.486584362, 0.509543387, 0.532318837,
						0.554970585, 0.57771412, 0.601166982, 0.625811624, 0.652038025, 0.680152405, 0.710384832, 0.742896012,
						0.777783434, 0.815087031, 0.854794442, 0.896845964, 0.941139238, 0.987533704, 1.035854869, 1.085898383,
						1.137433963  ]
				).buffer));
	// Contrast -2
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.031210281, 0.068285973, 0.101551761, 0.132158936,
						0.160893656, 0.188302321, 0.215465805, 0.245787053, 0.279449722, 0.315427111, 0.351812097, 0.386609889,
						0.423110071, 0.460310688, 0.49840922, 0.53710835, 0.575293346, 0.61215979, 0.647304693, 0.680626751,
						0.712198291, 0.742171033, 0.770721576, 0.798024375, 0.824240266, 0.849512889, 0.873968764, 0.897718877,
						0.920860756  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.125031422, 0.151121007, 0.179907158, 0.21124056, 0.244837237, 0.280317645, 0.316069712,
						0.347826102, 0.376601031, 0.403745563, 0.430511022, 0.458076706, 0.487569716, 0.512232259, 0.538212324,
						0.563787753, 0.589013066, 0.614435086, 0.640476557, 0.667481773, 0.695724061, 0.725412299, 0.756696709,
						0.789674087, 0.824392599, 0.860856239, 0.899029, 0.938838816, 0.980181311, 1.022923372, 1.066906563,
						1.111950408  ]
				).buffer));
	// Contrast -1
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.031210281, 0.083971133, 0.121494403, 0.154287516,
						0.183562707, 0.210419428, 0.238243695, 0.267538992, 0.297983064, 0.32913085, 0.360463177, 0.391461448,
						0.421734685, 0.453519587, 0.485544904, 0.518128718, 0.551268321, 0.584699085, 0.61821976, 0.651668307,
						0.684925468, 0.717912965, 0.750588498, 0.78293948, 0.814976874, 0.846729853, 0.878241601, 0.909566273,
						0.940767026  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.119702232, 0.140380917, 0.163951817, 0.190659752, 0.220743195, 0.254458113, 0.290796984,
						0.325213901, 0.357945224, 0.389621678, 0.420821249, 0.452083233, 0.483918385, 0.515547815, 0.546123016,
						0.576458327, 0.606169418, 0.635519362, 0.664689059, 0.693824954, 0.723042483, 0.752429059, 0.782046706,
						0.811934418, 0.842110312, 0.872573607, 0.903306472, 0.934275751, 0.965434601, 0.996724043, 1.028074436,
						1.059406888  ]
				).buffer));
	// Contrast 0
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.050605212, 0.101847391, 0.141801367, 0.174553642,
						0.202322185, 0.22874131, 0.255482461, 0.28250488, 0.309772209, 0.337252216, 0.364916477, 0.392740043,
						0.420701103, 0.44878065, 0.476962175, 0.505497001, 0.534850524, 0.564998669, 0.59599196, 0.62788934,
						0.660759718, 0.694683955, 0.729757441, 0.766093505, 0.803827992, 0.843125543, 0.884188395, 0.927269068,
						0.972689245  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.115301511, 0.13149171, 0.150709282, 0.173520311, 0.200596729, 0.232736113, 0.269479213,
						0.306121311, 0.342305347, 0.378112298, 0.41360763, 0.448844624, 0.483866883, 0.518710261, 0.553404354,
						0.587806017, 0.621210936, 0.653692164, 0.685268931, 0.715957019, 0.745769397, 0.77471673, 0.802807792,
						0.830049806, 0.856448717, 0.882009423, 0.906735956, 0.930631637, 0.9536992, 0.975940896, 0.997358579,
						1.017953772  ]
				).buffer));
	// Contrast +1
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.065301918, 0.122898589, 0.163791157, 0.195392233,
						0.222619063, 0.249062283, 0.274879392, 0.300175737, 0.325037946, 0.349539312, 0.373743447, 0.39770684,
						0.419269569, 0.442890208, 0.46719661, 0.492246446, 0.5186057, 0.546354484, 0.575623809, 0.606564753,
						0.639352843, 0.67419386, 0.711331721, 0.751059159, 0.793733115, 0.839797302, 0.889816948, 0.944534957,
						1.004968521  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.111565815, 0.123773786, 0.138880449, 0.157644772, 0.181032868, 0.210267605, 0.245497324,
						0.282372766, 0.320314165, 0.359178573, 0.398828899, 0.439131472, 0.47995439, 0.524196873, 0.564466885,
						0.603106531, 0.639442649, 0.673698044, 0.706021768, 0.736548095, 0.765398416, 0.792682782, 0.818501185,
						0.84294462, 0.866095988, 0.888030858, 0.908818132, 0.928520624, 0.947195571, 0.964895085, 0.981666562,
						0.997553059  ]
				).buffer));
	// Contrast +2
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.087126998, 0.14748523, 0.186008431, 0.215075483,
						0.241476046, 0.266270946, 0.289822865, 0.312379852, 0.334121161, 0.355181885, 0.375667304, 0.395661748,
						0.417935416, 0.437180913, 0.457332473, 0.478483044, 0.500910514, 0.525100922, 0.551252839, 0.579695788,
						0.610846553, 0.645240993, 0.683580724, 0.726803064, 0.776188158, 0.83352692, 0.901392061, 0.983599666,
						1.086113055  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.108032367, 0.116457848, 0.127644377, 0.14254077, 0.162414978, 0.188948062, 0.222967563,
						0.260543566, 0.300956216, 0.343919729, 0.389172406, 0.436469467, 0.485577963, 0.531756384, 0.579562028,
						0.623777205, 0.663826544, 0.700184042, 0.733216025, 0.763252327, 0.790590503, 0.815499305, 0.838221588,
						0.858976768, 0.87796295, 0.895358767, 0.911325024, 0.926006149, 0.939531523, 0.952016681, 0.963564429,
						0.974265872  ]
				).buffer));
	// Contrast +3
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.116722074, 0.172097954, 0.205648193, 0.232954536,
						0.257670154, 0.280585291, 0.302163456, 0.322705091, 0.342418861, 0.361457313, 0.379936505, 0.397947655,
						0.417231908, 0.434077046, 0.451785726, 0.470466477, 0.490260298, 0.511730454, 0.535127682, 0.560854029,
						0.589456615, 0.621707867, 0.658750465, 0.702381845, 0.755678207, 0.824596336, 0.923217546, 1.100371354,
						1.772368213  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.104692578, 0.10957075, 0.11711386, 0.12845072, 0.145121036, 0.169194945, 0.20204223,
						0.240018043, 0.282187099, 0.328050167, 0.377151866, 0.429068134, 0.483397275, 0.537416608, 0.590950346,
						0.639494073, 0.682513621, 0.720644883, 0.754394462, 0.784219764, 0.81053462, 0.83371391, 0.854097428,
						0.871993164, 0.887680123, 0.901410791, 0.91341331, 0.923893425, 0.933036256, 0.941007907, 0.947956957,
						0.954015838  ]
				).buffer));
	// Log Parameters
	this.log[0] = 5/Math.pow(2,this.clip);
	this.log[1] = this.loggy/this.clip;
	this.log[2] = (Math.log(1 + this.log[1])-Math.log(this.log[1]))/Math.LN10;
	this.log[3] = Math.log(this.log[1])/Math.LN10;
	this.log[4] = this.log[0] / (this.log[1] * this.log[2] * Math.LN10);
	this.log[5] = this.out[this.reccon].f(0);
};
LUTGammaDLog.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaDLog.prototype.changeContrast = function(rec,out) {
		this.reccon = rec + 3;
		this.outcon = out + 3;
};
LUTGammaDLog.prototype.changeRange = function(rec,out) {
};
LUTGammaDLog.prototype.linToD = function(buff,p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var log = this.log;
	for (var j=0; j<m; j++) {
		if (c[j] >= 0) {
			c[j] = ((Math.log((c[j] * log[0]) + log[1])/Math.LN10)-log[3])/log[2];
		} else {
			c[j] = c[j]*log[4];
		}
	}
	if (p && p.rec) {
		this.out[this.reccon].FCub(buff);
	} else {
		this.out[this.outcon].FCub(buff);
	}
};
LUTGammaDLog.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToD(buff,p);
	} else {
		this.linToD(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaDLog.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var log = this.log;
	this.rec[this.reccon].FCub(buff);
	for (var j=0; j<m; j++) {
		if (c[j] >= log[5]) {
			c[j] = (Math.pow(10,(c[j] * log[2]) + log[3]) - log[1]) / log[0];		
		} else {
			c[j] = c[j] / log[4];
		}
	}
};
LUTGammaDLog.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaDLog.prototype.linToData = function(input,p) {
	if (p && p.rec) {
		if (input >= 0) {
			return this.out[this.reccon].f(((Math.log((input * this.log[0]) + this.log[1])/Math.LN10)-this.log[3])/this.log[2]);
		} else {
			return this.out[this.reccon].f(input*this.log[4]);
		}
	} else {
		if (input >= 0) {
			return this.out[this.outcon].f(((Math.log((input * this.log[0]) + this.log[1])/Math.LN10)-this.log[3])/this.log[2]);
		} else {
			return this.out[this.outcon].f(input*this.log[4]);
		}
	}
};
LUTGammaDLog.prototype.linToLegal = function(input,p) {
	if (p) {
		return (this.linToData(input,p) - 0.06256109481916) / 0.85630498533724;
	} else {
		return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaDLog.prototype.linFromData = function(input) {
	var data = this.rec[this.reccon].f(input);
	if (data >= this.log[5]) {
		return (Math.pow(10,(data * this.log[2]) + this.log[3]) - this.log[1]) / this.log[0];		
	} else {
		return data / this.log[4];
	}
};
LUTGammaDLog.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// LUTAnalyst
function LUTGammaLA(name, lutMaker) {
	this.lutMaker = lutMaker;
	this.name = name;
	this.iso = 800;
	this.cat = 4;
}
LUTGammaLA.prototype.setLUT = function(lut) {
	this.lut = this.lutMaker.newLUT({
		title: lut.title,
		format: lut.format,
		dims: lut.dims,
		s: lut.s,
		min: [lut.min[0],lut.min[1],lut.min[2]],
		max: [lut.max[0],lut.max[1],lut.max[2]],
		C: lut.C
	});
	this.rev = this.lutMaker.newLUT({
		title: lut.title,
		format: lut.format,
		dims: lut.dims,
		s: lut.sr,
		min: [lut.minR[0],lut.minR[1],lut.minR[2]],
		max: [lut.maxR[0],lut.maxR[1],lut.maxR[2]],
		C: lut.R
	});
};
LUTGammaLA.prototype.setTitle = function(name) {
	this.name = name;
};
LUTGammaLA.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLA.prototype.changeContrast = function(rec,out) {
};
LUTGammaLA.prototype.changeRange = function(rec,out) {
};
LUTGammaLA.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= 0.0125) {
			c[j] = (0.2556207230 * Math.log((c[j] * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850;
		} else {
			c[j] = (c[j] + 0.0155818840)/0.1677922920;
		}
	}
	this.lut.FCub(buff);
};
LUTGammaLA.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLA.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = this.rev.fCub(c[j]);
		if (c[j] >= 0.1673609920) {
			c[j] = (Math.pow(10,(c[j] - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
		} else {
			c[j] = (0.1677922920*c[j]) + -0.0155818840;
		}
	}
};
LUTGammaLA.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaLA.prototype.linToData = function(input) {
	if (input >= 0.0125) {
		return this.lut.fCub((0.2556207230 * Math.log((input * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850);
	} else {
		return this.lut.fCub((input + 0.0155818840)/0.1677922920);
	}
};
LUTGammaLA.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaLA.prototype.linFromData = function(input) {
 	input = this.rev.fCub(input);
	if (input >= 0.1673609920) {
		return (Math.pow(10,(input - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
	} else {
		return (0.1677922920*input) + -0.0155818840;
	}
};
LUTGammaLA.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// Null
function LUTGammaNull(name) {
	this.name = name;
	this.iso = 800;
	this.cat = 3;
}
LUTGammaNull.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaNull.prototype.changeContrast = function(rec,out) {
};
LUTGammaNull.prototype.changeRange = function(rec,out) {
};
LUTGammaNull.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaNull.prototype.linToL = function(buff) {
// Do Nothing (null)!
};
LUTGammaNull.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaNull.prototype.linFromL = function(buff) {
// Do nothing (null)!
};
LUTGammaNull.prototype.linToData = function(input) {
	return (input * 0.85630498533724) + 0.06256109481916;
};
LUTGammaNull.prototype.linToLegal = function(input) {
	return input;
};
LUTGammaNull.prototype.linFromData = function(input) {
	return (input - 0.06256109481916) / 0.85630498533724;
};
LUTGammaNull.prototype.linFromLegal = function(input) {
	return input;
};
// I/O functions
LUTGamma.prototype.setParams = function(params) {
	var out = {	t: 20, v: this.ver , changedGamma: false};
	if (typeof params.v !== 'number') {
		out.err = true;
		out.details = 'Missing version no.';
		return out;
	}
	if (typeof params.inGamma === 'number') {
		if (params.inGamma !== 9999) {
			if (params.inGamma !== this.curIn) {
				out.changedGamma = true;
			}
			this.curIn = params.inGamma;
			out.inGamma = this.curIn;
		} else {
			if (typeof params.inLinGamma === 'number') {
				if (params.inLinGamma !== this.curIn) {
					out.changedGamma = true;
				}
				this.curIn = params.inLinGamma;
				out.inLinGamma = this.curIn;
			}
		}
	}
	this.changedOut = false;
	if (typeof params.outGamma === 'number') {
		if (params.outGamma !== 9999) {
			if (params.outGamma !== this.curOut) {
				out.changedGamma = true;
				this.changedOut = true;
			}
			this.curOut = params.outGamma;
			out.outGamma = this.curOut;
			if (this.gammas[this.curOut].cat === 3) {
				this.nul = true;
			} else {
				this.nul = false;
			}
		} else {
			if (typeof params.outLinGamma === 'number') {
				if (params.outLinGamma !== this.curOut) {
					out.changedGamma = true;
					this.changedOut = true;
				}
				this.curOut = params.outLinGamma;
				out.outLinGamma = this.curOut;
				this.nul = false;
			}
		}
	}
	if (typeof params.defGamma === 'number') {
		var max = this.gammas.length;
		for (var j = 0; j < max; j++) {
			if (defGamma == this.gammas[j].name) {
				this.curIn = j;
				break;
			}
		}
		this.eiMult = Math.pow(2,this.stopShift);
	}
	if (typeof params.contrast !== 'undefined' && typeof params.contrast.rec === 'number' && typeof params.contrast.out === 'number') {
		this.gammas[this.DLogM].changeContrast(params.contrast.rec,params.contrast.out);
	}
	if (typeof params.arriLegalIn === 'boolean' && typeof params.arriLegalOut === 'boolean') {
		var max = this.arriIdxList.length;
		for (var j=0; j < max; j++) {
			this.gammas[this.arriIdxList[j]].changeRange(params.arriLegalIn, params.arriLegalOut);
		}
	
	}
	if (typeof params.newISO === 'number') {
		var max = this.gammas.length;
		for (var j = 0; j < max; j++) {
			this.gammas[j].changeISO(params.newISO);
		}
		if (typeof params.natISO === 'number' && typeof params.camType === 'number' && params.camType === 0) {
			this.eiMult = params.newISO / params.natISO;
		}
	}
	if (typeof params.stopShift === 'number') {
		this.eiMult = Math.pow(2,params.stopShift);
	}
	out.eiMult = this.eiMult;
	if (typeof params.camClip === 'number') {
		this.camClip = params.camClip;
	}
	if (typeof params.inL === 'boolean') {
		this.inL = params.inL;
	}
	if (typeof params.outL === 'boolean') {
		this.outL = params.outL;
	}
	if (typeof params.scaleCheck === 'boolean' && params.scaleCheck && typeof params.scaleMin === 'number' && typeof params.scaleMax === 'number') {
		this.sMin = params.scaleMin;
		this.sMax = params.scaleMax;
		if (this.sMin !== 0 || this.sMax !== 1) {
			this.sIn = true;
		} else {
			this.sIn = false;
		}
	} else {
		this.sMin = 0;
		this.sMax = 1;
		this.sIn = false;
	}
//
	if (this.curOut === this.PQ || this.curOut === (this.PQ+1) || this.curOut === this.pqEOTFIdx) {
		this.hdrOut = true;
	} else {
		this.hdrOut = false;
	}
	this.changedHDR = false;
	if (typeof params.hlgBBCIn === 'boolean' && typeof params.hlgBBCOut === 'boolean') {
		this.gammas[this.HLG].setBBC(params.hlgBBCIn, params.hlgBBCOut)
		if (this.hlgOOTF.setBBC(params.hlgBBCIn, params.hlgBBCOut)) {
			this.changedHDR = true;
		}
		this.hlgOOTFNorm.setBBC(params.hlgBBCIn, params.hlgBBCOut);
		this.gammas[this.PQ + 1].setLw();
	}
	if (typeof params.pqLwIn === 'number' && typeof params.pqLwOut === 'number') {
		if (this.pqOOTF.setLw(params.pqLwIn, params.pqLwOut)) {
			this.changedHDR = true;
		}
		this.pqOOTFNorm.setLw(params.pqLwIn, params.pqLwOut);
		this.gammas[this.PQ].setLw();
	}
	if (typeof params.pqEOTFLwIn === 'number' && typeof params.pqEOTFLwOut === 'number') {
		if (this.pqNoOOTF.setLw(params.pqEOTFLwIn, params.pqEOTFLwOut)) {
			this.changedHDR = true;
		}
		this.gammas[this.pqEOTFIdx].setLw();
	}
	if (typeof params.hlgLwIn === 'number' && typeof params.hlgLwOut === 'number') {
		if (this.hlgOOTF.setLw(params.hlgLwIn, params.hlgLwOut)) {
			this.changedHDR = true;
		}
		this.hlgOOTFNorm.setLw(params.hlgLwIn, params.hlgLwOut);
		this.gammas[this.PQ + 1].setLw();
	}
//
	if (typeof params.clipSelect === 'number') {
		switch(params.clipSelect) {
			case 0: this.clipB = false;
					this.clipW = false;
					this.clip = false;
					break;
			case 1: this.clipB = true;
					this.clipW = true;
					this.clip = true;
					break;
			case 2: this.clipB = true;
					this.clipW = false;
					this.clip = true;
					break;
			case 3: this.clipB = false;
					this.clipW = true;
					this.clip = true;
					break;
		}
		out.clipSelect = params.clipSelect;
	}
	if (typeof params.clipLegal === 'boolean') {
		this.clipL = params.clipLegal;
		out.clipLegal = this.clipL;
	}
//	if (typeof params.clip === 'boolean') {
//		this.clip = params.clip;
//		out.clip = this.clip;
//	}
	if (typeof params.bClip === 'number') {
		this.bClip = params.bClip;
		this.wClip = params.wClip;
	}
	if (typeof params.tweaks === 'boolean') {
		this.tweaks = params.tweaks;
	} else {
		this.tweaks = false;
	}
	out.twkASCCDL = this.setASCCDL(params);
	out.twkKnee = this.setKnee(params);
	out.twkBlkHi = this.setBlkHi(params);
	out.twkBlkGam = this.setBlkGam(params);
	out.twkDisplay = this.setDisplay(params);

	if (typeof params.isTrans === 'boolean') {
		this.isTrans = params.isTrans;
	}
	this.ver = params.v;
	out.v = this.ver;
	return out;
};
LUTGamma.prototype.oneDCalc = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, start: i.start, vals: i.vals, dim: i.dim};
	var eiMult = this.eiMult;
	if (typeof i.eiMult === 'number') {
		eiMult = i.eiMult;
	}
	var s = i.start;
	var max = i.vals;
	var o = new Float64Array(max*3);
	var buff = o.buffer;
	var d = i.dim -1;
	var k;
	if (this.nul) {
		for (var j=0; j<max; j++) {
			k = (s+j)/d; // between 0-1.0
			if (this.sIn) {
				k = (k*(this.sMax-this.sMin)) + this.sMin;
			}
			if (this.inL) {
				o[(j*3)] = k;
			} else {
				o[(j*3)] = ((1023*k)-64)/876;
			}
			o[(j*3)+1] = o[(j*3)];
			o[(j*3)+2] = o[(j*3)];
		}
	} else {
		var l;
		for (var j=0; j<max; j++) {
			k = (s+j)/d; // between 0-1.0
			if (this.sIn) {
				k = (k*(this.sMax-this.sMin)) + this.sMin;
			}
			if (this.inL) {
				o[(j*3)] = this.gammas[this.curIn].linFromLegal(k)*eiMult;
			} else {
				o[(j*3)] = this.gammas[this.curIn].linFromData(k)*eiMult;
			}
			o[(j*3)+1] = o[(j*3)];
			o[(j*3)+2] = o[(j*3)];
		}
		if (this.doASCCDL) {
			this.ASCCDLOut(buff);
		}
		if (this.doKnee) {
			this.kneeOut(buff);
		} else {
			this.gammas[this.curOut].linToL(buff);
		}
		if (this.doBlkHi) {
			this.blkHiOut(buff);
		}
		if (this.doBlkGam) {
			this.blkGamOut(buff);
		}
		if (this.doDisplay) {
			this.displayOut(buff);
		}
	}
	this.finalOut(buff,false);
	out.o = o.buffer;
	out.to = ['o'];
	return out;
};
LUTGamma.prototype.laCalcRGB = function(p,t,i) {
	var dim = i.dim;
	var d = dim -1;
	var m = dim*dim*dim*3;
	var c = new Float64Array(m);
	var buff = c.buffer;
	var j=0;
	for (var B=0; B<dim; B++) {
		for (var G=0; G<dim; G++) {
			for (var R=0; R<dim; R++) {
				c[ j ] = R/d;
				c[j+1] = G/d;
				c[j+2] = B/d;
				j += 3;
			}
		}
	}
	var natTF;
	switch (this.gammas[i.gamma].name) {
		case 'S-Log3':
			natTF = 0;
			break;
		case 'S-Log2':
			natTF = 1;
			break;
		case 'S-Log':
			natTF = 2;
			break;
		case 'C-Log':
			natTF = 3;
			break;
		case 'Canon C-Log2':
			natTF = 4;
			break;
		case 'Panasonic V-Log':
			natTF = 5;
			break;
		case 'REDLogFilm':
			natTF = 6;
			break;
		case 'Cineon':
			natTF = 7;
			break;
		case 'LogC (Sup 3.x & 4.x)':
			natTF = 8;
			break;
		case 'LogC (Sup 2.x)':
			natTF = 9;
			break;
		default:
			if (i.legIn) {
				this.gammas[this.SL3Idx].linFromL(buff, { rgb: true });
				this.gammas[i.gamma].linToL(buff, { rgb: true, rec: true });
			} else {
				this.gammas[this.SL3Idx].linFromD(buff, { rgb: true });
				this.gammas[i.gamma].linToD(buff, { rgb: true, rec: true });
			}
			natTF = 0;
			break;		
	}
	var out = { p: p, t: t+20, v: this.ver };
	out.dim = i.dim;
	out.legIn = i.legIn;
	out.gamma = i.gamma;
	out.gamut = i.gamut;
	out.natTF = natTF;
	out.o = buff;
	out.to = ['o'];
	return out;
};
LUTGamma.prototype.inCalcRGB = function(p,t,i) {
	var eiMult = this.eiMult;
	if (typeof i.eiMult === 'number') {
		eiMult = i.eiMult;
	}
	var out = { p: p, t: t+20, v: this.ver, R:i.R, G:i.G, B:i.B, vals: i.vals, dim: i.dim, eiMult: eiMult};
	var B = i.B;
	var max = i.dim;
	var o = new Float64Array(i.vals*3);
	var d = i.dim -1;
	if (this.nul) {
		if (this.inL) {
			if (this.outL) {
				for (var G=0; G<max; G++) {
					for (var R=0; R<max; R++) {
						var j = (R+(G*max))*3;
						if (this.sIn) {
							o[(j*3)] = ((R/d)*(this.sMax-this.sMin)) + this.sMin;
							o[(j*3)+1] = ((G/d)*(this.sMax-this.sMin)) + this.sMin;
							o[(j*3)+2] = ((B/d)*(this.sMax-this.sMin)) + this.sMin;
						} else {
							o[(j*3)] = R/d;
							o[(j*3)+1] = G/d;
							o[(j*3)+2] = B/d;
						}
					}
				}
			} else {
				for (var G=0; G<max; G++) {
					for (var R=0; R<max; R++) {
						var j = (R+(G*max))*3;
						if (this.sIn) {
							o[ j ] = ((876*(((R/d)*(this.sMax-this.sMin)) + this.sMin))+64)/1023;
							o[j+1] = ((876*(((G/d)*(this.sMax-this.sMin)) + this.sMin))+64)/1023;
							o[j+2] = ((876*(((B/d)*(this.sMax-this.sMin)) + this.sMin))+64)/1023;
						} else {
							o[ j ] = ((876*(R/d))+64)/1023;
							o[j+1] = ((876*(G/d))+64)/1023;
							o[j+2] = ((876*(B/d))+64)/1023;
						}
					}
				}
			}
		} else {
			if (this.outL) {
				for (var G=0; G<max; G++) {
					for (var R=0; R<max; R++) {
						var j = (R+(G*max))*3;
						if (this.sIn) {
							o[ j ] = ((1023*(((R/d)*(this.sMax-this.sMin)) + this.sMin))-64)/876;
							o[j+1] = ((1023*(((G/d)*(this.sMax-this.sMin)) + this.sMin))-64)/876;
							o[j+2] = ((1023*(((B/d)*(this.sMax-this.sMin)) + this.sMin))-64)/876;
						} else {
							o[ j ] = ((1023*R/d)-64)/876;
							o[j+1] = ((1023*G/d)-64)/876;
							o[j+2] = ((1023*B/d)-64)/876;
						}
					}
				}
			} else {
				for (var G=0; G<max; G++) {
					for (var R=0; R<max; R++) {
						var j = (R+(G*max))*3;
						if (this.sIn) {
							o[ j ] = ((R/d)*(this.sMax-this.sMin)) + this.sMin;
							o[j+1] = ((G/d)*(this.sMax-this.sMin)) + this.sMin;
							o[j+2] = ((B/d)*(this.sMax-this.sMin)) + this.sMin;
						} else {
							o[ j ] = R/d;
							o[j+1] = G/d;
							o[j+2] = B/d;
						}
					}
				}
			}
		}
	} else {
		if (this.inL) {
			for (var G=0; G<max; G++) {
				for (var R=0; R<max; R++) {
					var j = (R+(G*max))*3;
					if (this.sIn) {
						o[ j ] = ((R/d)*(this.sMax-this.sMin)) + this.sMin;
						o[j+1] = ((G/d)*(this.sMax-this.sMin)) + this.sMin;
						o[j+2] = ((B/d)*(this.sMax-this.sMin)) + this.sMin;
					} else {
						o[ j ] = R/d;
						o[j+1] = G/d;
						o[j+2] = B/d;
					}
				}
			}
			this.gammas[this.curIn].linFromL(o.buffer, { rgb: true });
		} else {
			for (var G=0; G<max; G++) {
				for (var R=0; R<max; R++) {
					var j = (R+(G*max))*3;
					if (this.sIn) {
						o[ j ] = ((R/d)*(this.sMax-this.sMin)) + this.sMin;
						o[j+1] = ((G/d)*(this.sMax-this.sMin)) + this.sMin;
						o[j+2] = ((B/d)*(this.sMax-this.sMin)) + this.sMin;
					} else {
						o[ j ] = R/d;
						o[j+1] = G/d;
						o[j+2] = B/d;
					}
				}
			}
			this.gammas[this.curIn].linFromD(o.buffer, { rgb: true });
		}
	}
	out.o = o.buffer;
	out.to = ['o'];
	return out;
};
LUTGamma.prototype.outCalcRGB = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, R:i.R, G:i.G, B:i.B, vals: i.vals, dim: i.dim };
	var o = new Float64Array(i.o);
	var m = o.length;
	if (!this.nul) {
		if (this.doKnee) {
			this.kneeOut(i.o);
		} else {
			this.gammas[this.curOut].linToL(i.o, { rgb: true });
		}
		if (this.doBlkHi) {
			this.blkHiOut(i.o);
		}
		if (this.doBlkGam) {
			this.blkGamOut(i.o);
		}
		if (this.doDisplay) {
			this.displayOut(i.o, { rgb: true });
		}
		if (i.doGamutLim) {
			this.gamutLimOut(i.o, i.gLimY, i.gLimL, i.og, i.gLimB);
		}
		if (i.doFC) {
			this.fcOut(i.fc,i.o);
		}
	}
	if (typeof i.cb === 'boolean') {
		this.finalOut(i.o,i.cb);
	} else {
		this.finalOut(i.o,false);
	}
	out.o = o.buffer;
	out.to = ['o'];
	return out;
};
LUTGamma.prototype.getLists = function(p,t) {
	return {
		p: p,
		t: t+20,
		v: this.ver,
		inList: this.inList,
		outList: this.outList,
		linList: this.linList,
		disList: this.disList,
		catList: this.catList,
		baseGamuts: this.gts,
		baseDisGamuts: this.disGts,
		subNames: this.subNames,
		subList: this.gammaSub,
		gammaDat: this.gammaDat,
		gammaExt: this.gammaExt,
		rec709: this.rec709,
		PQ: this.PQ,
		HLG: this.HLG,
		PQOOTF: this.pqOOTFIdx,
		PQEOTF: this.pqEOTFIdx,
		HLGOOTF: this.hlgOOTFIdx,
		ARRIList: this.arriIdxList,
		DLogM: this.DLogM,
		LA: this.LA
	};
};
LUTGamma.prototype.setLA = function(p,t,i) {
	this.gammas[this.LA].setLUT(i);
	return { p: p, t:t+20, v: this.ver, i: i.title };
};
LUTGamma.prototype.setLATitle = function(p,t,i) {
	this.gammas[this.LA].setTitle(i);
	return { p: p, t:t+20, v: this.ver, i: i };
};
LUTGamma.prototype.SL3Val = function(p,t,i) {
	var m = i.dim;
	var d = m-1;
	var c = new Float64Array(m);
	var buff = c.buffer;
	for (var j=0; j<m; j++) {
		c[j] = j/d;
	}
	this.gammas[this.SL3Idx].linFromD(buff);
	if (i.legIn) {
		this.gammas[i.gamma].linToL(buff, { rgb: false, rec: true });
	} else {
		this.gammas[i.gamma].linToD(buff, { rgb: false, rec: true });
	}
	var out = { p: p, t: t+20, v: this.ver, o: buff};
	out.dim = i.dim;
	out.legIn = i.legIn;
	out.gamma = i.gamma;
	out.to = ['o'];
	return out;
};
LUTGamma.prototype.ioNames = function(p,t) {
	var out = {};
	out.inName = this.gammas[this.curIn].name;
	out.outName = this.gammas[this.curOut].name;
	if (this.gammas[this.curIn].cat === 1) {
		out.inG = this.gammas[this.curIn].gamma;
	}
	if (this.gammas[this.curOut].cat === 1) {
		out.outG = this.gammas[this.curOut].gamma;
	}
	return {p: p, t: t+20, v: this.ver, o: out};
};
LUTGamma.prototype.chartVals = function(p,t,i) {
	var out = {p: p, t: t+20, v: this.ver};
	var m = 129;
	var d = m-1;
	var k,r,bg;
	var refX = new Float64Array(m);
	var refIn = new Float64Array(m);
	var stopX = new Float64Array(m);
	var stopIn = new Float64Array(m);
	var lutIn = new Float64Array(m);
	var lutOut = new Float64Array(m);
	var colIn = new Float64Array(m);
	var cMin,cMax;
	cMin = (this.bClip - 64)/876;
	cMax = (this.wClip - 64)/876;
	if (this.clip) {
		if (this.outL || this.clipL) {
			if (this.clipB && cMin<0) {
				cMin = 0;
			}
			if (this.clipW && cMax>1) {
				cMax = 1;
			}
		}
	}
	if (this.hdrOut && !this.doDisplay) {
		var mx = this.gammas[this.curOut].mxO;
		if (mx < cMax) {
			cMax = mx;
		}
	}
	for (var j=0; j<m; j++) {
		k = j/d;
		refX[j] = 14*k;
		refIn[j] = refX[j]/0.9;
		stopX[j] = (18*k)-9;
		stopIn[j] = Math.pow(2,stopX[j]) / 5;
		lutIn[j] = k;
		lutOut[j] = ((k*1023) - 64)/876;
		colIn[j] = k;
	}
	var stopPreVals = new Float64Array(17);
	var stopVals = new Float64Array(17);
	for (var j=0; j<17; j++) {
		stopPreVals[j] = Math.pow(2,j-8) / 5;
		stopVals[j] = Math.pow(2,j-8) / 5;
	}
	var refOut = new Float64Array(refIn);
	out.curIn = this.curIn;
	out.curOut = this.curOut;
	this.gammas[this.curIn].linToL(refIn.buffer, { rec: true });
	var stopOut = new Float64Array(stopIn);
	this.gammas[this.curIn].linToL(stopIn.buffer, { rec: true });
	this.gammas[this.curIn].linFromL(colIn.buffer, { rec: true });
	if (this.nul) {
		refOut = new Float64Array(refIn);
		stopOut = new Float64Array(stopIn);
		this.gammas[this.curIn].linToL(stopPreVals.buffer, { rec: true });
		this.gammas[this.curIn].linToL(stopVals.buffer, { rec: true });
	} else {
		this.gammas[this.curIn].linFromL(lutOut.buffer);
		for (var j=0; j<m; j++) {
			refOut[j] *= this.eiMult;
			stopOut[j] *= this.eiMult;
			lutOut[j] *= this.eiMult;
		}
		for (var j=0; j<17; j++) {
			stopPreVals[j] /= this.eiMult;
		}
		this.getLumVals(refOut.buffer);
		this.getLumVals(stopOut.buffer);
		this.getLumVals(lutOut.buffer);
		this.gammas[this.curIn].linToL(stopPreVals.buffer, { rec: true });
		this.getLumVals(stopVals.buffer);
		if (this.doBlkHi) {
			for (var j=0; j<m; j++) {
				refOut[j] = (refOut[j] * this.al) + this.bl;
				stopOut[j] = (stopOut[j] * this.al) + this.bl;
				lutOut[j] = (lutOut[j] * this.al) + this.bl;
			}
			for (var j=0; j<17; j++) {
				stopVals[j] = (stopVals[j] * this.al) + this.bl;
			}
		}
		if (this.doBlkGam) {
			for (var j=0; j<m; j++) {
				if (refOut[j] > this.blkLevel && refOut[j] <= this.blkGamUL) {
					if (refOut[j] > this.blkGamLL) {
						bg = (Math.pow((refOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
						if (refOut[j] <= bg) {
							refOut[j] = bg;
						} else {
							r = (refOut[j]-this.blkGamLL)/this.blkGamF;
							r *= r;
							refOut[j] = (r*refOut[j]) + ((1-r)*bg);
						}
					} else {
						refOut[j] = (Math.pow((refOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					}
				}
				if (stopOut[j] > this.blkLevel && stopOut[j] <= this.blkGamUL) {
					if (stopOut[j] > this.blkGamLL) {
						bg = (Math.pow((stopOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
						if (stopOut[j] <= bg) {
							stopOut[j] = bg;
						} else {
							r = (stopOut[j]-this.blkGamLL)/this.blkGamF;
							r *= r;
							stopOut[j] = (r*stopOut[j]) + ((1-r)*bg);
						}
					} else {
						stopOut[j] = (Math.pow((stopOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					}
				}
				if (lutOut[j] > this.blkLevel && lutOut[j] <= this.blkGamUL) {
					if (lutOut[j] > this.blkGamLL) {
						bg = (Math.pow((lutOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
						if (lutOut[j] <= bg) {
							lutOut[j] = bg;
						} else {
							r = (lutOut[j]-this.blkGamLL)/this.blkGamF;
							r *= r;
							lutOut[j] = (r*lutOut[j]) + ((1-r)*bg);
						}
					} else {
						lutOut[j] = (Math.pow((lutOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					}
				}
			}
			for (var j=0; j<17; j++) {
				if (stopVals[j] > this.blkLevel && stopVals[j] <= this.blkGamUL) {
					if (stopVals[j] > this.blkGamLL) {
						bg = (Math.pow((stopVals[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
						if (stopVals[j] <= bg) {
							stopVals[j] = bg;
						} else {
							r = (stopVals[j]-this.blkGamLL)/this.blkGamF;
							r *= r;
							stopVals[j] = (r*stopVals[j]) + ((1-r)*bg);
						}
					} else {
						stopVals[j] = (Math.pow((stopVals[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					}
				}
			}
		}
		if (this.doDisplay) {
			this.displayOut(refOut.buffer);
			this.displayOut(stopOut.buffer);
			this.displayOut(lutOut.buffer);
			this.displayOut(stopVals.buffer);
		}
// Final clipping
		for (var j=0; j<m; j++) {
			refOut[ j ] = Math.min(cMax,Math.max(cMin,refOut[ j ]));
			stopOut[ j ] = Math.min(cMax,Math.max(cMin,stopOut[ j ]));
			lutOut[ j ] = Math.min(cMax,Math.max(cMin,lutOut[ j ]));
		}
		for (var j=0; j<17; j++) {
			stopVals[ j ] = Math.min(cMax,Math.max(cMin,stopVals[ j ]));
		}
//
	}
	var table = new Float64Array([0,0.18,0.38,0.44,0.9,7.2,this.camClip]);
	for (var j=0; j<7; j++) {
		table[j] /= 0.9;
	}
	if (this.nul) {
		this.gammas[this.curIn].linToL(table.buffer, { rec: true });
	} else {
		this.getLumVals(table.buffer);
		if (this.doBlkHi) {
			for (var j=0; j<7; j++) {
				table[j] = (table[j] * this.al) + this.bl;
			}
		}
		if (this.doBlkGam) {
			for (var j=0; j<7; j++) {
				if (table[j] > this.blkLevel && table[j] <= this.blkGamUL) {
					if (table[j] > this.blkGamLL) {
						bg = (Math.pow((table[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
						if (table[j] <= bg) {
							table[j] = bg;
						} else {
							r = (table[j]-this.blkGamLL)/this.blkGamF;
							r *= r;
							table[j] = (r*table[j]) + ((1-r)*bg);
						}
					} else {
						table[j] = (Math.pow((table[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					}
				}
			}
		}
		if (this.doDisplay) {
			this.displayOut(table.buffer);
		}
	}
	out.m = m;
	out.refX = refX.buffer;
	out.refIn = refIn.buffer;
	out.refOut = refOut.buffer;
	out.stopX = stopX.buffer;
	out.stopIn = stopIn.buffer;
	out.stopOut = stopOut.buffer;
	out.stopPreVals = stopPreVals.buffer;
	out.stopVals = stopVals.buffer;
	out.lutIn = lutIn.buffer;
	out.lutOut = lutOut.buffer;
	out.colIn = colIn.buffer;
	out.colOut = colIn.buffer.slice(0);
	out.table = table.buffer;
	out.eiMult = this.eiMult;
	out.to = ['refX','refIn','refOut','stopX','stopIn','stopOut','stopPreVals','stopVals','lutIn','lutOut','colIn','table'];
	return out;
};
LUTGamma.prototype.preview = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, leg:i.leg, line:i.line, upd: i.upd };
	var eiMult = 1;
	if (typeof i.eiMult === 'number') {
		eiMult = i.eiMult;
	}
	var f = new Float64Array(i.o);
	var m = f.length;
	var o = new Uint8Array(Math.round(m*4/3));
	var l;
	// Establish Clipping Levels
	var mn,mx,mx2;
	if (typeof i.cb === 'boolean' && i.cb) {
		mn = 0;
	} else {
		mn = (this.bClip - 64)/876;
	}
	mn = Math.max(mn,-0.073);
	mx = (this.wClip - 64)/876;
	mx = Math.min(mx,1.095);
	if (this.clip) {
		if (this.outL || this.clipL) {
			if (this.clipB && mn<0) {
				mn = 0;
			}
			if (this.clipW && mx>1) {
				mx = 1;
			}
		}
	}
	if (this.hdrOut && !this.doDisplay) {
		mx = Math.min(mx, this.gammas[this.curOut].mxO);
	}
	if (i.leg) {
		mx2 = 255;
	} else {
		mx2 = mx*255/1.095;
	}
	// Calculate Output
	if (this.nul) {
		l = 0;
		var mul = 239;
		if (i.leg) {
			mul = 255;
		}
		this.gammas[this.SL3Idx].linToL(i.o);
		for (var j=0; j<m; j += 3) {
			f[ j ] = Math.min(mx,Math.max(mn,f[ j ]));
			f[j+1] = Math.min(mx,Math.max(mn,f[j+1]));
			f[j+2] = Math.min(mx,Math.max(mn,f[j+2]));
			o[ l ] = Math.min(255,Math.max(0,Math.round(f[ j ]*mul)));
			o[l+1] = Math.min(255,Math.max(0,Math.round(f[j+1]*mul)));
			o[l+2] = Math.min(255,Math.max(0,Math.round(f[j+2]*mul)));
			o[l+3] = 255;
			l += 4;
		}
	} else {
		var m = f.length;
		// Exposure Correction
		for (var j=0; j<m; j += 3) {
			f[ j ] *= eiMult;
			f[j+1] *= eiMult;
			f[j+2] *= eiMult;
		}
		// ASC-CDL
		if (this.doASCCDL && !i.threeD) {
			for (var j=0; j<m; j += 3) {
				// Red
				f[ j ] = (f[ j ]*this.asc[0])+this.asc[3];
				f[ j ] = ((f[ j ]<0)?f[ j ]:Math.pow(f[ j ],this.asc[6]));
				f[ j ] = (isNaN(f[ j ])?0:f[ j ]);
				// Green
				f[j+1] = (f[j+1]*this.asc[1])+this.asc[4];
				f[j+1] = ((f[j+1]<0)?f[j+1]:Math.pow(f[j+1],this.asc[7]));
				f[j+1] = (isNaN(f[j+1])?0:f[j+1]);
				// Blue
				f[j+2] = (f[j+2]*this.asc[2])+this.asc[5];
				f[j+2] = ((f[j+2]<0)?f[j+2]:Math.pow(f[j+2],this.asc[8]));
				f[j+2] = (isNaN(f[j+2])?0:f[j+2]);
			}
			if (doOG) {
				for (var j=0; j<m; j += 3) {
					// Red
					og[ j ] = (og[ j ]*this.asc[0])+this.asc[3];
					og[ j ] = ((og[ j ]<0)?og[ j ]:Math.pow(og[ j ],this.asc[6]));
					og[ j ] = (isNaN(og[ j ])?0:og[ j ]);
					// Green
					og[j+1] = (og[j+1]*this.asc[1])+this.asc[4];
					og[j+1] = ((og[j+1]<0)?og[j+1]:Math.pow(og[j+1],this.asc[7]));
					og[j+1] = (isNaN(og[j+1])?0:og[j+1]);
					// Blue
					og[j+2] = (og[j+2]*this.asc[2])+this.asc[5];
					og[j+2] = ((og[j+2]<0)?og[j+2]:Math.pow(og[j+2],this.asc[8]));
					og[j+2] = (isNaN(og[j+2])?0:og[j+2]);
				}
			}
		}
		// Knee
		if (this.doKnee) {
			this.kneeOut(i.o, { rgb: true });
		} else {
			this.gammas[this.curOut].linToL(i.o, { rgb: true });
		}
		// Black Level / Highlight Level
		if (this.doBlkHi) {
			this.blkHiOut(i.o);
		}
		// Black Gamma
		if (this.doBlkGam) {
			this.blkGamOut(i.o);
		}
		// Display Colourspace Conversion
		if (this.doDisplay) {
			this.displayOut(i.o, { rgb: true });
		}
		// Gamut Limiter
		if (i.doGamutLim) {
			if (typeof i.og !== 'undefined') {
				var og = new Float64Array(i.og);
				for (var j=0; j<m; j++) {
					og[ j ] *= eiMult;
				}
			}
			this.gamutLimOut(i.o, i.gLimY, i.gLimL, i.og, i.gLimB);
		}
		// Hard Clipping
		for (var j=0; j<m; j++) {
			f[ j ] = Math.min(mx,Math.max(mn,(f[ j ])));
		}
		// False Colour
		if (i.doFC) {
			this.fcOut(i.fc, i.o);
		}
		// Legal / Extended
		l = 0;
		if (i.leg) {
			for (var j=0; j<m; j += 3) {
				o[ l ] = Math.min(mx2,Math.max(0,Math.round(f[ j ]*255)));
				o[l+1] = Math.min(mx2,Math.max(0,Math.round(f[j+1]*255)));
				o[l+2] = Math.min(mx2,Math.max(0,Math.round(f[j+2]*255)));
				o[l+3] = 255;
				l += 4;
			}
		} else {
			for (var j=0; j<m; j += 3) {
				o[ l ] = Math.min(mx2,Math.max(0,Math.round(f[ j ]*239)));
				o[l+1] = Math.min(mx2,Math.max(0,Math.round(f[j+1]*239)));
				o[l+2] = Math.min(mx2,Math.max(0,Math.round(f[j+2]*239)));
				o[l+3] = 255;
				l += 4;
			}
		}
	}
	out.o = o.buffer;
	out.f = f.buffer;
	out.to = ['o','f'];
	return out;
};
LUTGamma.prototype.previewLin = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, gamma: i.gamma, gamut: i.gamut, legal: i.legal, i: i.i };
	var o = i.i.slice(0);
	if (i.legal) {
		this.gammas[i.gamma].linFromL(o, { rgb: true });
	} else {
		this.gammas[i.gamma].linFromD(o, { rgb: true });
	}
	out.o = o;
	out.to = ['i','o'];
	return out;
/*
	var input = new Float64Array(i.i);
	var max = input.length;
	var o = new Float64Array(max);
	if (i.legal) {
		for (var j=0; j<max; j++) {
			o[j] = this.gammas[i.gamma].linFromLegal(input[j]);
		}
	} else {
		for (var j=0; j<max; j++) {
			o[j] = this.gammas[i.gamma].linFromData(input[j]);
		}
	}
	out.o = o.buffer;
	out.to = ['i','o'];
	return out;
*/
};
LUTGamma.prototype.getPrimaries = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver };
	var o = i.o.slice(0);
	this.gammas[this.curOut].linToL(o, { rgb: true });
	if (typeof i.cb === 'boolean' && i.cb) {
		var c = new Float64Array(o);
		var m = c.length;
		for (var j=0; j<m; j++) {
			c[j] = Math.max(0,c[j]);
		}
	}
	out.o = o;
/*
	var c = new Float64Array(i.o);
	var o = new Float64Array(18);
	if (typeof i.cb === 'boolean' && i.cb) {
		for (var j=0; j<18; j++) {
			o[j] = Math.max(0,this.gammas[this.curOut].linToLegal(c[j]));
		}
	} else {
		for (var j=0; j<18; j++) {
			o[j] = this.gammas[this.curOut].linToLegal(c[j]);
		}
	}
	out.o = o.buffer;
*/
	return out;
};
LUTGamma.prototype.psstColours = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver };
	var b = new Float64Array(i.b);
	var a = new Float64Array(i.a);
	var m = a.length;
	var before = new Uint8Array(m);
	var after = new Uint8Array(m);
	this.gammas[this.curOut].linToL(i.b, { rgb: true });
	this.gammas[this.curOut].linToL(i.a, { rgb: true });
	if (this.doDisplay) {
		this.displayOut(i.b, { rgb: true });
		this.displayOut(i.a, { rgb: true });
	}
// doBlkGam
	if (this.doBlkHi) {
		for (var j=0; j<m; j++) {
			before[j] = Math.min(255,Math.max(0,Math.round(((b[ j ] * this.al) + this.bl)*255)));
			after[j] = Math.min(255,Math.max(0,Math.round(((a[ j ] * this.al) + this.bl)*255)));
		}
	} else {
		for (var j=0; j<m; j++) {
			before[j] = Math.min(255,Math.max(0,Math.round(b[ j ]*255)));
			after[j] = Math.min(255,Math.max(0,Math.round(a[ j ]*255)));
		}
	}
	out.b = before.buffer;
	out.a = after.buffer;
	out.to = ['b','a'];
	return out;
};
LUTGamma.prototype.multiColours = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver };
	var input = new Float64Array(i.o);
	var m = input.length;
	var o = new Uint8Array(m);
	if (!this.nul) {
		if (this.doKnee) {
			this.kneeOut(i.o, { rgb: true });
		} else {
			this.gammas[this.curOut].linToL(i.o, { rgb: true });
		}
		if (this.doBlkHi) {
			this.blkHiOut(i.o);
		}
		if (this.doBlkGam) {
			this.blkGamOut(i.o);
		}
		if (this.doDisplay) {
			this.displayOut(i.o, { rgb: true });
		}
		if (i.doGamutLim) {
			this.gamutLimOut(i.o, i.gLimY, i.gLimL, i.og, i.gLimB);
		}
	}
	for (var j=0; j<m; j++) {
		o[j] = Math.max(0,(Math.min(255,input[j]*255/1.09475)));
	}
	out.o = o.buffer;
	out.hs = i.hs;
	out.to = ['o','hs'];
	return out;	
};
LUTGamma.prototype.chartRGB = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, colIn: i.colIn, rIn: i.rIn, gIn: i.gIn, bIn: i.bIn, rOut: i.rOut, gOut: i.gOut, bOut: i.bOut, to: ['rIn','gIn','bIn','rOut','gOut','bOut']};
	this.gammas[this.curIn].linToD(i.rIn, { rec: true });
	this.gammas[this.curIn].linToD(i.gIn, { rec: true });
	this.gammas[this.curIn].linToD(i.bIn, { rec: true });
	this.gammas[this.curOut].linToL(i.rOut);
	this.gammas[this.curOut].linToL(i.gOut);
	this.gammas[this.curOut].linToL(i.bOut);
	var ra = new Float64Array(i.rOut);
	var ga = new Float64Array(i.gOut);
	var ba = new Float64Array(i.bOut);
	var r,bg;
	if (this.doBlkHi) {
		for (var j=0; j<m; j++) {
			ra[j] = (ra[j] * this.al) + this.bl;
			ga[j] = (ga[j] * this.al) + this.bl;
			ba[j] = (ba[j] * this.al) + this.bl;
		}
	}
	if (this.doBlkGam) {
		for (var j=0; j<m; j++) {
			if (ra[j] > this.blkLevel && ra[j] <= this.blkGamUL) {
				if (ra[j] > this.blkGamLL) {
					bg = (Math.pow((ra[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					if (ra[j] <= bg) {
						ra[j] = bg;
					} else {
						r = (ra[j]-this.blkGamLL)/this.blkGamF;
						r *= r;
						ra[j] = (r*ra[j]) + ((1-r)*bg);
					}
				} else {
					ra[j] = (Math.pow((ra[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
				}
			}
			if (ga[j] > this.blkLevel && ga[j] <= this.blkGamUL) {
				if (ga[j] > this.blkGamLL) {
					bg = (Math.pow((ga[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					if (ga[j] <= bg) {
						ga[j] = bg;
					} else {
						r = (ga[j]-this.blkGamLL)/this.blkGamF;
						r *= r;
						ga[j] = (r*ga[j]) + ((1-r)*bg);
					}
				} else {
					ga[j] = (Math.pow((ga[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
				}
			}
			if (ba[j] > this.blkLevel && ba[j] <= this.blkGamUL) {
				if (ba[j] > this.blkGamLL) {
					bg = (Math.pow((ba[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					if (ba[j] <= bg) {
						ba[j] = bg;
					} else {
						r = (ba[j]-this.blkGamLL)/this.blkGamF;
						r *= r;
						ba[j] = (r*ba[j]) + ((1-r)*bg);
					}
				} else {
					ba[j] = (Math.pow((ba[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
				}
			}
		}
	}
	if (typeof i.cb === 'boolean' && i.cb) {
		for (var j=0; j<m; j++) {
			ra[j] = Math.max(0,ra[j]);
			ga[j] = Math.max(0,ga[j]);
			ba[j] = Math.max(0,ba[j]);
		}
	}
	return out;
};
LUTGamma.prototype.changePQ = function(p,t,i) {
	var out = {p: p, t: t+20, v: this.ver};
//	this.gammas[this.PQ].changeLMax(i);
	out.ok = true;
	return out;
};
LUTGamma.prototype.setHDRDisplayIntent = function(p,t,i) {
	var out = {p: p, t: t+20, v: this.ver};
	if (typeof i.Lw === 'number') {
		if (typeof i.Lw === 'number') {
			this.pqOOTF.setLw(i.Lw,i.Lb);
			this.pqOOTFNorm.setLw(i.Lw,i.Lb);
		} else {
			this.pqOOTF.setLw(i.Lw,0);
			this.pqOOTFNorm.setLw(i.Lw,0);
		}
	}
	out.ok = true;
	return out;
};
// Web worker messaging functions
function LUTGammaWorker() {
	this.gammas = new LUTGamma();
	addEventListener('message', function(e) {
		var d = e.data;
		if (typeof d.t === 'undefined') {
		} else if (d.t !== 0 && d.t < 20 && d.v !== lutGammaWorker.gammas.ver) {
			postMessage({p: d.p, t: d.t, v: d.v, resend: true, d: d.d});
		} else {
			switch (d.t) {
				case 0:	lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.setParams(d.d));
						break;
				case 1: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.oneDCalc(d.p,d.t,d.d)); // Calculate 1D (gamma only) conversion from input to output
						break;
				case 2: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.laCalcRGB(d.p,d.t,d.d));
						break;
				case 3: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.inCalcRGB(d.p,d.t,d.d)); 
						break;
				case 4: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.outCalcRGB(d.p,d.t,d.d)); 
						break;
				case 5: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.getLists(d.p,d.t)); 
						break;
				case 6: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.setLA(d.p,d.t,d.d)); 
						break;
				case 7: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.setLATitle(d.p,d.t,d.d)); 
						break;
				case 8: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.SL3Val(d.p,d.t,d.d)); 
						break;
//				case 9: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.laCalcInput(d.p,d.t,d.d)); 
//						break;
				case 10:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.ioNames(d.p,d.t));
						break;
				case 11:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.chartVals(d.p,d.t));
						break;
				case 12:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.preview(d.p,d.t,d.d));
						break;
				case 14:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.previewLin(d.p,d.t,d.d));
						break;
				case 15:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.getPrimaries(d.p,d.t,d.d));
						break;
				case 16:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.psstColours(d.p,d.t,d.d));
						break;
				case 17:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.multiColours(d.p,d.t,d.d));
						break;
				case 18:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.chartRGB(d.p,d.t,d.d));
						break;
				case 19:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.changePQ(d.p,d.t,d.d));
						break;
			}
		}
	}, false);
}
LUTGammaWorker.prototype.sendGammaMessage = function(d) {
	if (this.gammas.isTrans && typeof d.to !== 'undefined') {
		var max = d.to.length;
		var objArray = [];
		for (var j=0; j < max; j++) {
			objArray.push(d[d.to[j]]);
		}
		postMessage(d,objArray);
	} else {
		postMessage(d);
	}
};
// Stringify for inline Web Worker
function getGammaWorkerString() {
	var out = "";
	// Main Object Function
	out += LUTGamma.toString() + "\n";
	for (var j in LUTGamma.prototype) {
		out += 'LUTGamma.prototype.' + j + '=' + LUTGamma.prototype[j].toString() + "\n";
	}
	// LUTGammaLog
	out += LUTGammaLog.toString() + "\n";
	for (var j in LUTGammaLog.prototype) {
		out += 'LUTGammaLog.prototype.' + j + '=' + LUTGammaLog.prototype[j].toString() + "\n";
	}
	// LUTGammaLogClip
	out += LUTGammaLogClip.toString() + "\n";
	for (var j in LUTGammaLogClip.prototype) {
		out += 'LUTGammaLogClip.prototype.' + j + '=' + LUTGammaLogClip.prototype[j].toString() + "\n";
	}
	// LUTGammaCineon
	out += LUTGammaCineon.toString() + "\n";
	for (var j in LUTGammaCineon.prototype) {
		out += 'LUTGammaCineon.prototype.' + j + '=' + LUTGammaCineon.prototype[j].toString() + "\n";
	}
	// LUTGammaArri
	out += LUTGammaArri.toString() + "\n";
	for (var j in LUTGammaArri.prototype) {
		out += 'LUTGammaArri.prototype.' + j + '=' + LUTGammaArri.prototype[j].toString() + "\n";
	}
	// LUTGammaLogC4
	out += LUTGammaLogC4.toString() + "\n";
	for (var j in LUTGammaLogC4.prototype) {
		out += 'LUTGammaLogC4.prototype.' + j + '=' + LUTGammaLogC4.prototype[j].toString() + "\n";
	}
	// LUTGammaCLog3
	out += LUTGammaCLog3.toString() + "\n";
	for (var j in LUTGammaCLog3.prototype) {
		out += 'LUTGammaCLog3.prototype.' + j + '=' + LUTGammaCLog3.prototype[j].toString() + "\n";
	}
	// LUTGammaNLog
	out += LUTGammaNLog.toString() + "\n";
	for (var j in LUTGammaNLog.prototype) {
		out += 'LUTGammaNLog.prototype.' + j + '=' + LUTGammaNLog.prototype[j].toString() + "\n";
	}
	// LUTGammaLogLog
	out += LUTGammaLogLog.toString() + "\n";
	for (var j in LUTGammaLogLog.prototype) {
		out += 'LUTGammaLogLog.prototype.' + j + '=' + LUTGammaLogLog.prototype[j].toString() + "\n";
	}
	// LUTGammaDaVinci
	out += LUTGammaDaVinci.toString() + "\n";
	for (var j in LUTGammaDaVinci.prototype) {
		out += 'LUTGammaDaVinci.prototype.' + j + '=' + LUTGammaDaVinci.prototype[j].toString() + "\n";
	}
	// LUTGammaAppleLog
	out += LUTGammaAppleLog.toString() + "\n";
	for (var j in LUTGammaAppleLog.prototype) {
		out += 'LUTGammaAppleLog.prototype.' + j + '=' + LUTGammaAppleLog.prototype[j].toString() + "\n";
	}


	// LUTGammaLog2
	out += LUTGammaLog2.toString() + "\n";
	for (var j in LUTGammaLog2.prototype) {
		out += 'LUTGammaLog2.prototype.' + j + '=' + LUTGammaLog2.prototype[j].toString() + "\n";
	}



	// LUTGammaGam
	out += LUTGammaGam.toString() + "\n";
	for (var j in LUTGammaGam.prototype) {
		out += 'LUTGammaGam.prototype.' + j + '=' + LUTGammaGam.prototype[j].toString() + "\n";
	}
	// LUTGammaBBCGam
	out += LUTGammaBBCGam.toString() + "\n";
	for (var j in LUTGammaBBCGam.prototype) {
		out += 'LUTGammaBBCGam.prototype.' + j + '=' + LUTGammaBBCGam.prototype[j].toString() + "\n";
	}
	// LUTGammaLin
	out += LUTGammaLin.toString() + "\n";
	for (var j in LUTGammaLin.prototype) {
		out += 'LUTGammaLin.prototype.' + j + '=' + LUTGammaLin.prototype[j].toString() + "\n";
	}
	// LUTGammaPQ
	out += LUTGammaPQ.toString() + "\n";
	for (var j in LUTGammaPQ.prototype) {
		out += 'LUTGammaPQ.prototype.' + j + '=' + LUTGammaPQ.prototype[j].toString() + "\n";
	}
	// LUTGammaHLG
	out += LUTGammaHLG.toString() + "\n";
	for (var j in LUTGammaHLG.prototype) {
		out += 'LUTGammaHLG.prototype.' + j + '=' + LUTGammaHLG.prototype[j].toString() + "\n";
	}
	// LUTGammaOOTFPQ
	out += LUTGammaOOTFPQ.toString() + "\n";
	for (var j in LUTGammaOOTFPQ.prototype) {
		out += 'LUTGammaOOTFPQ.prototype.' + j + '=' + LUTGammaOOTFPQ.prototype[j].toString() + "\n";
	}
	// LUTGammaOOTFHLG
	out += LUTGammaOOTFHLG.toString() + "\n";
	for (var j in LUTGammaOOTFHLG.prototype) {
		out += 'LUTGammaOOTFHLG.prototype.' + j + '=' + LUTGammaOOTFHLG.prototype[j].toString() + "\n";
	}
	// LUTGammaOOTFNone
	out += LUTGammaOOTFNone.toString() + "\n";
	for (var j in LUTGammaOOTFNone.prototype) {
		out += 'LUTGammaOOTFNone.prototype.' + j + '=' + LUTGammaOOTFNone.prototype[j].toString() + "\n";
	}
	// LUTGammaITUProp
	out += LUTGammaITUProp.toString() + "\n";
	for (var j in LUTGammaITUProp.prototype) {
		out += 'LUTGammaITUProp.prototype.' + j + '=' + LUTGammaITUProp.prototype[j].toString() + "\n";
	}
	// LUTGammaBBC283
	out += LUTGammaBBC283.toString() + "\n";
	for (var j in LUTGammaBBC283.prototype) {
		out += 'LUTGammaBBC283.prototype.' + j + '=' + LUTGammaBBC283.prototype[j].toString() + "\n";
	}
	// LUTGammaACEScc
	out += LUTGammaACEScc.toString() + "\n";
	for (var j in LUTGammaACEScc.prototype) {
		out += 'LUTGammaACEScc.prototype.' + j + '=' + LUTGammaACEScc.prototype[j].toString() + "\n";
	}
	// LUTGammaACESProxy
	out += LUTGammaACESProxy.toString() + "\n";
	for (var j in LUTGammaACESProxy.prototype) {
		out += 'LUTGammaACESProxy.prototype.' + j + '=' + LUTGammaACESProxy.prototype[j].toString() + "\n";
	}
	// LUTGammaGen
	out += LUTGammaGen.toString() + "\n";
	for (var j in LUTGammaGen.prototype) {
		out += 'LUTGammaGen.prototype.' + j + '=' + LUTGammaGen.prototype[j].toString() + "\n";
	}
	// LUTGammaLUTSL3
	out += LUTGammaLUTSL3.toString() + "\n";
	for (var j in LUTGammaLUTSL3.prototype) {
		out += 'LUTGammaLUTSL3.prototype.' + j + '=' + LUTGammaLUTSL3.prototype[j].toString() + "\n";
	}
	// LUTGammaLUTSimple
	out += LUTGammaLUTSimple.toString() + "\n";
	for (var j in LUTGammaLUTSimple.prototype) {
		out += 'LUTGammaLUTSimple.prototype.' + j + '=' + LUTGammaLUTSimple.prototype[j].toString() + "\n";
	}
	// LUTGammaDLog
	out += LUTGammaDLog.toString() + "\n";
	for (var j in LUTGammaDLog.prototype) {
		out += 'LUTGammaDLog.prototype.' + j + '=' + LUTGammaDLog.prototype[j].toString() + "\n";
	}
	// LUTGammaIOLUT
	out += LUTGammaIOLUT.toString() + "\n";
	for (var j in LUTGammaIOLUT.prototype) {
		out += 'LUTGammaIOLUT.prototype.' + j + '=' + LUTGammaIOLUT.prototype[j].toString() + "\n";
	}
	// LUTGammaLA
	out += LUTGammaLA.toString() + "\n";
	for (var j in LUTGammaLA.prototype) {
		out += 'LUTGammaLA.prototype.' + j + '=' + LUTGammaLA.prototype[j].toString() + "\n";
	}
	// LUTGammaNull
	out += LUTGammaNull.toString() + "\n";
	for (var j in LUTGammaNull.prototype) {
		out += 'LUTGammaNull.prototype.' + j + '=' + LUTGammaNull.prototype[j].toString() + "\n";
	}
	// LUTGammaWorker
	out += LUTGammaWorker.toString() + "\n";
	for (var j in LUTGammaWorker.prototype) {
		out += 'LUTGammaWorker.prototype.' + j + '=' + LUTGammaWorker.prototype[j].toString() + "\n";
	}
	out += 'var lutGammaWorker = new LUTGammaWorker();' + "\n";
	return out;
}
var workerGammaString = getGammaWorkerString();
/* colourspace.js
* Colour Space (gamut) conversion web worker object for the LUTCalc Web App.
* 27th June December 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTColourSpace() {
	this.ready = 0;
	
	this.lutMaker = new LUTs();
	this.g = [];
	this.csIn = [];
	this.csOut = [];
	this.csM = [];
	this.CATs = new CSCAT();
	// CIECAT02
	// CIECAT97s
	// Bradford Chromatic Adaptation
	// Von Kries
	// Sharp
	// CMCCAT2000
	// Bianco BS
	// Bianco BS-PC
	// XYZ Scaling
	this.sysCAT = 'CIECAT02';
	this.sysCATIdx = this.CATs.setDefault(this.sysCAT);
	this.matList = [];
	this.xyzMatrices();
	this.system = this.g[this.sysIdx];
	this.system.fromXYZ = this.mInverse(this.system.toXYZ);
	this.y = new Float64Array([	0.2126, 0.7152, 0.0722 ]);
	this.systemMatrices();
	this.setSaturated();
	this.Ys = {};
	this.setYCoeffs();

	this.defLUTs = {};

	this.nul = false;
	this.isTrans = false;
	this.ver = 0;
	this.curIn = 0;
	this.curOut = 0;
	this.planck = new Planck(this.lutMaker);
	this.system.CCT = this.planck.getCCT(this.system.white);
	this.system.Dxy = this.planck.getDxy(this.system.white,this.system.CCT);
	this.wb = new CSWB(this.system.white,this.system.toXYZ, this.planck, this.CATs);
	this.curHG = 0;
	this.hgLow = 0;
	this.hgHigh = 0;
	this.hgLin = true;
	this.hgLowStop = 0;
	this.hgHighStop = 0;
	this.sdrSatGamma = 1.2;
	this.LA = 0;
	this.pass = 0;
	this.inList = [];
	this.outList = [];
	this.laList = [];
	this.csInSub = [];
	this.csOutSub = [];
	this.csLASub = [];
	if ((new Int8Array(new Int16Array([1]).buffer)[0]) > 0) {
		this.isLE = true;
	} else {
		this.isLE = false;
	}
	this.asc = new Float64Array([
		1,1,1,	// s - Slope / Gain
		0,0,0,	// o - Offset / Lift
		1,1,1,	// p - Power / Gamma
		1		// sat - Saturation
	]);
	this.initPSSTCDL();
	this.fcVals = new Float64Array([
		0.00078125,// Purple - Black Clip (18%-8 stops)
		0.002915728,// Blue - Just Above Black Clip (18%-6.1 stops)
		0.174110113,// Green - 18%-0.2 Stop
		0.229739671,// Green - 18%+0.2 stop
		0.354307008,// Pink - One Stop Over 18%-0.175 Stop
		0.451585762,// Pink - One Stop Over 18%+0.175 Stop
		0.885767519,// Orange - 90% White-0.175 Stop
		1.128964405,// Orange - 90% White+0.175 Stop
		10.39683067,// Yellow - White Clip (Sony F55,F5,FS7)-0.3 Stop
		12.36398501 // Red - White Clip (Sony F55,F5,FS7) 18%+6 stops
	]);
	this.gLimLin = false;
	this.gLimL = 1;
	this.gLimY = new Float64Array(this.y.buffer.slice(0));
	this.gLimGIn = 0;
	this.gLimGOut = 0;
	this.gLimC = false;
	this.gLimB = true;

	this.doHG = false;
	this.doWB = false;
	this.doASCCDL = false;
	this.doPSSTCDL = false;
	this.doGamutLim = false;
	this.doFC = false;

	this.loadColourSpaces();
	this.buildColourSquare();
	this.buildMultiColours();

	this.ready++;
	
}
// Prepare colour spaces
LUTColourSpace.prototype.subIdx = function(cat) {
	switch (cat) {
		case 'Sony': 		return 0;
		case 'ARRI': 		return 1;
		case 'Canon':		return 2;
		case 'Apple':		return 3;
		case 'Panasonic':	return 4;
		case 'Fujifilm':	return 5;
		case 'RED':			return 6;
		case 'DJI':			return 7;
		case 'GoPro':		return 8;
		case 'Blackmagic':	return 9;
		case 'Nikon':		return 10;
		case 'Bolex':		return 11;
		case 'Adobe':		return 12;
		case 'Rec709':		return 13;
		case 'Rec2020':		return 14;
		case 'Rec2100':		return 15;
		case 'P3':			return 16;
		case 'Wide Gamut':	return 17;
		case 'ACES':		return 18;
		case 'All':			return 19;
	}
	return false;
};
LUTColourSpace.prototype.loadColourSpaces = function() {
	this.subNames = [	'Sony',
						'ARRI',
						'Canon',
						'Apple',
						'Panasonic',
						'Fujifilm',
						'RED',
						'DJI',
						'GoPro',
						'Blackmagic',
						'Nikon',
						'Bolex',
						'Adobe',
						'Rec709',
						'Rec2020',
						'Rec2100',
						'P3',
						'Wide Gamut',
						'ACES',
						'All'
	];						
	this.SG3C = this.csIn.length;
	this.csIn.push(this.toSys('Sony S-Gamut3.cine'));
	this.csInSub.push([this.subIdx('Sony'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Sony S-Gamut3.cine (Venice)'));
	this.csInSub.push([this.subIdx('Sony'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Sony S-Gamut3'));
	this.csInSub.push([this.subIdx('Sony'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Sony S-Gamut3 (Venice)'));
	this.csInSub.push([this.subIdx('Sony'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Sony S-Gamut'));
	this.csInSub.push([this.subIdx('Sony'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('ARRI Wide Gamut 4'));
	this.csInSub.push([this.subIdx('ARRI'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Alexa Wide Gamut'));
	this.csInSub.push([this.subIdx('ARRI'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Canon Cinema Gamut'));
	this.csInSub.push([this.subIdx('Canon'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Panasonic V-Gamut'));
	this.csInSub.push([this.subIdx('Panasonic'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Fujifilm F-Log Gamut'));
	this.csInSub.push([this.subIdx('Fujifilm'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Blackmagic Wide Gamut'));
	this.csInSub.push([this.subIdx('Blackmagic'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('DaVinci Wide Gamut'));
	this.csInSub.push([this.subIdx('Blackmagic'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Blackmagic 4.6k Film'));
	this.csInSub.push([this.subIdx('Blackmagic'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Blackmagic 4k Film'));
	this.csInSub.push([this.subIdx('Blackmagic'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Blackmagic Pocket 6k Film'));
	this.csInSub.push([this.subIdx('Blackmagic'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('DRAGONColor'));
	this.csInSub.push([this.subIdx('RED')]);
	this.csIn.push(this.toSys('DRAGONColor2'));
	this.csInSub.push([this.subIdx('RED')]);
	this.csIn.push(this.toSys('REDColor'));
	this.csInSub.push([this.subIdx('RED')]);
	this.csIn.push(this.toSys('REDColor2'));
	this.csInSub.push([this.subIdx('RED')]);
	this.csIn.push(this.toSys('REDColor3'));
	this.csInSub.push([this.subIdx('RED')]);
	this.csIn.push(this.toSys('REDColor4'));
	this.csInSub.push([this.subIdx('RED')]);
	this.csIn.push(this.toSys('REDWideGamutRGB'));
	this.csInSub.push([this.subIdx('RED')]);
	this.csIn.push(this.toSys('DJI D-Gamut'));
	this.csInSub.push([this.subIdx('DJI'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('DJI D-GamutM'));
	this.csInSub.push([this.subIdx('DJI'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Protune Native'));
	this.csInSub.push([this.subIdx('GoPro'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Bolex Wide Gamut'));
	this.csInSub.push([this.subIdx('Bolex'),this.subIdx('Wide Gamut')]);
	this.rec709In = this.csIn.length;
	this.csIn.push(this.toSys('Rec709'));
	this.csInSub.push([this.subIdx('Rec709'),this.subIdx('DJI')]);
	this.csIn.push(this.toSys('Rec2020'));
	this.csInSub.push([this.subIdx('Rec2020'),this.subIdx('Apple'),this.subIdx('Nikon'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('Rec2100'));
	this.csInSub.push([this.subIdx('Rec2100'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('sRGB'));
	this.csInSub.push([]);
	this.csIn.push(this.toSys('ACES AP0'));
	this.csInSub.push([this.subIdx('ACES'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('ACEScg AP1'));
	this.csInSub.push([this.subIdx('ACES'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('XYZ'));
	this.csInSub.push([this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('P3 - DCI'));
	this.csInSub.push([this.subIdx('P3')]);
	this.csIn.push(this.toSys('P3 - D60'));
	this.csInSub.push([this.subIdx('P3')]);
	this.csIn.push(this.toSys('P3 - D65'));
	this.csInSub.push([this.subIdx('P3')]);
	this.csIn.push(new CSCanonIDT('Canon CP IDT (Daylight)', true, this.toSys('ACES AP0').m, this.system.white.buffer.slice(0)));
	this.csInSub.push([this.subIdx('Canon'),this.subIdx('Rec709')]);
	this.csIn.push(new CSCanonIDT('Canon CP IDT (Tungsten)', false, this.toSys('ACES AP0').m, this.system.white.buffer.slice(0)));
	this.csInSub.push([this.subIdx('Canon'),this.subIdx('Rec709')]);
	this.csIn.push(this.toSys('Canon DCI-P3+'));
	this.csInSub.push([this.subIdx('Canon'),this.subIdx('P3')]);
	this.csIn.push(this.toSys('Adobe RGB'));
	this.csInSub.push([this.subIdx('Adobe')]);
	this.csIn.push(this.toSys('Adobe Wide Gamut RGB'));
	this.csInSub.push([this.subIdx('Adobe'),this.subIdx('Wide Gamut')]);
	this.csIn.push(this.toSys('ProPhoto RGB'));
	this.csInSub.push([this.subIdx('Wide Gamut')]);
	this.csIn.push(new CSLabSpace('CIELAB D65', 95.0489, 100.0, 108.8840, true, this.toSys('XYZ')));
	this.csInSub.push([this.subIdx('Wide Gamut')]);
	this.csIn.push(new CSLabSpace('CIELAB D50', 96.4212, 100.0, 82.5188, true, this.toSys('XYZ')));
	this.csInSub.push([this.subIdx('Wide Gamut')]);
	this.custIn = this.csIn.length;
	this.csIn.push(this.toSys('Custom In'));
	this.csInSub.push([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]);
	this.csIn.push(new CSMatrix('Passthrough', new Float64Array([1,0,0, 0,1,0, 0,0,1]), this.system.white.buffer.slice(0)));
	this.csInSub.push([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]);

	this.csOut.push(this.fromSys('Sony S-Gamut3.cine'));
	this.csOutSub.push([this.subIdx('Sony'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Sony S-Gamut3.cine (Venice)'));
	this.csOutSub.push([this.subIdx('Sony'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Sony S-Gamut3'));
	this.csOutSub.push([this.subIdx('Sony'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Sony S-Gamut3 (Venice)'));
	this.csOutSub.push([this.subIdx('Sony'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Sony S-Gamut'));
	this.csOutSub.push([this.subIdx('Sony'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('ARRI Wide Gamut 4'));
	this.csOutSub.push([this.subIdx('ARRI'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Alexa Wide Gamut'));
	this.csOutSub.push([this.subIdx('ARRI'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Canon Cinema Gamut'));
	this.csOutSub.push([this.subIdx('Canon'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Panasonic V-Gamut'));
	this.csOutSub.push([this.subIdx('Panasonic'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Fujifilm F-Log Gamut'));
	this.csOutSub.push([this.subIdx('Fujifilm'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Blackmagic Wide Gamut'));
	this.csOutSub.push([this.subIdx('Blackmagic'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('DaVinci Wide Gamut'));
	this.csOutSub.push([this.subIdx('Blackmagic'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Blackmagic 4.6k Film'));
	this.csOutSub.push([this.subIdx('Blackmagic'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Blackmagic 4k Film'));
	this.csOutSub.push([this.subIdx('Blackmagic'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Blackmagic Pocket 6k Film'));
	this.csOutSub.push([this.subIdx('Blackmagic'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('DRAGONColor'));
	this.csOutSub.push([this.subIdx('RED')]);
	this.csOut.push(this.fromSys('DRAGONColor2'));
	this.csOutSub.push([this.subIdx('RED')]);
	this.csOut.push(this.fromSys('REDColor'));
	this.csOutSub.push([this.subIdx('RED')]);
	this.csOut.push(this.fromSys('REDColor2'));
	this.csOutSub.push([this.subIdx('RED')]);
	this.csOut.push(this.fromSys('REDColor3'));
	this.csOutSub.push([this.subIdx('RED')]);
	this.csOut.push(this.fromSys('REDColor4'));
	this.csOutSub.push([this.subIdx('RED')]);
	this.csOut.push(this.fromSys('REDWideGamutRGB'));
	this.csOutSub.push([this.subIdx('RED')]);
	this.csOut.push(this.fromSys('DJI D-Gamut'));
	this.csOutSub.push([this.subIdx('DJI'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('DJI D-GamutM'));
	this.csOutSub.push([this.subIdx('DJI'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Protune Native'));
	this.csOutSub.push([this.subIdx('GoPro'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Bolex Wide Gamut'));
	this.csOutSub.push([this.subIdx('Bolex'),this.subIdx('Wide Gamut')]);
	this.rec709Out = this.csIn.length;
	this.csOut.push(this.fromSys('Rec709'));
	this.csOutSub.push([this.subIdx('Rec709'),this.subIdx('DJI')]);
	this.defLUTs.Amira709 = this.csOut.length;
	this.csOut.push(
		this.fromSysLUT('Amira709',
			{
				format: 'cube',
				min: [0,0,0],
				max: [1,1,1],
				wp: this.illuminant('d65'),
				genInt: 1,
				preInt: 1
			}
		)
	);
	this.csOutSub.push([this.subIdx('ARRI'),this.subIdx('Rec709')]);
	this.defLUTs.AlexaX2 = this.csOut.length;
	this.csOut.push(
		this.fromSysLUT('Alexa-X-2',
			{
				format: 'cube',
				min: [0,0,0],
				max: [1,1,1],
				wp: this.illuminant('d65'),
				genInt: 1,
				preInt: 1
			}
		)
	);
	this.csOutSub.push([this.subIdx('ARRI'),this.subIdx('Rec709')]);

	this.defLUTs.s709 = this.csOut.length;
	this.csOut.push(
		this.fromSysLUT('s709',
			{
				format: 'cube',
				min: [0,0,0],
				max: [1,1,1],
				wp: this.illuminant('d65'),
				genInt: 1,
				preInt: 1
			}
		)
	);
	this.csOutSub.push([this.subIdx('Sony'),this.subIdx('Rec709')]);

	this.defLUTs.LC709 = this.csOut.length;
	this.csOut.push(
		this.fromSysLUT('LC709',
			{
				format: 'cube',
				min: [0,0,0],
				max: [1,1,1],
				wp: this.illuminant('d65'),
				genInt: 1,
				preInt: 1
			}
		)
	);
	this.csOutSub.push([this.subIdx('Sony'),this.subIdx('Rec709')]);
	this.defLUTs.LC709A = this.csOut.length;
	this.csOut.push(
		this.fromSysLUT('LC709A',
			{
				format: 'cube',
				min: [0,0,0],
				max: [1,1,1],
				wp: this.illuminant('d65'),
				genInt: 1,
				preInt: 1
			}
		)
	);
	this.csOutSub.push([this.subIdx('Sony'),this.subIdx('Rec709')]);
	this.defLUTs.Cine709 = this.csOut.length;
	this.csOut.push(
		this.fromSysLUT('Sony Cine+709',
			{
				format: 'cube',
				min: [0,0,0],
				max: [1,1,1],
				wp: this.illuminant('d65'),
				genInt: 1,
				preInt: 1
			}
		)
	);
	this.csOutSub.push([this.subIdx('Sony'),this.subIdx('Rec709')]);
	this.defLUTs.cpoutdaylight = this.csOut.length;
	this.csOut.push(
		this.fromSysLUT('Canon CP IDT (Daylight)',
			{
				format: 'cube',
				min: [0,0,0],
				max: [1,1,1],
				wp: this.illuminant('d65'),
				genInt: 1,
				preInt: 1
			}
		)
	);
	this.csOutSub.push([this.subIdx('Canon'),this.subIdx('Rec709')]);
	this.defLUTs.cpouttungsten = this.csOut.length;
	this.csOut.push(
		this.fromSysLUT('Canon CP IDT (Tungsten)',
			{
				format: 'cube',
				min: [0,0,0],
				max: [1,1,1],
				wp: this.illuminant('d65'),
				genInt: 1,
				preInt: 1
			}
		)
	);
	this.csOutSub.push([this.subIdx('Canon'),this.subIdx('Rec709')]);
	this.defLUTs.V709 = this.csOut.length;
	this.csOut.push(
		this.fromSysLUT('Varicam V709',
			{
				format: 'cube',
				min: [0,0,0],
				max: [1,1,1],
				wp: this.illuminant('d65'),
				genInt: 1,
				preInt: 1
			}
		)
	);
	this.csOutSub.push([this.subIdx('Panasonic'),this.subIdx('Rec709')]);
	this.csOut.push(this.fromSys('Rec2020'));
	this.csOutSub.push([this.subIdx('Rec2020'),this.subIdx('Nikon'),this.subIdx('Apple'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('Rec2100'));
	this.csOutSub.push([this.subIdx('Rec2100'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('sRGB'));
	this.csOutSub.push([]);
	this.csOut.push(this.fromSysMatrix('Luma B&W', new Float64Array([ this.y[0],this.y[1],this.y[2], this.y[0],this.y[1],this.y[2], this.y[0],this.y[1],this.y[2] ]), this.system.white.buffer.slice(0)));
	this.csOutSub.push([]);
	this.csOut.push(this.fromSys('ACES AP0'));
	this.csOutSub.push([this.subIdx('ACES'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('ACEScg AP1'));
	this.csOutSub.push([this.subIdx('ACES'),this.subIdx('Wide Gamut')]);
	this.XYZOut = this.csOut.length;
	this.csOut.push(this.fromSys('XYZ'));
	this.csOutSub.push([this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('P3 - DCI'));
	this.csOutSub.push([this.subIdx('P3')]);
	this.csOut.push(this.fromSys('P3 - D60'));
	this.csOutSub.push([this.subIdx('P3')]);
	this.csOut.push(this.fromSys('P3 - D65'));
	this.csOutSub.push([this.subIdx('P3')]);
	this.csOut.push(this.fromSys('Canon DCI-P3+'));
	this.csOutSub.push([this.subIdx('Canon'),this.subIdx('P3')]);
	this.csOut.push(this.fromSys('Adobe RGB'));
	this.csOutSub.push([this.subIdx('Adobe')]);
	this.csOut.push(this.fromSys('Adobe Wide Gamut RGB'));
	this.csOutSub.push([this.subIdx('Adobe'),this.subIdx('Wide Gamut')]);
	this.csOut.push(this.fromSys('ProPhoto RGB'));
	this.csOutSub.push([this.subIdx('Wide Gamut')]);
	this.csOut.push(new CSLabSpace('CIELAB D65', 95.0489, 100.0, 108.8840, false, this.fromSys('XYZ')));
	this.csOutSub.push([this.subIdx('Wide Gamut')]);
	this.csOut.push(new CSLabSpace('CIELAB D50', 96.4212, 100.0, 82.5188, false, this.fromSys('XYZ')));
	this.csOutSub.push([this.subIdx('Wide Gamut')]);
	this.custOut = this.csOut.length;
	this.csOut.push(this.toSys('Custom Out'));
	this.csOutSub.push([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]);
	this.pass = this.csOut.length;
	this.csOut.push(this.fromSysMatrix('Passthrough', new Float64Array([1,0,0, 0,1,0, 0,0,1]), this.system.white.buffer.slice(0)));
	this.csM.push(this.csOut[this.csOut.length - 1]);
	this.csOutSub.push([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]);
	this.LA = this.csOut.length;
	this.csOut.push(this.fromSysLA('LA', {wp: this.illuminant('d65')}));
	this.csOutSub.push([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]);

	var max = this.csIn.length;
	this.inCATs = [];
	this.outCATs = [];
	for (var j=0; j<max; j++) {
		this.inList.push({name: this.csIn[j].name,idx: j});
		this.inCATs.push(this.getCSCat(this.csIn[j].name));
	}
	var max2 = this.csOut.length;
	for (var j=0; j<max2; j++) {
		if (j !== this.LA) {
			this.outList.push({name: this.csOut[j].name,idx: j});
		}
		this.outCATs.push(this.getCSCat(this.csOut[j].name));
	}
	max2 = this.outList.length;
	var k=0;
	for (var i=0; i<max; i++) {
		if (this.csIn[i].isMatrix() && this.csIn[i].name !== 'Passthrough') {
			this.laList.push({name: this.csIn[i].name});
			this.csLASub.push(this.csInSub[i].slice(0));
			if (this.laList[k].name === 'Custom In') {
				this.laList[k].idx = this.custOut;
				this.csLASub[k] = this.csOutSub[this.custOut].slice(0);
			} else {
				for (var j=0; j<max2; j++) {
					if (this.laList[k].name === this.outList[j].name) {
						this.laList[k].idx = this.outList[j].idx;
						this.csLASub[k] = this.csOutSub[j].slice(0);
						break;
					}
				}
			}
			k++;
		}
	}
};
LUTColourSpace.prototype.getCSCat = function(name) {
	var m = this.g.length;
	for (var j=0; j<m; j++) {
		if (name === this.g[j].name) {
			return this.g[j].cat;
		}
	}
	return this.sysCATIdx; // fall back to default
};
// Colour calculations
LUTColourSpace.prototype.RGBtoXYZ = function(xy, white) {
//	xy = [	xr, yr,
//			xg, yg,
//			xb, yb ]
//	white = [ xw, yw, zw ];
	if (typeof white === 'undefined' || !white) {
		return false;
	}
	var XYZ = new Float64Array([
		xy[0]/xy[1],			xy[2]/xy[3],			xy[4]/xy[5],
		1,						1,						1,
		(1-xy[0]-xy[1])/xy[1],	(1-xy[2]-xy[3])/xy[3],	(1-xy[4]-xy[5])/xy[5]
	]);
	var invXYZ = this.mInverse(XYZ);
	if (!invXYZ) {
		return false;
	}
	var S = this.mMult(invXYZ, new Float64Array([white[0]/white[1],1,white[2]/white[1]]));
	return new Float64Array([
		S[0]*XYZ[0], S[1]*XYZ[1], S[2]*XYZ[2],
		S[0]*XYZ[3], S[1]*XYZ[4], S[2]*XYZ[5],
		S[0]*XYZ[6], S[1]*XYZ[7], S[2]*XYZ[8]
	]);
};
LUTColourSpace.prototype.calcCAT = function(m, ws, wd, model) {
	var cat = this.CATs.getModel(model);
	var inv = this.mInverse(cat);
	var s = this.mMult(cat, new Float64Array([ws[0]/ws[1],1,ws[2]/ws[1]]));
	var d = this.mMult(cat, new Float64Array([wd[0]/wd[1],1,wd[2]/wd[1]]));
	var CAT = new Float64Array([
		d[0]/s[0], 0, 0,
		0, d[1]/s[1], 0,
		0, 0, d[2]/s[2]
	]);
	var n = this.mMult(inv,this.mMult(CAT,cat));
	return this.mMult(n,m);
};
LUTColourSpace.prototype.toSys = function(name) {
	var m = this.g.length;
	for (var j=0; j<m; j++) {
		if (name === this.g[j].name) {
			return new CSMatrix(name, this.g[j].toSys, this.g[j].white.buffer.slice(0));
		}
	}
	return false;
};
LUTColourSpace.prototype.fromSys = function(name) {
	var max = this.g.length;
	for (var j=0; j<max; j++) {
		if (name === this.g[j].name) {
			var out = new CSMatrix(name, this.mInverse(this.g[j].toSys), this.g[j].white.buffer.slice(0));
			this.csM.push(out);
			this.Ys[name] = this.getYCoeffs(j);
// console.log(name);
// console.log(this.Ys[name]);
			return out;
		}
	}
	return false;
};
LUTColourSpace.prototype.matrixVals = function(name,to) {
	var m = this.g.length;
	for (var j=0; j<m; j++) {
		if (name === this.g[j].name) {
			if (to) {
				return this.g[j].toSys;
			} else {
				return this.mInverse(this.g[j].toSys);
			}
		}
	}
	return false;
};
LUTColourSpace.prototype.fromSysMatrix = function(name,matrix,white) {
	var out = new CSMatrix(name, matrix, white);
	this.csM.push(out);
	return out;
};
LUTColourSpace.prototype.fromSysLUT = function(name,params) {
	var colours = new Float64Array([
			1,0,0,
			0,1,0,
			0,0,1,
			1,1,1,
			0.8,0,0,
			0,0.8,0,
			0,0,0.8,
			0.4,0,0,
			0,0.4,0,
			0,0,0.4,
			0.2,0,0,
			0,0.2,0,
			0,0,0.2,
			0.8,0.8,0.8,
			0.4,0.4,0.4,
			0.2,0.2,0.2
		]);
	this.csIn[this.rec709In].lc(colours.buffer);
	var csLUT = new CSLUT(name, params, this.lutMaker, colours);
	this.csM.push(csLUT);	
	return csLUT;
};
LUTColourSpace.prototype.fromSysTC = function(name,params,xy,white,model) {
	var cat = this.CATs.getModel(model);
	var toXYZ = this.RGBtoXYZ(xy,white);
	this.csM.push(new CSMatrix(
		name,
		this.mInverse(this.mMult(this.system.fromXYZ, this.calcCAT(toXYZ,white,this.system.white,cat))),
		white
	));
	return new CSToneCurve(name, params);
};
LUTColourSpace.prototype.fromSysLA = function(name,params) {
	var colours = new Float64Array([
			1,0,0,
			0,1,0,
			0,0,1,
			1,1,1,
			0.8,0,0,
			0,0.8,0,
			0,0,0.8,
			0.4,0,0,
			0,0.4,0,
			0,0,0.4,
			0.2,0,0,
			0,0.2,0,
			0,0,0.2,
			0.8,0.8,0.8,
			0.4,0.4,0.4,
			0.2,0.2,0.2
		]);
	this.csIn[this.rec709In].lc(colours.buffer);
	var csLA = new CSLUT(name, params, this.lutMaker, colours);
	this.csM.push(csLA);
	return csLA;
};
LUTColourSpace.prototype.fx = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	var y = this.y;
	var Y;
// Colour Temperature Shift
	if (this.doWB) {
		this.wb.lc(buff);
	}
// ASC-CDL
	if (this.doASCCDL) {
		for (var j=0; j<m; j += 3) {
			o[ j ] = (o[ j ]*this.asc[0])+this.asc[3];
			o[ j ] = ((o[ j ]<0)?o[ j ]:Math.pow(o[ j ],this.asc[6]));
			o[ j ] = (isNaN(o[ j ])?0:o[ j ]);
			o[j+1] = (o[j+1]*this.asc[1])+this.asc[4];
			o[j+1] = ((o[j+1]<0)?o[j+1]:Math.pow(o[j+1],this.asc[7]));
			o[j+1] = (isNaN(o[j+1])?0:o[j+1]);
			o[j+2] = (o[j+2]*this.asc[2])+this.asc[5];
			o[j+2] = ((o[j+2]<0)?o[j+2]:Math.pow(o[j+2],this.asc[8]));
			o[j+2] = (isNaN(o[j+2])?0:o[j+2]);
			Y = ((y[0]*o[j])+(y[1]*o[j+1])+(y[2]*o[j+2])) * (1-this.asc[9]);
			o[ j ] = Y + (this.asc[9]*o[ j ]);
			o[j+1] = Y + (this.asc[9]*o[j+1]);
			o[j+2] = Y + (this.asc[9]*o[j+2]);
		}
	}
	this.csM[this.curOut].lc(buff);
	return o;
};
LUTColourSpace.prototype.rx = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	var y = this.y;
	var Y;
	this.csM[this.curOut].rc(buff);
// Colour Temperature Shift
	if (this.doWB) {
		this.wb.rc(buff);
	}
// ASC-CDL
	if (this.doASCCDL) {
		var s = 1/Math.max(this.asc[9],0.00000001); // avoid division by zero
		for (var j=0; j<m; j += 3) {
			Y = ((y[0]*o[j])+(y[1]*o[j+1])+(y[2]*o[j+2])) * (1-s);
			o[ j ] = (o[ j ]*s) + Y;
			o[j+1] = (o[j+1]*s) + Y;
			o[j+2] = (o[j+2]*s) + Y;
			o[ j ] = ((o[ j ]<0)?o[ j ]:Math.pow(o[ j ],1/this.asc[6]));
			o[ j ] = (o[ j ] - this.asc[3])/this.asc[0];
			o[ j ] = (isNaN(o[ j ])?0:o[ j ]);
			o[j+1] = ((o[j+1]<0)?o[j+1]:Math.pow(o[j+1],1/this.asc[7]));
			o[j+1] = (o[j+1] - this.asc[4])/this.asc[1];
			o[j+1] = (isNaN(o[j+1])?0:o[j+1]);
			o[j+2] = ((o[j+2]<0)?o[j+2]:Math.pow(o[j+2],1/this.asc[8]));
			o[j+2] = (o[j+2] - this.asc[5])/this.asc[2];
			o[j+2] = (isNaN(o[j+2])?0:o[j+2]);
		}
	}
	return o;
};
LUTColourSpace.prototype.firstGuess = function(goal, rgb, d) {
	var d2 = d*2;
	var data = new Float64Array([
		rgb[0]		,rgb[1]		,rgb[2],
		rgb[0] + d	,rgb[1]		,rgb[2],
		rgb[0] - d	,rgb[1]		,rgb[2],
		rgb[0]		,rgb[1] + d	,rgb[2],
		rgb[0]		,rgb[1] - d	,rgb[2],
		rgb[0]		,rgb[1]		,rgb[2] + d,
		rgb[0]		,rgb[1]		,rgb[2] - d
	]);
	var g = this.fx(data.buffer);
//
//if (goal[0] === goal[1] && goal[0] === goal[2]) {
//	self.postMessage({msg:true,details:g});
//}
//
	return {
		x: rgb,
		f: new Float64Array([g[0]-goal[0],g[1]-goal[1],g[2]-goal[2]]),
		J: new Float64Array([
			(g[3]-g[6])/d2, (g[ 9]-g[12])/d2, (g[15]-g[18])/d2,
			(g[4]-g[7])/d2, (g[10]-g[13])/d2, (g[16]-g[19])/d2,
			(g[5]-g[8])/d2, (g[11]-g[14])/d2, (g[17]-g[20])/d2,
		])
	};
};
LUTColourSpace.prototype.roundOff = function(i) {
	return parseFloat(i.toFixed(8));
};
// Matrix operations
LUTColourSpace.prototype.mInverse = function(M) {
	var det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
				(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
				(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	if (det === 0) {
		return false;
	}
	return new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
LUTColourSpace.prototype.mMult = function(m1,m2) {
	if (m1.length !== 9) {
		return false;
	}
	var len = m2.length;
	if (len === 3) {
		var out = new Float64Array(3);
		out[0] = (m1[0]*m2[0]) + (m1[1]*m2[1]) + (m1[2]*m2[2]);
		out[1] = (m1[3]*m2[0]) + (m1[4]*m2[1]) + (m1[5]*m2[2]);
		out[2] = (m1[6]*m2[0]) + (m1[7]*m2[1]) + (m1[8]*m2[2]);
		return out;
	} else if (len === 9) {
		var out = new Float64Array(9);
		out[0] = (m1[0]*m2[0]) + (m1[1]*m2[3]) + (m1[2]*m2[6]);
		out[1] = (m1[0]*m2[1]) + (m1[1]*m2[4]) + (m1[2]*m2[7]);
		out[2] = (m1[0]*m2[2]) + (m1[1]*m2[5]) + (m1[2]*m2[8]);
		out[3] = (m1[3]*m2[0]) + (m1[4]*m2[3]) + (m1[5]*m2[6]);
		out[4] = (m1[3]*m2[1]) + (m1[4]*m2[4]) + (m1[5]*m2[7]);
		out[5] = (m1[3]*m2[2]) + (m1[4]*m2[5]) + (m1[5]*m2[8]);
		out[6] = (m1[6]*m2[0]) + (m1[7]*m2[3]) + (m1[8]*m2[6]);
		out[7] = (m1[6]*m2[1]) + (m1[7]*m2[4]) + (m1[8]*m2[7]);
		out[8] = (m1[6]*m2[2]) + (m1[7]*m2[5]) + (m1[8]*m2[8]);
		return out;
	} else {
		return false;
	}
};
// Base colour data
LUTColourSpace.prototype.illuminant = function(name) {
	switch (name.toLowerCase()) {
		case 'a':	return new Float64Array([ 0.44757, 0.40745, 0.14498 ]);
		case 'b':	return new Float64Array([ 0.34842, 0.35161, 0.29997 ]);
		case 'c':	return new Float64Array([ 0.31006, 0.31616, 0.37378 ]);
		case 'd40':	return new Float64Array([ 0.38230, 0.38380, 0.23390 ]);
		case 'd45':	return new Float64Array([ 0.36210, 0.37090, 0.26700 ]);
		case 'd50':	return new Float64Array([ 0.34567, 0.35850, 0.29583 ]);
		case 'd55':	return new Float64Array([ 0.33242, 0.34743, 0.32015 ]);
		case 'd60':	return new Float64Array([ 0.32168, 0.33767, 0.34065 ]);
		case 'd65':	return new Float64Array([ 0.31270, 0.32900, 0.35830 ]);
		case 'd70':	return new Float64Array([ 0.30540, 0.32160, 0.37300 ]);
		case 'd75':	return new Float64Array([ 0.29902, 0.31485, 0.38613 ]);
		case 'e':	return new Float64Array([ 1/3    , 1/3	  , 1/3 	]);
		case 'p3':	return new Float64Array([ 0.31400, 0.35100, 0.33500 ]);
		case 'f1':	return new Float64Array([ 0.31310, 0.33727, 0.34963 ]);
		case 'f2':	return new Float64Array([ 0.37208, 0.37529, 0.25263 ]);
		case 'f3':	return new Float64Array([ 0.40910, 0.39430, 0.19660 ]);
		case 'f4':	return new Float64Array([ 0.44018, 0.40329, 0.15653 ]);
		case 'f5':	return new Float64Array([ 0.31379, 0.34531, 0.34090 ]);
		case 'f6':	return new Float64Array([ 0.37790, 0.38835, 0.23375 ]);
		case 'f7':	return new Float64Array([ 0.31292, 0.32933, 0.35775 ]);
		case 'f8':	return new Float64Array([ 0.34588, 0.35875, 0.29537 ]);
		case 'f9':	return new Float64Array([ 0.37417, 0.37281, 0.25302 ]);
		case 'f10':	return new Float64Array([ 0.34609, 0.35986, 0.29405 ]);
		case 'f11':	return new Float64Array([ 0.38052, 0.37713, 0.24235 ]);
		case 'f12':	return new Float64Array([ 0.43695, 0.40441, 0.15864 ]);
		case 'iso7589studiotungsten':	return new Float64Array([ 0.43088, 0.40784, 0.16128 ]);
		case 'iso7589photoflood':		return new Float64Array([ 0.41154, 0.39851, 0.18995 ]);
		case 'iso7589daylight':			return new Float64Array([ 0.33357, 0.35368, 0.31275 ]);
	}
};
LUTColourSpace.prototype.xyzMatrices = function() {
// S-Gamut3.cine
	this.sysIdx = this.g.length;
	var sgamut3cine = {};
	sgamut3cine.name = 'Sony S-Gamut3.cine';
	sgamut3cine.cat = this.CATs.modelIdx('CIECAT02');
	sgamut3cine.xy = new Float64Array([0.766,0.275, 0.225,0.800, 0.089,-0.087]);
	sgamut3cine.white = this.illuminant('d65');
	sgamut3cine.toXYZ = this.RGBtoXYZ(sgamut3cine.xy,sgamut3cine.white);
	this.g.push(sgamut3cine);
// Venice S-Gamut3.cine
	var vsgamut3cine = {};
	vsgamut3cine.name = 'Sony S-Gamut3.cine (Venice)';
	vsgamut3cine.cat = this.CATs.modelIdx('CIECAT02');
	vsgamut3cine.xy = new Float64Array([0.775901872,0.274502393,	0.188682903,0.828684937,	0.101337383,-0.089187517]);
	vsgamut3cine.white = this.illuminant('d65');
	vsgamut3cine.toXYZ = this.RGBtoXYZ(vsgamut3cine.xy,vsgamut3cine.white);
	this.g.push(vsgamut3cine);
// S-Gamut3
	var sgamut3 = {};
	sgamut3.name = 'Sony S-Gamut3';
	sgamut3.cat = this.CATs.modelIdx('CIECAT02');
	sgamut3.xy = new Float64Array([0.730,0.280, 0.140,0.855, 0.100,-0.05]);
	sgamut3.white = this.illuminant('d65');
	sgamut3.toXYZ = this.RGBtoXYZ(sgamut3.xy,sgamut3.white);
	this.g.push(sgamut3);
// Venice S-Gamut3
	var vsgamut3 = {};
	vsgamut3.name = 'Sony S-Gamut3 (Venice)';
	vsgamut3.cat = this.CATs.modelIdx('CIECAT02');
	vsgamut3.xy = new Float64Array([0.740464264,0.279364375,	0.089241145,0.893809529,	0.110488237,-0.052579333]);
	vsgamut3.white = this.illuminant('d65');
	vsgamut3.toXYZ = this.RGBtoXYZ(vsgamut3.xy,vsgamut3.white);
	this.g.push(vsgamut3);
// S-Gamut
	var sgamut = {};
	sgamut.name = 'Sony S-Gamut';
	sgamut.cat = this.CATs.modelIdx('CIECAT02');
	sgamut.xy = new Float64Array([0.730,0.280, 0.140,0.855, 0.100,-0.05]);
	sgamut.white = this.illuminant('d65');
	sgamut.toXYZ = this.RGBtoXYZ(sgamut.xy,sgamut.white);
	this.g.push(sgamut);
// ARRI Wide Gamut 4
	var arriwg4 = {};
	arriwg4.name = 'ARRI Wide Gamut 4';
	arriwg4.cat = this.CATs.modelIdx('CIECAT02');
	arriwg4.xy = new Float64Array([0.7347,0.2653, 0.1424,0.8576, 0.0991,-0.0308]);
	arriwg4.white = this.illuminant('d65');
	arriwg4.toXYZ = this.RGBtoXYZ(arriwg4.xy,arriwg4.white);
	this.g.push(arriwg4);
// ALEXA Wide Gamut RGB
	var alexawgrgb = {};
	alexawgrgb.name = 'Alexa Wide Gamut';
	alexawgrgb.cat = this.sysCATIdx;
	alexawgrgb.xy = new Float64Array([0.6840,0.3130, 0.2210,0.8480, 0.0861,-0.1020]);
	alexawgrgb.white = this.illuminant('d65');
	alexawgrgb.toXYZ = this.RGBtoXYZ(alexawgrgb.xy,alexawgrgb.white);
	this.g.push(alexawgrgb);
// Canon Cinema Gamut
	var canoncg = {};
	canoncg.name = 'Canon Cinema Gamut';
	canoncg.cat = this.CATs.modelIdx('CIECAT02');
	canoncg.xy = new Float64Array([0.74,0.27, 0.17,1.14, 0.08,-0.10]);
	canoncg.white = this.illuminant('d65');
	canoncg.toXYZ = this.RGBtoXYZ(canoncg.xy,canoncg.white);
	this.g.push(canoncg);
// Blackmagic Wide Gamut
	var blackmagicwg = {};
	blackmagicwg.name = 'Blackmagic Wide Gamut';
	blackmagicwg.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	blackmagicwg.xy = new Float64Array([0.7177215,0.3171181, 0.2280410,0.8615690, 0.1005841,-0.0820452]);
	blackmagicwg.white = new Float64Array([ 0.3127170, 0.3290312, 0.3582518 ]);
	blackmagicwg.toXYZ = this.RGBtoXYZ(blackmagicwg.xy,blackmagicwg.white);
	this.g.push(blackmagicwg);
// DaVinci Wide Gamut
	var davinciwg = {};
	davinciwg.name = 'DaVinci Wide Gamut';
	davinciwg.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	davinciwg.xy = new Float64Array([0.8000,0.3130, 0.1682,0.9877, 0.0790,-0.1155]);
	davinciwg.white = this.illuminant('d65');
	davinciwg.toXYZ = this.RGBtoXYZ(davinciwg.xy,davinciwg.white);
	this.g.push(davinciwg);
// Panasonic V-Gamut
	var vgamut = {};
	vgamut.name = 'Panasonic V-Gamut';
	vgamut.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	vgamut.xy = new Float64Array([0.730,0.280, 0.165,0.840, 0.100,-0.030]);
	vgamut.white = this.illuminant('d65');
	vgamut.toXYZ = this.RGBtoXYZ(vgamut.xy,vgamut.white);
	this.g.push(vgamut);
// BMD 4k Film
	var bmd4k = {};
	bmd4k.name = 'Blackmagic 4k Film';
	bmd4k.cat = this.CATs.modelIdx('CIECAT02');
	bmd4k.xy = new Float64Array([1.065485164,0.395870911, 0.369219642,0.778131628, 0.095906214,0.033373394]);
	bmd4k.white = new Float64Array([ 0.313122422, 0.32974025, 0.357137329 ]);
	bmd4k.toXYZ = this.RGBtoXYZ(bmd4k.xy,bmd4k.white);
	this.g.push(bmd4k);
// BMD 4.6k Film
	var bmd46k = {};
	bmd46k.name = 'Blackmagic 4.6k Film';
	bmd46k.cat = this.CATs.modelIdx('CIECAT02');
	bmd46k.xy = new Float64Array([0.860834693,0.368871184, 0.328213148,0.615592065, 0.07825175,-0.023256123]);
	bmd46k.white = this.illuminant('d65');
	bmd46k.toXYZ = this.RGBtoXYZ(bmd46k.xy,bmd46k.white);
	this.g.push(bmd46k);
// BMD Pocket 6k Film
	var bmdp6k = {};
	bmdp6k.name = 'Blackmagic Pocket 6k Film';
	bmdp6k.cat = this.CATs.modelIdx('CIECAT02');
	bmdp6k.xy = new Float64Array([0.720597149,0.329307006, 0.298281489,0.629701953, 0.132079051,0.031392256]);
	bmdp6k.white = this.illuminant('d65');
	bmdp6k.toXYZ = this.RGBtoXYZ(bmdp6k.xy,bmdp6k.white);
	this.g.push(bmdp6k);
// Fujifilm F-Log Gamut
	var fgamut = {};
	fgamut.name = 'Fujifilm F-Log Gamut';
	fgamut.cat = this.sysCATIdx;
	fgamut.xy = new Float64Array([0.70800,0.29200, 0.17000,0.79700, 0.13100,0.04600]);
	fgamut.white = this.illuminant('d65');
	fgamut.toXYZ = this.RGBtoXYZ(fgamut.xy,fgamut.white);
	this.g.push(fgamut);
// REDWideGamutRGB
	var redWideGamutRGB = {};
	redWideGamutRGB.name = 'REDWideGamutRGB';
	redWideGamutRGB.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	redWideGamutRGB.xy = new Float64Array([0.780308,0.304253, 0.121595,1.493994, 0.095612,-0.084589]);
	redWideGamutRGB.white = this.illuminant('d65');
	redWideGamutRGB.toXYZ = this.RGBtoXYZ(redWideGamutRGB.xy,redWideGamutRGB.white);
	this.g.push(redWideGamutRGB);
// DRAGONColor
	var redDragonColor = {};
	redDragonColor.name = 'DRAGONColor';
	redDragonColor.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	redDragonColor.xy = new Float64Array([0.75002604,0.32671294, 0.32008411,0.68143644, 0.07431725,-0.05592259]);
	redDragonColor.white = this.illuminant('e');
	redDragonColor.toXYZ = this.RGBtoXYZ(redDragonColor.xy,redDragonColor.white);
	this.g.push(redDragonColor);
// DRAGONColor2
	var redDragonColor2 = {};
	redDragonColor2.name = 'DRAGONColor2';
	redDragonColor2.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	redDragonColor2.xy = new Float64Array([0.7500263,0.32671336, 0.32008437,0.68143652, 0.145629,0.05124619]);
	redDragonColor2.white = this.illuminant('e');
	redDragonColor2.toXYZ = this.RGBtoXYZ(redDragonColor2.xy,redDragonColor2.white);
	this.g.push(redDragonColor2);
// REDColor
	var redColor = {};
	redColor.name = 'REDColor';
	redColor.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	redColor.xy = new Float64Array([0.70017112,0.32750563, 0.32289102,0.6077074, 0.13468038,0.03479195]);
	redColor.white = this.illuminant('e');
	redColor.toXYZ = this.RGBtoXYZ(redColor.xy,redColor.white);
	this.g.push(redColor);
// REDColor2
	var redColor2 = {};
	redColor2.name = 'REDColor2';
	redColor2.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	redColor2.xy = new Float64Array([0.86581522,0.32487259, 0.32087226,0.66073571, 0.09160032,-0.02994923]);
	redColor2.white = this.illuminant('e');
	redColor2.toXYZ = this.RGBtoXYZ(redColor2.xy,redColor2.white);
	this.g.push(redColor2);
// REDColor3
	var redColor3 = {};
	redColor3.name = 'REDColor3';
	redColor3.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	redColor3.xy = new Float64Array([0.70151835,0.32748417, 0.32069982,0.66526394, 0.10554785,-0.00898842]);
	redColor3.white = this.illuminant('e');
	redColor3.toXYZ = this.RGBtoXYZ(redColor3.xy,redColor3.white);
	this.g.push(redColor3);
// REDColor4
	var redColor4 = {};
	redColor4.name = 'REDColor4';
	redColor4.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	redColor4.xy = new Float64Array([0.70151793,0.32748374, 0.32069991,0.66526392, 0.14597596,0.05176764]);
	redColor4.white = this.illuminant('e');
	redColor4.toXYZ = this.RGBtoXYZ(redColor4.xy,redColor4.white);
	this.g.push(redColor4);
// Bolex
	var bolex = {};
	bolex.name = 'Bolex Wide Gamut';
	bolex.cat = this.CATs.modelIdx('Bradford Chromatic Adaptation');
	bolex.xy = new Float64Array([0.73000,0.29400, 0.22300,0.82000, 0.10300,-0.05500]);
	bolex.white = this.illuminant('d65');
	bolex.toXYZ = this.RGBtoXYZ(bolex.xy,bolex.white);
	this.g.push(bolex);
// DJI D-Gamut
	var djidgamut = {};
	djidgamut.name = 'DJI D-Gamut';
	djidgamut.cat = this.sysCATIdx;
	djidgamut.xy = new Float64Array([0.71,0.31, 0.21,0.88, 0.09,-0.08]);
	djidgamut.white = this.illuminant('d65');
	djidgamut.toXYZ = this.RGBtoXYZ(djidgamut.xy,djidgamut.white);
	this.g.push(djidgamut);
// DJI D-GamutM
	var djidgamutm = {};
	djidgamutm.name = 'DJI D-GamutM';
	djidgamutm.cat = this.sysCATIdx;
	djidgamutm.xy = new Float64Array([0.721565,0.305591,0.229956,0.802053,0.074012,-0.056283]);
	djidgamutm.white = this.illuminant('d65');
	djidgamutm.toXYZ = this.RGBtoXYZ(djidgamutm.xy,djidgamutm.white);
	this.g.push(djidgamutm);
// Protune Native
	var protune = {};
	protune.name = 'Protune Native';
	protune.cat = this.sysCATIdx;
	protune.xy = new Float64Array([0.70419975,0.19595152, 0.33147178,0.98320117, 0.1037611,-0.04367584]);
	protune.white = this.illuminant('d60');
	protune.toXYZ = this.RGBtoXYZ(protune.xy,protune.white);
	this.g.push(protune);
// Rec709
	var rec709 = {};
	rec709.name = 'Rec709';
	rec709.cat = this.sysCATIdx;
	rec709.xy = new Float64Array([0.64,0.33, 0.30,0.60, 0.15,0.06]);
	rec709.white = this.illuminant('d65');
	rec709.toXYZ = this.RGBtoXYZ(rec709.xy,rec709.white);
	this.rec709Idx = this.g.length;
	this.g.push(rec709);
// Rec2020
	var rec2020 = {};
	rec2020.name = 'Rec2020';
	rec2020.cat = this.sysCATIdx;
	rec2020.xy = new Float64Array([0.708,0.292, 0.170,0.797, 0.131,0.046]);
	rec2020.white = this.illuminant('d65');
	rec2020.toXYZ = this.RGBtoXYZ(rec2020.xy,rec2020.white);
	this.g.push(rec2020);
// Rec2100
	var rec2100 = {};
	rec2100.name = 'Rec2100';
	rec2100.cat = this.sysCATIdx;
	rec2100.xy = new Float64Array([0.708,0.292, 0.170,0.797, 0.131,0.046]);
	rec2100.white = this.illuminant('d65');
	rec2100.toXYZ = this.RGBtoXYZ(rec2100.xy,rec2100.white);
	this.g.push(rec2100);
// sRGB
	var srgb = {};
	srgb.name = 'sRGB';
	srgb.cat = this.sysCATIdx;
	srgb.xy = new Float64Array([0.64,0.33, 0.30,0.60, 0.15,0.06]);
	srgb.white = this.illuminant('d65');
	srgb.toXYZ = this.RGBtoXYZ(srgb.xy,srgb.white);
	this.g.push(srgb);
// ACES AP0
	var aces = {};
	aces.name = 'ACES AP0';
	aces.cat = this.sysCATIdx;
	aces.xy = new Float64Array([0.73470,0.26530, 0.00000,1.00000, 0.00010,-0.07700]);
	aces.white = this.illuminant('d60');
	aces.toXYZ = this.RGBtoXYZ(aces.xy,aces.white);
	this.g.push(aces);
// ACEScg AP1
	var ap1 = {};
	ap1.name = 'ACEScg AP1';
	ap1.cat = this.sysCATIdx;
	ap1.xy = new Float64Array([0.7130,0.2930, 0.1650,0.8300, 0.1280,0.0440]);
	ap1.white = this.illuminant('d60');
	ap1.toXYZ = this.RGBtoXYZ(ap1.xy,ap1.white);
	this.g.push(ap1);
// XYZ
	var xyz = {};
	xyz.name = 'XYZ';
	xyz.cat = this.sysCATIdx;
	xyz.xy = false;
	xyz.white = this.illuminant('d65');
	xyz.toXYZ = new Float64Array([1,0,0, 0,1,0, 0,0,1]);
	this.xyzIdx = this.g.length;
	this.g.push(xyz);
// P3 - DCI
	var p3 = {};
	p3.name = 'P3 - DCI';
	p3.cat = this.sysCATIdx;
	p3.xy = new Float64Array([0.680,0.320, 0.265,0.690, 0.150,0.060]);
	p3.white = this.illuminant('p3');
	p3.toXYZ = this.RGBtoXYZ(p3.xy,p3.white);
	this.g.push(p3);
// P3 - D60
	var p3d60 = {};
	p3d60.name = 'P3 - D60';
	p3d60.cat = this.sysCATIdx;
	p3d60.xy = new Float64Array([0.680,0.320, 0.265,0.690, 0.150,0.060]);
	p3d60.white = this.illuminant('d60');
	p3d60.toXYZ = this.RGBtoXYZ(p3d60.xy,p3d60.white);
	this.g.push(p3d60);
// P3 - D65
	var p3d65 = {};
	p3d65.name = 'P3 - D65';
	p3d65.cat = this.sysCATIdx;
	p3d65.xy = new Float64Array([0.680,0.320, 0.265,0.690, 0.150,0.060]);
	p3d65.white = this.illuminant('d65');
	p3d65.toXYZ = this.RGBtoXYZ(p3d65.xy,p3d65.white);
	this.g.push(p3d65);
// Canon DCI-P3+
	var canonp3p = {};
	canonp3p.name = 'Canon DCI-P3+';
	canonp3p.cat = this.sysCATIdx;
	canonp3p.xy = new Float64Array([0.74,0.27, 0.22,0.78, 0.09,-0.09]);
	canonp3p.white = this.illuminant('p3');
	canonp3p.toXYZ = this.RGBtoXYZ(canonp3p.xy,canonp3p.white);
	this.g.push(canonp3p);
// Adobe RGB
	var adobergb = {};
	adobergb.name = 'Adobe RGB';
	adobergb.cat = this.sysCATIdx;
	adobergb.xy = new Float64Array([0.64,0.33, 0.21,0.71, 0.15,0.06]);
	adobergb.white = this.illuminant('d65');
	adobergb.toXYZ = this.RGBtoXYZ(adobergb.xy,adobergb.white);
	this.g.push(adobergb);
// Adobe Wide Gamut RGB
	var adobewg = {};
	adobewg.name = 'Adobe Wide Gamut RGB';
	adobewg.cat = this.sysCATIdx;
	adobewg.xy = new Float64Array([0.7347,0.2653, 0.1152,0.8264, 0.1566,0.0177]);
	adobewg.white = this.illuminant('d50');
	adobewg.toXYZ = this.RGBtoXYZ(adobewg.xy,adobewg.white);
	this.g.push(adobewg);
// ProPhoto rgb
	var prophoto = {};
	prophoto.name = 'ProPhoto RGB';
	prophoto.cat = this.sysCATIdx;
	prophoto.xy = new Float64Array([0.7347,0.2653, 0.1596,0.8404, 0.0366,0.0001]);
	prophoto.white = this.illuminant('d50');
	prophoto.toXYZ = this.RGBtoXYZ(prophoto.xy,prophoto.white);
	this.g.push(prophoto);
// Custom In (initially Rec709)
	var customIn = {};
	customIn.name = 'Custom In';
	customIn.cat = this.sysCATIdx;
	customIn.xy = new Float64Array([0.64,0.33, 0.30,0.60, 0.15,0.06]);
	customIn.white = this.illuminant('d65');
	customIn.toXYZ = this.RGBtoXYZ(customIn.xy,customIn.white);
	this.g.push(customIn);
// Custom Out (initially Rec709)
	var customOut = {};
	customOut.name = 'Custom Out';
	customOut.cat = this.sysCATIdx;
	customOut.xy = new Float64Array([0.64,0.33, 0.30,0.60, 0.15,0.06]);
	customOut.white = this.illuminant('d65');
	customOut.toXYZ = this.RGBtoXYZ(customOut.xy,customOut.white);
	this.g.push(customOut);
};
LUTColourSpace.prototype.systemMatrices = function() {
	var max = this.g.length;
	for (var j=0; j<max; j++) {
		if (this.g[j].name !== 'Custom In' && this.g[j].name !== 'Custom Out' && this.g[j].name !== 'Passthrough') {
			this.matList.push({name: this.g[j].name,idx: j});
		}
		if (j === this.sysIdx) {
			this.g[j].toSys = new Float64Array([1,0,0, 0,1,0, 0,0,1]);
		} else if (this.g[j].name === 'XYZ') {
			this.g[j].toSys = this.system.fromXYZ;
		} else if (this.g[j].white[0] !== this.system.white[0] && this.g[j].white[1] !== this.system.white[1] && this.g[j].white[2] !== this.system.white[2]) {
			this.g[j].toSys = this.mMult(this.system.fromXYZ, this.calcCAT(this.g[j].toXYZ,this.g[j].white,this.system.white,this.g[j].cat));
		} else {
			this.g[j].toSys = this.mMult(this.system.fromXYZ, this.g[j].toXYZ);
		}
		// console.log(this.g[j].name);
		// console.log(this.g[j].toXYZ);
	}
};
LUTColourSpace.prototype.initPSSTCDL = function() {
	this.psstMC = true;
	this.psstYC = false;
	this.psstC = new Ring();
  	this.psstC.setDetails({
		title: 'Colour',
		L: new Float64Array([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0
		]).buffer,
		p: false,
		mod: 1
	});
	this.psstSat = new Ring();
  	this.psstSat.setDetails({
		title: 'Saturation',
		L: new Float64Array([
			1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,
			1,1,1,1,1
		]).buffer,
		p: false
	});
	this.psstS = new Ring();
  	this.psstS.setDetails({
		title: 'Slope',
		L: new Float64Array([
			1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,
			1,1,1,1,1
		]).buffer,
		p: false
	});
	this.psstO = new Ring();
  	this.psstO.setDetails({
		title: 'Offset',
		L: new Float64Array([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0
		]).buffer,
		p: false
	});
	this.psstP = new Ring();
  	this.psstP.setDetails({
		title: 'Power',
		L: new Float64Array([
			1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,
			1,1,1,1,1
		]).buffer,
		p: false
	});
	this.psstF = new Ring();
  	this.psstF.setDetails({
		title: 'Forward',
		L: new Float64Array([
		   -0.0038695657404562, 0.0065858762356100, 0.0201406099404900, 0.0352828041364269, 0.0520594851346660, 0.0701816671759477, 0.0888871169278112, 0.1071434832095446, 0.1241300598546256,
			0.1394968704492374, 0.1532401783604684, 0.1657675172633559, 0.1775709068913177, 0.1889505001250262, 0.2001195960344167, 0.2112553615444404, 0.2225296284119030, 0.2341370761420996,
			0.2463352166687472, 0.2595247516121330, 0.2744679542490435, 0.2933226298747170, 0.3287624039244701, 0.4006899403301722, 0.4276051836096898, 0.4447257669774564, 0.4589794729871186,
			0.4717842618396581, 0.4837468755866364, 0.4952093965712169, 0.5064034638133755, 0.5175127750345129, 0.5287073445057027, 0.5401709526670702, 0.5521354485080856, 0.5649433872473982,
			0.5790664946157549, 0.5943630562521310, 0.6106992294013223, 0.6278535155401859, 0.6454346342920819, 0.6629428672584311, 0.6798980496803277, 0.6959546592769115, 0.7109387359446133,
			0.7250595197384678, 0.7388861383721239, 0.7524290718192624, 0.7656794919842305, 0.7786321731846290, 0.7912850081995813, 0.8036385234867822, 0.8156954169692322, 0.8274601335361318,
			0.8389384865889260, 0.8501373280139014, 0.8610751527873562, 0.8718717120052339, 0.8825403689956453, 0.8930611389578428, 0.9034170399839038, 0.9135941187798583, 0.9235814085450882,
			0.9333707275123123, 0.9429564536395982, 0.9523352418731073, 0.9615057270095099, 0.9704682268100525, 0.9792244585320422, 0.9877772736056640, 0.9961304342481022
		]).buffer,
		p: true
	});
	this.psstB = new Ring();
  	this.psstB.setDetails({
		title: 'Back',
		L: new Float64Array([
			0.042311434,
			0.828850698,
			1.852489293,
			2.158688535,
			3.183904084,
			3.970443351,
			4.994081951,
			6.325496742
		]).buffer,
		p: true
	});
	this.psstY = new Ring();
  	this.psstY.setDetails({
		title: 'Luma',
		L: new Float64Array([
			0.0722,
			0.2848,
			0.2126,
			0.6,
//			0.3082,
			0.9278,
			0.7152,
			0.7874,
			0.0722
		]).buffer,
		p: false
	});
	this.psstM = new Ring();
  	this.psstM.setDetails({
		title: 'CbCr Magnitude',
		L: new Float64Array([
			0.346430745,0.342962699,0.33969838,0.337347957,0.336560982,0.337917133,0.341937773,0.349106433,0.359887984,
			0.374737194,0.394086142,0.361208741,0.334229968,0.31322564,0.297800651,0.287381612,0.281345482,0.279049081,
			0.279803042,0.282820273,0.287167419,0.2780547,0.272555398,0.269216643,0.267119872,0.265609644,0.264162578,
			0.262344581,0.259835788,0.256508476,0.252538822,0.248681245,0.245993008,0.245298419,0.247291756,0.252580435,
			0.261730792,0.275291255,0.293766309,0.317502734,0.346430744,0.340484523,0.337392505,0.336559654,0.337660332,
			0.340582153,0.345407661,0.352427205,0.362187055,0.375589699,0.394086141,0.362588341,0.337932638,0.318643857,
			0.303748703,0.292615326,0.284863469,0.280318319,0.278996163,0.281119417,0.287167418,0.269072329,0.25607167,
			0.248148933,0.24525667,0.247440263,0.254900418,0.268012927,0.287301219,0.313327834,0.346430745
		]).buffer,
		p: false
	});
};
LUTColourSpace.prototype.calcYCoeffs = function(cs) {
	var cur = this.curOut;
	if (typeof cs !== 'undefined') {
		var m = this.csOut.length;
		for (var j=0; j<m; j++) {
			if (this.csOut[j].name === cs) {
				cur = j;
			}
		}
	}
	var g = new Float64Array([ // The output gamut - these values to be converted to XYZ then xy
		1,0,0,
		0,1,0,
		0,0,1
	]);
	var xy = new Float64Array(9);
	var l,den;
	var wd,ws;
	var XYZ;
//	this.rx(g.buffer);
	this.csM[cur].rc(g.buffer);
	this.csOut[this.XYZOut].lc(g.buffer);
	wd = this.csOut[cur].getWP();
	ws = this.system.white;
	for (var j=0; j<3; j++) {
		k = j*3;
		XYZ = this.calcCAT(new Float64Array([g[k],g[k+1],g[k+2]]),ws,wd,this.outCATs[cur]);
		den = XYZ[0] + XYZ[1] + XYZ[2];
		xy[ k ] = (XYZ[0]/den);
		xy[k+1] = (XYZ[1]/den);
		xy[k+2] = (XYZ[2]/den);
	}
	var C = new Float64Array([
		xy[0],xy[3],xy[6],
		xy[1],xy[4],xy[7],
		xy[2],xy[5],xy[8]
	]);
	var invC = this.mInverse(C);
	var W = new Float64Array([wd[0]/wd[1],1,(1-wd[0]-wd[1])/wd[1]]);
	var J = this.mMult(invC,W);
	return new Float64Array([J[0]*C[3],J[1]*C[4],J[2]*C[5]]);
};
LUTColourSpace.prototype.setYCoeffs = function() {
	this.y = this.getYCoeffs(this.system.name);
};
LUTColourSpace.prototype.getYCoeffs = function(cs) {
	var xy,w;
	if (typeof cs === 'number') {
		xy = this.g[cs].xy;
		w = this.g[cs].white;
	} else {
		var m = this.g.length;
		for (var j=0; j<m; j++) {
			if (this.g[j].name === cs) {
				xy = this.g[j].xy;
				w = this.g[j].white;
			}
		}
	}
	var C = new Float64Array([
		xy[0],xy[2],xy[4],
		xy[1],xy[3],xy[5],
		1-xy[0]-xy[1],1-xy[2]-xy[3],1-xy[4]-xy[5]
	]);
	var invC = this.mInverse(C);
	var W = new Float64Array([w[0]/w[1],1,(1-w[0]-w[1])/w[1]]);
	var J = this.mMult(invC,W);
//	console.log(W);
	return new Float64Array([J[0]*C[3],J[1]*C[4],J[2]*C[5]]);
};
LUTColourSpace.prototype.setSaturated = function() {
	var max = this.g.length;
	var idx = this.rec709Idx;
	var y = this.mMult(this.g[idx].toSys, new Float64Array([ 1,1,0 ]));
	var c = this.mMult(this.g[idx].toSys, new Float64Array([ 0,1,1 ]));
	var g = this.mMult(this.g[idx].toSys, new Float64Array([ 0,1,0 ]));
	var m = this.mMult(this.g[idx].toSys, new Float64Array([ 1,0,1 ]));
	var r = this.mMult(this.g[idx].toSys, new Float64Array([ 1,0,0 ]));
	var b = this.mMult(this.g[idx].toSys, new Float64Array([ 0,0,1 ]));
	this.clrs = new Float64Array([
		y[0],y[1],y[2],
		c[0],c[1],c[2],
		g[0],g[1],g[2],
		m[0],m[1],m[2],
		r[0],r[1],r[2],
		b[0],b[1],b[2]
	]).buffer;
};
LUTColourSpace.prototype.buildColourSquare = function() {
	var d = 256;
	var colSqr = new Float64Array(d*d*3);
	this.colSqr = colSqr.buffer;
	var j=0;
	var r,g,b;
	var Hd,S,L,C,X,m;
	for (var y=0; y<d; y++) {
		for (var x=0; x<d; x++) {
			Hd = 6*x/(d-1);
			S = 1-(y/(d-1));
			L = 0.5;
			C = (1-Math.abs((2*L)-1))*S;
			X = C*(1 - Math.abs((Hd%2) - 1));
			if (Hd < 1) {
				r = C;
				g = X;
				b = 0;
			} else if (Hd < 2) {
				r = X;
				g = C;
				b = 0;
			} else if (Hd < 3) {
				r = 0;
				g = C;
				b = X;
			} else if (Hd < 4) {
				r = 0;
				g = X;
				b = C;
			} else if (Hd < 5) {
				r = X;
				g = 0;
				b = C;
			} else {
				r = C;
				g = 0;
				b = X;
			}
			m = L - (0.5*C);
			colSqr[ j ] = r + m;
			colSqr[j+1] = g + m;
			colSqr[j+2] = b + m;
			j += 3;
		}
	}
	this.csIn[this.rec709In].lc(this.colSqr);
};
LUTColourSpace.prototype.buildMultiColours = function() {
	var mclrs = new Float64Array(17*3*3);
	this.mclrs = mclrs.buffer;
	var l;
	for (var j=0; j<17; j++) {
		l = Math.pow(2,j-8)*0.2;
		mclrs[ j*3 ] = l/0.2126;
		mclrs[((j+17)*3)+1] = l/0.7152;
		mclrs[((j+34)*3)+2] = l/0.0722;
	}
	this.csIn[this.rec709In].lc(this.mclrs);
	this.multiSat = new Float64Array([
		1,1,1,1,1,1,1,1,
		1,
		1,1,1,1,1,1,1,1
	]);
};
// Parameter setting functions
LUTColourSpace.prototype.setCS = function(params) {
	var out = {};
	if (typeof params.twkCS !== 'undefined') {
		var p = params.twkCS;
		out.editIdx = p.editIdx;
		var modelEdit = 0;
		if (typeof p.edit.cat === 'number') {
			modelEdit = p.edit.cat;
		}
		var modelIn = 0;
		if (typeof p.input.cat === 'number') {
			modelIn = p.input.cat;
		}
		var modelOut = 0;
		if (typeof p.output.cat === 'number') {
			modelOut = p.output.cat;
		}

		var edit = {};
		var customIn = {};
		var customOut = {};

		if (!p.edit.isMatrix && p.lock) {
			edit.xy = new Float64Array([
				p.edit.rx, p.edit.ry,
				p.edit.gx, p.edit.gy,
				p.edit.bx, p.edit.by
			]);
			edit.white = new Float64Array([
				p.edit.wx, p.edit.wy, 1 - p.edit.wx - p.edit.wy
			]);
			edit.toXYZ = this.RGBtoXYZ(edit.xy,edit.white);
			if (p.edit.wcs === this.xyzIdx) {
				this.edMatrix = this.RGBtoXYZ(edit.xy,edit.white);
			} else {
				this.edMatrix = this.mMult(this.mInverse(this.g[p.edit.wcs].toXYZ), this.calcCAT(edit.toXYZ,edit.white,this.g[p.edit.wcs].white,modelEdit));
			}
			out.editMatrix = new Float64Array(this.edMatrix.buffer.slice(0));
			out.wcs = p.edit.wcs;
			out.xyVals = edit.xy;
		} else if (p.edit.isMatrix) {
// primaries from matrix and white point code would go here!
			edit.white = new Float64Array([
				p.edit.wx, p.edit.wy, 1 - p.edit.wx - p.edit.wy
			]);
			var editToXYZ = this.calcCAT(
				this.mMult(this.g[p.edit.wcs].toXYZ,p.edit.matrix),
				this.g[p.edit.wcs].white,
				edit.white,
				modelIn
			);
			var mu = new Float64Array([
				(editToXYZ[0]+editToXYZ[3]+editToXYZ[6]),
				(editToXYZ[1]+editToXYZ[4]+editToXYZ[7]),
				(editToXYZ[2]+editToXYZ[5]+editToXYZ[8])
			]);
			edit.xy = new Float64Array([
				Math.round(editToXYZ[0]/mu[0]*10000000)/10000000, Math.round(editToXYZ[3]/mu[0]*10000000)/10000000,
				Math.round(editToXYZ[1]/mu[1]*10000000)/10000000, Math.round(editToXYZ[4]/mu[1]*10000000)/10000000,
				Math.round(editToXYZ[2]/mu[2]*10000000)/10000000, Math.round(editToXYZ[5]/mu[2]*10000000)/10000000
			]);
			out.xyVals = edit.xy;
		}

		if (p.input.isMatrix) {
			customIn.white = new Float64Array([ p.input.wx, p.input.wy, 1 - p.input.wx - p.input.wy ]);
			if (p.input.wcs === this.xyzIdx) {
				var inWCSToSys = this.system.fromXYZ;
			} else {
				var inWCSToSys = this.mMult(
					this.system.fromXYZ,
					this.calcCAT(
						this.g[p.input.wcs].toXYZ,
						this.g[p.input.wcs].white,
						this.system.white,
						modelIn
					)
				);
			}
			customIn.toSys = this.mMult(inWCSToSys, p.input.matrix);
		} else {
			customIn.white = new Float64Array([ p.input.wx, p.input.wy, 1 - p.input.wx - p.input.wy ]);
			customIn.xy = new Float64Array([
				p.input.rx, p.input.ry,
				p.input.gx, p.input.gy,
				p.input.bx, p.input.by
			]);
			customIn.toXYZ = this.RGBtoXYZ(customIn.xy,customIn.white);
			customIn.toSys = this.mMult(
				this.system.fromXYZ,
				this.calcCAT(
					customIn.toXYZ,
					customIn.white,
					this.system.white,
					modelIn
				)
			);
		}

		if (p.output.isMatrix) {
			customOut.white = new Float64Array([ p.output.wx, p.output.wy, 1 - p.output.wx - p.output.wy ])
			if (p.output.wcs === this.xyzIdx) {
				var outWCSFromSys = this.system.toXYZ;
			} else {
				var outWCSFromSys = this.mInverse(this.mMult(
					this.system.fromXYZ,
					this.calcCAT(
						this.g[p.output.wcs].toXYZ,
						this.g[p.output.wcs].white,
						this.system.white,
						modelOut
					)
				));
			}
			customOut.fromSys = this.mMult(p.output.matrix, outWCSFromSys);
		} else {
			customOut.white = new Float64Array([ p.output.wx, p.output.wy, 1 - p.output.wx - p.output.wy ])
			customOut.xy = new Float64Array([
				p.output.rx, p.output.ry,
				p.output.gx, p.output.gy,
				p.output.bx, p.output.by
			]);
			customOut.toXYZ = this.RGBtoXYZ(customOut.xy,customOut.white);
			customOut.fromSys = this.mInverse(this.mMult(
				this.system.fromXYZ,
				this.calcCAT(
					customOut.toXYZ,
					customOut.white,
					this.system.white,
					modelOut
				)
			));
		}

		this.csIn[this.custIn] = new CSMatrix(
			'Custom',
			customIn.toSys,
			customIn.white.buffer
		);
		this.csOut[this.custOut] = new CSMatrix(
			'Custom',
			customOut.fromSys,
			customOut.white.buffer
		);
		this.csM[this.custOut] = this.csOut[this.custOut];

		out.doCS = true;
	} else {
		out.doCS = false;
	}
	return out;
};
LUTColourSpace.prototype.setWB = function(params) {
	var out = {};
	this.doWB = false;
	if (this.tweaks && typeof params.twkWB !== 'undefined') {
		var p = params.twkWB;
		if (typeof p.doWB === 'boolean' && p.doWB) {
			this.doWB = true;
			if (typeof p.CAT === 'number') {
				this.wb.setModel(p.CAT);
				out.CAT = params.CAT;
			}
			out.ref = p.ref;
			out.ctShift = p.ctShift;
			out.lampShift = p.lampShift;
			out.duv = p.duv;
			out.dpl = p.dpl;
			this.wb.setVals(p.ref, p.ctShift, p.lampShift, p.duv, p.dpl);
		}
	}
	out.doWB = this.doWB;
	return out;
};
LUTColourSpace.prototype.setASCCDL = function(params) {
	var out = {};
	this.doASCCDL = false;
	this.changedASCCDL = false;
	if (this.tweaks && typeof params.twkASCCDL !== 'undefined') {
		var p = params.twkASCCDL;
		if (typeof p.doASCCDL === 'boolean') {
			var didASCCDL = this.doASCCDL;
			this.doASCCDL = p.doASCCDL;		
			if (didASCCDL && !this.doASCCDL) {
				this.changedASCCDL = true;
			}
		}
		if (typeof p.cdl !== 'undefined') {
			var newCDL = new Float64Array(p.cdl);
			for (var j=0; j<10; j++) {
				if (newCDL[j] !== this.asc[j]) {
					this.asc = newCDL;
					if (j < 9) {
						this.changedASCCDL = true;
					}
					break;
				}
			}
		}
	}
	out.doASCCDL = this.doASCCDL;
	return out;
};
LUTColourSpace.prototype.setPSSTCDL = function(params) {
	var out = {};
	this.doPSSTCDL = false;
	if (this.tweaks && typeof params.twkPSSTCDL !== 'undefined') {
		var p = params.twkPSSTCDL;
		if (typeof p.doPSSTCDL === 'boolean' && p.doPSSTCDL) {
			this.doPSSTCDL = true;		
			if (typeof p.c !== 'undefined') {
				this.psstC.setL(p.c);
			}
			if (typeof p.sat !== 'undefined') {
				this.psstSat.setL(p.sat);
			}
			if (typeof p.s !== 'undefined') {
				this.psstS.setL(p.s);
			}
			if (typeof p.o !== 'undefined') {
				this.psstO.setL(p.o);
			}
			if (typeof p.p !== 'undefined') {
				this.psstP.setL(p.p);
			}
			if (typeof p.chromaScale === 'boolean') {
				this.psstMC = p.chromaScale;
			}
			if (typeof p.lumaScale === 'boolean') {
				this.psstYC = p.lumaScale;
			}
		}
	}
	out.doPSSTCDL = this.doPSSTCDL;
	return out;
};
LUTColourSpace.prototype.setHG = function(params) {
	var out = {};
	this.doHG = false;
	this.curHG = this.curOut;
	if (this.tweaks && typeof params.twkHG !== 'undefined') {
		var p = params.twkHG;
		if (typeof p.doHG === 'boolean' && p.doHG) {
			this.doHG = true;
		}
		if (typeof p.gamut === 'number') {
			this.curHG = p.gamut;
		}

		if (typeof p.lin === 'boolean') {
			this.hgLin = p.lin;
			out.lin = this.hgLin;
		} else {
			this.doHG = false;
		}
		if (typeof p.low === 'number') {
			this.hgLowStop = p.low;
			this.hgLow = Math.pow(2,this.hgLowStop)/5;
			out.low = this.hgLowStop;
		} else {
			this.doHG = false;
		}
		if (typeof p.high === 'number') {
			this.hgHighStop = p.high;
			this.hgHigh = Math.pow(2,this.hgHighStop)/5;
			out.high = this.hgHighStop;
		} else {
			this.doHG = false;
		}
	}
	out.gamut = this.curHG;
	out.doHG = this.doHG;
	return out;
};
LUTColourSpace.prototype.setMulti = function(params) {
	var out = {};
	this.doMulti = false;
	if (this.tweaks && typeof params.twkMulti !== 'undefined') {
		var p = params.twkMulti;
		if (typeof p.doMulti === 'boolean' && p.doMulti) {
			this.doMulti = true;
		}
		if (typeof p.sat !== 'undefined') {
			this.multiSat = new Float64Array(p.sat);
		}
		if (typeof p.sat !== 'undefined') {
			this.multiSat = new Float64Array(p.sat);
		}
		if (typeof p.pHue !== 'undefined' && typeof p.pSat !== 'undefined' && typeof p.pStop !== 'undefined') {
			this.multiStop = new Float64Array(p.pStop);
			var h = new Uint8Array(p.pHue);
			var s = new Uint8Array(p.pSat);
			var m = this.multiStop.length;
			this.multiRGB = new Float64Array(m*3);
			var f = new Float64Array(this.colSqr);
			var k;
			for (var j=0; j<m; j++) {
				k = (h[j]+(256*(255-s[j])))*3;
				this.multiRGB[ (j*3) ] = f[ k ];
				this.multiRGB[(j*3)+1] = f[k+1];
				this.multiRGB[(j*3)+2] = f[k+2];
			}
			this.csOut[this.curOut].lc(this.multiRGB.buffer);
		} else {
			this.multiStop = new Float64Array([0]);
			this.multiRGB = new Float64Array([1,1,1]);
		}
	}
	out.doMulti = this.doMulti;
	return out;
};
LUTColourSpace.prototype.setSDRSat = function(params) {
	var out = {};
	this.doSDRSat = false;
	if (this.tweaks && typeof params.twkSDRSat !== 'undefined') {
		var p = params.twkSDRSat;
		if (typeof p.doSDRSat === 'boolean' && p.doSDRSat) {
			this.doSDRSat = true;
			if (typeof p.gamma === 'number') {
				this.sdrSatGamma = p.gamma;
			}
		}
	}
	out.doSDRSat = this.doSDRSat;
	return out;
};
LUTColourSpace.prototype.setGamutLim = function(params) {
	var out = {};
	this.doGamutLim = false;
	if (this.tweaks && typeof params.twkGamutLim !== 'undefined') {
		var p = params.twkGamutLim;
		if (typeof p.doGamutLim === 'boolean' && p.doGamutLim) {
			this.doGamutLim = true;
			this.gLimY = this.calcYCoeffs();
			if (typeof p.gamut === 'string') {
				this.gLimC = false;
				this.gLimB = true;
				var m = this.csOut.length;
				for (var j=0; j<m; j++) {
					if (this.csOut[j].name === p.gamut) {
						if (j === this.curOut) {
							this.gLimGIn = 0;
							this.gLimGOut = this.curOut;
							break;
						} else {
							this.gLimGOut = j;
							var m2 = this.csIn.length;
							for (var k=0; k<m2; k++) {
								if (this.csIn[k].name === this.csOut[this.curOut].name) {
									this.gLimGIn = k;
									this.gLimC = true;
									this.gLimB = p.both;
									break;
								}
							}
						}
						break;
					}
				}
			} else {
				this.gLimC = false;
			}
			if (typeof p.lin === 'boolean') {
				this.gLimLin = p.lin;
			} else {
				this.gLimLin = false;
			}
			if (typeof p.level === 'number') {
				this.gLimL = parseFloat(p.level);
			}
		}
	}
	return out;
};
LUTColourSpace.prototype.setFC = function(params) {
	var out = {};
	this.doFC = false;
	this.fcVals[0] = -10;	// Purple - Black Clip
	this.fcVals[1] = -10;	// Blue - Just Above Black Clip (18%-6.1 stops)
	this.fcVals[2] = -10;	// Green - 18%-0.2 Stop
	this.fcVals[3] = -10;	// Green - 18%+0.2 stop
	this.fcVals[4] = -10;	// Pink - One Stop Over 18%-0.175 Stop
	this.fcVals[5] = -10;	// Pink - One Stop Over 18%+0.175 Stop
	this.fcVals[6] = -10;	// Orange - 90% White-0.175 Stop
	this.fcVals[7] = -10;	// Orange - 90% White+0.175 Stop
	this.fcVals[8] = -10;	// Yellow - White Clip (Sony F55,F5,FS7)-0.25 Stop
	this.fcVals[9] = -10;	// Red - White Clip (Sony F55,F5,FS7)
	this.doFCPurple = false;
	this.doFCYellow = false;
	this.doFCRed = false;
	if (this.tweaks && typeof params.twkFC !== 'undefined') {
		var p = params.twkFC;
		if (typeof p.doFC === 'boolean' && p.doFC) {
			this.doFC = true;
			var noFCs = true;
			if (typeof p.fcs !== 'undefined') {
				var fcs = p.fcs;
				if (fcs[0]) { 
					this.fcVals[0] = Math.pow(2,-8)*0.2; // default 8 stops below 18% gray
					this.doFCPurple = true;
					noFCs = false;
				}
				if (fcs[1]) {
					if (typeof p.blue === 'number') {
						this.fcVals[1] = Math.pow(2,-p.blue)*0.2;
					} else {
						this.fcVals[1] = Math.pow(2,-6.1)*0.2; // default 6.1 stops below 18% gray
					}
					this.fcVals[0] = Math.pow(2,-10)*0.2; // default 10 stops below 18% gray
					noFCs = false;
				}
				if (fcs[2]) {
					this.fcVals[2] = 0.174110113;
					this.fcVals[3] = 0.229739671;
					noFCs = false;
				}
				if (fcs[3]) {
					this.fcVals[4] = 0.354307008;
					this.fcVals[5] = 0.451585762;
					noFCs = false;
				}
				if (fcs[4]) {
					this.fcVals[6] = 0.885767519;
					this.fcVals[7] = 1.128964405;
					noFCs = false;
				}
				if (fcs[5]) {
					if (typeof p.yellow === 'number') {
						if (typeof p.red === 'number') {
							this.fcVals[8] = Math.pow(2,p.red-p.yellow)*0.2;
						} else {
							this.fcVals[8] = Math.pow(2,5.95-p.yellow)*0.2;
						}
					} else {
						if (typeof p.red === 'number') {
							this.fcVals[8] = Math.pow(2,p.red-0.26)*0.2; // default 0.26 stops below white clip
						} else {
							this.fcVals[8] = Math.pow(2,5.95-0.26)*0.2; // default 0.26 stops below white clip
						}
					}
					this.fcVals[9] = Math.pow(2,5.95)*0.2; // default 5.95 stops above mid gray
					this.doFCYellow = true;
					noFCs = false;
				}
				if (fcs[6]) {
					if (typeof p.red === 'number') {
						this.fcVals[9] = Math.pow(2,p.red)*0.2;
					} else {
						this.fcVals[9] = Math.pow(2,5.95)*0.2; // default 5.95 stops above mid gray
					}
					this.doFCRed = true;
					noFCs = false;
				}
				if (noFCs) {
					this.doFC = false;
				}
			} else {
				this.doFC = false;
			}
		}
	}
	out.blue = Math.log(this.fcVals[1]/0.2)/Math.log(2);
	out.yellow = Math.log(this.fcVals[8]/0.2)/Math.log(2);
	out.red = Math.log(this.fcVals[9]/0.2)/Math.log(2);
	out.doFC = this.doFC;
	return out;
};
// Adjustment functions
LUTColourSpace.prototype.FCOut = function(buff,out) {
	var o = new Float64Array(buff);
	var m = o.length;
	var y = this.y;
	var Y;
	var fc = new Uint8Array(m/3);
	out.fc = fc.buffer;
	out.to.push('fc');
	var k;
	for (var j=0; j<m; j += 3) {
		k = parseInt(j/3);
		Y = (y[0]*o[j])+(y[1]*o[j+1])+(y[2]*o[j+2]);
		for (var s=0; s<10; s++) {
			if (this.fcVals[s] !==-10 && Y <= this.fcVals[s]) {
				fc[k] = s;
				break;
			}
		}
		if (fc[k] === 0 && this.doFCRed && Y > this.fcVals[9]) {
			fc[k] = 10;
		} else if ((fc[k] === 0  && Y > this.fcVals[0]) || (fc[k] === 0 && !this.doFCPurple && Y < 0.1) || (fc[k] === 9 && !this.doFCYellow)) {
			fc[k] = 8;
		}
	}
};
LUTColourSpace.prototype.PSSTCDLOut = function(buff) {
	var o = new Float64Array(buff);
	var max = o.length;
	var y = this.y;
	var Y;
	var Pb,Pr;
	var m,h,f,y1,y2,m1,m2,col,sat,S,O,P,M,a;
	var Db = 2*(1-y[2]);
	var Dr = 2*(1-y[0]);
	for (var j=0; j<max; j += 3) {
		Y = (y[0]*o[j])+(y[1]*o[j+1])+(y[2]*o[j+2]);
		Pb = (o[j+2]-Y)/Db;
		Pr = (o[ j ]-Y)/Dr;
		m = Math.pow((Pb*Pb)+(Pr*Pr),0.5);
		h = Math.atan2(Pr,Pb)/(2*Math.PI); // converts coordinates to angle from x-axis. 0-deg = 0, 360-deg = 1
		if (h < 0) {
			h += 1;
		}
		f = this.psstF.fCub(h);
		y1 = this.psstY.fLin(f);
		m1 = this.psstM.fLin(f);
		col = this.psstC.fCub(f);
		sat = Math.max(0,this.psstSat.fCub(f));
		S = Math.max(0,this.psstS.fCub(f));
		O = this.psstO.fCub(f);
		P = Math.max(0,this.psstP.fCub(f));
		f = (f+col)%1;
		if (this.psstYC) {
			y2 = this.psstY.fLin(f);
		} else {
			y2 = y1;
		}
		if (this.psstMC) {
			m2 = this.psstM.fLin(f);
		} else {
			m2 = m1;
		}
		M = m*sat*m2/m1;
		a = this.psstB.fCub(f);
		if (m > 0.005) {
			Y = (Y*S/y1)+O;
			Y = ((Y<0)?Y:Math.pow(Y,P));
			Y = (isNaN(Y)?0:Y);
			Y *= y2;
			Pb = M * Math.cos(a);
			Pr = M * Math.sin(a);
		} else {
			var Y2 = (Y*S/y1)+O;
			Y2 = ((Y2<0)?Y2:Math.pow(Y2,P));
			Y2 = (isNaN(Y2)?0:Y2);
			Y2 *= y2;
			Y =  (((0.005-m) * Y) + (m * Y2))/0.005;
			Pb = (((0.005-m) * Pb) + (m * M * Math.cos(a)))/0.005;
			Pr = (((0.005-m) * Pr) + (m * M * Math.sin(a)))/0.005;
		}
		o[ j ] = (Pr * Dr) + Y;
		o[j+2] = (Pb * Db) + Y;
		o[j+1] = (Y - (y[0]*o[ j ]) -(y[2]*o[j+2]))/y[1];
	}
};
LUTColourSpace.prototype.ASCCDLOut = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	var y = this.y;
	var Y;
	for (var j=0; j<m; j += 3) {
		o[ j ] = (o[ j ]*this.asc[0])+this.asc[3];
		o[ j ] = ((o[ j ]<0)?o[ j ]:Math.pow(o[ j ],this.asc[6]));
		o[ j ] = (isNaN(o[ j ])?0:o[ j ]);
		o[j+1] = (o[j+1]*this.asc[1])+this.asc[4];
		o[j+1] = ((o[j+1]<0)?o[j+1]:Math.pow(o[j+1],this.asc[7]));
		o[j+1] = (isNaN(o[j+1])?0:o[j+1]);
		o[j+2] = (o[j+2]*this.asc[2])+this.asc[5];
		o[j+2] = ((o[j+2]<0)?o[j+2]:Math.pow(o[j+2],this.asc[8]));
		o[j+2] = (isNaN(o[j+2])?0:o[j+2]);
		Y = (y[0]*o[j])+(y[1]*o[j+1])+(y[2]*o[j+2]);
		o[ j ] = Y + (this.asc[9]*(o[ j ]-Y));
		o[j+1] = Y + (this.asc[9]*(o[j+1]-Y));
		o[j+2] = Y + (this.asc[9]*(o[j+2]-Y));
	}
};
LUTColourSpace.prototype.multiOut = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var Y, stp, sat, r, b;
	var mt = this.multiStop.length;
	var mono = new Float64Array(3);
	var Y2, mul, mL, mH;
	for (var j=0; j<m; j +=3) {
		Y = (this.y[0]*c[j])+(this.y[1]*c[j+1])+(this.y[2]*c[j+2]);
		if (Y <= 0) {
			sat = this.multiSat[0];
			mono[0] = Y;
			mono[1] = Y;
			mono[2] = Y;
		} else {
			stp = (Math.log(Y/0.2)/Math.LN2) + 8;
			if (stp <= 0) {
				sat = this.multiSat[0];
			} else if (stp >= 16) {
				sat = this.multiSat[16];
			} else {
				b = Math.floor(stp);
				r = stp - b;
				sat = ((1-r)*this.multiSat[b]) + (r*this.multiSat[b+1]);
			}
			if (sat >= 1) {
				mono[0] = Y;
				mono[1] = Y;
				mono[2] = Y;
			} else {
				if (mt === 1) {
					mono[0] = this.multiRGB[0];
					mono[1] = this.multiRGB[1];
					mono[2] = this.multiRGB[2];
				} else if (mt > 1) {
					stp -= 8;
					mL = mt-1;
					mH = mt;
					for (var k=0; k<mt; k++) {
						if (this.multiStop[k] > stp) {
							mL = k-1;
							mH = k;
							break;
						}
					}
					if (mL < 0) {
						mono[0] = this.multiRGB[0];
						mono[1] = this.multiRGB[1];
					mono[2] = this.multiRGB[2];
					} else if (mH >= mt) {
						mono[0] = this.multiRGB[ ((mt-1)*3) ];
						mono[1] = this.multiRGB[((mt-1)*3)+1];
						mono[2] = this.multiRGB[((mt-1)*3)+2];
					} else {
						r = (stp-this.multiStop[mL])/(this.multiStop[mH]-this.multiStop[mL]);
						mono[0] = ((1-r)*this.multiRGB[ ((mL)*3) ])+(r*this.multiRGB[ ((mH)*3) ]);
						mono[1] = ((1-r)*this.multiRGB[((mL)*3)+1])+(r*this.multiRGB[((mH)*3)+1]);
						mono[2] = ((1-r)*this.multiRGB[((mL)*3)+2])+(r*this.multiRGB[((mH)*3)+2]);
					} 
				} else {
					mono[0] = Y;
					mono[1] = Y;
					mono[2] = Y;
				}
				if (mt > 0) {
					Y2 = (this.y[0]*mono[0])+(this.y[1]*mono[1])+(this.y[2]*mono[2]);
					if (Y2 > 0) {
						mul = Y/Y2;
						mono[0] *= mul;
						mono[1] *= mul;
						mono[2] *= mul;
					} else {
						mono[0] = Y;
						mono[1] = Y;
						mono[2] = Y;
					}
				}
			}
		}
		c[ j ] = mono[0] + (sat*(c[ j ]-mono[0]));
		c[j+1] = mono[1] + (sat*(c[j+1]-mono[1]));
		c[j+2] = mono[2] + (sat*(c[j+2]-mono[2]));
	}
};
LUTColourSpace.prototype.HGOut = function(buff,g) {
	var o = new Float64Array(buff);
	var m = o.length;
	var y = this.y;
	var Y,r;
	var h = new Float64Array(o.buffer.slice(0));
	if (typeof g === 'boolean' && g) {
		this.csOut[this.curOut].lc(buff);
		this.csOut[this.curHG].lc(h.buffer);
	} else {
		this.csOut[this.curOut].lf(buff);
		this.csOut[this.curHG].lf(h.buffer);
	}
	for (var j=0; j<m; j += 3) {
		Y = (y[0]*o[j])+(y[1]*o[j+1])+(y[2]*o[j+2]);
		if (Y >= this.hgHigh) {
			o[ j ] = h[j];
			o[j+1] = h[j+1];
			o[j+2] = h[j+2];
		} else if (Y > this.hgLow) {
			if (this.hgLin) {
				r = (this.hgHigh - Y)/(this.hgHigh - this.hgLow);
			} else {
				r = (this.hgHighStop - (Math.log(Y * 5)/Math.LN2))/(this.hgHighStop - this.hgLowStop);
			}
			o[ j ] = (o[ j ] * (r)) + (h[ j ] * (1-r));
			o[j+1] = (o[j+1] * (r)) + (h[j+1] * (1-r));
			o[j+2] = (o[j+2] * (r)) + (h[j+2] * (1-r));
		}
	}
};
LUTColourSpace.prototype.SDRSatOut = function(buff) {
	if (typeof this.Ys[this.csOut[this.curOut].name] !== 'undefined') {
		var o = new Float64Array(buff);
		var m = o.length;
		var y = this.Ys[this.csOut[this.curOut].name];
		var Y, Pb, Pr;
		var R,G,B;
		var Db = 2*(1-y[2]);
		var Dr = 2*(1-y[0]);
		var gi = this.sdrSatGamma;
		var g = 1/gi;
		for (var j=0; j<m; j += 3) {
			R = ((o[ j ]<0)?o[ j ]/12:Math.pow(o[ j ]/12,g));
			R = (isNaN(R)?0:R);
			G = ((o[j+1]<0)?o[j+1]/12:Math.pow(o[j+1]/12,g));
			G = (isNaN(G)?0:G);
			B = ((o[j+2]<0)?o[j+2]/12:Math.pow(o[j+2]/12,g));
			B = (isNaN(B)?0:B);
			Y = (y[0]*R)+(y[1]*G)+(y[2]*B);
			if (Y>0) {
				Pb = (B-Y)/Db;
				Pr = (R-Y)/Dr;
				Y = Math.pow(Y,gi);
				o[ j ] = (Pr * Dr) + Y;
				o[j+2] = (Pb * Db) + Y;
				o[j+1] = (Y - (y[0]*o[ j ]) -(y[2]*o[j+2]))/y[1];
				o[ j ] *= 12;
				o[j+1] *= 12;
				o[j+2] *= 12;
			}
		}
	}
};
LUTColourSpace.prototype.gamutLimOut = function(buff,out) {
	var o = new Float64Array(buff);
	var max = o.length;
	var y = this.y;
	var Y,k;
	if (this.gLimLin) { // Linear Space
		out.doGamutLim = false;
		if (this.gLimC) { // Secondary colourspace to protect 
			for (var j=0; j<max; j++) {
				o[ j ] = Math.max(0, o[ j ]);
			}
			var og = new Float64Array(o.buffer.slice(0));
			this.csIn[this.gLimGIn].lc(og.buffer);
			this.csOut[this.gLimGOut].lc(og.buffer);
			var gMX, gMN, gSat;
			var gY = this.gLimY;
			var gL = this.gLimL;
			if (this.gLimB) { // Protect both Primary and Secondary
				var gMX2, gMN2;
				for (var j=0; j<max; j += 3) {
					k = parseInt(j/3);
					gMX = Math.max(o[ j ], o[j+1], o[j+2]);
					gMN = Math.min(o[ j ], o[j+1], o[j+2]);
					gMX2 = Math.max(og[ j ], og[j+1], og[j+2]);
					gMN2 = Math.min(og[ j ], og[j+1], og[j+2]);
					gSat = Math.max(gMX - gMN, gMX2 - gMN2)/gL ;
					if (gSat > 1) {
						Y = (gY[0]*o[j])+(gY[1]*o[j+1])+(gY[2]*o[j+2]);
						o[ j ] = Y + ((o[ j ]-Y)/gSat);
						o[j+1] = Y + ((o[j+1]-Y)/gSat);
						o[j+2] = Y + ((o[j+2]-Y)/gSat);
					}
				}
			} else { // Protect Secondary only
				for (var j=0; j<max; j += 3) {
					k = parseInt(j/3);
					gMX = Math.max(og[ j ], og[j+1], og[j+2]);
					gMN = Math.min(og[ j ], og[j+1], og[j+2]);
					gSat = (gMX - gMN)/gL;
					if (gSat > 1) {
						Y = (gY[0]*o[j])+(gY[1]*o[j+1])+(gY[2]*o[j+2]);
						o[ j ] = Y + ((o[ j ]-Y)/gSat);
						o[j+1] = Y + ((o[j+1]-Y)/gSat);
						o[j+2] = Y + ((o[j+2]-Y)/gSat);
					}
				}
			}
		} else { // Protect Primary
			var gMX, gMN;
			var gSat;
			var gY = this.gLimY;
			var gL = this.gLimL;
			for (var j=0; j<max; j += 3) {
				k = parseInt(j/3);
				o[ j ] = Math.max(0, o[ j ]);
				o[j+1] = Math.max(0, o[j+1]);
				o[j+2] = Math.max(0, o[j+2]);
				gMX = Math.max(o[ j ], o[j+1], o[j+2]);
				if (gMX > gL) {
					gMN = Math.min(o[ j ], o[j+1], o[j+2]);
					gSat = (gMX - gMN)/gL;
					if (gSat > 1) {
						Y = (gY[0]*o[j])+(gY[1]*o[j+1])+(gY[2]*o[j+2]);
						o[ j ] = Y + ((o[ j ]-Y)/gSat);
						o[j+1] = Y + ((o[j+1]-Y)/gSat);
						o[j+2] = Y + ((o[j+2]-Y)/gSat);
					}
				}
			}
		}
	} else { // Post Gamma
		out.doGamutLim = true;
		out.gLimY = this.gLimY;
		out.gLimL = this.gLimL;
		if (this.gLimC) { // Secondary colourspace to protect
			var og = new Float64Array(o.buffer.slice(0));
			this.csIn[this.gLimGIn].lc(og.buffer);
			this.csOut[this.gLimGOut].lc(og.buffer);
			out.og = og.buffer;
			out.to.push('og');
			out.gLimB = this.gLimB;
		}
	} // Default protects Primary
};
// Colour space data objects
function CCTxy(LUT) {
	this.lut = LUT;
	this.u = 0.32;
	this.v = 0.21;
}
CCTxy.prototype.setxy = function(x,y) {
	this.u = (4*x)/((-2*x) + (12*y) + 3);
	this.v = (6*y)/((-2*x) + (12*y) + 3);
};
CCTxy.prototype.setuv = function(u,v) {
	this.u = u;
	this.v = v;
};
CCTxy.prototype.f = function(T) {
	var T0 = T - 0.05;
	var T1 = T + 0.05;
	var xy0 = this.lut.fRGBCub(T0);
	var uv0 = new Float64Array([
		4 * xy0[0] / ((-2*xy0[0]) + (12*xy0[1]) + 3),
		6 * xy0[1] / ((-2*xy0[0]) + (12*xy0[1]) + 3)
	]);
	var xy1 = this.lut.fRGBCub(T1);
	var uv1 = new Float64Array([
		4 * xy1[0] / ((-2*xy1[0]) + (12*xy1[1]) + 3),
		6 * xy1[1] / ((-2*xy1[0]) + (12*xy1[1]) + 3)
	]);
	var d0 = Math.pow(Math.pow(this.u - uv0[0],2) + Math.pow(this.v - uv0[1],2),0.5);
	var d1 = Math.pow(Math.pow(this.u - uv1[0],2) + Math.pow(this.v - uv1[1],2),0.5);
	return (d0-d1)*10;
};
function Planck(lutMaker) {
	this.setLoci(lutMaker);
	this.slope = new CCTxy(this.loci);
	this.brent = new Brent(this.slope,0,50000);
	this.brent.setDelta(1000);
}
Planck.prototype.setLoci = function(lutMaker) {
	this.loci = lutMaker.newLUT({
		title: 'loci',
		format: 'cube',
		dims: 1,
		s: 501,
		min: [100,100,100],
		max: [50100,50100,50100],
		C: [new Float64Array(
			[
				0.7346901, 0.7346893, 0.7343438, 0.7304724, 0.7213855, 0.7092079, 0.6955663, 0.6813343, 0.6669815, 0.6527507,
				0.6387563, 0.6250448, 0.6116315, 0.5985211, 0.5857180, 0.5732296, 0.5610674, 0.5492451, 0.5377773, 0.5266775,
				0.5159573, 0.5056253, 0.4956867, 0.4861436, 0.4769946, 0.4682353, 0.4598590, 0.4518569, 0.4442182, 0.4369311,
				0.4299827, 0.4233596, 0.4170480, 0.4110339, 0.4053035, 0.3998431, 0.3946393, 0.3896790, 0.3849498, 0.3804395,
				0.3761367, 0.3720303, 0.3681099, 0.3643654, 0.3607875, 0.3573673, 0.3540963, 0.3509665, 0.3479705, 0.3451012,
				0.3423519, 0.3397163, 0.3371885, 0.3347629, 0.3324344, 0.3301979, 0.3280487, 0.3259827, 0.3239954, 0.3220832,
				0.3202423, 0.3184693, 0.3167609, 0.3151141, 0.3135259, 0.3119936, 0.3105146, 0.3090864, 0.3077068, 0.3063736,
				0.3050847, 0.3038382, 0.3026321, 0.3014648, 0.3003345, 0.2992398, 0.2981790, 0.2971509, 0.2961540, 0.2951870,
				0.2942488, 0.2933382, 0.2924541, 0.2915955, 0.2907613, 0.2899506, 0.2891625, 0.2883962, 0.2876509, 0.2869256,
				0.2862198, 0.2855327, 0.2848636, 0.2842119, 0.2835769, 0.2829581, 0.2823549, 0.2817668, 0.2811931, 0.2806336,
				0.2800876, 0.2795547, 0.2790345, 0.2785265, 0.2780304, 0.2775458, 0.2770723, 0.2766095, 0.2761572, 0.2757149,
				0.2752824, 0.2748594, 0.2744456, 0.2740407, 0.2736444, 0.2732565, 0.2728767, 0.2725048, 0.2721406, 0.2717838,
				0.2714343, 0.2710918, 0.2707561, 0.2704270, 0.2701044, 0.2697881, 0.2694778, 0.2691735, 0.2688750, 0.2685821,
				0.2682946, 0.2680125, 0.2677356, 0.2674637, 0.2671968, 0.2669346, 0.2666771, 0.2664242, 0.2661757, 0.2659315,
				0.2656916, 0.2654558, 0.2652240, 0.2649961, 0.2647720, 0.2645517, 0.2643351, 0.2641220, 0.2639123, 0.2637061,
				0.2635032, 0.2633035, 0.2631070, 0.2629136, 0.2627232, 0.2625358, 0.2623513, 0.2621696, 0.2619907, 0.2618144,
				0.2616409, 0.2614699, 0.2613014, 0.2611355, 0.2609719, 0.2608108, 0.2606520, 0.2604954, 0.2603411, 0.2601890,
				0.2600390, 0.2598911, 0.2597453, 0.2596015, 0.2594597, 0.2593198, 0.2591818, 0.2590457, 0.2589114, 0.2587788,
				0.2586481, 0.2585191, 0.2583917, 0.2582660, 0.2581420, 0.2580195, 0.2578986, 0.2577792, 0.2576614, 0.2575450,
				0.2574301, 0.2573166, 0.2572046, 0.2570939, 0.2569845, 0.2568765, 0.2567698, 0.2566643, 0.2565602, 0.2564572,
				0.2563555, 0.2562550, 0.2561557, 0.2560575, 0.2559605, 0.2558645, 0.2557697, 0.2556759, 0.2555833, 0.2554916,
				0.2554010, 0.2553114, 0.2552228, 0.2551352, 0.2550485, 0.2549628, 0.2548780, 0.2547942, 0.2547112, 0.2546291,
				0.2545479, 0.2544676, 0.2543881, 0.2543095, 0.2542317, 0.2541546, 0.2540784, 0.2540030, 0.2539283, 0.2538544,
				0.2537813, 0.2537089, 0.2536372, 0.2535663, 0.2534960, 0.2534265, 0.2533576, 0.2532894, 0.2532219, 0.2531551,
				0.2530888, 0.2530233, 0.2529583, 0.2528940, 0.2528303, 0.2527672, 0.2527047, 0.2526428, 0.2525815, 0.2525207,
				0.2524605, 0.2524009, 0.2523418, 0.2522832, 0.2522252, 0.2521677, 0.2521107, 0.2520543, 0.2519983, 0.2519429,
				0.2518879, 0.2518334, 0.2517795, 0.2517259, 0.2516729, 0.2516203, 0.2515682, 0.2515165, 0.2514653, 0.2514145,
				0.2513641, 0.2513142, 0.2512647, 0.2512156, 0.2511669, 0.2511186, 0.2510708, 0.2510233, 0.2509762, 0.2509295,
				0.2508832, 0.2508373, 0.2507917, 0.2507465, 0.2507017, 0.2506572, 0.2506131, 0.2505694, 0.2505260, 0.2504829,
				0.2504402, 0.2503978, 0.2503558, 0.2503141, 0.2502727, 0.2502316, 0.2501908, 0.2501504, 0.2501102, 0.2500704,
				0.2500309, 0.2499917, 0.2499527, 0.2499141, 0.2498757, 0.2498377, 0.2497999, 0.2497624, 0.2497252, 0.2496882,
				0.2496516, 0.2496152, 0.2495790, 0.2495432, 0.2495075, 0.2494722, 0.2494371, 0.2494022, 0.2493676, 0.2493333,
				0.2492991, 0.2492653, 0.2492316, 0.2491982, 0.2491651, 0.2491321, 0.2490994, 0.2490670, 0.2490347, 0.2490027,
				0.2489709, 0.2489393, 0.2489079, 0.2488767, 0.2488458, 0.2488150, 0.2487845, 0.2487542, 0.2487240, 0.2486941,
				0.2486644, 0.2486348, 0.2486055, 0.2485764, 0.2485474, 0.2485186, 0.2484901, 0.2484617, 0.2484335, 0.2484054,
				0.2483776, 0.2483499, 0.2483224, 0.2482951, 0.2482680, 0.2482410, 0.2482142, 0.2481876, 0.2481611, 0.2481348,
				0.2481087, 0.2480827, 0.2480569, 0.2480313, 0.2480058, 0.2479804, 0.2479553, 0.2479302, 0.2479054, 0.2478806,
				0.2478561, 0.2478317, 0.2478074, 0.2477833, 0.2477593, 0.2477354, 0.2477117, 0.2476882, 0.2476648, 0.2476415,
				0.2476183, 0.2475953, 0.2475724, 0.2475497, 0.2475271, 0.2475046, 0.2474823, 0.2474601, 0.2474380, 0.2474160,
				0.2473942, 0.2473725, 0.2473509, 0.2473294, 0.2473081, 0.2472868, 0.2472657, 0.2472448, 0.2472239, 0.2472031,
				0.2471825, 0.2471620, 0.2471416, 0.2471213, 0.2471011, 0.2470810, 0.2470611, 0.2470412, 0.2470215, 0.2470018,
				0.2469823, 0.2469629, 0.2469436, 0.2469243, 0.2469052, 0.2468862, 0.2468673, 0.2468485, 0.2468298, 0.2468112,
				0.2467927, 0.2467743, 0.2467559, 0.2467377, 0.2467196, 0.2467016, 0.2466836, 0.2466658, 0.2466480, 0.2466304,
				0.2466128, 0.2465953, 0.2465779, 0.2465606, 0.2465434, 0.2465263, 0.2465093, 0.2464923, 0.2464754, 0.2464587,
				0.2464420, 0.2464254, 0.2464088, 0.2463924, 0.2463760, 0.2463597, 0.2463435, 0.2463274, 0.2463114, 0.2462954,
				0.2462795, 0.2462637, 0.2462480, 0.2462323, 0.2462167, 0.2462012, 0.2461858, 0.2461704, 0.2461552, 0.2461400,
				0.2461248, 0.2461098, 0.2460948, 0.2460799, 0.2460650, 0.2460502, 0.2460355, 0.2460209, 0.2460063, 0.2459918,
				0.2459774, 0.2459630, 0.2459487, 0.2459345, 0.2459203, 0.2459062, 0.2458922, 0.2458782, 0.2458643, 0.2458505,
				0.2458367, 0.2458230, 0.2458093, 0.2457957, 0.2457822, 0.2457687, 0.2457553, 0.2457420, 0.2457287, 0.2457155,
				0.2457023, 0.2456892, 0.2456761, 0.2456631, 0.2456502, 0.2456373, 0.2456245, 0.2456117, 0.2455990, 0.2455864,
				0.2455738
			]).buffer,
			new Float64Array(
		    [
				0.2653099, 0.2653107, 0.2656557, 0.2695173, 0.2785681, 0.2906601, 0.3041078, 0.3179314, 0.3315172, 0.3444616,
				0.3564976, 0.3674542, 0.3772323, 0.3857882, 0.3931213, 0.3992642, 0.4042739, 0.4082249, 0.4112022, 0.4132970,
				0.4146018, 0.4152076, 0.4152017, 0.4146658, 0.4136754, 0.4122992, 0.4105990, 0.4086300, 0.4064408, 0.4040740,
				0.4015669, 0.3989516, 0.3962561, 0.3935040, 0.3907157, 0.3879084, 0.3850966, 0.3822926, 0.3795065, 0.3767468,
				0.3740204, 0.3713329, 0.3686888, 0.3660918, 0.3635445, 0.3610490, 0.3586068, 0.3562189, 0.3538859, 0.3516080,
				0.3493852, 0.3472171, 0.3451032, 0.3430428, 0.3410352, 0.3390794, 0.3371744, 0.3353191, 0.3335125, 0.3317534,
				0.3300405, 0.3283728, 0.3267490, 0.3251679, 0.3236283, 0.3221291, 0.3206690, 0.3192470, 0.3178619, 0.3165126,
				0.3151980, 0.3139171, 0.3126689, 0.3114523, 0.3102664, 0.3091102, 0.3079829, 0.3068835, 0.3058113, 0.3047652,
				0.3037446, 0.3027487, 0.3017766, 0.3008278, 0.2999014, 0.2989968, 0.2981134, 0.2972504, 0.2964073, 0.2955834,
				0.2947783, 0.2939913, 0.2932219, 0.2924696, 0.2917339, 0.2910143, 0.2903104, 0.2896216, 0.2889476, 0.2882878,
				0.2876421, 0.2870098, 0.2863907, 0.2857843, 0.2851904, 0.2846086, 0.2840385, 0.2834798, 0.2829322, 0.2823955,
				0.2818693, 0.2813533, 0.2808473, 0.2803510, 0.2798641, 0.2793865, 0.2789178, 0.2784578, 0.2780064, 0.2775632,
				0.2771282, 0.2767010, 0.2762815, 0.2758695, 0.2754648, 0.2750672, 0.2746766, 0.2742928, 0.2739156, 0.2735448,
				0.2731804, 0.2728221, 0.2724698, 0.2721234, 0.2717828, 0.2714477, 0.2711181, 0.2707939, 0.2704749, 0.2701610,
				0.2698521, 0.2695481, 0.2692488, 0.2689543, 0.2686643, 0.2683787, 0.2680975, 0.2678206, 0.2675479, 0.2672793,
				0.2670147, 0.2667540, 0.2664972, 0.2662441, 0.2659947, 0.2657489, 0.2655066, 0.2652678, 0.2650324, 0.2648004,
				0.2645715, 0.2643459, 0.2641234, 0.2639039, 0.2636875, 0.2634740, 0.2632634, 0.2630557, 0.2628507, 0.2626484,
				0.2624488, 0.2622519, 0.2620575, 0.2618657, 0.2616763, 0.2614893, 0.2613048, 0.2611226, 0.2609427, 0.2607651,
				0.2605897, 0.2604164, 0.2602453, 0.2600764, 0.2599094, 0.2597445, 0.2595817, 0.2594207, 0.2592617, 0.2591046,
				0.2589494, 0.2587959, 0.2586443, 0.2584945, 0.2583464, 0.2582000, 0.2580552, 0.2579122, 0.2577707, 0.2576309,
				0.2574926, 0.2573559, 0.2572207, 0.2570870, 0.2569548, 0.2568240, 0.2566946, 0.2565667, 0.2564401, 0.2563149,
				0.2561911, 0.2560685, 0.2559473, 0.2558273, 0.2557086, 0.2555912, 0.2554750, 0.2553599, 0.2552461, 0.2551334,
				0.2550219, 0.2549115, 0.2548022, 0.2546940, 0.2545869, 0.2544809, 0.2543759, 0.2542720, 0.2541691, 0.2540672,
				0.2539663, 0.2538663, 0.2537674, 0.2536694, 0.2535723, 0.2534761, 0.2533809, 0.2532866, 0.2531931, 0.2531006,
				0.2530089, 0.2529180, 0.2528280, 0.2527388, 0.2526505, 0.2525629, 0.2524761, 0.2523902, 0.2523050, 0.2522205,
				0.2521369, 0.2520539, 0.2519717, 0.2518903, 0.2518095, 0.2517295, 0.2516501, 0.2515715, 0.2514935, 0.2514162,
				0.2513396, 0.2512636, 0.2511883, 0.2511136, 0.2510395, 0.2509661, 0.2508932, 0.2508210, 0.2507494, 0.2506784,
				0.2506079, 0.2505381, 0.2504688, 0.2504001, 0.2503319, 0.2502643, 0.2501973, 0.2501307, 0.2500648, 0.2499993,
				0.2499344, 0.2498699, 0.2498060, 0.2497426, 0.2496797, 0.2496172, 0.2495553, 0.2494938, 0.2494328, 0.2493723,
				0.2493123, 0.2492527, 0.2491935, 0.2491348, 0.2490766, 0.2490188, 0.2489614, 0.2489044, 0.2488479, 0.2487918,
				0.2487361, 0.2486808, 0.2486259, 0.2485715, 0.2485174, 0.2484637, 0.2484104, 0.2483575, 0.2483050, 0.2482528,
				0.2482010, 0.2481496, 0.2480986, 0.2480479, 0.2479976, 0.2479476, 0.2478980, 0.2478487, 0.2477997, 0.2477511,
				0.2477029, 0.2476549, 0.2476073, 0.2475601, 0.2475131, 0.2474665, 0.2474202, 0.2473742, 0.2473285, 0.2472831,
				0.2472380, 0.2471932, 0.2471487, 0.2471045, 0.2470606, 0.2470170, 0.2469737, 0.2469306, 0.2468879, 0.2468454,
				0.2468032, 0.2467613, 0.2467196, 0.2466782, 0.2466371, 0.2465962, 0.2465556, 0.2465152, 0.2464751, 0.2464353,
				0.2463957, 0.2463564, 0.2463173, 0.2462784, 0.2462398, 0.2462014, 0.2461633, 0.2461254, 0.2460877, 0.2460503,
				0.2460131, 0.2459761, 0.2459393, 0.2459028, 0.2458665, 0.2458304, 0.2457945, 0.2457588, 0.2457234, 0.2456881,
				0.2456531, 0.2456182, 0.2455836, 0.2455492, 0.2455150, 0.2454810, 0.2454471, 0.2454135, 0.2453801, 0.2453469,
				0.2453138, 0.2452810, 0.2452483, 0.2452158, 0.2451835, 0.2451514, 0.2451195, 0.2450877, 0.2450562, 0.2450248,
				0.2449936, 0.2449625, 0.2449317, 0.2449010, 0.2448704, 0.2448401, 0.2448099, 0.2447799, 0.2447500, 0.2447203,
				0.2446908, 0.2446614, 0.2446322, 0.2446032, 0.2445743, 0.2445455, 0.2445169, 0.2444885, 0.2444602, 0.2444321,
				0.2444041, 0.2443763, 0.2443486, 0.2443211, 0.2442937, 0.2442664, 0.2442393, 0.2442123, 0.2441855, 0.2441588,
				0.2441323, 0.2441059, 0.2440796, 0.2440535, 0.2440275, 0.2440016, 0.2439759, 0.2439503, 0.2439248, 0.2438994,
				0.2438742, 0.2438491, 0.2438241, 0.2437993, 0.2437746, 0.2437500, 0.2437255, 0.2437012, 0.2436770, 0.2436528,
				0.2436289, 0.2436050, 0.2435812, 0.2435576, 0.2435341, 0.2435107, 0.2434874, 0.2434642, 0.2434411, 0.2434182,
				0.2433953, 0.2433726, 0.2433500, 0.2433275, 0.2433050, 0.2432827, 0.2432605, 0.2432384, 0.2432165, 0.2431946,
				0.2431728, 0.2431511, 0.2431295, 0.2431081, 0.2430867, 0.2430654, 0.2430442, 0.2430232, 0.2430022, 0.2429813,
				0.2429605, 0.2429398, 0.2429192, 0.2428987, 0.2428783, 0.2428580, 0.2428378, 0.2428176, 0.2427976, 0.2427776,
				0.2427578, 0.2427380, 0.2427183, 0.2426987, 0.2426792, 0.2426598, 0.2426405, 0.2426212, 0.2426021, 0.2425830,
				0.2425640, 0.2425451, 0.2425262, 0.2425075, 0.2424888, 0.2424702, 0.2424517, 0.2424333, 0.2424150, 0.2423967,
				0.2423785
		    ]).buffer,
			new Float64Array(
			[
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1,1,1,1,1,1,1,1,1,1,
				1
			]).buffer
		]
	});
};
Planck.prototype.getCCT = function(white) {
	if (white[0] < 0 || white[1] < 0 || white[0]+white[1] > 1) {
		return false;
	} else {
		var u = 4 * white[0] / ((-2*white[0]) + (12*white[1]) + 3);
		var v = 6 * white[1] / ((-2*white[0]) + (12*white[1]) + 3);
		// Test if in triangles below 1000K or above 25000K
/*
		var left = (0.42644748-0.44800714)*(v-0.3546253) - (0.1055567-0.3546253)*(u-0.44800714);
		if (left >= 0) {
			return 1000;
		} else 
*/
		left = (0.42207761-0.18293282)*(v-0.2740731) - (0.2012049-0.2740731)*(u-0.18293282);
		if (left <= 0) {
			return 25000;
		}
		// Find CCT using Brents method
		this.slope.setuv(u,v);
		var m = 26;
		var best = 0;
		var bDist = 999;
		var root, xy, dist;
		var uv = new Float64Array(2);
		for (var j=0; j<m; j++) {
			root = this.brent.findRoot((j*1000)+100,0);
			if (root > 100) {
				xy = this.loci.fRGBCub(root);
				uv = this.xy2uv(xy);
				dist = Math.pow(Math.pow(u - uv[0],2) + Math.pow(v - uv[1],2),0.5);
				if (dist < bDist) {
					best = root;
					bDist = dist;
				}
			}
		}
		if (best < 500) {
			best = 500;
		} else if (best > 25000) {
			best = 25000;
		}
		return Math.round(best);
	}
};
Planck.prototype.getDuvMag = function(white,T) {
	var xy = this.loci.fRGBCub(T);
	var xy1 = this.loci.fRGBCub(T + 0.1);
	var xy2 = this.loci.fRGBCub(T - 0.1);
	var uv = this.xy2uv(xy);
	var uv1 = this.xy2uv(xy1);
	var uv2 = this.xy2uv(xy2);
	var uvW = this.xy2uv(white);
	var a = uv2[0]-uv1[0];
	var b = uv2[1]-uv1[1];
	var c = - (a * uv[0]) - (b * uv[1]);
	var u = ((b*((b*uvW[0])-(a*uvW[1]))) - (a*c))/((a*a) + (b*b));
	var v = ((a*((-b*uvW[0])+(a*uvW[1]))) - (b*c))/((a*a) + (b*b));
	var du = u - uv[0];
	var dv = v - uv[1];
	var nBelow = (uv1[0]-uv2[0])*(v-uv2[1]) - (uv1[1]-uv2[1])*(u-uv2[0]);
	var nMag = Math.pow((du*du)+(dv*dv),0.5);
	var dut = u - uvW[0];
	var dvt = v - uvW[1];
	var tLeft = (uv[0]-u)*(uvW[1]-v) - (uv[1]-v)*(uvW[0]-u);
	var tMag = Math.pow((dut*dut)+(dvt*dvt),0.5);
	var out = new Float64Array(2);
	if (nBelow > 0 && nMag > 0.0000001) {
		out[0] = -nMag;
	} else if (nMag > 0.0000001) {
		out[0] = nMag;
	} else {
		out[0] = 0;
	}
	if (tLeft > 0 && tMag > 0.0000001) {
		out[1] = tMag;
	} else if (tMag > 0.0000001) {
		out[1] = -tMag;
	} else {
		out[1] = 0;
	}
	return out;
};
Planck.prototype.getDxy = function(white,T) {
	var xyY = this.loci.fRGBCub(T);
	var xyY1 = this.loci.fRGBCub(T + 0.1);
	var xyY2 = this.loci.fRGBCub(T - 0.1);
	var uv = new Float64Array([
		(4*xyY[0])/((-2*xyY[0]) + (12*xyY[1]) + 3),
		(6*xyY[1])/((-2*xyY[0]) + (12*xyY[1]) + 3)
	]);
	var uv1 = new Float64Array([
		(4*xyY1[0])/((-2*xyY1[0]) + (12*xyY1[1]) + 3),
		(6*xyY1[1])/((-2*xyY1[0]) + (12*xyY1[1]) + 3)
	]);
	var uv2 = new Float64Array([
		(4*xyY2[0])/((-2*xyY2[0]) + (12*xyY2[1]) + 3),
		(6*xyY2[1])/((-2*xyY2[0]) + (12*xyY2[1]) + 3)
	]);
	var a = uv2[0]-uv1[0];
	var b = uv2[1]-uv1[1];
	var c = - (a * uv[0]) - (b * uv[1]);
	var u0 = 4 * white[0] / ((-2*white[0]) + (12*white[1]) + 3);
	var v0 = 6 * white[1] / ((-2*white[0]) + (12*white[1]) + 3);
	var u = ((b*((b*u0)-(a*v0))) - (a*c))/((a*a) + (b*b));
	var v = ((a*((-b*u0)+(a*v0))) - (b*c))/((a*a) + (b*b));
	var x = (3*u)/((2*u)-(8*v)+4);
	var y = (2*v)/((2*u)-(8*v)+4);
	var dx = x - xyY[0];
	var dy = y - xyY[1];
	var left = (xyY1[0]-xyY2[0])*(y-xyY2[1]) - (xyY1[1]-xyY2[1])*(x-xyY2[0]);
	var mag = Math.pow((dx*dx)+(dy*dy),0.5);
// self.postMessage({msg:true,details:'xy, x, y - ' + xyY[0] + ' , ' + xyY[1] + ' , ' + x + ' , ' + y});
	if (left > 0) {
		return -mag;
	} else {
		return mag;
	}
};
Planck.prototype.xyY = function(T) {
	var out = this.loci.fRGBCub(T);
	out[2] = 1;
	return out;
};
Planck.prototype.xyz = function(T) {
	var xyY = this.loci.fRGBCub(T);
	return new Float64Array([
		xyY[0],xyY[1],1-xyY[0]-xyY[1]
	]);
};
Planck.prototype.XYZ = function(T) {
	var xyY = this.loci.fRGBCub(T);
	return new Float64Array([
		xyY[0]/xyY[1],1,(1-xyY[0]-xyY[1])/xyY[1]
	]);
};
Planck.prototype.uv = function(T) {
	var xy = this.loci.fRGBCub(T);
	var den = (-2*xy[0]) + (12*xy[1]) + 3;
	return new Float64Array([
		4*xy[0] / den,
		6*xy[1] / den
	]);
};
Planck.prototype.xy2uv = function(xy) {
	var den = (-2*xy[0]) + (12*xy[1]) + 3;
	return new Float64Array([
		4*xy[0] / den,
		6*xy[1] / den
	]);
};
Planck.prototype.uv2xy = function(uv) {
	var den = (2*uv[0]) - (8*uv[1]) + 4;
	return new Float64Array([
		3*uv[0] / den,
		2*uv[1] / den,
		1 - (((3*uv[0]) + (2*uv[1])) / den)
	]);
};
Planck.prototype.uv2XYZ = function(uv) {
	var xy = this.uv2xy(uv);
	return new Float64Array([
		xy[0]/xy[1],
		1,
		xy[2]/xy[1]
	]);
};
Planck.prototype.Dxy = function(T) {
	var xyY = this.loci.fRGBCub(T);
	var xyY1 = this.loci.fRGBCub(T + 0.1);
	var xyY2 = this.loci.fRGBCub(T - 0.1);
	var uv = new Float64Array([
		(4*xyY[0])/((-2*xyY[0]) + (12*xyY[1]) + 3),
		(6*xyY[1])/((-2*xyY[0]) + (12*xyY[1]) + 3)
	]);
	var uv1 = new Float64Array([
		(4*xyY1[0])/((-2*xyY1[0]) + (12*xyY1[1]) + 3),
		(6*xyY1[1])/((-2*xyY1[0]) + (12*xyY1[1]) + 3)
	]);
	var uv2 = new Float64Array([
		(4*xyY2[0])/((-2*xyY2[0]) + (12*xyY2[1]) + 3),
		(6*xyY2[1])/((-2*xyY2[0]) + (12*xyY2[1]) + 3)
	]);
	var dvdu = Math.atan2(uv2[1]-uv1[1], uv2[0]-uv1[0]) + (Math.PI/2);
// self.postMessage({msg:true,details:'xy('+T+'): x - ' + xyY[0] + ', y - ' + xyY[1]});
// self.postMessage({msg:true,details:'dv/du('+T+'): rad - ' + dvdu + ', deg - ' + Math.round(180*dvdu/Math.PI)});
	var u = uv[0] + Math.sin(dvdu);
	var v = uv[1] + Math.cos(dvdu);
	var x = (3*u)/((2*u)-(8*v)+4);
	var y = (2*v)/((2*u)-(8*v)+4);
	var dx = x - xyY[0];
	var dy = y - xyY[1];
	var mag = Math.pow((dx*dx)+(dy*dy),0.5);
	return new Float64Array([mag, Math.atan2(dy, dx)]);
};
Planck.prototype.Duv = function(T) {
	var uv1 = this.uv(T + 1);
	var uv2 = this.uv(T - 1);
	var du = uv2[0]-uv1[0];
	var dv = uv2[1]-uv1[1];
	var norm = Math.atan2(du,-dv); // Locus offset (normal)
	var tang = Math.atan2(dv, du); // Planck slope (tangent)
	return new Float64Array([norm,tang]);
};
function CSCAT() {
	this.def = 0;
	this.names = [];
	this.lower = [];
	this.M = [];
	this.models();
}
CSCAT.prototype.models = function() {
	this.addModel('CIECAT02', new Float64Array([0.7328,0.4296,-0.1624, -0.7036,1.6975,0.0061, 0.003,0.0136,0.9834]));
	this.addModel('CIECAT97s', new Float64Array([0.8562,0.3372,-0.1934, -0.8360,1.8327,0.0033, 0.0357,-0.0469,1.0112]));
	this.addModel('Bradford Chromatic Adaptation', new Float64Array([0.8951,0.2664,-0.1614, -0.7502,1.7135,0.0367, 0.0389,-0.0685,1.0296]));
	this.addModel('Von Kries', new Float64Array([0.40024,0.7076,-0.08081, -0.2263,1.16532,0.0457, 0,0,0.91822]));
	this.addModel('Sharp', new Float64Array([1.2694,-0.0988,-0.1706, -0.8364,1.8006,0.0357, 0.0297,-0.0315,1.0018]));
	this.addModel('CMCCAT2000', new Float64Array([0.7982,0.3389,-0.1371, -0.5918,1.5512,0.0406, 0.0008,0.0239,0.9753]));
	this.addModel('Bianco BS', new Float64Array([0.8752,0.2787,-0.1539, -0.8904,1.8709,0.0195, -0.0061,0.0162,0.9899]));
	this.addModel('Bianco BS-PC', new Float64Array([0.6489,0.3915,-0.0404, -0.3775,1.3055,0.0720, -0.0271,0.0888,0.9383]));
	this.addModel('XYZ Scaling', new Float64Array([1,0,0, 0,1,0, 0,0,1]));
};
CSCAT.prototype.addModel = function(name,M) {
	this.names.push(name);
	this.lower.push(name.toLowerCase())
	this.M.push(M);
};
CSCAT.prototype.getModel = function(idx) {
	if (typeof idx === 'string' && isNaN(idx)) {
		idx = this.modelIdx(idx); // if it gets sent a title rather than index
	} else if (typeof idx !== 'number' || isNaN(idx)) {
		idx = this.def; // the default fallback
	}
	return new Float64Array(this.M[idx]);
};
CSCAT.prototype.getModels = function() {
	return this.names.slice(0);
};
CSCAT.prototype.modelIdx = function(model) {
	if (typeof model === 'number' && !isNaN(model)) {
		return model; // if accidentally sent a number, assume the index has already been found
	} else if (typeof model === 'undefined' || model === '') {
		return this.def; // the default option
	}
	var m = this.lower.length;
	for (var j=0; j<m; j++) {
		if (model.toLowerCase() === this.lower[j]) {
			return j;
		}
	}
	return this.def;
};
CSCAT.prototype.setDefault = function(model) {
	if (typeof model !== 'string' || model === '') {
		this.def = 0;
		return 0; // the default option
	}
	var m = this.lower.length;
	for (var j=0; j<m; j++) {
		if (model.toLowerCase() === this.lower[j]) {
			this.def = j;
			return j;
		}
	}
	this.def = 0;
	return 0;
};
// Adjustment objects
function CSWB(sysWhite, toXYZ, planck, CATs) {
	this.fromSys = toXYZ;
	this.toSys = this.mInverse(toXYZ);
	this.planck = planck;

	this.sysWhiteXYZ = new Float64Array([sysWhite[0]/sysWhite[1],1,(1-sysWhite[0]-sysWhite[1])/sysWhite[1]]);
	this.CCT0 = this.planck.getCCT(sysWhite);
	this.Duv0 = this.planck.getDuvMag(sysWhite,this.CCT0)[0];
	var uv0 = this.planck.uv(this.CCT0);
	var a = this.planck.Duv(this.CCT0);
	uv0[0] += this.Duv0 * Math.cos(a[0]);
	uv0[1] += this.Duv0 * Math.sin(a[0]);
	
	this.w0 = this.planck.uv2xy(uv0);
	this.W0 = this.planck.uv2XYZ(uv0);
	this.CATs = CATs;

	this.ref = 5500;
	this.ct = 5500;
	this.lamp = 5500;
	this.duv = 0;
	this.dpl = 0;

	this.setModel(0);
}
CSWB.prototype.getSys = function() {
	return this.CCT0;
};
CSWB.prototype.setModel = function(idx) {
	this.cur = idx;
	this.M = this.CATs.getModel(idx);
	this.Minv = this.mInverse(this.M);
	this.setToLocus();
	this.setCAT();
};
CSWB.prototype.setToLocus = function() {
	var Msys = this.mMult(this.M,this.sysWhiteXYZ);
	var Mcct = this.mMult(this.M,this.planck.XYZ(this.CCT0));
	var Mtolocus = new Float64Array([
		Mcct[0]/Msys[0],	0,					0,
		0,					Mcct[1]/Msys[1],	0,
		0,					0,					Mcct[2]/Msys[2]
	]);
	this.Ntolocus = this.mMult(this.Minv,this.mMult(Mtolocus, this.M));
};
CSWB.prototype.setCAT = function() {
	var Msys = this.mMult(this.M,this.planck.XYZ(this.CCT0));
	var Mctd = this.mMult(this.M,this.planck.XYZ(this.base));
	var Mcts = this.mMult(this.M,this.planck.XYZ(this.ct));
	var Md = this.mMult(this.M,this.planck.XYZ(this.lamp));
	var UVlamp = this.planck.uv(this.lamp);
	var a = this.planck.Duv(this.lamp);
	this.uvAdd(
		UVlamp,
		(this.duv * Math.cos(a[0])) + (this.dpl * Math.cos(a[1])),
		(this.duv * Math.sin(a[0])) + (this.dpl * Math.sin(a[1]))
	);
	var Ms = this.mMult(this.M,this.planck.uv2XYZ(UVlamp));

	var Mct = new Float64Array([
		Mctd[0]/Mcts[0],	0,					0,
		0,					Mctd[1]/Mcts[1],	0,
		0,					0,					Mctd[2]/Mcts[2]
	]);
	var Mduv = new Float64Array([
		Md[0]/Ms[0],	0,				0,
		0,				Md[1]/Ms[1],	0,
		0,				0,				Md[2]/Ms[2]
	]);

	var Mnet = this.mMult(this.mMult(this.mMult(Mduv,Mct), this.M),this.fromSys);
	this.N = this.mMult(this.toSys,this.mMult(this.Minv,Mnet));
	this.NInv = this.mInverse(this.N);
};
CSWB.prototype.uvAdd = function(uv, du, dv) {
	uv[0] += du;
	uv[1] += dv;
	var xyz = this.planck.uv2xy(uv);
	if (xyz[0]<0) {
		xyz[0] = 0;
	}
	if (xyz[1]<0) {
		xyz[1] = 0;
	}
	var bar = xyz[0] + xyz[1];
	if (bar > 1) {
		xyz[0] /= bar;
		xyz[1] /= bar;
	}
	xyz[2] = 1 - xyz[0] - xyz[1];
	var uv2 = this.planck.xy2uv(xyz);
	uv[0] = uv2[0];
	uv[1] = uv2[1];
};
CSWB.prototype.setVals = function(ref,ctShift,lampShift,duv,dpl) {
	// Colour Temperature Shift
	this.base = this.CCT0;
	var baseMired = 1000000 / this.base;
	var ctMired;
	if (-ctShift > baseMired * 0.9 || -lampShift > baseMired * 0.9) {
		if (ctShift < lampShift) {
			baseMired = -ctShift / 0.9;
		} else {
			baseMired = -lampShift / 0.9;
		}
		this.base = 1000000 / baseMired;
	}
	this.ct = 1000000 / (baseMired + ctShift);
	this.lamp = 1000000 / (baseMired + lampShift);
	// Duv / Dpl
	this.duv = -duv * 0.0175;
	this.dpl = dpl * 0.0175;
	this.setCAT();
};
CSWB.prototype.toLocus = function(XYZ) {
	return new Float64Array([
		(this.Ntolocus[0]*XYZ[0])+(this.Ntolocus[1]*XYZ[1])+(this.Ntolocus[2]*XYZ[2]),
		(this.Ntolocus[3]*XYZ[0])+(this.Ntolocus[4]*XYZ[1])+(this.Ntolocus[5]*XYZ[2]),
		(this.Ntolocus[6]*XYZ[0])+(this.Ntolocus[7]*XYZ[1])+(this.Ntolocus[8]*XYZ[2])
	]);
};
CSWB.prototype.mInverse = function(M) {
	var det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
				(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
				(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	if (det === 0) {
		return false;
	}
	return new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
CSWB.prototype.mMult = function(m1,m2) {
	if (m1.length !== 9) {
		return false;
	}
	var len = m2.length;
	if (len === 3) {
		var out = new Float64Array(3);
		out[0] = (m1[0]*m2[0]) + (m1[1]*m2[1]) + (m1[2]*m2[2]);
		out[1] = (m1[3]*m2[0]) + (m1[4]*m2[1]) + (m1[5]*m2[2]);
		out[2] = (m1[6]*m2[0]) + (m1[7]*m2[1]) + (m1[8]*m2[2]);
		return out;
	} else if (len === 9) {
		var out = new Float64Array(9);
		out[0] = (m1[0]*m2[0]) + (m1[1]*m2[3]) + (m1[2]*m2[6]);
		out[1] = (m1[0]*m2[1]) + (m1[1]*m2[4]) + (m1[2]*m2[7]);
		out[2] = (m1[0]*m2[2]) + (m1[1]*m2[5]) + (m1[2]*m2[8]);
		out[3] = (m1[3]*m2[0]) + (m1[4]*m2[3]) + (m1[5]*m2[6]);
		out[4] = (m1[3]*m2[1]) + (m1[4]*m2[4]) + (m1[5]*m2[7]);
		out[5] = (m1[3]*m2[2]) + (m1[4]*m2[5]) + (m1[5]*m2[8]);
		out[6] = (m1[6]*m2[0]) + (m1[7]*m2[3]) + (m1[8]*m2[6]);
		out[7] = (m1[6]*m2[1]) + (m1[7]*m2[4]) + (m1[8]*m2[7]);
		out[8] = (m1[6]*m2[2]) + (m1[7]*m2[5]) + (m1[8]*m2[8]);
		return out;
	} else {
		return false;
	}
};
CSWB.prototype.lc = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var r,g,b;
	var M = this.N;
	for (var j=0; j<m; j+= 3) {
		r = c[ j ];
		g = c[j+1];
		b = c[j+2];
		c[ j ] = (M[0]*r)+(M[1]*g)+(M[2]*b);
		c[j+1] = (M[3]*r)+(M[4]*g)+(M[5]*b);
		c[j+2] = (M[6]*r)+(M[7]*g)+(M[8]*b);
	}
};
CSWB.prototype.rc = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var r,g,b;
	var M = this.NInv;
	for (var j=0; j<m; j+= 3) {
		r = c[ j ];
		g = c[j+1];
		b = c[j+2];
		c[ j ] = (M[0]*r)+(M[1]*g)+(M[2]*b);
		c[j+1] = (M[3]*r)+(M[4]*g)+(M[5]*b);
		c[j+2] = (M[6]*r)+(M[7]*g)+(M[8]*b);
	}
};
// Log Gamma calculation objects
function CSSL3() {
}
CSSL3.prototype.f = function(i) {
	i *= 0.9;
	if (i >= 0.01125) {
		return (420.0 + (Math.log((i + 0.01) / 0.19)*261.5/Math.log(10))) / 1023.0;
	} else {
		return ((i * 76.2102946929 / 0.01125) + 95.0) / 1023.0;
	}
};
CSSL3.prototype.r = function(i) {
	if (i >= 171.2102946929 / 1023.0) {
		return (((Math.pow(10,((i*1023)-420)/261.5)*(0.18 +0.01))-0.01))/0.9;
	} else {
		return (((((i*1023)-95.0)*0.01125)/(171.2102946929 - 95.0)))/0.9;
	}
};
function CSLogC(iso) {
	this.nomEI = 400;
	this.blackSig = 0.003907;
	this.blackOff = 0;
	this.midGray = 0.01;
	this.encGain = 0.256598;
	this.encOff = 0.391007;
	this.iso = iso;
	var gain,encGain,encOffset,nz;
	var slope, offset, gray, s, t;
	this.cut = 1/9;
	slope = 1 / (this.cut*Math.LN10);
	offset = (Math.log(this.cut)/Math.LN10) - slope * this.cut;
	gain = iso / this.nomEI;
	gray = this.midGray / gain;
	encGain = (Math.log(iso/this.nomEI)/Math.log(2) * (0.89 - 1) / 3 + 1) * this.encGain;
	encOffset = this.encOff;
	for (var j=0; j<3; j++) {
		nz = ((95.0 / 1023.0 - encOffset) / encGain - offset) / slope;
		encOffset = this.encOff - (Math.log(1 + nz)/Math.LN10) * encGain
	}
	this.a = 1/gray;
	this.b = nz - this.blackSig / gray;
	this.e = slope * this.a * encGain;
	this.ff = encGain * (slope*this.b + offset) + encOffset;
	s = 4 / (0.18*iso);
	t = this.blackSig;
	this.b = this.b + this.a * t;
	this.a = this.a * s;
	this.ff = this.ff + this.e * t;
	this.e = this.e * s;
	this.c = encGain;
	this.d = encOffset;
	this.cut = (this.cut - this.b) / this.a;
	this.ecf = (this.e * this.cut) + this.ff;
}
CSLogC.prototype.f = function(i) {
	i *= 0.9;
	if (i > this.cut) {
		return (this.c*Math.log((this.a*i)+this.b)/Math.LN10) + this.d;
	} else {
		return (this.e*i)+this.ff;
	}
};
CSLogC.prototype.r = function(i) {
	if (i > this.ecf) {
		return (Math.pow(10, (i - this.d) / this.c) - this.b) / (this.a*0.9);
	} else {
		return (i - this.ff) / (this.e*0.9);
	}
};
function CSVLog() {
}
CSVLog.prototype.f = function(i) {
	i *= 0.9;
	if (i < 0.01) {
		return (5.6*i)+0.125;
	} else {
		return (0.241514*Math.log(i+0.00873)/Math.log(10))+0.598206
	}
};
CSVLog.prototype.r = function(i) {
	if (i < 0.181) {
		return ((i-0.125)/5.6)/0.9;
	} else {
		return (Math.pow(10,((i-0.598206)/0.241514))-0.00873)/0.9;
	}
};
// Colour space calculation objects
function CSMatrix(name,params,wp) {
	this.name = name;
	this.m = params;
	this.mInv = this.mInverse(this.m);
	this.wp = wp;
}
CSMatrix.prototype.getWP = function() {
	return new Float64Array(this.wp.slice(0));
};
CSMatrix.prototype.isMatrix = function() {
	return true;
};
CSMatrix.prototype.getMatrix = function() {
	return this.m;
};
CSMatrix.prototype.cb = function() {
	return false;
};
CSMatrix.prototype.lc = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var M = this.m;
	var r,g,b;
	for (var j=0; j<m; j+= 3) {
		r = c[ j ];
		g = c[j+1];
		b = c[j+2];
		c[ j ] = (M[0]*r)+(M[1]*g)+(M[2]*b);
		c[j+1] = (M[3]*r)+(M[4]*g)+(M[5]*b);
		c[j+2] = (M[6]*r)+(M[7]*g)+(M[8]*b);
	}
};
CSMatrix.prototype.lf = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var M = this.m;
	var r,g,b;
	for (var j=0; j<m; j+= 3) {
		r = c[ j ];
		g = c[j+1];
		b = c[j+2];
		c[ j ] = (M[0]*r)+(M[1]*g)+(M[2]*b);
		c[j+1] = (M[3]*r)+(M[4]*g)+(M[5]*b);
		c[j+2] = (M[6]*r)+(M[7]*g)+(M[8]*b);
	}
};
CSMatrix.prototype.rc = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var M = this.mInv;
	var r,g,b;
	for (var j=0; j<m; j+= 3) {
		r = c[ j ];
		g = c[j+1];
		b = c[j+2];
		c[ j ] = (M[0]*r)+(M[1]*g)+(M[2]*b);
		c[j+1] = (M[3]*r)+(M[4]*g)+(M[5]*b);
		c[j+2] = (M[6]*r)+(M[7]*g)+(M[8]*b);
	}
};
CSMatrix.prototype.mInverse = function(M) {
	var det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
				(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
				(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	if (det === 0) {
		return false;
	}
	return new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
function CSToneCurve(name,params) {
	this.name = name;
	this.o = params.isOut;
	if (params.isOut) {
		this.m1 = params.linMatrix;
		this.m2 = params.tcMatrix;
	} else {
		this.m1 = this.mInverse(params.linMatrix);
		this.m2 = this.mInverse(params.tcMatrix);
	}
	this.l = params.logBase;
	this.tc = params.tc;
	this.wp = params.wp;
	this.sb = true;
	this.sb = params.sb;
	this.cB = false;
	this.cB = params.cb;
}
CSToneCurve.prototype.mInverse = function(M) {
	var det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
				(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
				(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	if (det === 0) {
		return false;
	}
	return new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
CSToneCurve.prototype.getWP = function() {
	return new Float64Array(this.wp.slice(0));
};
CSToneCurve.prototype.isMatrix = function() {
	return false;
};
CSToneCurve.prototype.cb = function() {
	return this.cB;
};
CSToneCurve.prototype.lc = function(buff) {
	var c = new Float64Array(buff);
	var max = c.length;
	var r,g,b;
	var sb = this.sb;
	if (this.o) {
		for (var j=0; j<max; j+= 3) {
			r = c[ j ];
			g = c[j+1];
			b = c[j+2];
			c[ j ] = (this.m1[0]*r)+(this.m1[1]*g)+(this.m1[2]*b);
			c[j+1] = (this.m1[3]*r)+(this.m1[4]*g)+(this.m1[5]*b);
			c[j+2] = (this.m1[6]*r)+(this.m1[7]*g)+(this.m1[8]*b);
			c[ j ] = this.tc.f(this.l.f(c[ j ]));
			c[j+1] = this.tc.f(this.l.f(c[j+1]));
			c[j+2] = this.tc.f(this.l.f(c[j+2]));
			r = c[ j ];
			g = c[j+1];
			b = c[j+2];
			c[ j ] = (this.m2[0]*r)+(this.m2[1]*g)+(this.m2[2]*b);
			c[j+1] = (this.m2[3]*r)+(this.m2[4]*g)+(this.m2[5]*b);
			c[j+2] = (this.m2[6]*r)+(this.m2[7]*g)+(this.m2[8]*b);
			c[ j ] = this.l.r(this.tc.r(c[ j ]));
			c[j+1] = this.l.r(this.tc.r(c[j+1]));
			c[j+2] = this.l.r(this.tc.r(c[j+2]));
			if (!sb) {
				c[ j ] = Math.max(0,c[ j ]);
				c[j+1] = Math.max(0,c[j+1]);
				c[j+2] = Math.max(0,c[j+2]);
			}
		}
	} else {
		for (var j=0; j<max; j+= 3) {
			r = this.tc.f(this.l.f(c[ j ]));
			g = this.tc.f(this.l.f(c[j+1]));
			b = this.tc.f(this.l.f(c[j+2]));
			c[ j ] = (this.m2[0]*r)+(this.m2[1]*g)+(this.m2[2]*b);
			c[j+1] = (this.m2[3]*r)+(this.m2[4]*g)+(this.m2[5]*b);
			c[j+2] = (this.m2[6]*r)+(this.m2[7]*g)+(this.m2[8]*b);
			r = this.l.r(this.tc.r(c[ j ]));
			g = this.l.r(this.tc.r(c[j+1]));
			b = this.l.r(this.tc.r(c[j+2]));
			c[ j ] = (this.m1[0]*r)+(this.m1[1]*g)+(this.m1[2]*b);
			c[j+1] = (this.m1[3]*r)+(this.m1[4]*g)+(this.m1[5]*b);
			c[j+2] = (this.m1[6]*r)+(this.m1[7]*g)+(this.m1[8]*b);
		}
	}
};
CSToneCurve.prototype.lf = function(buff) {
	var c = new Float64Array(buff);
	var max = c.length;
	var r,g,b;
	var sb = this.sb;
	if (this.o) {
		for (var j=0; j<max; j+= 3) {
			r = c[ j ];
			g = c[j+1];
			b = c[j+2];
			c[ j ] = (this.m1[0]*r)+(this.m1[1]*g)+(this.m1[2]*b);
			c[j+1] = (this.m1[3]*r)+(this.m1[4]*g)+(this.m1[5]*b);
			c[j+2] = (this.m1[6]*r)+(this.m1[7]*g)+(this.m1[8]*b);
			c[ j ] = this.tc.f(this.l.f(c[ j ]));
			c[j+1] = this.tc.f(this.l.f(c[j+1]));
			c[j+2] = this.tc.f(this.l.f(c[j+2]));
			r = c[ j ];
			g = c[j+1];
			b = c[j+2];
			c[ j ] = (this.m2[0]*r)+(this.m2[1]*g)+(this.m2[2]*b);
			c[j+1] = (this.m2[3]*r)+(this.m2[4]*g)+(this.m2[5]*b);
			c[j+2] = (this.m2[6]*r)+(this.m2[7]*g)+(this.m2[8]*b);
			c[ j ] = this.l.r(this.tc.r(c[ j ]));
			c[j+1] = this.l.r(this.tc.r(c[j+1]));
			c[j+2] = this.l.r(this.tc.r(c[j+2]));
			if (!sb) {
				c[ j ] = Math.max(0,c[ j ]);
				c[j+1] = Math.max(0,c[j+1]);
				c[j+2] = Math.max(0,c[j+2]);
			}
		}
	} else {
		for (var j=0; j<max; j+= 3) {
			r = this.tc.f(this.l.f(c[ j ]));
			g = this.tc.f(this.l.f(c[j+1]));
			b = this.tc.f(this.l.f(c[j+2]));
			c[ j ] = (this.m2[0]*r)+(this.m2[1]*g)+(this.m2[2]*b);
			c[j+1] = (this.m2[3]*r)+(this.m2[4]*g)+(this.m2[5]*b);
			c[j+2] = (this.m2[6]*r)+(this.m2[7]*g)+(this.m2[8]*b);
			r = this.l.r(this.tc.r(c[ j ]));
			g = this.l.r(this.tc.r(c[j+1]));
			b = this.l.r(this.tc.r(c[j+2]));
			c[ j ] = (this.m1[0]*r)+(this.m1[1]*g)+(this.m1[2]*b);
			c[j+1] = (this.m1[3]*r)+(this.m1[4]*g)+(this.m1[5]*b);
			c[j+2] = (this.m1[6]*r)+(this.m1[7]*g)+(this.m1[8]*b);
		}
	}
};
function CSToneCurvePlus(name,params) {
	this.name = name;
	this.o = params.isOut;
	if (params.isOut) {
		this.m1 = params.linMatrix;
		this.m2 = params.tcMatrix;
	} else {
		this.m1 = this.mInverse(params.linMatrix);
		this.m2 = this.mInverse(params.tcMatrix);
	}
	this.l = params.logBase;
	this.tc = params.tc;
	this.wp = params.wp;
	this.lY = params.linY;
	this.lC = params.linClamp;
	this.tcY = params.tcY;
	this.tcC = params.tcClamp;
	this.sb = true;
	this.sb = params.sb;
	this.cB = false;
	this.cB = params.cb;
}
CSToneCurvePlus.prototype.mInverse = function(M) {
	var det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
				(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
				(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	if (det === 0) {
		return false;
	}
	return new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
CSToneCurvePlus.prototype.getWP = function() {
	return new Float64Array(this.wp.slice(0));
};
CSToneCurvePlus.prototype.isMatrix = function() {
	return false;
};
CSToneCurvePlus.prototype.cb = function() {
	return this.cB;
};
CSToneCurvePlus.prototype.lc = function(buff) {
	var c = new Float64Array(buff);
	var max = c.length;
	var r,g,b;
	var Y, pB, pR;
	var lC = this.lC;
	var lY = this.lY;
	var	dB = 2*(1-lY[2]);
	var dR = 2*(1-lY[0]);
	var tcC = this.tcC;
	var tcY = this.tcY;
	var	tcB = 2*(1-lY[2]);
	var tcR = 2*(1-lY[0]);
	if (this.o) {
		for (var j=0; j<max; j+= 3) {
			r = c[ j ];
			g = c[j+1];
			b = c[j+2];
			c[ j ] = (this.m1[0]*r)+(this.m1[1]*g)+(this.m1[2]*b);
			c[j+1] = (this.m1[3]*r)+(this.m1[4]*g)+(this.m1[5]*b);
			c[j+2] = (this.m1[6]*r)+(this.m1[7]*g)+(this.m1[8]*b);
			if (lC) {
				Y = (lY[0]*c[j])+(lY[1]*c[j+1])+(lY[2]*c[j+2]);
				pB = (c[j+2]-Y)/dB;
				pR = (c[ j ]-Y)/dR;
				if (pB >0.5) {
					pB = 0.5;
				} else if (pB < -0.5) {
					pB = -0.5;
				}
				if (pR >0.5) {
					pR = 0.5;
				} else if (pR < -0.5) {
					pR = -0.5;
				}
				c[ j ] = (pR * dR) + Y;
				c[j+2] = (pB * dB) + Y;
				c[j+1] = (Y - (lY[0]*c[ j ]) - (lY[2]*c[j+2]))/lY[1];
			}
			c[ j ] = this.tc.f(this.l.f(c[ j ]));
			c[j+1] = this.tc.f(this.l.f(c[j+1]));
			c[j+2] = this.tc.f(this.l.f(c[j+2]));
			r = c[ j ];
			g = c[j+1];
			b = c[j+2];
			c[ j ] = (this.m2[0]*r)+(this.m2[1]*g)+(this.m2[2]*b);
			c[j+1] = (this.m2[3]*r)+(this.m2[4]*g)+(this.m2[5]*b);
			c[j+2] = (this.m2[6]*r)+(this.m2[7]*g)+(this.m2[8]*b);
			if (tcC) {
				Y = (tcY[0]*c[j])+(tcY[1]*c[j+1])+(tcY[2]*c[j+2]);
				pB = (c[j+2]-Y)/tcB;
				pR = (c[ j ]-Y)/tcR;
				if (pB >0.5) {
					pB = 0.5;
				} else if (pB < -0.5) {
					pB = -0.5;
				}
				if (pR >0.5) {
					pR = 0.5;
				} else if (pR < -0.5) {
					pR = -0.5;
				}
				c[ j ] = (pR * tcR) + Y;
				c[j+2] = (pB * tcB) + Y;
				c[j+1] = (Y - (tcY[0]*c[ j ]) - (tcY[2]*c[j+2]))/tcY[1];
			}
			c[ j ] = this.l.r(this.tc.r(c[ j ]));
			c[j+1] = this.l.r(this.tc.r(c[j+1]));
			c[j+2] = this.l.r(this.tc.r(c[j+2]));
			if (!sb) {
				c[ j ] = Math.max(0,c[ j ]);
				c[j+1] = Math.max(0,c[j+1]);
				c[j+2] = Math.max(0,c[j+2]);
			}
		}
	} else {
		for (var j=0; j<max; j+= 3) {
			r = this.tc.f(this.l.f(c[ j ]));
			g = this.tc.f(this.l.f(c[j+1]));
			b = this.tc.f(this.l.f(c[j+2]));
			c[ j ] = (this.m2[0]*r)+(this.m2[1]*g)+(this.m2[2]*b);
			c[j+1] = (this.m2[3]*r)+(this.m2[4]*g)+(this.m2[5]*b);
			c[j+2] = (this.m2[6]*r)+(this.m2[7]*g)+(this.m2[8]*b);
			r = this.l.r(this.tc.r(c[ j ]));
			g = this.l.r(this.tc.r(c[j+1]));
			b = this.l.r(this.tc.r(c[j+2]));
			c[ j ] = (this.m1[0]*r)+(this.m1[1]*g)+(this.m1[2]*b);
			c[j+1] = (this.m1[3]*r)+(this.m1[4]*g)+(this.m1[5]*b);
			c[j+2] = (this.m1[6]*r)+(this.m1[7]*g)+(this.m1[8]*b);
		}
	}
};
CSToneCurvePlus.prototype.lf = function(buff) {
	var c = new Float64Array(buff);
	var max = c.length;
	var r,g,b;
	var Y, pB, pR;
	var lC = this.lC;
	var lY = this.lY;
	var	dB = 2*(1-lY[2]);
	var dR = 2*(1-lY[0]);
	var tcC = this.tcC;
	var tcY = this.tcY;
	var	tcB = 2*(1-lY[2]);
	var tcR = 2*(1-lY[0]);
	if (this.o) {
		for (var j=0; j<max; j+= 3) {
			r = c[ j ];
			g = c[j+1];
			b = c[j+2];
			c[ j ] = (this.m1[0]*r)+(this.m1[1]*g)+(this.m1[2]*b);
			c[j+1] = (this.m1[3]*r)+(this.m1[4]*g)+(this.m1[5]*b);
			c[j+2] = (this.m1[6]*r)+(this.m1[7]*g)+(this.m1[8]*b);
			if (this.lC) {
				Y = (lY[0]*c[j])+(lY[1]*c[j+1])+(lY[2]*c[j+2]);
				pB = (c[j+2]-Y)/dB;
				pR = (c[ j ]-Y)/dR;
				if (pB >0.5) {
					pB = 0.5;
				} else if (pB < -0.5) {
					pB = -0.5;
				}
				if (pR >0.5) {
					pR = 0.5;
				} else if (pR < -0.5) {
					pR = -0.5;
				}
				c[ j ] = (pR * dR) + Y;
				c[j+2] = (pB * dB) + Y;
				c[j+1] = (Y - (lY[0]*c[ j ]) -(lY[2]*c[j+2]))/lY[1];
			}
			c[ j ] = this.tc.f(this.l.f(c[ j ]));
			c[j+1] = this.tc.f(this.l.f(c[j+1]));
			c[j+2] = this.tc.f(this.l.f(c[j+2]));
			r = c[ j ];
			g = c[j+1];
			b = c[j+2];
			c[ j ] = (this.m2[0]*r)+(this.m2[1]*g)+(this.m2[2]*b);
			c[j+1] = (this.m2[3]*r)+(this.m2[4]*g)+(this.m2[5]*b);
			c[j+2] = (this.m2[6]*r)+(this.m2[7]*g)+(this.m2[8]*b);
			if (tcC) {
				Y = (tcY[0]*c[j])+(tcY[1]*c[j+1])+(tcY[2]*c[j+2]);
				pB = (c[j+2]-Y)/tcB;
				pR = (c[ j ]-Y)/tcR;
				if (pB >0.5) {
					pB = 0.5;
				} else if (pB < -0.5) {
					pB = -0.5;
				}
				if (pR >0.5) {
					pR = 0.5;
				} else if (pR < -0.5) {
					pR = -0.5;
				}
				c[ j ] = (pR * tcR) + Y;
				c[j+2] = (pB * tcB) + Y;
				c[j+1] = (Y - (tcY[0]*c[ j ]) - (tcY[2]*c[j+2]))/tcY[1];
			}
			c[ j ] = this.l.r(this.tc.r(c[ j ]));
			c[j+1] = this.l.r(this.tc.r(c[j+1]));
			c[j+2] = this.l.r(this.tc.r(c[j+2]));
			if (!sb) {
				c[ j ] = Math.max(0,c[ j ]);
				c[j+1] = Math.max(0,c[j+1]);
				c[j+2] = Math.max(0,c[j+2]);
			}
		}
	} else {
		for (var j=0; j<max; j+= 3) {
			r = this.tc.f(this.l.f(c[ j ]));
			g = this.tc.f(this.l.f(c[j+1]));
			b = this.tc.f(this.l.f(c[j+2]));
			c[ j ] = (this.m2[0]*r)+(this.m2[1]*g)+(this.m2[2]*b);
			c[j+1] = (this.m2[3]*r)+(this.m2[4]*g)+(this.m2[5]*b);
			c[j+2] = (this.m2[6]*r)+(this.m2[7]*g)+(this.m2[8]*b);
			r = this.l.r(this.tc.r(c[ j ]));
			g = this.l.r(this.tc.r(c[j+1]));
			b = this.l.r(this.tc.r(c[j+2]));
			c[ j ] = (this.m1[0]*r)+(this.m1[1]*g)+(this.m1[2]*b);
			c[j+1] = (this.m1[3]*r)+(this.m1[4]*g)+(this.m1[5]*b);
			c[j+2] = (this.m1[6]*r)+(this.m1[7]*g)+(this.m1[8]*b);
		}
	}
};
function CSLUT(name,params,lutMaker,colours) {
	this.name = name;
	this.wp = params.wp.buffer;
	if (typeof params.format !== 'undefined') {
		this.format = params.format;
	} else {
		this.format = 'cube';
	}
	if (typeof params.min !== 'undefined') {
		this.min = params.min;
	} else {
		this.min = [0,0,0];
	}
	if (typeof params.max !== 'undefined') {
		this.max = params.max;
	} else {
		this.max = [1,1,1];
	}
	this.lutMaker = lutMaker;
	this.colours = colours;
	if (typeof params.genInt === 'number' && typeof params.preInt === 'number') {
		this.genInt = params.genInt;
		this.preInt = params.preInt;
	} else {
		this.genInt = 1;
		this.preInt = 1;
	}
	this.im = false;
	this.natTF = 0;
	this.inL = false;
}
CSLUT.prototype.setLUT = function(params) {
	var meta = params.meta;
	if (typeof meta.inputMatrix !== 'undefined' && meta.inputMatrix) {
		this.inM = meta.inputMatrix;
		this.im = true;
	} else {
		this.im = false;
	}
	if (typeof meta.inputTF === 'string' && meta.inputTF !== '') {
		switch (meta.inputTF) {
			case 'S-Log3': this.natTF = 0;
				break;
			case 'S-Log2': this.natTF = 1;
				break;
			case 'S-Log': this.natTF = 2;
				break;
			case 'C-Log': this.natTF = 3;
				break;
			case 'Canon C-Log2': this.natTF = 4;
				break;
			case 'Panasonic V-Log': this.natTF = 5;
				break;
			case 'REDLogFilm': this.natTF = 6;
				break;
			case 'Cineon': this.natTF = 7;
				break;
			case 'LogC (Sup 3.x & 4.x)': this.natTF = 8;
				if (typeof meta.baseISO === 'number') {
					this.setISO(meta.baseISO);
				} else {
					this.setISO(800);
				}
				break;
			case 'LogC (Sup 2.x)': this.natTF = 9;
				if (typeof meta.baseISO === 'number') {
					this.setISO(meta.baseISO);
				} else {
					this.setISO(800);
				}
				break;
			default : this.natTF = 0;
				break;
		}
	} else if (typeof meta.nativeTF === 'number') {
		this.natTF = meta.nativeTF;
		if (this.natTF === 8 || this.natTF === 9) { // LogC
			if (typeof meta.baseISO === 'number') {
				this.setISO(meta.baseISO);
			} else {
				this.setISO(800);
			}
		}
	} else {
		this.natTF = 0;
	}
	if (typeof meta.inputEX === 'boolean') {
		this.inL = !meta.inputEX;
	} else {
		this.inL = false;
	}
	if (typeof params.format !== 'undefined') {
		this.format = params.format;
	} else {
		this.format = 'cube';
	}
	if (typeof params.min !== 'undefined') {
		this.min = params.min;
	} else {
		this.min = [0,0,0];
	}
	if (typeof params.max !== 'undefined') {
		this.max = params.max;
	} else {
		this.max = [1,1,1];
	}
	this.lut = this.lutMaker.newLUT({
		title: this.name,
		format: this.format,
		dims: 3,
		s: params.s,
		min: this.min,
		max: this.max,
		C: params.C
	});
	this.setRC();
};
CSLUT.prototype.setISO = function(iso) {
	if (this.natTF === 8) { //	LogC (Sup 3.x & 4.x)
		this.arri = {};
		var gain,encGain,encOffset,nz;
		var slope, offset, gray, s, t;
		this.arri.cut = 1/9;
		slope = 1 / (this.arri.cut*Math.LN10);
		offset = (Math.log(this.arri.cut)/Math.LN10) - slope * this.arri.cut;
		gain = iso / 400;
		gray = 0.01 / gain;
		encGain = (Math.log(iso/400)/Math.log(2) * (0.89 - 1) / 3 + 1) * 0.256598;
		encOffset = 0.391007;
		for (var j=0; j<3; j++) {
			nz = ((95.0 / 1023.0 - encOffset) / encGain - offset) / slope;
			encOffset = 0.391007 - (Math.log(1 + nz)/Math.LN10) * encGain
		}
		this.arri.a = 1/gray;
		this.arri.b = nz - 0.003907 / gray;
		this.arri.e = slope * this.arri.a * encGain;
		this.arri.ff = encGain * (slope*this.arri.b + offset) + encOffset;
		s = 4 / (0.18*iso);
		t = 0.003907;
		this.arri.b = this.arri.b + this.arri.a * t;
		this.arri.a = this.arri.a * s;
		this.arri.ff = this.arri.ff + this.arri.e * t;
		this.arri.e = this.arri.e * s;
		this.arri.c = encGain;
		this.arri.d = encOffset;
		this.arri.cut = (this.arri.cut - this.arri.b) / this.arri.a;
	} else if (this.natTF === 9) { // LogC (Sup 2.x)
		this.arri = {};
		var encGain, f16, f17;
		encGain = (Math.log(iso/400)/Math.log(2) * -0.11 / 3 + 1) * 0.256598;
		f16 = (Math.log(0.000977 / 0.010977) * encGain / Math.LN10) + 0.391007;
		f17 = (Math.log((((0.003907 + 1.0 / 4095.0) - 0.003907) * (iso/400) + 0.000977) / 0.010977)/Math.LN10) * encGain + 0.391007;
		this.arri.cut = 0.003907;
		this.arri.d = 0.391007;
		this.arri.c = encGain;
		this.arri.b = 0.000977 / 0.010977;
		this.arri.a = (iso / (400*0.010977))/(iso * (0.18/(400*0.01)));
		this.arri.ff = f16;
		this.arri.e = 4095 * (f17-f16)/(iso*(0.18/(400*0.01)));
	}
};
CSLUT.prototype.getWP = function() {
	return new Float64Array(this.wp.slice(0));
};
CSLUT.prototype.setRC = function() {
	var MI = this.colours;
	var MO = new Float64Array(MI.buffer.slice(0));
	this.lc(MO.buffer);
	// MI = matrix of input values, MO = matrix of output values, M is the approximate matrix of the colourspace
	// then M MI = MO
	// M (MI MIT) = (MO MIT) 
	// M (MI MIT)(MI MIT)-1 = (MO MIT)(MI MIT)-1
	// M = (MO MIT)(MI MIT)-1
	var m = MI.length;
	var MIMIT = new Float64Array(9);
	var MOMIT = new Float64Array(9);
	for (var j=0; j<m; j+=3) {
		// MIMIT
		MIMIT[0] += MI[ j ]*MI[ j ];
		MIMIT[1] += MI[ j ]*MI[j+1];
		MIMIT[2] += MI[ j ]*MI[j+2];
//		MIMIT[3] += MI[j+1]*MI[ j ];
		MIMIT[4] += MI[j+1]*MI[j+1];
		MIMIT[5] += MI[j+1]*MI[j+2];
//		MIMIT[6] += MI[j+2]*MI[ j ];
//		MIMIT[7] += MI[j+2]*MI[j+1];
		MIMIT[8] += MI[j+2]*MI[j+2];
		// MOMIT
		MOMIT[0] += MO[ j ]*MI[ j ];
		MOMIT[1] += MO[ j ]*MI[j+1];
		MOMIT[2] += MO[ j ]*MI[j+2];
		MOMIT[3] += MO[j+1]*MI[ j ];
		MOMIT[4] += MO[j+1]*MI[j+1];
		MOMIT[5] += MO[j+1]*MI[j+2];
		MOMIT[6] += MO[j+2]*MI[ j ];
		MOMIT[7] += MO[j+2]*MI[j+1];
		MOMIT[8] += MO[j+2]*MI[j+2];
	}
	MIMIT[3] = MIMIT[1];
	MIMIT[6] = MIMIT[2];
	MIMIT[7] = MIMIT[5];
	MI = MIMIT;
	MO = MOMIT;
	var det =	(MI[0]*((MI[4]*MI[8]) - (MI[5]*MI[7]))) -
				(MI[1]*((MI[3]*MI[8]) - (MI[5]*MI[6]))) +
				(MI[2]*((MI[3]*MI[7]) - (MI[4]*MI[6])));
	var MIInv = new Float64Array([
		((MI[4]*MI[8])-(MI[5]*MI[7]))/det, ((MI[2]*MI[7])-(MI[1]*MI[8]))/det, ((MI[1]*MI[5])-(MI[2]*MI[4]))/det,
		((MI[5]*MI[6])-(MI[3]*MI[8]))/det, ((MI[0]*MI[8])-(MI[2]*MI[6]))/det, ((MI[2]*MI[3])-(MI[0]*MI[5]))/det,
		((MI[3]*MI[7])-(MI[4]*MI[6]))/det, ((MI[1]*MI[6])-(MI[0]*MI[7]))/det, ((MI[0]*MI[4])-(MI[1]*MI[3]))/det
	]);
	var M = new Float64Array([
		(MO[0]*MIInv[0])+(MO[1]*MIInv[3])+(MO[2]*MIInv[6]), (MO[0]*MIInv[1])+(MO[1]*MIInv[4])+(MO[2]*MIInv[7]), (MO[0]*MIInv[2])+(MO[1]*MIInv[5])+(MO[2]*MIInv[8]),
		(MO[3]*MIInv[0])+(MO[4]*MIInv[3])+(MO[5]*MIInv[6]), (MO[3]*MIInv[1])+(MO[4]*MIInv[4])+(MO[5]*MIInv[7]), (MO[3]*MIInv[2])+(MO[4]*MIInv[5])+(MO[5]*MIInv[8]),
		(MO[6]*MIInv[0])+(MO[7]*MIInv[3])+(MO[8]*MIInv[6]), (MO[6]*MIInv[1])+(MO[7]*MIInv[4])+(MO[8]*MIInv[7]), (MO[6]*MIInv[2])+(MO[7]*MIInv[5])+(MO[8]*MIInv[8])
	]);
	det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
			(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
			(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	this.mInv = new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
CSLUT.prototype.isMatrix = function() {
	return false;
};
CSLUT.prototype.setInterpolation = function(genInt,preInt) {
	this.genInt = genInt;
	this.preInt = preInt;
};
CSLUT.prototype.setTitle = function(name) {
	this.name = name;
};
CSLUT.prototype.rc = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var M = this.mInv;
	var r,g,b;
	for (var j=0; j<m; j+= 3) {
		r = c[ j ];
		g = c[j+1];
		b = c[j+2];
		c[ j ] = (M[0]*r)+(M[1]*g)+(M[2]*b);
		c[j+1] = (M[3]*r)+(M[4]*g)+(M[5]*b);
		c[j+2] = (M[6]*r)+(M[7]*g)+(M[8]*b);
	}
};
CSLUT.prototype.cb = function() {
	return false;
};
CSLUT.prototype.lc = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var p;
	if (this.im) {
		var M = this.inM;
		var r,g,b;
		for (var j=0; j<m; j += 3) {
			r = c[ j ];
			g = c[j+1];
			b = c[j+2];
			c[ j ] = (M[0]*r)+(M[1]*g)+(M[2]*b);
			c[j+1] = (M[3]*r)+(M[4]*g)+(M[5]*b);
			c[j+2] = (M[6]*r)+(M[7]*g)+(M[8]*b);
		}
	}
	switch (this.natTF) {
		case 0: // S-Log3
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.0125) {
					c[j] = (0.2556207230 * Math.log((c[j] * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850;
				} else {
					c[j] = (c[j] + 0.0155818840)/0.1677922920;
				}
			}
			break;
		case 1: // S-Log2
			for (var j=0; j<m; j++) {
				if (c[j] >= 0) {
					c[j] = (0.3705223107287920 * Math.log((c[j] * 0.7077625570776260) + 0.0375840001141552)/Math.LN10) + 0.6162444730868150;
				} else {
					c[j] = (c[j] + 0.0291229262672453)/0.330000000129966;
				}
			}
			break;
		case 2: // S-log
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.000000000000001) {
					c[j] = (0.3705223110 * Math.log(c[j] + 0.0375840000)/Math.LN10) + 0.6162444740;
				} else {
					c[j] = (c[j] + 0.0286107171)/0.3241960136;
				}
			}
			break;
		case 3: // C-Log
			for (var j=0; j<m; j++) {
				if (c[j] >= -0.0452664) {
					c[j] = (0.45310179472141 * Math.log((c[j] * 10.1596) + 1)/Math.LN10) + 0.1251224801564;
				} else {
					c[j] = (c[j] + 0.0467265867)/0.3734467748;
				}
			}
			break;
		case 4: // C-Log2
			for (var j=0; j<m; j++) {
				if (c[j] >= -0.006747091156) {
					c[j] = (0.241360772 * Math.log((c[j] * 87.09937546) + 1)/Math.LN10) + 0.092864125;
				} else {
					c[j] = (c[j] + 0.006747091156)/0.045164984;
				}
			}
			break;
		case 5: // V-Log
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.009) {
					c[j] = (0.241514 * Math.log((c[j] * 0.9) + 0.00873)/Math.LN10) + 0.598206;
				} else {
					c[j] = (c[j] + 0.024801587)/0.198412698;
				}
			}
			break;
		case 6: // Cineon
		case 7: // RedLogFilm
			for (var j=0; j<m; j++) {
				if (c[j] < -0.006278688) {
					c[j] = (c[j] + 0.006278688)/0.045949378;
				} else {
					c[j] = ((Math.log((c[j]*0.890282024)+0.010797752)/(Math.LN10*0.003333333))+685)/1023;
				}
			}
			break;
		case 8: // LogC (Sup 3.x & 4.x)
		case 9: // LogC (Sup 2.x)
			p = this.arri;
			for (var j=0; j<m; j++) {
				c[j] = c[j] * 0.9;
				if (c[j] > p.cut) {
					c[j] = ((p.c * Math.log((p.a * c[j]) + p.b)/Math.LN10) + p.d);
				} else {
					c[j] = ((p.e * c[j]) + p.ff);
				}
			}
			break;
		default: // S-Log3
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.0125) {
					c[j] = (0.2556207230 * Math.log((c[j] * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850;
				} else {
					c[j] = (c[j] + 0.0155818840)/0.1677922920;
				}
			}
	}
	if (this.inL) {
		for (var j=0; j<m; j++) {
			c[j] = ((c[j]*1023)-64)/876;
		}
	}
	if (this.genInt === 0) {
		this.lut.RGBCub(buff);
	} else if (this.genInt === 1) {
		this.lut.RGBTet(buff);
	} else {
		this.lut.RGBLin(buff);
	}
	if (this.inL) {
		for (var j=0; j<m; j++) {
			c[j] = ((c[j]*876)+64)/1023;
		}
	}
	switch (this.natTF) {
		case 0: // S-Log3
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.1673609920) {
					c[j] = (Math.pow(10,(c[j] - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
				} else {
					c[j] = (0.1677922920*c[j]) - 0.0155818840;
				}
			}
			break;
		case 1: // S-Log2
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.0375840001141552) {
					c[j] = (Math.pow(10,(c[j] - 0.6162444730868150)/0.3705223107287920) - 0.0375840001141552)/0.7077625570776260;		
				} else {
					c[j] = (0.330000000129966*c[j]) - 0.0291229262672453;
				}
			}
			break;
		case 2: // S-Log
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.0882900450) {
					c[j] = (Math.pow(10,(c[j] - 0.6162444740)/0.3705223110) - 0.0375840000);		
				} else {
					c[j] = (0.3241960136*c[j]) - 0.0286107171;
				}
			}
			break;
		case 3: // C-Log
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.00391002619746) {
					c[j] = (Math.pow(10,(c[j] - 0.1251224801564)/0.45310179472141) - 1)/10.1596;		
				} else {
					c[j] = (0.3734467748*c[j]) - 0.0467265867;
				}
			}
			break;
		case 4: // C-Log2
			for (var j=0; j<m; j++) {
				if (c[j] >= 0) {
					c[j] = (Math.pow(10,(c[j] - 0.092864125)/0.241360772) - 1)/87.09937546;		
				} else {
					c[j] = (0.045164984*c[j]) - 0.006747091156;
				}
			}
			break;
		case 5: // V-Log
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.181) {
					c[j] = (Math.pow(10,(c[j] - 0.598206)/0.241514) - 0.00873)/0.9;		
				} else {
					c[j] = (0.198412698*c[j]) - 0.024801587;
				}
			}
			break;
		case 6: // Cineon
		case 7: // RedLogFilm
			for (var j=0; j<m; j++) {
				if (c[j] < 0) {
					c[j] = (c[j]*0.045949378) - 0.006278688;
				} else {
					c[j] = (Math.pow(10,((c[j]*1023)-685)*0.003333333) - 0.010797752)/0.890282024;
				}
			}
			break;
		case 8: // LogC (Sup 3.x & 4.x)
		case 9: // LogC (Sup 2.x)
			p = this.arri;
			for (var j=0; j<m; j++) {
				if (c[j] > ((p.e * p.cut) + p.ff)) {
					c[j] = (Math.pow(10, (c[j] - p.d) / p.c) - p.b)/(p.a*0.9);
				} else {
					c[j] = ((c[j] - p.ff) / (p.e*0.9));
				}
			}
			break;
		default: // S-Log3
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.1673609920) {
					c[j] = (Math.pow(10,(c[j] - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
				} else {
					c[j] = (0.1677922920 * c[j]) - 0.0155818840;
				}
			}
	}
};
CSLUT.prototype.lf = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var p;
	if (this.im) {
		var M = this.inM;
		var r,g,b;
		for (var j=0; j<m; j += 3) {
			r = c[ j ];
			g = c[j+1];
			b = c[j+2];
			c[ j ] = (M[0]*r)+(M[1]*g)+(M[2]*b);
			c[j+1] = (M[3]*r)+(M[4]*g)+(M[5]*b);
			c[j+2] = (M[6]*r)+(M[7]*g)+(M[8]*b);
		}
	}
	switch (this.natTF) {
		case 0: // S-Log3
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.0125) {
					c[j] = (0.2556207230 * Math.log((c[j] * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850;
				} else {
					c[j] = (c[j] + 0.0155818840)/0.1677922920;
				}
			}
			break;
		case 1: // S-Log2
			for (var j=0; j<m; j++) {
				if (c[j] >= 0) {
					c[j] = (0.3705223107287920 * Math.log((c[j] * 0.7077625570776260) + 0.0375840001141552)/Math.LN10) + 0.6162444730868150;
				} else {
					c[j] = (c[j] + 0.0291229262672453)/0.330000000129966;
				}
			}
			break;
		case 2: // S-log
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.000000000000001) {
					c[j] = (0.3705223110 * Math.log(c[j] + 0.0375840000)/Math.LN10) + 0.6162444740;
				} else {
					c[j] = (c[j] + 0.0286107171)/0.3241960136;
				}
			}
			break;
		case 3: // C-Log
			for (var j=0; j<m; j++) {
				if (c[j] >= -0.0452664) {
					c[j] = (0.45310179472141 * Math.log((c[j] * 10.1596) + 1)/Math.LN10) + 0.1251224801564;
				} else {
					c[j] = (c[j] + 0.0467265867)/0.3734467748;
				}
			}
			break;
		case 4: // C-Log2
			for (var j=0; j<m; j++) {
				if (c[j] >= -0.006747091156) {
					c[j] = (0.241360772 * Math.log((c[j] * 87.09937546) + 1)/Math.LN10) + 0.092864125;
				} else {
					c[j] = (c[j] + 0.006747091156)/0.045164984;
				}
			}
			break;
		case 5: // V-Log
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.009) {
					c[j] = (0.241514 * Math.log((c[j] * 0.9) + 0.00873)/Math.LN10) + 0.598206;
				} else {
					c[j] = (c[j] + 0.024801587)/0.198412698;
				}
			}
			break;
		case 6: // Cineon
		case 7: // RedLogFilm
			for (var j=0; j<m; j++) {
				if (c[j] < -0.006278688) {
					c[j] = (c[j] + 0.006278688)/0.045949378;
				} else {
					c[j] = ((Math.log((c[j]*0.890282024)+0.010797752)/(Math.LN10*0.003333333))+685)/1023;
				}
			}
			break;
		case 8: // LogC (Sup 3.x & 4.x)
		case 9: // LogC (Sup 2.x)
			p = this.arri;
			for (var j=0; j<m; j++) {
				c[j] = c[j] * 0.9;
				if (c[j] > p.cut) {
					c[j] = ((p.c * Math.log((p.a * c[j]) + p.b)/Math.LN10) + p.d);
				} else {
					c[j] = ((p.e * c[j]) + p.ff);
				}
			}
			break;
		default: // S-Log3
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.0125) {
					c[j] = (0.2556207230 * Math.log((c[j] * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850;
				} else {
					c[j] = (c[j] + 0.0155818840)/0.1677922920;
				}
			}
	}
	if (this.inL) {
		for (var j=0; j<m; j++) {
			c[j] = ((c[j]*1023)-64)/876;
		}
	}
	if (this.preInt === 0) {
		this.lut.RGBCub(buff);
	} else if (this.preInt === 1) {
		this.lut.RGBTet(buff);
	} else {
		this.lut.RGBLin(buff);
	}
	if (this.inL) {
		for (var j=0; j<m; j++) {
			c[j] = ((c[j]*876)+64)/1023;
		}
	}
	switch (this.natTF) {
		case 0: // S-Log3
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.1673609920) {
					c[j] = (Math.pow(10,(c[j] - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
				} else {
					c[j] = (0.1677922920*c[j]) - 0.0155818840;
				}
			}
			break;
		case 1: // S-Log2
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.0375840001141552) {
					c[j] = (Math.pow(10,(c[j] - 0.6162444730868150)/0.3705223107287920) - 0.0375840001141552)/0.7077625570776260;		
				} else {
					c[j] = (0.330000000129966*c[j]) - 0.0291229262672453;
				}
			}
			break;
		case 2: // S-Log
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.0882900450) {
					c[j] = (Math.pow(10,(c[j] - 0.6162444740)/0.3705223110) - 0.0375840000);		
				} else {
					c[j] = (0.3241960136*c[j]) - 0.0286107171;
				}
			}
			break;
		case 3: // C-Log
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.00391002619746) {
					c[j] = (Math.pow(10,(c[j] - 0.1251224801564)/0.45310179472141) - 1)/10.1596;		
				} else {
					c[j] = (0.3734467748*c[j]) - 0.0467265867;
				}
			}
			break;
		case 4: // C-Log2
			for (var j=0; j<m; j++) {
				if (c[j] >= 0) {
					c[j] = (Math.pow(10,(c[j] - 0.092864125)/0.241360772) - 1)/87.09937546;		
				} else {
					c[j] = (0.045164984*c[j]) - 0.006747091156;
				}
			}
			break;
		case 5: // V-Log
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.181) {
					c[j] = (Math.pow(10,(c[j] - 0.598206)/0.241514) - 0.00873)/0.9;		
				} else {
					c[j] = (0.198412698*c[j]) - 0.024801587;
				}
			}
			break;
		case 6: // Cineon
		case 7: // RedLogFilm
			for (var j=0; j<m; j++) {
				if (c[j] < 0) {
					c[j] = (c[j]*0.045949378) - 0.006278688;
				} else {
					c[j] = (Math.pow(10,((c[j]*1023)-685)*0.003333333) - 0.010797752)/0.890282024;
				}
			}
			break;
		case 8: // LogC (Sup 3.x & 4.x)
		case 9: // LogC (Sup 2.x)
			p = this.arri;
			for (var j=0; j<m; j++) {
				if (c[j] > ((p.e * p.cut) + p.ff)) {
					c[j] = (Math.pow(10, (c[j] - p.d) / p.c) - p.b)/(p.a*0.9);
				} else {
					c[j] = ((c[j] - p.ff) / (p.e*0.9));
				}
			}
			break;
		default: // S-Log3
			for (var j=0; j<m; j++) {
				if (c[j] >= 0.1673609920) {
					c[j] = (Math.pow(10,(c[j] - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
				} else {
					c[j] = (0.1677922920 * c[j]) - 0.0155818840;
				}
			}
	}
};
function CSCanonIDT(name, day, toSys, wp) {
	this.name = name;
	this.day = day;
	this.toSys = toSys;
	this.wp = wp;
	this.setParams();
}
CSCanonIDT.prototype.getWP = function() {
	return new Float64Array(this.wp.slice(0));
};
CSCanonIDT.prototype.setParams = function() {
	if (this.day) {
		this.cR = new Float64Array([
					 1.08190037262167000,-0.1802987013687820, 0.09839832874710690,
					 1.94585453645180000,-0.5095399369373750,-0.47489567735516000,
					-0.77808675219706800,-0.7412266070049000, 0.55789443704270100,
					-3.27787395719078000, 0.2548784176387170, 3.45581530576474000,
					 0.33547171397473900,-0.4335212547847600,-1.65050137344141000, 1.46581418175682,
					 0.94464656660567600,-0.7236530991558810,-0.37107650116785700]);
		this.cG = new Float64Array([
					-0.00858997792576314, 1.0067374011962100, 0.00185257672955608,
					 0.08487361382964520, 0.3476269064489020, 0.00202302744639390,
					-0.07905084140915240,-0.1794975829587160,-0.17597512335707200,
					 2.30205579706951000,-0.6272576133852190,-2.90795250918851000,
					 1.37002437502321000,-0.1086681585655630,-2.21150552827555000, 1.53315057595445,
					-0.54318870669950500, 1.6379303849037600,-0.44458861683658700]);
		this.cB = new Float64Array([
					 0.12696639806511000,-0.0118914411278690, 0.88492504306275900,
					 1.34780279822258000, 1.0364735225736500, 0.45911328995592200,
					-0.87815742229526800,-1.3066278750436000,-0.65860431341328300,
					-1.44440779967030000, 0.5566765887851730, 2.18798497054968000,
					-1.43030768398665000,-0.0388323570817641, 2.63698573112453000,-1.66598882056039,
					 0.33450249360103000,-1.6585693073090100, 0.52195618454768500]);
		this.sys = this.mMult(this.toSys,new Float64Array([
			0.561538969,0.402060105,0.036400926,
			0.092739623,0.924121198,-0.016860821,
			0.084812961,0.006373835,0.908813204					
		]));
	} else {
		this.cR = new Float64Array([
					 0.9638030044548990,-0.1607222025706550, 0.19691919811575600,
					 2.0344468563981900,-0.4426769314510210,-0.40798378153750900,
					-0.6407033231292540,-0.8602427982478480, 0.31715997796744600,
					-4.8056708010296600, 0.2711837039756700, 5.10690050495570000,
					 0.3408958169205850,-0.4869417385078620,-2.23737935753692000, 1.96647555251297,
					 1.3020405176624300,-1.0650311762855400,-0.39247302266737800]);
		this.cG = new Float64Array([
					-0.0421935892309314, 1.0484595917518300,-0.00626600252090315,
					-0.1064388968872160, 0.3629086214707810, 0.11807070047226100,
					 0.0193542539838734,-0.1560830295432670,-0.23781164949643300,
					 1.6791642058219800,-0.6328353271678970,-1.95984471387461000,
					 0.9532214645628140, 0.0599085176294623,-1.66452046236246000, 1.14041188349761,
					-0.3875526235503080, 1.1482009968551200,-0.33615394141170900]);
		this.cB = new Float64Array([
					 0.1702950331350280,-0.0682984448537245, 0.89800341171869700,
					 1.2210682199239900, 1.6019486592292500, 0.37759919113712400,
					-0.8257814284875310,-1.4459086807674900,-0.92892596103534400,
					-0.8385489974558520, 0.7580939721711600, 1.32966795243196000,
					-1.2002190566835500,-0.2548389958451290, 2.33232411639308000,-1.86381505762773,
					 0.1115760389564230,-1.1259331584976600, 0.75169318615728700]);
		this.sys = this.mMult(this.toSys,new Float64Array([
			0.566996399,0.365079418,0.067924183,
			0.070901044,0.880331008,0.048767948,
			0.073013542,-0.066540862,0.99352732
		]));
	}
};
CSCanonIDT.prototype.mMult = function(m1,m2) {
	var out = new Float64Array(9);
	out[0] = (m1[0]*m2[0]) + (m1[1]*m2[3]) + (m1[2]*m2[6]);
	out[1] = (m1[0]*m2[1]) + (m1[1]*m2[4]) + (m1[2]*m2[7]);
	out[2] = (m1[0]*m2[2]) + (m1[1]*m2[5]) + (m1[2]*m2[8]);
	out[3] = (m1[3]*m2[0]) + (m1[4]*m2[3]) + (m1[5]*m2[6]);
	out[4] = (m1[3]*m2[1]) + (m1[4]*m2[4]) + (m1[5]*m2[7]);
	out[5] = (m1[3]*m2[2]) + (m1[4]*m2[5]) + (m1[5]*m2[8]);
	out[6] = (m1[6]*m2[0]) + (m1[7]*m2[3]) + (m1[8]*m2[6]);
	out[7] = (m1[6]*m2[1]) + (m1[7]*m2[4]) + (m1[8]*m2[7]);
	out[8] = (m1[6]*m2[2]) + (m1[7]*m2[5]) + (m1[8]*m2[8]);
	return out;
};
CSCanonIDT.prototype.isMatrix = function() {
	return false;
};
CSCanonIDT.prototype.cb = function() {
	return false;
};
CSCanonIDT.prototype.lc = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var R2, G2, B2;
	var off;
	var lin = new Float64Array(3);
	for (var j=0; j<m; j++) {
// Linear to C-Log ire
		off = (10.1596*c[j])+1;
		if (off <= 0 ) {
			off = 0.00000000001;
		}
		c[j] = (0.529136*Math.log(off)/Math.LN10) + 0.0730597;
	}
	for (var j=0; j<m; j += 3) {
		R2 = c[ j ]*c[ j ];
		G2 = c[j+1]*c[j+1];
		B2 = c[j+2]*c[j+2];
		var vec = new Float64Array([
			c[ j ],					c[j+1],			c[j+2],
			c[ j ]*c[j+1],			c[j+1]*c[j+2],	c[j+2]*c[ j ],
			R2,						G2,				B2,
			R2*c[j+1],				R2*c[j+2],		c[ j ]*G2,
			c[ j ]*c[j+1]*c[j+2],	c[ j ]*B2,		G2*c[j+2],		c[j+1]*B2,
			c[ j ]*R2,				c[j+1]*G2,		c[j+2]*B2
		]);
// ACES conversion stage 1 (C-Log space)
		c[ j ] =	(this.cR[0]  * vec[0] ) + (this.cR[1]  * vec[1] ) + (this.cR[2]  * vec[2] ) +
			  		(this.cR[3]  * vec[3] ) + (this.cR[4]  * vec[4] ) + (this.cR[5]  * vec[5] ) +
			  		(this.cR[6]  * vec[6] ) + (this.cR[7]  * vec[7] ) + (this.cR[8]  * vec[8] ) +
			  		(this.cR[9]  * vec[9] ) + (this.cR[10] * vec[10]) + (this.cR[11] * vec[11]) +
			  		(this.cR[12] * vec[12]) + (this.cR[13] * vec[13]) + (this.cR[14] * vec[14]) + (this.cR[15] * vec[15]) +
			  		(this.cR[16] * vec[16]) + (this.cR[17] * vec[17]) + (this.cR[18] * vec[18]);
		c[j+1] =	(this.cG[0]  * vec[0] ) + (this.cG[1]  * vec[1] ) + (this.cG[2]  * vec[2] ) +
			  		(this.cG[3]  * vec[3] ) + (this.cG[4]  * vec[4] ) + (this.cG[5]  * vec[5] ) +
			  		(this.cG[6]  * vec[6] ) + (this.cG[7]  * vec[7] ) + (this.cG[8]  * vec[8] ) +
			  		(this.cG[9]  * vec[9] ) + (this.cG[10] * vec[10]) + (this.cG[11] * vec[11]) +
			  		(this.cG[12] * vec[12]) + (this.cG[13] * vec[13]) + (this.cG[14] * vec[14]) + (this.cG[15] * vec[15]) +
			  		(this.cG[16] * vec[16]) + (this.cG[17] * vec[17]) + (this.cG[18] * vec[18]);
		c[j+2] =	(this.cB[0]  * vec[0] ) + (this.cB[1]  * vec[1] ) + (this.cB[2]  * vec[2] ) +
			  		(this.cB[3]  * vec[3] ) + (this.cB[4]  * vec[4] ) + (this.cB[5]  * vec[5] ) +
			  		(this.cB[6]  * vec[6] ) + (this.cB[7]  * vec[7] ) + (this.cB[8]  * vec[8] ) +
			  		(this.cB[9]  * vec[9] ) + (this.cB[10] * vec[10]) + (this.cB[11] * vec[11]) +
			  		(this.cB[12] * vec[12]) + (this.cB[13] * vec[13]) + (this.cB[14] * vec[14]) + (this.cB[15] * vec[15]) +
			  		(this.cB[16] * vec[16]) + (this.cB[17] * vec[17]) + (this.cB[18] * vec[18]);
// C-Log back to linear
		lin[0] = (Math.pow(10,(c[ j ]-0.0730597)/0.529136)-1)/10.1596;
		lin[1] = (Math.pow(10,(c[j+1]-0.0730597)/0.529136)-1)/10.1596;
		lin[2] = (Math.pow(10,(c[j+2]-0.0730597)/0.529136)-1)/10.1596;
// CP -> ACES stage 2 -> system (Canon's IDT sets clip to max for Uint16 - ACES is actually half float and sets max to 65504)
		c[ j ] = Math.min(65504,(this.sys[0] * lin[0]) + (this.sys[1] * lin[1]) + (this.sys[2] * lin[2]));
		c[j+1] = Math.min(65504,(this.sys[3] * lin[0]) + (this.sys[4] * lin[1]) + (this.sys[5] * lin[2]));
		c[j+2] = Math.min(65504,(this.sys[6] * lin[0]) + (this.sys[7] * lin[1]) + (this.sys[8] * lin[2]));
	}
};
CSCanonIDT.prototype.lf = function(buff) {
	this.lc(buff);
};
function CSLabSpace(name, Xn, Yn, Zn, toSys, XYZ) {
	this.name = name;
	this.toSys = toSys;
	this.XYZ = XYZ;
	this.Xn = Xn / Yn;
	this.Yn = 1.0;
	this.Zn = Zn / Yn;
	this.d = 6.0 / 29.0;
	this.d3 = Math.pow(this.d, 3);
	this.oneover3d2 = 1.0 / (3.0 * this.d * this.d);
	this.threed2 = 3.0 * this.d * this.d;
	this.fourover29 = 4.0 / 29.0;
	
	this.p1 = 24389.0 / 2700.0;
	this.p2 = 0.16;
	this.p3 = 216.0 / 24389.0;
	this.p4 = 216.0 / 2700.0;
}
CSLabSpace.prototype.f = function(buff, transfer) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (transfer) {
		for (var j=0; j<m; j++) {
			if (c[j] >= this.p3) {
				c[j] = (1.16 * Math.cbrt(c[j])) - 0.16;
			} else {
				c[j] = this.p1 * c[j];
			}
		}
	} else {
		for (var j=0; j<m; j++) {
			if (c[j] >= this.p3) {
				c[j] = Math.cbrt(c[j]);
			} else {
				c[j] = ((this.p1 * c[j]) + 0.16) / 1.16;
			}
		}
	}
};
CSLabSpace.prototype.fInv = function(buff, transfer) {
	var c= new Float64Array(buff);
	var m = c.length;
	if (transfer) {
		for (var j=0; j<m; j++) {
			if (c[j] >= this.p4) {
				c[j] = Math.pow((c[j] + 0.16)/(1.16), 3.0);		
			} else {
				c[j] = (c[j] / this.p1);
			}
		}
	} else {
		for (var j=0; j<m; j++) {
			if (c[j] >= this.p4) {
				c[j] = Math.pow(c[j], 3.0);		
			} else {
				c[j] = ((c[j] * 1.16) - 0.16) / this.p1;
			}
		}
	}
};
CSLabSpace.prototype.getWP = function() {
	return new Float64Array([this.Xn, this.Yn, this.Zn]);
};
CSLabSpace.prototype.isMatrix = function() {
	return false;
};
CSLabSpace.prototype.cb = function() {
	return false;
};
CSLabSpace.prototype.lc = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (this.toSys) {
		this.f(c.buffer, true);
		var m = c.length;
		var fY;
		for (var j=0; j<m; j+= 3) {
			fY = (c[ j ] + 0.16) / 1.16;
			c[ j ] = (c[j+1] + fY) / 5.0;
			c[j+2] = (c[j+2] + fY) / 2.0;
			c[j+1] = fY;
		}
		this.fInv(c.buffer, false);
		for (var j=0; j<m; j+= 3) {
			c[ j ] *= this.Xn;
			c[j+1] *= this.Yn;
			c[j+2] *= this.Zn;
		}
		this.XYZ.lc(c.buffer);
	} else {
		this.XYZ.lc(c.buffer);
		for (var j=0; j<m; j+= 3) {
			c[ j ] /= this.Xn;
			c[j+1] /= this.Yn;
			c[j+2] /= this.Zn;
		}
		this.f(c.buffer, false);
		var fY;
		for (var j=0; j<m; j+= 3) {
			fY = c[j+1];
			c[j+1] = 5.0 * (c[ j ] - fY);	// a*
			c[j+2] = 2.0 * (c[j+2] - fY);	// b*
			c[ j ] = (1.16 * fY) - 0.16;	// L*
		}
		this.fInv(c.buffer, true);
	}
};
CSLabSpace.prototype.lf = function(buff) {
	this.lc(buff);
};
// IO functions
LUTColourSpace.prototype.setParams = function(params) {
	var out = {	t: 20, v: this.ver };
	if (typeof params.v !== 'number') {
		out.err = true;
		out.details = 'Missing version no.';
		return out;
	}
	out.to = [];
	if (typeof params.inGamut === 'number') {
		this.curIn = params.inGamut;
		out.inGamut = this.curIn;
	}
	if (typeof params.outGamut === 'number') {
		this.curOut = params.outGamut;
		out.outGamut = this.curOut;
	}
	if (typeof params.tweaks === 'boolean') {
		this.tweaks = params.tweaks;
	} else {
		this.tweaks = false;
	}
	if (typeof params.twkLA !== 'undefined') {
		var genInt,preInt;
		if (typeof params.twkLA.genInt === 'number' ) {
			genInt = params.twkLA.genInt;
		} else {
			genInt = 0; // tricubic
		}
		if (typeof params.twkLA.preInt === 'number' ) {
			preInt = params.twkLA.preInt;
		} else {
			preInt = 1; // tetrahedral
		}
		this.csOut[this.LA].setInterpolation(genInt,preInt);
	}
	out.twkCS = this.setCS(params);
	out.twkWB = this.setWB(params);
	out.twkASCCDL = this.setASCCDL(params);
	out.twkPSSTCDL = this.setPSSTCDL(params);
	out.twkHG = this.setHG(params);
	out.twkMulti = this.setMulti(params);
	out.twkSDRSat = this.setSDRSat(params);
	out.twkGamutLim = this.setGamutLim(params);
	out.twkFC = this.setFC(params);
	if (typeof params.isTrans === 'boolean') {
		this.isTrans = params.isTrans;
	}
	this.ver = params.v;
	out.v = this.ver;
	return out;
};
LUTColourSpace.prototype.calc = function(p,t,i,g) {
	var buff = i.o;
	var o = new Float64Array(buff);
	var out = { p: p, t: t+20, v: this.ver, outGamut: this.curOut, o:buff,  cb: this.csOut[this.curOut].cb()};
	out.to = ['o'];
	if (g) {
		out.R = i.R;
		out.G = i.G;
		out.B = i.B;
		out.vals = i.vals;
		out.dim = i.dim;
	} else {
		out.leg = i.leg;
		out.line =  i.line;
		out.upd = i.upd;
		out.threeD = true;
	}
	if (!this.nul) {
		if (g) {
			this.csIn[this.curIn].lc(buff);
		}
		var y = this.y;
		var max = o.length;
		var eiMult = i.eiMult;
		var Y;
// CineEI / Exposure Shift
		for (var j=0; j<max; j++) {
			if (isNaN(o[j])) {
				o[j] = 0;
			} else {
				o[j] *= eiMult;
			}
		}
// False Colour
		if (this.doFC) {
			this.FCOut(buff,out);
		}
		out.doFC = this.doFC;
// Colour Temperature Shift
		if (this.doWB) {
			this.wb.lc(buff);
		}
// PSST-CDL
		if (this.doPSSTCDL) {
			this.PSSTCDLOut(buff);
		}
// ASC-CDL
		if (this.doASCCDL) {
			this.ASCCDLOut(buff);
		}
// MultiTone
		if (this.doMulti) {
			this.multiOut(buff);
		}		
// Highlight Gamut
		if (this.doHG) {
			this.HGOut(buff,g);
		} else {
			if (g) {
				this.csOut[this.curOut].lc(buff);
			} else {
				this.csOut[this.curOut].lf(buff);
			}
		}
// SDR Saturation
		if (this.doSDRSat) {
			this.SDRSatOut(buff);
		}		
// Gamut Limiter
		if (this.doGamutLim) {
			this.gamutLimOut(buff,out);
		} else {
			out.doGamutLim = false;
		}
	}
// Done
	return out;
};
LUTColourSpace.prototype.laCalc = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, dim: i.dim, gamma: i.gamma, gamut: i.gamut };
	if (i.gamut === this.custOut) {
		out.inputMatrix = this.mInverse(this.csIn[this.custIn].getMatrix()).buffer;
	} else {
		out.inputMatrix = this.csOut[i.gamut].getMatrix().buffer.slice(0);
	}
	out.to = ['inputMatrix'];
	return out;
};
LUTColourSpace.prototype.recalcMatrix = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, idx: i.idx, wcs: i.newWCS};
	var matrix;
	var oMat = new Float64Array(i.matrix);
	if (i.newWCS === this.xyzIdx) {
		matrix = this.mMult(this.g[i.oldWCS].toXYZ,oMat);
	} else if (i.oldWCS === this.xyzIdx) {
		matrix = this.mMult(this.mInverse(this.g[i.newWCS].toXYZ),oMat);
	} else {
		var oToXYZ = this.g[i.oldWCS].toXYZ;
		var nFromXYZ = this.mInverse(this.g[i.newWCS].toXYZ);
		var oToN = this.mMult(nFromXYZ, this.calcCAT(oToXYZ,this.g[i.oldWCS].white,this.g[i.newWCS].white,i.cat));
		matrix = this.mMult(oToN,oMat);
	}
	out.matrix = matrix.buffer;
	out.to = ['matrix'];
	return out;
};
LUTColourSpace.prototype.loadDefaultLUTs = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver};
	var meta;
	if (typeof i.meta !== 'undefined') {
		meta = i.meta;
	} else {
		meta = {};
	}
	if (typeof i.title !== 'undefined') {
		out.title = i.title;
	}
	var lut = this.csOut[this.defLUTs[i.fileName]];
	var idx = -1;
	if (typeof meta.inputCS !== 'undefined' && meta.inputCS !== '') {
		var list = this.laList;
		var m = list.length;
		var idx = -1
		if (meta.inputCS !== 'Custom In') {
			for (var j=0; j<m; j++) {
				if (list.name === meta.inputCS) {
					idx = list.idx;
					break;
				}
			}
		}
	}
	if (idx < 0) { // custom / unknown gamut - use the matrix supplied with the LA LUT
	} else if (idx !== this.sysIdx) {
		meta.inputMatrix = this.csOut[idx].getMatrix();
	} else { // The system default so no input matrix needed
		meta.inputMatrix = new Float64Array([1,0,0, 0,1,0, 0,0,1]);
	}
	var params = {
		name: lut.name,
		format: 'cube',
		dims: i.dims,
		s: i.s,
		min: i.min,
		max: i.max,
		C: i.C,
		meta: meta
	};
	lut.setLUT(params);
	return out;
};
LUTColourSpace.prototype.getLists = function(p,t) {
	return {
		p: p,
		t: t+20,
		v: this.ver,
		inList: this.inList,
		outList: this.outList,
		laList: this.laList,
		matList: this.matList,
		subNames: this.subNames,
		inSub: this.csInSub,
		outSub: this.csOutSub,
		laSub: this.csLASub,
		CATList: this.CATs.getModels(),
		pass: this.pass,
		LA: this.LA
	};
};
LUTColourSpace.prototype.setLA = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver};
	var meta;
	if (typeof i.meta !== 'undefined') {
		meta = i.meta;
	} else {
		meta = {};
	}
	if (typeof i.title !== 'undefined') {
		out.title = i.title;
	}
	var lut = this.csOut[this.LA];
	var idx = -1;
	if (typeof meta.inputCS !== 'undefined' && meta.inputCS !== '') {
		var list = this.laList;
		var m = list.length;
		var idx = -1
		if (meta.inputCS !== 'Custom In') {
			for (var j=0; j<m; j++) {
				if (list.name === meta.inputCS) {
					idx = list.idx;
					break;
				}
			}
		}
	}
	if (idx < 0) { // custom / unknown gamut - use the matrix supplied with the LA LUT
	} else if (idx !== this.sysIdx) {
		meta.inputMatrix = this.csOut[idx].getMatrix();
	} else { // The system default so no input matrix needed
		meta.inputMatrix = new Float64Array([1,0,0, 0,1,0, 0,0,1]);
	}
	var params = {
		name: lut.name,
		format: 'cube',
		dims: i.dims,
		s: i.s,
		min: i.min,
		max: i.max,
		C: i.C,
		meta: meta
	};
	lut.setLUT(params);
	return out;
};
LUTColourSpace.prototype.setLATitle = function(p,t,i) {
	this.csOut[this.LA].setTitle(i);
	return { p: p, t:t+20, v: this.ver, i: i };
};
LUTColourSpace.prototype.getColSqr = function(p,t,i) {
	var c = this.colSqr.slice(0);
	var f = new Float64Array(c);
	this.csOut[this.curOut].lc(c);
	var m = 256*256;
	var o = new Uint8Array(Math.round(4*m));
	var M;
	for (var j=0; j<m; j++) {
		M = 255 / Math.max.apply(Math, [f[ (j*3) ],f[(j*3)+1],f[(j*3)+2]]);
		if (M>255) {
			M = 255;
		}
		o[ (j*4) ] = Math.min(255,Math.max(0,f[ (j*3) ]*M));
		o[(j*4)+1] = Math.min(255,Math.max(0,f[(j*3)+1]*M));
		o[(j*4)+2] = Math.min(255,Math.max(0,f[(j*3)+2]*M));
		o[(j*4)+3] = 255;
	}
	return {p: p, t: t+20, v: this.ver, tIdx: i.tIdx, o: o.buffer, cb: this.csOut[this.curOut].cb(), to: ['o']};
};
LUTColourSpace.prototype.multiColours = function(p,t,i) {
	var buff = this.mclrs.slice(0);
	out = {p: p, t: t+20, v: this.ver, o: buff, cb: this.csOut[this.curOut].cb(), to: ['o','hs']};
// Colour Temperature Shift
	if (this.doWB) {
		this.wb.lc(buff);
	}
// PSST-CDL
	if (this.doPSSTCDL) {
		this.PSSTCDLOut(buff);
	}
// ASC-CDL
	if (this.doASCCDL) {
		this.ASCCDLOut(buff);
	}
// MultiTone
	this.multiOut(buff);		
// Highlight Gamut
	if (this.doHG) {
		this.HGOut(buff,false);
	} else {
		this.csOut[this.curOut].lf(buff);
	}
// Gamut Limiter
	if (this.doGamutLim) {
		this.gamutLimOut(buff,out);
	} else {
		out.doGamutLim = false;
	}
// Multi Tones
	var m = i.hues.length;
	var hf = new Float64Array(m*3);
	var f = new Float64Array(this.colSqr);
	var k;
	for (var j=0; j<m; j++) {
		k = (i.hues[j]+(256*(255-i.sats[j])))*3;
		hf[ (j*3) ] = f[ k ];
		hf[(j*3)+1] = f[k+1];
		hf[(j*3)+2] = f[k+2];
	}
	this.csOut[this.curOut].lc(hf.buffer);
	var hs = new Uint8Array(m*3);
	var M;
	for (var j=0; j<m; j++) {
		M = 255 / Math.max.apply(Math, [hf[ (j*3) ],hf[(j*3)+1],hf[(j*3)+2]]);
		if (M>255) {
			M = 255;
		}
		hs[ (j*3) ] = Math.min(255,Math.max(0,hf[ (j*3) ]*M));
		hs[(j*3)+1] = Math.min(255,Math.max(0,hf[(j*3)+1]*M));
		hs[(j*3)+2] = Math.min(255,Math.max(0,hf[(j*3)+2]*M));
	}
	out.hs = hs.buffer;
	return out;
};
LUTColourSpace.prototype.ioNames = function(p,t) {
	var out = {};
	out.inName = this.csIn[this.curIn].name;
	out.outName = this.csOut[this.curOut].name;
	out.hgName = this.csOut[this.curHG].name;
	return {p: p, t: t+20, v: this.ver, o: out};
};
LUTColourSpace.prototype.chartVals = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, cb: this.csOut[this.curOut].cb()};
	if (typeof i.colIn !== 'undefined') {
		var y = this.y;
		var colIn = new Float64Array(i.colIn);
		var m = colIn.length*3;
		var rIn = new Float64Array(m);
		var gIn = new Float64Array(m);
		var bIn = new Float64Array(m);
		var k = 0;
		var last = Math.round((m/3)-1);
		var rM = 12.8/(colIn[last-2] * 0.2126);
		var gM = 12.8/(colIn[last-1] * 0.7152);
		var bM = 12.8/(colIn[ last ] * 0.0722);
		for (var j=0; j<m; j += 3) {
			rIn[ j ] = Math.pow(colIn[k] * rM, 1.5);
			gIn[j+1] = Math.pow(colIn[k] * gM, 1.5);
			bIn[j+2] = Math.pow(colIn[k] * bM, 1.5);
			k++;
		}
		this.csIn[this.rec709In].lc(rIn.buffer);
		this.csIn[this.rec709In].lc(gIn.buffer);
		this.csIn[this.rec709In].lc(bIn.buffer);
		var r = new Float64Array(rIn.buffer.slice(0));
		var g = new Float64Array(gIn.buffer.slice(0));
		var b = new Float64Array(bIn.buffer.slice(0));
		var eiMult = i.eiMult;
		var max = this.csOut.length;
		var got = false;
		for (var j=0; j<max; j++) {
			if (this.csOut[j].name === this.csIn[this.curIn].name) {
				this.csOut[j].lc(rIn.buffer);
				this.csOut[j].lc(gIn.buffer);
				this.csOut[j].lc(bIn.buffer);
				got = true;
				break;
			}
		}
		if (!got) {
			self.postMessage({msg:true,details:this.csIn[this.curIn].name});
			return out;
		}
// self.postMessage({msg:true,details:r});
// self.postMessage({msg:true,details:g});
// self.postMessage({msg:true,details:b});
		for (var j=0; j<m; j++) {
			if (isNaN(r[j])) {
				r[j] = 0;
			} else {
				r[j] *= eiMult;
			}
			if (isNaN(g[j])) {
				g[j] = 0;
			} else {
				g[j] *= eiMult;
			}
			if (isNaN(b[j])) {
				b[j] = 0;
			} else {
				b[j] *= eiMult;
			}
		}
	// Colour Temperature Shift
		if (this.doWB) {
			this.wb.lc(r.buffer);
			this.wb.lc(g.buffer);
			this.wb.lc(b.buffer);
		}
/*
		if (this.doCT) {
			this.CAT.lc(r.buffer);
			this.CAT.lc(g.buffer);
			this.CAT.lc(b.buffer);
		}
*/
	// Fluori Correction
/*
		if (this.doFL) {
			this.green.lc(r.buffer);
			this.green.lc(g.buffer);
			this.green.lc(b.buffer);
		}
*/
	// ASC-CDL
		if (this.doASCCDL) {
			var Y;
			for (var j=0; j<m; j += 3) {
				r[ j ] = (r[ j ]*this.asc[0])+this.asc[3];
				r[ j ] = ((r[ j ]<0)?r[ j ]:Math.pow(r[ j ],this.asc[6]));
				r[ j ] = (isNaN(r[ j ])?0:r[ j ]);
				r[j+1] = (r[j+1]*this.asc[1])+this.asc[4];
				r[j+1] = ((r[j+1]<0)?r[j+1]:Math.pow(r[j+1],this.asc[7]));
				r[j+1] = (isNaN(r[j+1])?0:r[j+1]);
				r[j+2] = (r[j+2]*this.asc[2])+this.asc[5];
				r[j+2] = ((r[j+2]<0)?r[j+2]:Math.pow(r[j+2],this.asc[8]));
				r[j+2] = (isNaN(r[j+2])?0:r[j+2]);
				Y = (y[0]*r[j])+(y[1]*r[j+1])+(y[2]*r[j+2]);
				r[ j ] = Y + (this.asc[9]*(r[ j ]-Y));
				r[j+1] = Y + (this.asc[9]*(r[j+1]-Y));
				r[j+2] = Y + (this.asc[9]*(r[j+2]-Y));
				g[ j ] = (g[ j ]*this.asc[0])+this.asc[3];
				g[ j ] = ((g[ j ]<0)?g[ j ]:Math.pow(g[ j ],this.asc[6]));
				g[ j ] = (isNaN(g[ j ])?0:g[ j ]);
				g[j+1] = (g[j+1]*this.asc[1])+this.asc[4];
				g[j+1] = ((g[j+1]<0)?g[j+1]:Math.pow(g[j+1],this.asc[7]));
				g[j+1] = (isNaN(g[j+1])?0:g[j+1]);
				g[j+2] = (g[j+2]*this.asc[2])+this.asc[5];
				g[j+2] = ((g[j+2]<0)?g[j+2]:Math.pow(g[j+2],this.asc[8]));
				g[j+2] = (isNaN(g[j+2])?0:g[j+2]);
				Y = (y[0]*g[j])+(y[1]*g[j+1])+(y[2]*g[j+2]);
				g[ j ] = Y + (this.asc[9]*(g[ j ]-Y));
				g[j+1] = Y + (this.asc[9]*(g[j+1]-Y));
				g[j+2] = Y + (this.asc[9]*(g[j+2]-Y));
				b[ j ] = (b[ j ]*this.asc[0])+this.asc[3];
				b[ j ] = ((b[ j ]<0)?b[ j ]:Math.pow(b[ j ],this.asc[6]));
				b[ j ] = (isNaN(b[ j ])?0:b[ j ]);
				b[j+1] = (b[j+1]*this.asc[1])+this.asc[4];
				b[j+1] = ((b[j+1]<0)?b[j+1]:Math.pow(b[j+1],this.asc[7]));
				b[j+1] = (isNaN(b[j+1])?0:b[j+1]);
				b[j+2] = (b[j+2]*this.asc[2])+this.asc[5];
				b[j+2] = ((b[j+2]<0)?b[j+2]:Math.pow(b[j+2],this.asc[8]));
				b[j+2] = (isNaN(b[j+2])?0:b[j+2]);
				Y = (y[0]*b[j])+(y[1]*b[j+1])+(y[2]*b[j+2]);
				b[ j ] = Y + (this.asc[9]*(b[ j ]-Y));
				b[j+1] = Y + (this.asc[9]*(b[j+1]-Y));
				b[j+2] = Y + (this.asc[9]*(b[j+2]-Y));
			}
		}
	// Highlight Gamut
		if (this.doHG) {
			var Y;
			var hr = new Float64Array(r.buffer.slice(0));
			var hg = new Float64Array(g.buffer.slice(0));
			var hb = new Float64Array(b.buffer.slice(0));
			this.csOut[this.curOut].lf(r.buffer);
			this.csOut[this.curHG].lf(hr.buffer);
			this.csOut[this.curOut].lf(g.buffer);
			this.csOut[this.curHG].lf(hg.buffer);
			this.csOut[this.curOut].lf(b.buffer);
			this.csOut[this.curHG].lf(hb.buffer);
			var rat;
			for (var j=0; j<m; j += 3) {
				Y = (y[0]*r[j])+(y[1]*r[j+1])+(y[2]*r[j+2]);
				if (Y >= this.hgHigh) {
					r[ j ] = hr[j];
					r[j+1] = hr[j+1];
					r[j+2] = hr[j+2];
				} else if (Y > this.hgLow) {
					if (this.hgLin) {
						rat = (this.hgHigh - Y)/(this.hgHigh - this.hgLow);
					} else {
						rat = (this.hgHighStop - (Math.log(Y * 5)/Math.LN2))/(this.hgHighStop - this.hgLowStop);
					}
					r[ j ] = (r[ j ] * (rat)) + (hr[ j ] * (1-rat));
					r[j+1] = (r[j+1] * (rat)) + (hr[j+1] * (1-rat));
					r[j+2] = (r[j+2] * (rat)) + (hr[j+2] * (1-rat));
				}
				Y = (y[0]*g[j])+(y[1]*g[j+1])+(y[2]*g[j+2]);
				if (Y >= this.hgHigh) {
					g[ j ] = hg[j];
					g[j+1] = hg[j+1];
					g[j+2] = hg[j+2];
				} else if (Y > this.hgLow) {
					if (this.hgLin) {
						rat = (this.hgHigh - Y)/(this.hgHigh - this.hgLow);
					} else {
						rat = (this.hgHighStop - (Math.log(Y * 5)/Math.LN2))/(this.hgHighStop - this.hgLowStop);
					}
					g[ j ] = (g[ j ] * (rat)) + (hg[ j ] * (1-rat));
					g[j+1] = (g[j+1] * (rat)) + (hg[j+1] * (1-rat));
					g[j+2] = (g[j+2] * (rat)) + (hg[j+2] * (1-rat));
				}
				Y = (y[0]*b[j])+(y[1]*b[j+1])+(y[2]*b[j+2]);
				if (Y >= this.hgHigh) {
					b[ j ] = hb[j];
					b[j+1] = hb[j+1];
					b[j+2] = hb[j+2];
				} else if (Y > this.hgLow) {
					if (this.hgLin) {
						rat = (this.hgHigh - Y)/(this.hgHigh - this.hgLow);
					} else {
						rat = (this.hgHighStop - (Math.log(Y * 5)/Math.LN2))/(this.hgHighStop - this.hgLowStop);
					}
					b[ j ] = (b[ j ] * (rat)) + (hb[ j ] * (1-rat));
					b[j+1] = (b[j+1] * (rat)) + (hb[j+1] * (1-rat));
					b[j+2] = (b[j+2] * (rat)) + (hb[j+2] * (1-rat));
				}
			}
		} else {
			this.csOut[this.curOut].lf(r.buffer);
			this.csOut[this.curOut].lf(g.buffer);
			this.csOut[this.curOut].lf(b.buffer);
		}
		var rInput = new Float64Array(colIn.length);
		var gInput = new Float64Array(colIn.length);
		var bInput = new Float64Array(colIn.length);
		var rOutput = new Float64Array(colIn.length);
		var gOutput = new Float64Array(colIn.length);
		var bOutput = new Float64Array(colIn.length);
		k = 0;
		for (var j=0; j<m; j += 3) {
			rInput[k] = ((0.2126*rIn[j])+(0.7152*rIn[j+1])+(0.0722*rIn[j+2]));
			gInput[k] = ((0.2126*gIn[j])+(0.7152*gIn[j+1])+(0.0722*gIn[j+2]));
			bInput[k] = ((0.2126*bIn[j])+(0.7152*bIn[j+1])+(0.0722*bIn[j+2]));
			rOutput[k] = ((0.2126*r[j])+(0.7152*r[j+1])+(0.0722*r[j+2]));
			gOutput[k] = ((0.2126*g[j])+(0.7152*g[j+1])+(0.0722*g[j+2]));
			bOutput[k] = ((0.2126*b[j])+(0.7152*b[j+1])+(0.0722*b[j+2]));
			k++;
		}
		out.rIn = rInput.buffer;
		out.gIn = gInput.buffer;
		out.bIn = bInput.buffer;
		out.rOut = rOutput.buffer;
		out.gOut = gOutput.buffer;
		out.bOut = bOutput.buffer;
		out.to = ['rIn', 'gIn', 'bIn', 'rOut', 'gOut', 'bOut'];
	}
	return out;
};
LUTColourSpace.prototype.getCATs = function(p,t) {
	return {
		p: p,
		t: t+20,
		v: this.ver,
		o: this.CATs.getModels()
	};
};
LUTColourSpace.prototype.previewLin = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, gamma: i.gamma, gamut: i.gamut, legal: i.legal, i: i.i, o: i.o };
	this.csIn[i.gamut].lc(i.o);
	out.to = ['i','o'];
	return out;
};
LUTColourSpace.prototype.getPrimaries = function(p,t) {
	var c = this.clrs.slice(0);
	this.csOut[this.curOut].lc(c);
	return {p: p, t: t+20, v: this.ver, o: c, cb: this.csOut[this.curOut].cb(), to: ['o']};
};
LUTColourSpace.prototype.psstColours = function(p,t) {
	var out = { p: p, t: t+20, v: this.ver,  cb: this.csOut[this.curOut].cb() };
	var bef64 = new Float64Array(84);
	var aft64 = new Float64Array(84);
	var f,a,m1,m2,M,Y,c,sat,Pb,Pr;
	var y = this.y;
	var Db = 2*(1-y[2]);
	var Dr = 2*(1-y[0]);
	var i=0;
	for (var j=0; j<84; j += 3) {
		f = i;
		i += 1/28;
		a = this.psstB.fCub(f);
		m1 = this.psstM.fLin(f);
		c = this.psstC.fCub(f);
		sat = this.psstSat.fCub(f);
		if (sat < 0) {
			sat = 0;
		}
		S = this.psstS.fCub(f);
		if (S < 0) {
			S = 0;
		}
		O = this.psstO.fCub(f);
		P = this.psstP.fCub(f);
		if (P < 0) {
			P = 0;
		}
		M = 0.5 * m1;
		y1 = this.psstY.fLin(f);
		Y = 0.7*y1;
		Pb = M * Math.cos(a);
		Pr = M * Math.sin(a);
		bef64[ j ] = (Pr * Dr) + Y;
		bef64[j+2] = (Pb * Db) + Y;
		bef64[j+1] = (Y - (y[0]*bef64[ j ]) -(y[2]*bef64[j+2]))/y[1];
		f = (f+c%1);
		if (this.psstYC) {
			y2 = this.psstY.fLin(f);
		} else {
			y2 = y1;
		}
		if (this.psstMC) {
			m2 = this.psstM.fLin(f);
		} else {
			m2 = m1;
		}
		M = M * m2 * sat / m1;
		a = this.psstB.fCub(f);
		Y = (Y*S/y1)+O;
		Y = ((Y<0)?Y:Math.pow(Y,P));
		Y = (isNaN(Y)?0:Y);
		Y *= y2;
		Pb = M * Math.cos(a);
		Pr = M * Math.sin(a);
		aft64[ j ] = (Pr * Dr) + Y;
		aft64[j+2] = (Pb * Db) + Y;
		aft64[j+1] = (Y - (y[0]*aft64[ j ]) -(y[2]*aft64[j+2]))/y[1];
	}
	this.csOut[this.curOut].lc(bef64.buffer);
	this.csOut[this.curOut].lc(aft64.buffer);
	out.b = bef64.buffer;
	out.a = aft64.buffer;
	out.to = ['b','a'];
	return out;
};
LUTColourSpace.prototype.getCCTDuv = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver };
	var rgb = new Float64Array(i.rgb);
	var XYZ = this.wb.toLocus(this.mMult(this.system.toXYZ,rgb));
	var L = XYZ[0] + XYZ[1] + XYZ[2];
	var xyz = new Float64Array([XYZ[0]/L,XYZ[1]/L,XYZ[2]/L]);
	var CCT = this.planck.getCCT(xyz);
	var delta = this.planck.getDuvMag(xyz,CCT);
	out.sys = this.wb.getSys();
	out.ct = CCT;
	out.lamp = out.ct;
	out.duv = (-delta[0] / 0.0175).toFixed(2);
//	out.dpl = (-delta[1] / 0.0175).toFixed(2);
	out.dpl = 0;
	this.wb.setVals(out.sys,out.ct,out.lamp,out.duv,out.dpl);
	return out;
};
LUTColourSpace.prototype.calcPrimaries = function(p,t) {
	var gIn = new Float64Array([ // The input or recorded gamut - these values to be converted to XYZ then xy
		1,1,1,
		1,0,0,
		0,1,0,
		0,0,1
	]);
	var gOut = new Float64Array([ // The output gamut - these values to be converted to XYZ then xy
		1,1,1,
		1,0,0,
		0,1,0,
		0,0,1
	]);
	var m = 4;
	var xy = new Float64Array(16);
	var k,l,den;
	var wd,ws;
	var XYZ;

	// Input Gamut
	this.csIn[this.curIn].lc(gIn.buffer);
	this.csOut[this.XYZOut].lc(gIn.buffer);
	wd = this.csIn[this.curIn].getWP();
	ws = this.system.white;
	for (var j=0; j<4; j++) {
		k = j*3;
		l = j*2;
		XYZ = this.calcCAT(new Float64Array([gIn[k],gIn[k+1],gIn[k+2]]),ws,wd,this.inCATs[this.curIn]);
		den = XYZ[0] + XYZ[1] + XYZ[2];
		xy[ l ] = (XYZ[0]/den);
		xy[l+1] = (XYZ[1]/den);
	}
	// Output Gamut
	this.rx(gOut.buffer);
	this.csOut[this.XYZOut].lc(gOut.buffer);
	wd = this.csOut[this.curOut].getWP();
	ws = this.system.white;
	for (var j=0; j<4; j++) {
		k = j*3;
		l = j*2;
		XYZ = this.calcCAT(new Float64Array([gOut[k],gOut[k+1],gOut[k+2]]),ws,wd,this.outCATs[this.curOut]);
		den = XYZ[0] + XYZ[1] + XYZ[2];
		xy[l+8] = (XYZ[0]/den);
		xy[l+9] = (XYZ[1]/den);
	}
	// Return object
	return {
		p: p,
		t: t+20,
		v: this.ver,
		xy: xy
	};
};
// Web worker messaging functions
function LUTCSWorker() {
	this.cs = new LUTColourSpace();
	addEventListener('message', function(e) {
		var d = e.data;
		if (typeof d.t === 'undefined') {
		} else if (d.t !== 0 && d.t < 20 && d.v !== lutCSWorker.cs.ver) {
			postMessage({p: d.p, t: d.t, v: d.v, resend: true, d: d.d});
		} else {
			switch (d.t) {
				case 0:	lutCSWorker.sendCSMessage(lutCSWorker.cs.setParams(d.d));
						break;
				case 1: lutCSWorker.sendCSMessage(lutCSWorker.cs.calc(d.p,d.t,d.d,true)); 
						break;
				case 2: lutCSWorker.sendCSMessage(lutCSWorker.cs.laCalc(d.p,d.t,d.d)); 
						break;
				case 3: lutCSWorker.sendCSMessage(lutCSWorker.cs.recalcMatrix(d.p,d.t,d.d)); 
						break;
				case 4: lutCSWorker.sendCSMessage(lutCSWorker.cs.loadDefaultLUTs(d.p,d.t,d.d)); 
						break;
				case 5: lutCSWorker.sendCSMessage(lutCSWorker.cs.getLists(d.p,d.t)); 
						break;
				case 6: lutCSWorker.sendCSMessage(lutCSWorker.cs.setLA(d.p,d.t,d.d)); 
						break;
				case 7: lutCSWorker.sendCSMessage(lutCSWorker.cs.setLATitle(d.p,d.t,d.d)); 
						break;
				case 8: lutCSWorker.sendCSMessage(lutCSWorker.cs.getColSqr(d.p,d.t,d.d)); 
						break;
				case 9: lutCSWorker.sendCSMessage(lutCSWorker.cs.multiColours(d.p,d.t,d.d)); 
						break;
				case 10:lutCSWorker.sendCSMessage(lutCSWorker.cs.ioNames(d.p,d.t));
						break;
				case 11:lutCSWorker.sendCSMessage(lutCSWorker.cs.chartVals(d.p,d.t,d.d));
						break;
				case 12:lutCSWorker.sendCSMessage(lutCSWorker.cs.calc(d.p,d.t,d.d,false)); 
						break;
				case 14:lutCSWorker.sendCSMessage(lutCSWorker.cs.previewLin(d.p,d.t,d.d));
						break;
				case 15:lutCSWorker.sendCSMessage(lutCSWorker.cs.getPrimaries(d.p,d.t));
						break;
				case 16:lutCSWorker.sendCSMessage(lutCSWorker.cs.psstColours(d.p,d.t));
						break;
				case 17:lutCSWorker.sendCSMessage(lutCSWorker.cs.getCATs(d.p,d.t));
						break;
				case 18:lutCSWorker.sendCSMessage(lutCSWorker.cs.getCCTDuv(d.p,d.t,d.d));
						break;
				case 19:lutCSWorker.sendCSMessage(lutCSWorker.cs.calcPrimaries(d.p,d.t));
						break;
			}
		}
	}, false);
}
LUTCSWorker.prototype.sendCSMessage = function(d) {
	if (this.cs.isTrans && typeof d.to !== 'undefined') {
		var max = d.to.length;
		var objArray = [];
		for (var j=0; j < max; j++) {
			objArray.push(d[d.to[j]]);
		}
		postMessage(d,objArray);
	} else {
		postMessage(d);
	}
};
// Stringify for inline Web Workers
function getCSString() {
	var out = "";
	// LUTColourSpace
	out += LUTColourSpace.toString() + "\n";
	for (var j in LUTColourSpace.prototype) {
		out += 'LUTColourSpace.prototype.' + j + '=' + LUTColourSpace.prototype[j].toString() + "\n";
	}
	// CCTxy
	out += CCTxy.toString() + "\n";
	for (var j in CCTxy.prototype) {
		out += 'CCTxy.prototype.' + j + '=' + CCTxy.prototype[j].toString() + "\n";
	}
	// Planck
	out += Planck.toString() + "\n";
	for (var j in Planck.prototype) {
		out += 'Planck.prototype.' + j + '=' + Planck.prototype[j].toString() + "\n";
	}
	// CSCAT
	out += CSCAT.toString() + "\n";
	for (var j in CSCAT.prototype) {
		out += 'CSCAT.prototype.' + j + '=' + CSCAT.prototype[j].toString() + "\n";
	}
	// CSWB
	out += CSWB.toString() + "\n";
	for (var j in CSWB.prototype) {
		out += 'CSWB.prototype.' + j + '=' + CSWB.prototype[j].toString() + "\n";
	}
	// CSSL3
	out += CSSL3.toString() + "\n";
	for (var j in CSSL3.prototype) {
		out += 'CSSL3.prototype.' + j + '=' + CSSL3.prototype[j].toString() + "\n";
	}
	// CSLogC
	out += CSLogC.toString() + "\n";
	for (var j in CSLogC.prototype) {
		out += 'CSLogC.prototype.' + j + '=' + CSLogC.prototype[j].toString() + "\n";
	}
	// CSVLog
	out += CSVLog.toString() + "\n";
	for (var j in CSVLog.prototype) {
		out += 'CSVLog.prototype.' + j + '=' + CSVLog.prototype[j].toString() + "\n";
	}
	// CSMatrix
	out += CSMatrix.toString() + "\n";
	for (var j in CSMatrix.prototype) {
		out += 'CSMatrix.prototype.' + j + '=' + CSMatrix.prototype[j].toString() + "\n";
	}
	// CSToneCurve
	out += CSToneCurve.toString() + "\n";
	for (var j in CSToneCurve.prototype) {
		out += 'CSToneCurve.prototype.' + j + '=' + CSToneCurve.prototype[j].toString() + "\n";
	}
	// CSToneCurvePlus
	out += CSToneCurvePlus.toString() + "\n";
	for (var j in CSToneCurvePlus.prototype) {
		out += 'CSToneCurvePlus.prototype.' + j + '=' + CSToneCurvePlus.prototype[j].toString() + "\n";
	}
	// CSLUT
	out += CSLUT.toString() + "\n";
	for (var j in CSLUT.prototype) {
		out += 'CSLUT.prototype.' + j + '=' + CSLUT.prototype[j].toString() + "\n";
	}
	// CSCanonIDT
	out += CSCanonIDT.toString() + "\n";
	for (var j in CSCanonIDT.prototype) {
		out += 'CSCanonIDT.prototype.' + j + '=' + CSCanonIDT.prototype[j].toString() + "\n";
	}
	// CSLabSpace
	out += CSLabSpace.toString() + "\n";
	for (var j in CSLabSpace.prototype) {
		out += 'CSLabSpace.prototype.' + j + '=' + CSLabSpace.prototype[j].toString() + "\n";
	}
	// LUTCSWorker
	out += LUTCSWorker.toString() + "\n";
	for (var j in LUTCSWorker.prototype) {
		out += 'LUTCSWorker.prototype.' + j + '=' + LUTCSWorker.prototype[j].toString() + "\n";
	}
	out += 'var lutCSWorker = new LUTCSWorker();' + "\n";
	return out;
}
var workerCSString = getCSString();
/* bounding.js
* Bounding Box objects for the LUTCalc Web App.
* 10th June 2016
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function Bound(baseMatrix,boxList) {
	this.b = baseMatrix;
	this.l = boxList;
}
Bound.prototype.lc = function(pBuff) {
	var p = new Float64Array(pBuff);
	var m = Math.round(p.length)/3;
	var m2 = this.l.length;
	var rgb;
	var r1,r2;
	var R,G,B;
	var mat = new Float64Array(11);
	var mat2 = new Float64Array(11);
	var buff = mat2.buffer;
	for (var j=0; j<m; j++) {
		rgb = p.subarray(j*3,3);
		mat[0] = 0;
		mat[1] = 0;
		mat[2] = 0;
		mat[3] = 0;
		mat[4] = 0;
		mat[5] = 0;
		mat[6] = 0;
		mat[7] = 0;
		mat[8] = 0;
		mat[9] = 0;
		mat[10] = 0;
		for (var k=0; k<m2; k++) {
			mat2[0] = 0;
			mat2[1] = 0;
			mat2[2] = 0;
			mat2[3] = 0;
			mat2[4] = 0;
			mat2[5] = 0;
			mat2[6] = 0;
			mat2[7] = 0;
			mat2[8] = 0;
			mat2[9] = 0;
			mat2[10] = 0;
			this.l[k].lc(buff,1,rgb);
			if (mat2[9] > 0) { // If point is in the bounding box, add to the total
				mat[0] += mat2[0];
				mat[1] += mat2[1];
				mat[2] += mat2[2];
				mat[3] += mat2[3];
				mat[4] += mat2[4];
				mat[5] += mat2[5];
				mat[6] += mat2[6];
				mat[7] += mat2[7];
				mat[8] += mat2[8];
				mat[9] += mat2[9];
				mat[10] += mat2[10];
			}
		}
		if (mat[9] > 0) {
			if (mat[10] > 0) {
				r1 = mat[9] / (mat[9] + mat[10]);
				r2 = mat[10] / (mat[9] + mat[10]);
				mat[0] = (r1*mat[0])+(r2*this.b[0]);
				mat[1] = (r1*mat[1])+(r2*this.b[1]);
				mat[2] = (r1*mat[2])+(r2*this.b[2]);
				mat[3] = (r1*mat[3])+(r2*this.b[3]);
				mat[4] = (r1*mat[4])+(r2*this.b[4]);
				mat[5] = (r1*mat[5])+(r2*this.b[5]);
				mat[6] = (r1*mat[6])+(r2*this.b[6]);
				mat[7] = (r1*mat[7])+(r2*this.b[7]);
				mat[8] = (r1*mat[8])+(r2*this.b[8]);
			} else {
				mat[0] /= mat[9];
				mat[1] /= mat[9];
				mat[2] /= mat[9];
				mat[3] /= mat[9];
				mat[4] /= mat[9];
				mat[5] /= mat[9];
				mat[6] /= mat[9];
				mat[7] /= mat[9];
				mat[8] /= mat[9];
			}
			R = rgb[0];
			G = rgb[1];
			B = rgb[2];
			rgb[0] = (mat[0]*R) + (mat[1]*G) + (mat[2]*B);
			rgb[1] = (mat[3]*R) + (mat[4]*G) + (mat[5]*B);
			rgb[2] = (mat[6]*R) + (mat[7]*G) + (mat[8]*B);
		} else { // Apply the base matrix
			R = rgb[0];
			G = rgb[1];
			B = rgb[2];
			rgb[0] = (this.b[0]*R) + (this.b[1]*G) + (this.b[2]*B);
			rgb[1] = (this.b[3]*R) + (this.b[4]*G) + (this.b[5]*B);
			rgb[2] = (this.b[6]*R) + (this.b[7]*G) + (this.b[8]*B);
		}
	}
};
function BoundBase() {
	this.mat = false;
}
BoundBase.prototype.lc = function(buff,rat,rgb) {
	if (typeof rat === "number" && rat > 0) {
		var mat = new Float64Array(buff);
		mat[10] += Math.min(1,rat);
	}
};
function BoundNull() {
	this.mat = false;
}
BoundNull.prototype.lc = function(buff,rat,rgb) {
	if (typeof rat === "number" && rat > 0) {
		var mat = new Float64Array(buff);
		mat[10] += Math.min(1,rat);
	}
};
function BoundMatrix(matrix,idx) {
	this.mat = matrix;
}
BoundMatrix.prototype.lc = function(buff,rat,rgb) {
	var mat = new Float64Array(buff);
	if (typeof rat !== "number" || rat >= 1) {
		mat[0] = this.mat[0];
		mat[1] = this.mat[1];
		mat[2] = this.mat[2];
		mat[3] = this.mat[3];
		mat[4] = this.mat[4];
		mat[5] = this.mat[5];
		mat[6] = this.mat[6];
		mat[7] = this.mat[7];
		mat[8] = this.mat[8];
		mat[9] += 1;
	} else {
		mat[0] = this.mat[0]*rat;
		mat[1] = this.mat[1]*rat;
		mat[2] = this.mat[2]*rat;
		mat[3] = this.mat[3]*rat;
		mat[4] = this.mat[4]*rat;
		mat[5] = this.mat[5]*rat;
		mat[6] = this.mat[6]*rat;
		mat[7] = this.mat[7]*rat;
		mat[8] = this.mat[8]*rat;
		mat[9] += rat;
	}
};
function BoundLine(overMatrix,underMatrix,xAxis,yAxis,width,a,b) {
	this.o = overMatrix;
	this.u = underMatrix;
	if (typeof xAxis === "string") {
		xAxis = xAxis.substr(0,1).toLowerCase();
		switch(xAxis) {
			case "r":	this.x = 0;
						break;
			case "g":	this.x = 1;
						break;
			case "b":	this.x = 2;
			break;
		}
	} else if (typeof xAxis === "number" && xAxis <= 2 && xAxis >= 0) {
		this.x = Math.round(xAxis);
	} else {
		this.x = 0;
	}
	if (typeof yAxis === "string") {
		yAxis = yAxis.substr(0,1).toLowerCase();
		switch(yAxis) {
			case "r":	this.y = 0;
						break;
			case "g":	this.y = 1;
						break;
			case "b":	this.y = 2;
			break;
		}
	} else if (typeof yAxis === "number" && yAxis <= 2 && xAxis >= 0) {
		this.y = Math.round(yAxis);
	} else {
		this.y = 1;
	}
	if (width > 0) {
		this.w = Math.abs(width);
		this.f = this.w/2;
	} else {
		this.w = false;
		this.f = false;
	}
	this.a = a;
	this.b = b;
}
BoundLine.prototype.lc = function(buff,rat,rgb) {
	if (rat > 0) {
		var Y = (this.a*rgb[this.x]) + this.b;
		if (this.w) {
			if (rgb[this.y] <= Y - this.f) {
				if (rat >= 1) {
					this.u.lc(buff);
				} else {
					this.u.lc(buff,rat);
				}
			} else if (rgb[this.y] > Y + this.f) {
				if (rat >= 1) {
					this.o.lc(buff);
				} else {
					this.o.lc(buff,rat);
				}
			} else {
				var r = (rgb[this.y] - Y + this.f) / this.w;
				if (rat >= 1) {
					this.u.lc(buff,1-r);
					this.o.lc(buff,r);
				} else {
					this.u.lc(buff,(1-r)*rat);
					this.o.lc(buff,r*rat);
				}
			}
		} else {
			if (rgb[this.y] <= Y) {
				if (rat >= 1) {
					this.u.lc(buff);
				} else {
					this.u.lc(buff,rat);
				}
			} else {
				if (rat >= 1) {
					this.o.lc(buff);
				} else {
					this.o.lc(buff,rat);
				}
			}
		}
	}
};
function BoundParabolic(overMatrix,underMatrix,xAxis,yAxis,width,a,b,c) {
	this.o = overMatrix;
	this.u = underMatrix;
	if (typeof xAxis === "string") {
		xAxis = xAxis.substr(0,1).toLowerCase();
		switch(xAxis) {
			case "r":	this.x = 0;
						break;
			case "g":	this.x = 1;
						break;
			case "b":	this.x = 2;
			break;
		}
	} else if (typeof xAxis === "number" && xAxis <= 2 && xAxis >= 0) {
		this.x = Math.round(xAxis);
	} else {
		this.x = 0;
	}
	if (typeof yAxis === "string") {
		yAxis = yAxis.substr(0,1).toLowerCase();
		switch(yAxis) {
			case "r":	this.y = 0;
						break;
			case "g":	this.y = 1;
						break;
			case "b":	this.y = 2;
			break;
		}
	} else if (typeof yAxis === "number" && yAxis <= 2 && xAxis >= 0) {
		this.y = Math.round(yAxis);
	} else {
		this.y = 1;
	}
	if (width > 0) {
		this.w = Math.abs(width);
		this.f = this.w/2;
	} else {
		this.w = false;
		this.f = false;
	}
	this.a = a;
	this.b = b;
	this.c = c;
}
BoundParabolic.prototype.lc = function(buff,rat,rgb) {
	if (rat > 0) {
		var Y = (this.a*rgb[this.x]*rgb[this.x]) + (this.b*rgb[this.x]) + this.c;
		if (this.w) {
			if (rgb[this.y] <= Y - this.f) {
				if (rat >= 1) {
					this.u.lc(buff);
				} else {
					this.u.lc(buff,rat);
				}
			} else if (rgb[this.y] > Y + this.f) {
				if (rat >= 1) {
					this.o.lc(buff);
				} else {
					this.o.lc(buff,rat);
				}
			} else {
				var r = (rgb[this.y] - Y + this.f) / this.w;
				if (rat >= 1) {
					this.u.lc(buff,1-r);
					this.o.lc(buff,r);
				} else {
					this.u.lc(buff,(1-r)*rat);
					this.o.lc(buff,r*rat);
				}
			}
		} else {
			if (rgb[this.y] <= Y) {
				if (rat >= 1) {
					this.u.lc(buff);
				} else {
					this.u.lc(buff,rat);
				}
			} else {
				if (rat >= 1) {
					this.o.lc(buff);
				} else {
					this.o.lc(buff,rat);
				}
			}
		}
	}
};
function BoundCubic(overMatrix,underMatrix,xAxis,yAxis,width,a,b,c,d) {
	this.o = overMatrix;
	this.u = underMatrix;
	if (typeof xAxis === "string") {
		xAxis = xAxis.substr(0,1).toLowerCase();
		switch(xAxis) {
			case "r":	this.x = 0;
						break;
			case "g":	this.x = 1;
						break;
			case "b":	this.x = 2;
			break;
		}
	} else if (typeof xAxis === "number" && xAxis <= 2 && xAxis >= 0) {
		this.x = Math.round(xAxis);
	} else {
		this.x = 0;
	}
	if (typeof yAxis === "string") {
		yAxis = yAxis.substr(0,1).toLowerCase();
		switch(yAxis) {
			case "r":	this.y = 0;
						break;
			case "g":	this.y = 1;
						break;
			case "b":	this.y = 2;
			break;
		}
	} else if (typeof yAxis === "number" && yAxis <= 2 && xAxis >= 0) {
		this.y = Math.round(yAxis);
	} else {
		this.y = 1;
	}
	if (width > 0) {
		this.w = Math.abs(width);
		this.f = this.w/2;
	} else {
		this.w = false;
		this.f = false;
	}
	this.a = a;
	this.b = b;
	this.c = c;
	this.d = d;
}
BoundCubic.prototype.lc = function(buff,rat,rgb) {
	if (rat > 0) {
		var Y = (this.a*rgb[this.x]*rgb[this.x]*rgb[this.x]) + (this.b*rgb[this.x]*rgb[this.x]) + (this.c*rgb[this.x]) + this.d;
		if (this.w) {
			if (rgb[this.y] <= Y - this.f) {
				if (rat >= 1) {
					this.u.lc(buff);
				} else {
					this.u.lc(buff,rat);
				}
			} else if (rgb[this.y] > Y + this.f) {
				if (rat >= 1) {
					this.o.lc(buff);
				} else {
					this.o.lc(buff,rat);
				}
			} else {
				var r = (rgb[this.y] - Y + this.f) / this.w;
				if (rat >= 1) {
					this.u.lc(buff,1-r);
					this.o.lc(buff,r);
				} else {
					this.u.lc(buff,(1-r)*rat);
					this.o.lc(buff,r*rat);
				}
			}
		} else {
			if (rgb[this.y] <= Y) {
				if (rat >= 1) {
					this.u.lc(buff);
				} else {
					this.u.lc(buff,rat);
				}
			} else {
				if (rat >= 1) {
					this.o.lc(buff);
				} else {
					this.o.lc(buff,rat);
				}
			}
		}
	}
};
function BoundPlane(insideMatrix,outsideMatrix,axis,value,width,feather) {
	this.i = insideMatrix;
	this.o = outsideMatrix;
	if (typeof axis === "string") {
		axis = axis.substr(0,1).toLowerCase();
		switch(axis) {
			case "r":	this.x = 0;
						break;
			case "g":	this.x = 1;
						break;
			case "b":	this.x = 2;
			break;
		}
	} else if (typeof axis === "number" && axis <= 2 && axis >= 0) {
		this.x = Math.round(axis);
	} else {
		this.x = 0;
	}
	width = Math.abs(width);
	this.h = value + (width/2);
	this.l = value - (width/2);
	if (typeof feather === "number" && feather > 0) {
		this.f = feather;
		this.h2 = this.h + this.f;
		this.l2 = this.l - this.f;
	} else {
		this.f = false;
	}
}
BoundPlane.prototype.lc = function(buff,rat,rgb) {
	if (rat > 0) {
		if (rgb[this.x] > this.l && rgb[this.x] < this.h) { // within the bounding plane
			if (rat >= 1) {
				this.i.lc(buff);
			} else {
				this.i.lc(buff,rat);
			}
		} else if (this.f) {
			if (rgb[this.x] > this.l2 && rgb[this.x] < this.h2) { // within the feather
				var r = Math.min(rgb[this.x]-this.l2, this.h2-rgb[this.x]);
				r /= this.f;
				this.i.lc(buff,(1-r)*rat);
				this.o.lc(buff,r*rat);
			} else {
				if (rat >= 1) {
					this.o.lc(buff);
				} else {
					this.o.lc(buff,rat);
				}
			}
		} else {
			if (rat >= 1) {
				this.o.lc(buff);
			} else {
				this.o.lc(buff,rat);
			}
		}
	}
};
function BoundSphere(insideMatrix,outsideMatrix,point,radius,feather) {
	this.i = insideMatrix;
	this.o = outsideMatrix;
	this.p = point;
	this.r = radius;
	this.r2 = radius*radius;
	if (typeof feather === "number" && feather > 0) {
		this.f = feather;
		this.f2 = (feather + radius) * (feather + radius);
	} else {
		this.f = false;
	}
}
BoundSphere.prototype.lc = function(buff,rat,rgb) {
	if (rat > 0) {
		var d2 = ((rgb[0]-this.p[0])*(rgb[0]-this.p[0])) + ((rgb[1]-this.p[1])*(rgb[1]-this.p[1])) + ((rgb[2]-this.p[2])*(rgb[2]-this.p[2]));
		if (d2 < this.r2) { // within the bounding sphere
			if (rat >= 1) {
				this.i.lc(buff);
			} else {
				this.i.lc(buff,rat);
			}
		} else if (this.f) {
			if (d2 < this.f2) { // within the feather
				var r = (Math.sqrt(d2)-this.r)/this.f;
				this.i.lc(buff,(1-r)*rat);
				this.o.lc(buff,r*rat);
			} else {
				if (rat >= 1) {
					this.o.lc(buff);
				} else {
					this.o.lc(buff,rat);
				}
			}
		} else {
			if (rat >= 1) {
				this.o.lc(buff);
			} else {
				this.o.lc(buff,rat);
			}
		}
	}
};
function BoundBox(insideMatrix,outsideMatrix,minPoint,maxPoint,feather) {
	this.i = insideMatrix;
	this.o = outsideMatrix;
	this.p1 = minPoint;
	this.p2 = maxPoint;
	if (typeof feather === "number" && feather > 0) {
		this.f = feather;
		this.f1 = new Float64Array([this.p1[0] - this.f, this.p1[1] - this.f,this.p1[2] - this.f]);
		this.f2 = new Float64Array([this.p2[0] + this.f, this.p2[1] + this.f,this.p2[2] + this.f]);
	} else {
		this.f = false;
		this.d = new Float64Array(3);
	}
}
BoundBox.prototype.lc = function(buff,rat,rgb) {
	if (rat > 0) {
		if (
			rgb[0] >= this.p1[0] && rgb[0] <= this.p2[0] &&
			rgb[1] >= this.p1[1] && rgb[1] <= this.p2[1] &&
			rgb[2] >= this.p1[2] && rgb[2] <= this.p2[2]
		) { // within the bounding box
			if (rat >= 1) {
				this.i.lc(buff);
			} else {
				this.i.lc(buff,rat);
			}
		} else if (this.f) {
			if (
				rgb[0] >= this.f1[0] && rgb[0] <= this.f2[0] &&
				rgb[1] >= this.f1[1] && rgb[1] <= this.f2[1] &&
				rgb[2] >= this.f1[2] && rgb[2] <= this.f2[2]
			) { // within the feather
				this.d[0] = Math.max(this.p1[0]-rgb[0], 0, rgb[0]-this.p2[0]);
				this.d[1] = Math.max(this.p1[1]-rgb[1], 0, rgb[1]-this.p2[1]);
				this.d[2] = Math.max(this.p1[2]-rgb[2], 0, rgb[2]-this.p2[2]);
				var r = Math.sqrt((this.d[0]*this.d[0])+(this.d[1]*this.d[1])+(this.d[2]*this.d[2]))/this.f;
				this.i.lc(buff,(1-r)*rat);
				this.o.lc(buff,r*rat);
			} else {
				if (rat >= 1) {
					this.o.lc(buff);
				} else {
					this.o.lc(buff,rat);
				}
			}
		} else {
			if (rat >= 1) {
				this.o.lc(buff);
			} else {
				this.o.lc(buff,rat);
			}
		}
	}
};
/* lut.js
* LUT handling object for the LUTCalc Web App.
* 31st December 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTs() {
}
LUTs.prototype.newLUT = function(d) {
	var params = {};
	if (typeof d.title === 'string') {
		params.title = d.title;
	}
	if (typeof d.format === 'string') {
		params.format = d.format;
	}
	if (typeof d.dims === 'number') {
		this.dims = d.dims;
	} else {
		dims = 1;
	}
	if (typeof d.min !== 'undefined' && (d.min[0] !== 0 || d.min[1] !== 0 || d.min[2] !== 0)) {
		params.fL = d.min[0];
		params.fLR = d.min[0];
		params.fLG = d.min[1];
		params.fLB = d.min[2];
	}
	if (typeof d.max !== 'undefined' && (d.max[0] !== 1 || d.max[1] !== 1 || d.max[2] !== 1)) {
		params.fH = d.max[0];
		params.fHR = d.max[0];
		params.fHG = d.max[1];
		params.fHB = d.max[2];
	}
	if (typeof d.fL === 'number') {
		params.fL = d.fL;
	}
	if (typeof d.fH === 'number') {
		params.fH = d.fH;
	}
	if (typeof d.fLR === 'number') {
		params.fLR = d.fLR;
	}
	if (typeof d.fLG === 'number') {
		params.fLG = d.fLG;
	}
	if (typeof d.fLB === 'number') {
		params.fLB = d.fLB;
	}
	if (typeof d.fHR === 'number') {
		params.fHR = d.fHR;
	}
	if (typeof d.fHG === 'number') {
		params.fHG = d.fHG;
	}
	if (typeof d.fHB === 'number') {
		params.fHB = d.fHB;
	}
	if (typeof d.spline !== 'undefined') {
		params.inSpline = d.spline;
	}
	if (typeof d.meta !== 'undefined') {
		params.meta = d.meta;
	}
	if (d.C.length === 3) {
		params.buffR = d.C[0].slice(0);
		params.buffG = d.C[1].slice(0);
		params.buffB = d.C[2].slice(0);
		if (this.dims === 3) {
			return new LUTVolume(params);
		} else {
			return new LUTRGBSpline(params);
		}
	} else {
		params.buff = d.C[0].slice(0);
		return new LUTSpline(params);
	}
};
// LUTSpline - base spline object; forward only but with arbitrary input range
function LUTSpline(params) {
	// Metadata
	if (typeof params.title === 'string') {
		this.title = params.title;
	} else {
		this.title = '';
	}
	if (typeof params.format === 'string') {
		this.format = params.format;
	} else {
		this.format = '';
	}
	if (typeof params.meta !== 'undefined') {
		this.meta = params.meta;
	} else {
		this.meta = {};
	}
	// Precalculate forward parameters
	this.FD = new Float64Array(params.buff);
	var fm = this.FD.length;
	var mono = this.FD[fm-1]-this.FD[0];
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	this.FA = new Float64Array(fm);
	this.FB = new Float64Array(fm);
	this.FC = new Float64Array(fm);
	var FP1 = new Float64Array(fm);
	var FD1 = new Float64Array(fm);
	for (var j=0; j<fm; j++) {
		if (j === 0) {
			FP1[0] = this.FD[1];
//			this.FC[0] = (0.1*this.FD[3]) - (0.8*this.FD[2]) + (2.3*this.FD[1]) - (1.6*this.FD[0]);
//			if (this.FC[0]*mono <= 0) { // opposite slope to monotonic
				this.FC[0] = -(0.5*this.FD[2]) + (2*this.FD[1]) - (1.5*this.FD[0]);
				if (this.FC[0]*mono <= 0) { // still opposite slope to monotonic
					this.FC[0] = 0.0075 * mono / (fm-1);
				}
//			}
			FD1[0] = (this.FD[2] - this.FD[0])/2;
		} else if (j < fm-1) {
			FP1[j] = this.FD[j+1];
			this.FC[j] = (this.FD[j+1] - this.FD[j-1])/2;
			if (j === fm-2) {
//				FD1[j] = (-0.1*this.FD[j-2]) + (0.8*this.FD[j-1]) - (2.3*this.FD[j]) + (1.6*this.FD[j+1]);
//				if (FD1[j]*mono <= 0) { // opposite slope to monotonic
					FD1[j] = (0.5*this.FD[j-1]) - (2*this.FD[j]) + (1.5*this.FD[j+1]);
					if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						FD1[j] = 0.0075 * mono / (fm-1);
					}
//				}
			} else {
				FD1[j] = (this.FD[j+2] - this.FD[j])/2;
			}
		} else {
			FP1[j] = this.FD[j];
			this.FC[j] = FD1[j-1];
			FD1[j] = FD1[j-1];
		}
		this.FA[j] = (2*this.FD[j]) + this.FC[j] - (2*FP1[j]) + FD1[j];
		this.FB[j] = (-3*this.FD[j]) - (2*this.FC[j]) + (3*FP1[j]) - FD1[j];
	}
	this.FM = fm-1;
	// Set forward range
	this.fS = false;
	if (typeof params.fL === 'undefined' && typeof params.min !== 'undefined' && params.min[0] !== 0) {
		params.fL = params.min[0];
	}
	if (typeof params.fH === 'undefined' && typeof params.max !== 'undefined' && params.max[0] !== 1) {
		params.fH = params.max[0];
	}
	if (typeof params.fH === 'number') {
		this.fH = params.fH;
		if (typeof params.fL === 'number') {
			this.fL = params.fL;
		} else {
			this.fL = 0;
		}
	} else {
		this.fH = 1;
		this.fL = 0;
	}
	this.fLH = this.fH-this.fL;
	if (this.fL !== 0 || this.fH !==1) {
		this.fS = true;
	}
	// Allow for spline input (a bit nuts for 1D, but being robust)
	if (typeof params.inSpline !== 'undefined') {
		this.sin = true;
		this.ins = new LUTQSpline(params.inSpline);
	} else {
		this.sin = false;
	}
}
LUTSpline.prototype.buildL = function() {
	var fm = this.FD.length;
	var mono = this.FD[fm-1]-this.FD[0];
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	var FP1 = new Float64Array(fm);
	var FD1 = new Float64Array(fm);
	for (var j=0; j<fm; j++) {
		if (j === 0) {
			FP1[0] = this.FD[1];
				this.FC[0] = -(0.5*this.FD[2]) + (2*this.FD[1]) - (1.5*this.FD[0]);
				if (this.FC[0]*mono <= 0) { // still opposite slope to monotonic
					this.FC[0] = 0.0075 * mono / (fm-1);
				}
			FD1[0] = (this.FD[2] - this.FD[0])/2;
		} else if (j < fm-1) {
			FP1[j] = this.FD[j+1];
			this.FC[j] = (this.FD[j+1] - this.FD[j-1])/2;
			if (j === fm-2) {
					FD1[j] = (0.5*this.FD[j-1]) - (2*this.FD[j]) + (1.5*this.FD[j+1]);
					if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						FD1[j] = 0.0075 * mono / (fm-1);
					}
			} else {
				FD1[j] = (this.FD[j+2] - this.FD[j])/2;
			}
		} else {
			FP1[j] = this.FD[j];
			this.FC[j] = FD1[j-1];
			FD1[j] = FD1[j-1];
		}
		this.FA[j] = (2*this.FD[j]) + this.FC[j] - (2*FP1[j]) + FD1[j];
		this.FB[j] = (-3*this.FD[j]) - (2*this.FC[j]) + (3*FP1[j]) - FD1[j];
	}
	this.FM = fm-1;
};
LUTSpline.prototype.f = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
};
LUTSpline.prototype.df = function(L) {
	var s = this.FM;
	var o;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		o = s*this.FC[0];
	} else if (L >= s) {
		o = s*this.FC[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		o = s*((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
	}
	// Allow for nonlinear inputs
	if (this.sin) {
		var dO = this.ins.df(L);
		o *= dO;
	}
	if (this.fS) {
		o /= this.fLH;
	}
	return o;
};
LUTSpline.prototype.fCub = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
};
LUTSpline.prototype.fTet = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTSpline.prototype.fLin = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTSpline.prototype.FCub = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
		}
	}
};
LUTSpline.prototype.FTet = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTSpline.prototype.FLin = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTSpline.prototype.fRGBCub = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		L = (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		L = ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		L = (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
	return new Float64Array([L,L,L]);
};
LUTSpline.prototype.fRGBTet = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		L = (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		L = ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		L = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
	return new Float64Array([L,L,L]);
};
LUTSpline.prototype.fRGBLin = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		L = (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		L = ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		L = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
	return new Float64Array([L,L,L]);
};
LUTSpline.prototype.rgbCub = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FCub(out.buffer);
	return out;
};
LUTSpline.prototype.rgbTet = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FTet(out.buffer);
	return out;
};
LUTSpline.prototype.rgbLin = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FLin(out.buffer);
	return out;
};
LUTSpline.prototype.RGBCub = function(buff) {
	this.FCub(out);
};
LUTSpline.prototype.RGBLin = function(buff) {
	this.FTet(out);
};
LUTSpline.prototype.RGBLin = function(buff) {
	this.FLin(out);
};
LUTSpline.prototype.J = function(rgbIn) {
	// calculate the Jacobian matrix at rgbIn
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var J = new Float64Array(9);
		var s = this.FM;
		var r,l;
		if (this.fS) {
			c[0] = (c[0] - this.fL)/(this.fLH);
			c[1] = (c[1] - this.fL)/(this.fLH);
			c[2] = (c[2] - this.fL)/(this.fLH);
		}
		if (this.sin) {
			c[0] = this.ins.f(c[0]);
			c[1] = this.ins.f(c[1]);
			c[2] = this.ins.f(c[2]);
		}
		c[0] *= s;
		c[1] *= s;
		c[2] *= s;
		if (c[0] <= 0) {
			J[0] = this.FC[0];
		} else if (c[0] >= s) {
			J[0] = this.FC[s];
		} else {
			l = Math.floor(c[0]);
			r = c[0]-l;
			J[0] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[1] <= 0) {
			J[4] = this.FC[0];
		} else if (c[1] >= s) {
			J[4] = this.FC[s];
		} else {
			l = Math.floor(c[1]);
			r = c[1]-l;
			J[4] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[2] <= 0) {
			J[8] = this.FC[0];
		} else if (c[2] >= s) {
			J[8] = this.FC[s];
		} else {
			l = Math.floor(c[2]);
			r = c[2]-l;
			J[8] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		return J;
	} else {
		return false;
	}
};
LUTSpline.prototype.JInv = function(rgbIn) {
	var M = this.J(rgbIn);
	if (M[0] !== 0 && M[4] !== 0 && M[8] !== 0) {
		return new Float64Array([
			1/M[0],	0,		0,
			0,		1/M[4],	0,
			0,		0,		1/M[8]
		]);
	} else {
		return false;
	}
};
LUTSpline.prototype.getDetails = function() {
	var out = {
		title: this.title,
		format: this.format,
		dims: 1,
		s: this.FM+1,
		min: new Float64Array([this.fL,this.fL,this.fL]),
		max: new Float64Array([this.fH,this.fH,this.fH]),
		C: [this.FD.buffer],
		meta: this.meta
	};
	return out;
};
LUTSpline.prototype.getL = function() {
	return this.FD.buffer;
};
LUTSpline.prototype.getRGB = function() {
	return [this.FD.buffer];
};
LUTSpline.prototype.getSize = function() {
	return this.FM+1;
};
LUTSpline.prototype.is1D = function() {
	return true;
};
LUTSpline.prototype.is3D = function() {
	return false;
};
LUTSpline.prototype.getTitle = function() {
	return this.title;
};
LUTSpline.prototype.getMetadata = function() {
	return this.meta;
};
LUTSpline.prototype.isClamped = function() {
	if (typeof this.clamped === 'undefined') {
		var mm = this.minMax();
		if ((mm[0] === 0 && mm[1] <= 1) || (mm[0] >= 0 && mm[1] === 1)) {
			this.clamped = true;
		} else {
			this.clamped = false;
		}
	}
	return this.clamped;
};
LUTSpline.prototype.deClamp = function() {
	if (this.isClamped()) {
		var m,c,C,L,H,LH,S;
		var fL,fH,fLH;
		var FD = this.FD;
		m = FD.length;
		var C = false;
		var L = 0;
		var H = m-1;
		for (var j=0; j<m; j++) {
			if (j>0) {
				if (FD[j] === 0) {
					C = true;
					L = j+1;
				}
			}
		}
		for (var j=m-2; j>=0; j--) {
			if (FD[j] === 1) {
				C = true;
				H = j-1;
			}
		}
		if (C) {
			if (L > H) {
				var low = H;
				var H = Math.min(L-2,m-1);
				var L = Math.max(low+2,0);
			}
			var LH = H-L;
			var S = new LUTQSpline(new Float64Array(c.subarray(L,LH+1)).buffer);
			var fL = this.fL;
			var fH = this.fH;
			var fLH= fH-fL;
			for (var j=0; j<m; j++) {
				if (j===L) {
					j = H;
				}
				// pass through the splines
				FD[j] = S.fCub((j - L)/LH);
			}
		}
		this.buildL();
		this.clamped = false;
	}
};
LUTSpline.prototype.minMax = function() {
	var x = new Float64Array([
		 9999,	// Absolute min value
		-9999	// Absolute max value
	]);
	var FD = this.FD;
	var m = FD.length;
	for (var j=0; j<m; j++) {
		if (FD[j] < x[0]) {
			x[0] = FD[j];
		}
		if (FD[j] > x[1]) {
			x[1] = FD[j];
		}
	}
	return x;
};
// LUTRSpline - spline object with arbitrary input range and inverse automatically calculated
function LUTRSpline(params) {
	this.method = 0; // choose which approach to use on 'f(x)', cubic, or linear - used by brent to calculate the reverse
	// Metadata
	if (typeof params.title === 'string') {
		this.title = params.title;
	} else {
		this.title = '';
	}
	if (typeof params.format === 'string') {
		this.format = params.format;
	} else {
		this.format = '';
	}
	if (typeof params.meta !== 'undefined') {
		this.meta = params.meta;
	} else {
		this.meta = {};
	}
	// Precalculate forward parameters
	this.FD = new Float64Array(params.buff);
	var fm = this.FD.length;
	var mono = this.FD[fm-1]-this.FD[0];
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	this.FA = new Float64Array(fm);
	this.FB = new Float64Array(fm);
	this.FC = new Float64Array(fm);
	var FP1 = new Float64Array(fm);
	var FD1 = new Float64Array(fm);
	for (var j=0; j<fm; j++) {
		if (j === 0) {
			FP1[0] = this.FD[1];
//			this.FC[0] = (0.1*this.FD[3]) - (0.8*this.FD[2]) + (2.3*this.FD[1]) - (1.6*this.FD[0]);
//			if (this.FC[0]*mono <= 0) { // opposite slope to monotonic
				this.FC[0] = -(0.5*this.FD[2]) + (2*this.FD[1]) - (1.5*this.FD[0]);
				if (this.FC[0]*mono <= 0) { // still opposite slope to monotonic
					this.FC[0] = 0.0075 * mono / (fm-1);
				}
//			}
			FD1[0] = (this.FD[2] - this.FD[0])/2;
		} else if (j < fm-1) {
			FP1[j] = this.FD[j+1];
			this.FC[j] = (this.FD[j+1] - this.FD[j-1])/2;
			if (j === fm-2) {
//				FD1[j] = (-0.1*this.FD[j-2]) + (0.8*this.FD[j-1]) - (2.3*this.FD[j]) + (1.6*this.FD[j+1]);
//				if (FD1[j]*mono <= 0) { // opposite slope to monotonic
					FD1[j] = (0.5*this.FD[j-1]) - (2*this.FD[j]) + (1.5*this.FD[j+1]);
					if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						FD1[j] = 0.0075 * mono / (fm-1);
					}
//				}
			} else {
				FD1[j] = (this.FD[j+2] - this.FD[j])/2;
			}
		} else {
			FP1[j] = this.FD[j];
			this.FC[j] = FD1[j-1];
			FD1[j] = FD1[j-1];
		}
		this.FA[j] = (2*this.FD[j]) + this.FC[j] - (2*FP1[j]) + FD1[j];
		this.FB[j] = (-3*this.FD[j]) - (2*this.FC[j]) + (3*FP1[j]) - FD1[j];
	}
	this.FM = fm-1;
	// Allow for spline input (a bit nuts for 1D, but being robust)
	if (typeof params.inSpline !== 'undefined') {
		this.sin = true;
		this.ins = new LUTQSpline(params.inSpline);
	} else {
		this.sin = false;
	}
	// Set forward range
	this.fS = false;
	if (typeof params.fL === 'undefined' && typeof params.min !== 'undefined' && params.min[0] !== 0) {
		params.fL = params.min[0];
	}
	if (typeof params.fH === 'undefined' && typeof params.max !== 'undefined' && params.max[0] !== 1) {
		params.fH = params.max[0];
	}
	if (typeof params.fH === 'number') {
		this.fH = params.fH;
		if (typeof params.fL === 'number') {
			this.fL = params.fL;
		} else {
			this.fL = 0;
		}
	} else {
		this.fH = 1;
		this.fL = 0;
	}
	this.fLH = this.fH-this.fL;
	if (this.fL !== 0 || this.fH !==1) {
		this.fS = true;
	}
	// Set reverse range
	if (typeof params.rL === 'undefined' && typeof params.rmin !== 'undefined' && params.rmin[0] !== 0) {
		params.rL = params.rmin[0];
	}
	if (typeof params.rH === 'undefined' && typeof params.rmax !== 'undefined' && params.rmax[0] !== 1) {
		params.rH = params.rmax[0];
	}
	if (typeof params.rH === 'number') {
		this.rH = rH;
		if (typeof params.rL === 'number') {
			this.rL = rL;
		} else {
			this.rL = this.fL;
		}
	} else {
		this.rH = this.FD[fm - 1];
		this.rL = this.FD[0];
	}
	this.rLH = this.rH-this.rL;
	// Create reverse data points
	var rm;
	if (typeof params.minRM === 'number') {
		rm = Math.max(fm, minRM);
	} else {
		rm = Math.max(fm, 1024);
	}
	this.RM = rm-1;
	this.brent = new Brent(this);
	this.buildReverse();
}
LUTRSpline.prototype.f = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		if (this.method === 0) { // cubic
			return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
		} else { // tetrahedral or linear
			return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTRSpline.prototype.df = function(L) {
	var s = this.FM;
	var o;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		o = s*this.FC[0];
	} else if (L >= s) {
		o = s*this.FC[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		if (this.method === 0) { // cubic
			o = s*((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		} else { // tetrahedral or linear
			return s*(this.FD[l+1]-this.FD[l]);
		}
	}
	// Allow for nonlinear inputs
	if (this.sin) {
		var dO = this.ins.df(L);
		o *= dO;
	}
	if (this.fS) {
		o /= this.fLH;
	}
	return o;
};
LUTRSpline.prototype.fCub = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
};
LUTRSpline.prototype.fTet = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTRSpline.prototype.fLin = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTRSpline.prototype.FCub = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
		}
	}
};
LUTRSpline.prototype.FTet = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTRSpline.prototype.FLin = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTRSpline.prototype.fRGBCub = function(L) {
	L = this.f(L);
	return new Float64Array([L,L,L]);
};
LUTRSpline.prototype.fRGBTet = function(L) {
	L = this.fLin(L);
	return new Float64Array([L,L,L]);
};
LUTRSpline.prototype.fRGBLin = function(L) {
	L = this.fLin(L);
	return new Float64Array([L,L,L]);
};
LUTRSpline.prototype.rgbCub = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FCub(out.buffer);
	return out;
};
LUTRSpline.prototype.rgbTet = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FLin(out.buffer);
	return out;
};
LUTRSpline.prototype.rgbLin = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FLin(out.buffer);
	return out;
};
LUTRSpline.prototype.RGBCub = function(buff) {
	this.FCub(out);
};
LUTRSpline.prototype.RGBTet = function(buff) {
	this.FLin(out);
};
LUTRSpline.prototype.RGBLin = function(buff) {
	this.FLin(out);
};
LUTRSpline.prototype.J = function(rgbIn) {
	// calculate the Jacobian matrix at rgbIn
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var J = new Float64Array(9);
		var s = this.FM;
		var r,l;
		if (this.fS) {
			c[0] = (c[0] - this.fL)/(this.fLH);
			c[1] = (c[1] - this.fL)/(this.fLH);
			c[2] = (c[2] - this.fL)/(this.fLH);
		}
		if (this.sin) {
			c[0] = this.ins.f(c[0]);
			c[1] = this.ins.f(c[1]);
			c[2] = this.ins.f(c[2]);
		}
		c[0] *= s;
		c[1] *= s;
		c[2] *= s;
		if (c[0] <= 0) {
			J[0] = this.FC[0];
		} else if (c[0] >= s) {
			J[0] = this.FC[s];
		} else {
			l = Math.floor(c[0]);
			r = c[0]-l;
			J[0] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[1] <= 0) {
			J[4] = this.FC[0];
		} else if (c[1] >= s) {
			J[4] = this.FC[s];
		} else {
			l = Math.floor(c[1]);
			r = c[1]-l;
			J[4] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[2] <= 0) {
			J[8] = this.FC[0];
		} else if (c[2] >= s) {
			J[8] = this.FC[s];
		} else {
			l = Math.floor(c[2]);
			r = c[2]-l;
			J[8] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		return J;
	} else {
		return false;
	}
};
LUTRSpline.prototype.JInv = function(rgbIn) {
	var M = this.J(rgbIn);
	if (M[0] !== 0 && M[4] !== 0 && M[8] !== 0) {
		return new Float64Array([
			1/M[0],	0,		0,
			0,		1/M[4],	0,
			0,		0,		1/M[8]
		]);
	} else {
		return false;
	}
};
LUTRSpline.prototype.getDetails = function() {
	var out = {
		title: this.title,
		format: this.format,
		dims: 1,
		s: this.FM+1,
		min: new Float64Array([this.fL,this.fL,this.fL]),
		max: new Float64Array([this.fH,this.fH,this.fH]),
		C: [this.FD.buffer],
		meta: this.meta
	};
	return out;
};
LUTRSpline.prototype.getL = function() {
	return this.FD.buffer;
};
LUTRSpline.prototype.getRGB = function() {
	return [this.FD.buffer];
};
LUTRSpline.prototype.getSize = function() {
	return this.FM+1;
};
LUTRSpline.prototype.is1D = function() {
	return true;
};
LUTRSpline.prototype.is3D = function() {
	return false;
};
LUTRSpline.prototype.getTitle = function() {
	return this.title;
};
LUTRSpline.prototype.getMetadata = function() {
	return this.meta;
};
//
LUTRSpline.prototype.r = function(L) {
	var s = this.RM;
	var r,l;
	L = s * (L - this.rL)/(this.rLH);
	if (L <= 0) {
		return (L * this.RC[0]) + this.RD[0];
	} else if (L >= s) {
		return ((L-s) * this.RC[s]) + this.RD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		if (this.method === 0) { // cubic
			return (((((this.RA[l] * r) + this.RB[l]) * r) + this.RC[l]) * r) + this.RD[l];
		} else { // tetrahedral or linear
			return ((1-r)*this.RD[l]) + (r*this.RD[l+1]);
		}
	}
};
LUTRSpline.prototype.R = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.RM;
	var r,l;
	for (var j=0; j<m; j++) {
		c[j] = s * (c[j] - this.rL)/(this.rLH);
		if (c[j] <= 0) {
			c[j] = (c[j] * this.RC[0]) + this.RD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.RC[s]) + this.RD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			if (this.method === 0) { // cubic
				c[j] = (((((this.RA[l] * r) + this.RB[l]) * r) + this.RC[l]) * r) + this.RD[l];
			} else { // tetrahedral or linear
				c[j] = ((1-r)*this.RD[l]) + (r*this.RD[l+1]);
			}
		}
	}
};
LUTRSpline.prototype.buildReverse = function() {
	var rm = this.RM + 1;
	this.RD = new Float64Array(rm);
	var x;
	for (var j=0; j<rm; j++) {
		x = ((j/(rm-1))*(this.rLH)) + this.rL;
		if (j === 0 || x <= 0 || isNaN(this.RD[j-1]) || this.RD[j-1] <= -65534 || this.RD[j-1] >= 65534) {
			this.RD[j] = this.brent.findRoot(x,x);
		} else {
			this.RD[j] = this.brent.findRoot(this.RD[j-1],x);
		}
		if (this.RD[j] < -65534) {
			this.RD[j] = -65534;
		} else if (this.RD[j] > 65534) {
			this.RD[j] = 65534;
		}
	}
	if (isNaN(this.RD[0])) {
		for (var j=0; j<rm; j++) {
			if (!isNaN(this.RD[j])) {
				this.RD[0] = this.RD[j];
				break;
			}
		}
	}
	for (var j=1; j<rm; j++) {
		if (isNaN(this.RD[j])) {
			this.RD[j] = this.RD[j-1];
		}
	}
	for (var j=1; j<rm; j++) {
		this.RD[j] = (this.RD[j] * this.fLH) + this.fL;
	}
	mono = this.RD[rm-1]-this.RD[0]; // If things are working, should be unchanged, but belt and braces....
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	// Precalculate reverse parameters
	this.RA = new Float64Array(rm);
	this.RB = new Float64Array(rm);
	this.RC = new Float64Array(rm);
	var RP1 = new Float64Array(rm);
	var RD1 = new Float64Array(rm);
	for (var j=0; j<rm; j++) {
		if (j === 0) {
			RP1[0] = this.RD[1];
//			this.RC[0] = (0.1*this.RD[3]) - (0.8*this.RD[2]) + (2.3*this.RD[1]) - (1.6*this.RD[0]);
//			if (this.RC[0]*mono <= 0) { // opposite slope to monotonic
				this.RC[0] = -(0.5*this.RD[2]) + (2*this.RD[1]) - (1.5*this.RD[0]);
				if (this.RC[0]*mono <= 0) { // still opposite slope to monotonic
					this.RC[0] = 0.0075 * mono / (rm-1);
				}
//			}
			RD1[0] = (this.RD[2] - this.RD[0])/2;
		} else if (j < rm-1) {
			RP1[j] = this.RD[j+1];
			this.RC[j] = (this.RD[j+1] - this.RD[j-1])/2
			if (j === rm-2) {
//				RD1[j] = (-0.1*this.RD[j-2]) + (0.8*this.RD[j-1]) - (2.3*this.RD[j]) + (1.6*this.RD[j+1]);
//				if (RD1[j]*mono <= 0) { // opposite slope to monotonic
					RD1[j] = (0.5*this.RD[j-1]) - (2*this.RD[j]) + (1.5*this.RD[j+1]);
					if (RD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						RD1[j] = 0.0075 * mono / (rm-1);
					}
//				}
			} else {
				RD1[j] = (this.RD[j+2] - this.RD[j])/2;
			}
		} else {
			RP1[j] = this.RD[j];
			this.RC[j] = RD1[j-1];
			RD1[j] = RD1[j-1];
		}
		this.RA[j] = (2*this.RD[j]) + this.RC[j] - (2*RP1[j]) + RD1[j];
		this.RB[j] = (-3*this.RD[j]) - (2*this.RC[j]) + (3*RP1[j]) - RD1[j];
	}
};
LUTRSpline.prototype.setMethod = function(idx) {
	if (typeof idx === 'number') {
		this.method = idx;
		this.buildReverse();
		return true;
	} else {
		return false;
	}
};
LUTRSpline.prototype.getMethod = function() {
	return this.method;
};
LUTRSpline.prototype.getReverse = function() {
	return this.RD.buffer;
};
LUTRSpline.prototype.getMinMax = function() {
	var a=0;
	var b=1;
	var m = this.RD.length;
	for (var j=0; j<m; j++) {
		if (this.RD[j] > b) {
			b = this.RD[j];
		} else if (this.RD[j] < a) {
			a = this.RD[j];
		}
	}
	return {a: a, b: b};
};
LUTRSpline.prototype.getHighLow = function() {
	return {forH:this.fH,forL:this.fL,revH:this.rH,revL:this.rL}
};
LUTRSpline.prototype.getRM = function() {
	return this.RM + 1;
};
LUTRSpline.prototype.getR = function() {
	return this.RD.buffer;
};
// LUTQSpline - spline object paired down to forward only and mesh over 0-1.0
function LUTQSpline(buff) {
	this.meta = {};
	// Precalculate forward parameters
	this.FD = new Float64Array(buff);
	var fm = this.FD.length;
	var mono = this.FD[fm-1]-this.FD[0];
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	this.FA = new Float64Array(fm);
	this.FB = new Float64Array(fm);
	this.FC = new Float64Array(fm);
	var FP1 = new Float64Array(fm);
	var FD1 = new Float64Array(fm);
	for (var j=0; j<fm; j++) {
		if (j === 0) {
			FP1[0] = this.FD[1];
//			this.FC[0] = (0.1*this.FD[3]) - (0.8*this.FD[2]) + (2.3*this.FD[1]) - (1.6*this.FD[0]);
//			if (this.FC[0]*mono <= 0) { // opposite slope to monotonic
				this.FC[0] = -(0.5*this.FD[2]) + (2*this.FD[1]) - (1.5*this.FD[0]);
				if (this.FC[0]*mono <= 0) { // still opposite slope to monotonic
					this.FC[0] = 0.0075 * mono / (fm-1);
				}
//			}
			FD1[0] = (this.FD[2] - this.FD[0])/2;
		} else if (j < fm-1) {
			FP1[j] = this.FD[j+1];
			this.FC[j] = (this.FD[j+1] - this.FD[j-1])/2;
			if (j === fm-2) {
//				FD1[j] = (-0.1*this.FD[j-2]) + (0.8*this.FD[j-1]) - (2.3*this.FD[j]) + (1.6*this.FD[j+1]);
//				if (FD1[j]*mono <= 0) { // opposite slope to monotonic
					FD1[j] = (0.5*this.FD[j-1]) - (2*this.FD[j]) + (1.5*this.FD[j+1]);
					if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						FD1[j] = 0.0075 * mono / (fm-1);
					}
//				}
			} else {
				FD1[j] = (this.FD[j+2] - this.FD[j])/2;
			}
		} else {
			FP1[j] = this.FD[j];
			this.FC[j] = FD1[j-1];
			FD1[j] = FD1[j-1];
		}
		this.FA[j] = (2*this.FD[j]) + this.FC[j] - (2*FP1[j]) + FD1[j];
		this.FB[j] = (-3*this.FD[j]) - (2*this.FC[j]) + (3*FP1[j]) - FD1[j];
	}
	this.FM = fm-1;
}
LUTQSpline.prototype.f = function(L) {
	var s = this.FM;
	var r,l;
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
};
LUTQSpline.prototype.df = function(L) {
	var s = this.FM;
	var o;
	var r,l;
	L *= s;
	if (L <= 0) {
		return s*this.FC[0];
	} else if (L >= s) {
		return s*this.FC[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return s*((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
	}
};
LUTQSpline.prototype.fCub = function(L) {
	var s = this.FM;
	var r,l;
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
};
LUTQSpline.prototype.fTet = function(L) {
	var s = this.FM;
	var r,l;
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTQSpline.prototype.fLin = function(L) {
	var s = this.FM;
	var r,l;
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTQSpline.prototype.FCub = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
		}
	}
};
LUTQSpline.prototype.FTet = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTQSpline.prototype.FLin = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTQSpline.prototype.fRGBCub = function(L) {
	L = this.f(L);
	return new Float64Array([L,L,L]);
};
LUTQSpline.prototype.fRGBTet = function(L) {
	L = this.fLin(L);
	return new Float64Array([L,L,L]);
};
LUTQSpline.prototype.fRGBLin = function(L) {
	L = this.fLin(L);
	return new Float64Array([L,L,L]);
};
LUTQSpline.prototype.rgbCub = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FCub(out.buffer);
	return out;
};
LUTQSpline.prototype.rgbTet = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FLin(out.buffer);
	return out;
};
LUTQSpline.prototype.rgbLin = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FLin(out.buffer);
	return out;
};
LUTQSpline.prototype.RGBCub = function(buff) {
	this.FCub(out);
};
LUTQSpline.prototype.RGBTet = function(buff) {
	this.FLin(out);
};
LUTQSpline.prototype.RGBLin = function(buff) {
	this.FLin(out);
};
LUTQSpline.prototype.J = function(rgbIn) {
	// calculate the Jacobian matrix at rgbIn
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var J = new Float64Array(9);
		var s = this.FM;
		var r,l;
		c[0] *= s;
		c[1] *= s;
		c[2] *= s;
		if (c[0] <= 0) {
			J[0] = this.FC[0];
		} else if (c[0] >= s) {
			J[0] = this.FC[s];
		} else {
			l = Math.floor(c[0]);
			r = c[0]-l;
			J[0] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[1] <= 0) {
			J[4] = this.FC[0];
		} else if (c[1] >= s) {
			J[4] = this.FC[s];
		} else {
			l = Math.floor(c[1]);
			r = c[1]-l;
			J[4] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[2] <= 0) {
			J[8] = this.FC[0];
		} else if (c[2] >= s) {
			J[8] = this.FC[s];
		} else {
			l = Math.floor(c[2]);
			r = c[2]-l;
			J[8] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		J[0] *= s;
		J[4] *= s;
		J[8] *= s;
		return J;
	} else {
		return false;
	}
};
LUTQSpline.prototype.JInv = function(rgbIn) {
	var M = this.J(rgbIn);
	if (M[0] !== 0 && M[4] !== 0 && M[8] !== 0) {
		return new Float64Array([
			1/M[0],	0,		0,
			0,		1/M[4],	0,
			0,		0,		1/M[8]
		]);
	} else {
		return false;
	}
};
LUTQSpline.prototype.getDetails = function() {
	return {
		title: '',
		format: '',
		dims: 1,
		s: this.FM+1,
		min: new Float64Array([0,0,0]),
		max: new Float64Array([1,1,1]),
		C: [this.FD.buffer],
		meta: this.meta
	};
};
LUTQSpline.prototype.getL = function() {
	return this.FD.buffer;
};
LUTQSpline.prototype.getRGB = function() {
	return [this.FD.buffer];
};
LUTQSpline.prototype.getSize = function() {
	return this.FM+1;
};
LUTQSpline.prototype.is1D = function() {
	return true;
};
LUTQSpline.prototype.is3D = function() {
	return false;
};
LUTQSpline.prototype.getTitle = function() {
	return '';
};
LUTQSpline.prototype.getMetadata = function() {
	return this.meta;
};
//
LUTQSpline.prototype.dRGB = function(rgbIn) {
	// no point in a full, square Jacobian matrix for a 1D LUT
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var o = new Float64Array(3);
		var s = this.FM;
		var r,l;
		c[0] *= s;
		c[1] *= s;
		c[2] *= s;
		if (c[0] <= 0) {
			o[0] = this.FC[0];
		} else if (c[0] >= s) {
			o[0] = this.FC[s];
		} else {
			l = Math.floor(c[0]);
			r = c[0]-l;
			o[0] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[1] <= 0) {
			o[1] = this.FC[0];
		} else if (c[1] >= s) {
			o[1] = this.FC[s];
		} else {
			l = Math.floor(c[1]);
			r = c[1]-l;
			o[1] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[2] <= 0) {
			o[2] = this.FC[0];
		} else if (c[2] >= s) {
			o[2] = this.FC[s];
		} else {
			l = Math.floor(c[2]);
			r = c[2]-l;
			o[2] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		o[0] *= s;
		o[1] *= s;
		o[2] *= s;
		return o;
	} else {
		return false;
	}
};
// LUTRGBSpline - spline object with different 1D splines for each RGB channel
function LUTRGBSpline(params) {
	// Metadata
	if (typeof params.title === 'string') {
		this.title = params.title;
	} else {
		this.title = '';
	}
	if (typeof params.format === 'string') {
		this.format = params.format;
	} else {
		this.format = '';
	}
	if (typeof params.meta !== 'undefined') {
		this.meta = params.meta;
	} else {
		this.meta = {};
	}
	this.Y = new Float64Array([0.2126,0.7152,0.0722]); // Rec709 luma coefficients
	// Set forward range
	this.fL = new Float64Array(4);
	this.fH = new Float64Array(4);
	this.fS = false;
	if (typeof params.min !== 'undefined' && (params.min[0] !== 0 || params.min[1] !== 0 || params.min[2] !== 0)) {
		params.fL = params.min[0];
		params.fLR = params.min[0];
		params.fLG = params.min[1];
		params.fLB = params.min[2];
	}
	if (typeof params.max !== 'undefined' && (params.max[0] !== 1 || params.max[1] !== 1 || params.max[2] !== 1)) {
		params.fH = params.max[0];
		params.fHR = params.max[0];
		params.fHG = params.max[1];
		params.fHB = params.max[2];
	}
	if (typeof params.fH === 'number') {
		this.fH[0] = params.fH;
		this.fH[1] = params.fH;
		this.fH[2] = params.fH;
	} else {
		this.fH[0] = 1;
		this.fH[1] = 1;
		this.fH[2] = 1;
	}
	if (typeof params.fL === 'number') {
		this.fL[0] = params.fL;
		this.fL[1] = params.fL;
		this.fL[2] = params.fL;
	} else {
		this.fL[0] = 0;
		this.fL[1] = 0;
		this.fL[2] = 0;
	}
	if (typeof params.fLR === 'number' &&
		typeof params.fHR === 'number' &&
		typeof params.fLG === 'number' &&
		typeof params.fHG === 'number' &&
		typeof params.fLB === 'number' &&
		typeof params.fHB === 'number') {
		this.fL[0] = params.fLR;
		this.fH[0] = params.fHR;
		this.fL[1] = params.fLG;
		this.fH[1] = params.fHG;
		this.fL[2] = params.fLB;
		this.fH[2] = params.fHB;
	}
	this.fLH = new Float64Array([this.fH[0]-this.fL[0],this.fH[1]-this.fL[1],this.fH[2]-this.fL[2],0]);
	if (this.fL[0] !== 0 || this.fL[1] !== 0 || this.fL[2] !== 0 || this.fH[0] !== 1 || this.fH[1] !== 1 || this.fH[2] !== 1) {
		this.fS = true;
	}
	// Allow for spline input (a bit nuts for 1D, but being robust)
	if (typeof params.inSpline !== 'undefined') {
		this.sin = true;
		this.ins = new LUTQSpline(params.inSpline);
	} else {
		this.sin = false;
	}
	// Create three separate splines for the red, green and blue channels.
	this.FA = [];
	this.FB = [];
	this.FC = [];
	this.FD = [];
	this.FM = [];
	this.FD[0] = new Float64Array(params.buffR);
	this.FD[1] = new Float64Array(params.buffG);
	this.FD[2] = new Float64Array(params.buffB);
	var fm;
	for (var i=0; i<3; i++) {
		fm = this.FD[i].length;
		this.FA[i] = new Float64Array(fm);
		this.FB[i] = new Float64Array(fm);
		this.FC[i] = new Float64Array(fm);
		this.FM[i] = fm-1;
	}
	this.buildMesh();
	// Precalculate Luma arrays
	this.buildL();
}
LUTRGBSpline.prototype.buildMesh = function() {
	var buff,fm,mono;
	var FP1,FD1;
	// Precalculate forward parameters
	for (var i=0; i<3; i++) {
		fm = this.FD[i].length;
		mono = this.FD[i][fm-1]-this.FD[i][0];
		if (mono >= 0) {
			mono = 1;
		} else if (mono < 0) {
			mono = -1;
		}
		FP1 = new Float64Array(fm);
		FD1 = new Float64Array(fm);
		for (var j=0; j<fm; j++) {
			if (j === 0) {
				FP1[0] = this.FD[i][1];
//				this.FC[i][0] = (0.1*this.FD[i][3]) - (0.8*this.FD[i][2]) + (2.3*this.FD[i][1]) - (1.6*this.FD[i][0]);
//				if (this.FC[i][0]*mono <= 0) { // opposite slope to monotonic
					this.FC[i][0] = -(0.5*this.FD[i][2]) + (2*this.FD[i][1]) - (1.5*this.FD[i][0]);
					if (this.FC[i][0]*mono <= 0) { // still opposite slope to monotonic
						this.FC[i][0] = 0.0075 * mono / (fm-1);
					}
//				}
				FD1[0] = (this.FD[i][2] - this.FD[i][0])/2;
			} else if (j < fm-1) {
				FP1[j] = this.FD[i][j+1];
				this.FC[i][j] = (this.FD[i][j+1] - this.FD[i][j-1])/2;
				if (j === fm-2) {
//					FD1[j] = (-0.1*this.FD[i][j-2]) + (0.8*this.FD[i][j-1]) - (2.3*this.FD[i][j]) + (1.6*this.FD[i][j+1]);
//					if (FD1[j]*mono <= 0) { // opposite slope to monotonic
						FD1[j] = (0.5*this.FD[i][j-1]) - (2*this.FD[i][j]) + (1.5*this.FD[i][j+1]);
						if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
							FD1[j] = 0.0075 * mono / (fm-1);
						}
//					}
				} else {
					FD1[j] = (this.FD[i][j+2] - this.FD[i][j])/2;
				}
			} else {
				FP1[j] = this.FD[i][j];
				this.FC[i][j] = FD1[j-1];
				FD1[j] = FD1[j-1];
			}
			this.FA[i][j] = (2*this.FD[i][j]) + this.FC[i][j] - (2*FP1[j]) + FD1[j];
			this.FB[i][j] = (-3*this.FD[i][j]) - (2*this.FC[i][j]) + (3*FP1[j]) - FD1[j];
		}
	}
};
LUTRGBSpline.prototype.buildL = function() {
	this.fL[3] = Math.min(this.fL[0],this.fL[1],this.fL[2]);
	this.fH[3] = Math.max(this.fH[0],this.fH[1],this.fH[2]);
	this.fLH[3]= this.fH[3]-this.fL[3];
	this.FM[3] = Math.max(this.FM[0],this.FM[1],this.FM[2]);
	if (this.FM[3] < 64) {
		this.FM[3] = 64;
	}
	var m = this.FM[3] + 1;
	this.FD[3] = new Float64Array(m);
	var input,L,s,r,l,mono;
	// First build array of luma values from RGB splines
	for (var j=0; j<m; j++) {
		input = (j*(this.fLH[3])/(m-1))+this.fL[3];
		for (var i=0; i<3; i++) {
			s = this.FM[i];
			L = (input - this.fL[i])/(this.fLH[i]);
			if (this.sin) {
				L = this.ins.f(L);
			}
			L *= s;
			if (L <= 0) {
				L = (L * this.FC[i][0]) + this.FD[i][0];
			} else if (L >= s) {
				L = ((L-s) * this.FC[i][s]) + this.FD[i][s];
			} else {
				l = Math.floor(L);
				r = L-l;
				L = (((((this.FA[i][l] * r) + this.FB[i][l]) * r) + this.FC[i][l]) * r) + this.FD[i][l];
			}
			this.FD[3][j] += L * this.Y[i];
		}
	}
	// Now precalculate forward parameters
	this.FA[3] = new Float64Array(m);
	this.FB[3] = new Float64Array(m);
	this.FC[3] = new Float64Array(m);
	var FP1 = new Float64Array(m);
	var FD1 = new Float64Array(m);
	mono = this.FD[3][m-1]-this.FD[3][0];
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	for (var j=0; j<m; j++) {
		if (j === 0) {
			FP1[0] = this.FD[3][1];
//			this.FC[3][0] = (0.1*this.FD[3][3]) - (0.8*this.FD[3][2]) + (2.3*this.FD[3][1]) - (1.6*this.FD[3][0]);
//			if (this.FC[3][0]*mono <= 0) { // opposite slope to monotonic
				this.FC[3][0] = -(0.5*this.FD[3][2]) + (2*this.FD[3][1]) - (1.5*this.FD[3][0]);
				if (this.FC[3][0]*mono <= 0) { // still opposite slope to monotonic
					this.FC[3][0] = 0.0075 * mono / (m-1);
				}
//			}
			FD1[0] = (this.FD[3][2] - this.FD[3][0])/2;
		} else if (j < m-1) {
			FP1[j] = this.FD[3][j+1];
			this.FC[3][j] = (this.FD[3][j+1] - this.FD[3][j-1])/2;
			if (j === m-2) {
//				FD1[j] = (-0.1*this.FD[3][j-2]) + (0.8*this.FD[3][j-1]) - (2.3*this.FD[3][j]) + (1.6*this.FD[3][j+1]);
//				if (FD1[j]*mono <= 0) { // opposite slope to monotonic
					FD1[j] = (0.5*this.FD[3][j-1]) - (2*this.FD[3][j]) + (1.5*this.FD[3][j+1]);
					if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						FD1[j] = 0.0075 * mono / (m-1);
					}
//				}
			} else {
				FD1[j] = (this.FD[3][j+2] - this.FD[3][j])/2;
			}
		} else {
			FP1[j] = this.FD[3][j];
			this.FC[3][j] = FD1[j-1];
			FD1[j] = FD1[j-1];
		}
		this.FA[3][j] = (2*this.FD[3][j]) + this.FC[3][j] - (2*FP1[j]) + FD1[j];
		this.FB[3][j] = (-3*this.FD[3][j]) - (2*this.FC[3][j]) + (3*FP1[j]) - FD1[j];
	}
};
LUTRGBSpline.prototype.f = function(L) {
	var s = this.FM[3];
	var r,l;
	if (this.fS) {
		L = s * (L - this.fL[3])/(this.fLH[3]);
	} else {
		L *= s;
	}
	if (L <= 0) {
		return (L * this.FC[3][0]) + this.FD[3][0];
	} else if (L >= s) {
		return ((L-s) * this.FC[3][s]) + this.FD[3][s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[3][l] * r) + this.FB[3][l]) * r) + this.FC[3][l]) * r) + this.FD[3][l];
	}
};
LUTRGBSpline.prototype.df = function(L) {
	var s = this.FM[3];
	var o;
	var r,l;
	if (this.fS) {
		L = s * (L - this.fL[3])/(this.fLH[3]);
	} else {
		L *= s;
	}
	if (L <= 0) {
		o = s*this.FC[3][0];
	} else if (L >= s) {
		o = s*this.FC[3][s];
	} else {
		l = Math.floor(L);
		r = L-l;
		o = s*((((3*this.FA[3][l] * r) + (2*this.FB[3][l])) * r) + this.FC[3][l]);
	}
	// Allow for scaled inputs
	if (this.fS) {
		o /= this.fLH[3];
	}
	return o;
};
LUTRGBSpline.prototype.fCub = function(L) {
	var s = this.FM[3];
	var r,l;
	if (this.fS) {
		L = s * (L - this.fL[3])/(this.fLH[3]);
	} else {
		L *= s;
	}
	if (L <= 0) {
		return (L * this.FC[3][0]) + this.FD[3][0];
	} else if (L >= s) {
		return ((L-s) * this.FC[3][s]) + this.FD[3][s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[3][l] * r) + this.FB[3][l]) * r) + this.FC[3][l]) * r) + this.FD[3][l];
	}
};
LUTRGBSpline.prototype.fTet = function(L) {
	var s = this.FM[3];
	var r,l;
	if (this.fS) {
		L = s * (L - this.fL[3])/(this.fLH[3]);
	} else {
		L *= s;
	}
	if (L <= 0) {
		return (L * this.FC[3][0]) + this.FD[3][0];
	} else if (L >= s) {
		return ((L-s) * this.FC[3][s]) + this.FD[3][s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[3][l]) + (r*this.FD[3][l+1]);
	}
};
LUTRGBSpline.prototype.fLin = function(L) {
	var s = this.FM[3];
	var r,l;
	if (this.fS) {
		L = s * (L - this.fL[3])/(this.fLH[3]);
	} else {
		L *= s;
	}
	if (L <= 0) {
		return (L * this.FC[3][0]) + this.FD[3][0];
	} else if (L >= s) {
		return ((L-s) * this.FC[3][s]) + this.FD[3][s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[3][l]) + (r*this.FD[3][l+1]);
	}
};
LUTRGBSpline.prototype.FCub = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM[3];
	var fL = this.fL[3];
	var fLH = this.fLH[3];
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - fL)/(fLH);
		}
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[3][0]) + this.FD[3][0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[3][s]) + this.FD[3][s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = (((((this.FA[3][l] * r) + this.FB[3][l]) * r) + this.FC[3][l]) * r) + this.FD[3][l];
		}
	}
};
LUTRGBSpline.prototype.FTet = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM[3];
	var fL = this.fL[3];
	var fLH = this.fLH[3];
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = s * (c[j] - fL)/(fLH);
		}
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[3][0]) + this.FD[3][0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[3][s]) + this.FD[3][s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[3][l]) + (r*this.FD[3][l+1]);
		}
	}
};
LUTRGBSpline.prototype.FLin = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM[3];
	var fL = this.fL[3];
	var fLH = this.fLH[3];
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = s * (c[j] - fL)/(fLH);
		}
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[3][0]) + this.FD[3][0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[3][s]) + this.FD[3][s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[3][l]) + (r*this.FD[3][l+1]);
		}
	}
};
LUTRGBSpline.prototype.fRGBCub = function(L) {
	var s;
	var r,l;
	var o = new Float64Array(3);
	if (this.fS) {
		o[0] = (L - this.fL[0])/(this.fLH[0]);
		o[1] = (L - this.fL[1])/(this.fLH[1]);
		o[2] = (L - this.fL[2])/(this.fLH[2]);
	}
	if (this.sin) {
		this.ins.FCub(o.buffer);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		o[i] *= s;
		if (o[i] <= 0) {
			o[i] = (o[i] * this.FC[i][0]) + this.FD[i][0];
		} else if (o[i] >= s) {
			o[i] = ((o[i]-s) * this.FC[i][s]) + this.FD[i][s];
		} else {
			l = Math.floor(o[i]);
			r = o[i]-l;
			o[i] = (((((this.FA[i][l] * r) + this.FB[i][l]) * r) + this.FC[i][l]) * r) + this.FD[i][l];
		}
	}
	return o;
};
LUTRGBSpline.prototype.fRGBTet = function(L) {
	var s;
	var r,l;
	var o = new Float64Array(3);
	if (this.fS) {
		o[0] = (L - this.fL[0])/(this.fLH[0]);
		o[1] = (L - this.fL[1])/(this.fLH[1]);
		o[2] = (L - this.fL[2])/(this.fLH[2]);
	}
	if (this.sin) {
		this.ins.FCub(o.buffer);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		o[i] *= s;
		if (o[i] <= 0) {
			o[i] = (o[i] * this.FC[i][0]) + this.FD[i][0];
		} else if (o[i] >= s) {
			o[i] = ((o[i]-s) * this.FC[i][s]) + this.FD[i][s];
		} else {
			l = Math.floor(o[i]);
			r = o[i]-l;
			o[j] = ((1-r)*this.FD[i][l]) + (r*this.FD[i][l+1]);
		}
	}
	return o;
};
LUTRGBSpline.prototype.fRGBLin = function(L) {
	var s;
	var r,l;
	var o = new Float64Array(3);
	if (this.fS) {
		o[0] = (L - this.fL[0])/(this.fLH[0]);
		o[1] = (L - this.fL[1])/(this.fLH[1]);
		o[2] = (L - this.fL[2])/(this.fLH[2]);
	}
	if (this.sin) {
		this.ins.FCub(o.buffer);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		o[i] *= s;
		if (o[i] <= 0) {
			o[i] = (o[i] * this.FC[i][0]) + this.FD[i][0];
		} else if (o[i] >= s) {
			o[i] = ((o[i]-s) * this.FC[i][s]) + this.FD[i][s];
		} else {
			l = Math.floor(o[i]);
			r = o[i]-l;
			o[j] = ((1-r)*this.FD[i][l]) + (r*this.FD[i][l+1]);
		}
	}
	return o;
};
LUTRGBSpline.prototype.rgbCub = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.RGBCub(out.buffer);
	return out;
};
LUTRGBSpline.prototype.rgbTet = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.RGBLin(out.buffer);
	return out;
};
LUTRGBSpline.prototype.rgbLin = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.RGBLin(out.buffer);
	return out;
};
LUTRGBSpline.prototype.RGBCub = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var fL = this.fL;
	var fLH = this.fLH;
	var s,k,l,r;
	if (this.fS) {
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		for (var j=0; j<m; j+=3) {
			k = j+i;
			c[k] *= s;
			if (c[k] <= 0) {
				c[k] = (c[k] * this.FC[i][0]) + this.FD[i][0];
			} else if (c[k] >= s) {
				c[k] = ((c[k]-s) * this.FC[i][s]) + this.FD[i][s];
			} else {
				l = Math.floor(c[k]);
				r = c[k]-l;
				c[k] = (((((this.FA[i][l] * r) + this.FB[i][l]) * r) + this.FC[i][l]) * r) + this.FD[i][l];
			}
		}
	}
};
LUTRGBSpline.prototype.RGBTet = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var fL = this.fL;
	var fLH = this.fLH;
	var s,k,l,r;
	if (this.fS) {
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		for (var j=0; j<m; j+=3) {
			k = j+i;
			c[k] *= s;
			if (c[k] <= 0) {
				c[k] = (c[k] * this.FC[i][0]) + this.FD[i][0];
			} else if (c[k] >= s) {
				c[k] = ((c[k]-s) * this.FC[i][s]) + this.FD[i][s];
			} else {
				l = Math.floor(c[k]);
				r = c[k]-l;
				c[j] = ((1-r)*this.FD[i][l]) + (r*this.FD[i][l+1]);
			}
		}
	}
};
LUTRGBSpline.prototype.RGBLin = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var fL = this.fL;
	var fLH = this.fLH;
	var s,k,l,r;
	if (this.fS) {
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		for (var j=0; j<m; j+=3) {
			k = j+i;
			c[k] *= s;
			if (c[k] <= 0) {
				c[k] = (c[k] * this.FC[i][0]) + this.FD[i][0];
			} else if (c[k] >= s) {
				c[k] = ((c[k]-s) * this.FC[i][s]) + this.FD[i][s];
			} else {
				l = Math.floor(c[k]);
				r = c[k]-l;
				c[j] = ((1-r)*this.FD[i][l]) + (r*this.FD[i][l+1]);
			}
		}
	}
};
LUTRGBSpline.prototype.J = function(rgbIn) {
	// calculate the Jacobian matrix at rgbIn
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var J = new Float64Array(9);
		var s;
		var r,l;
		if (this.fS) {
			c[0] = (c[0] - this.fL[0])/(this.fLH[0]);
			c[1] = (c[1] - this.fL[1])/(this.fLH[1]);
			c[2] = (c[2] - this.fL[2])/(this.fLH[2]);
		}
		if (this.sin) {
			c[0] = this.ins.f(c[0]);
			c[1] = this.ins.f(c[1]);
			c[2] = this.ins.f(c[2]);
		}
		s = this.FM[0];
		c[0] *= s;
		if (c[0] <= 0) {
			J[0] = this.FC[0][0];
		} else if (c[0] >= s) {
			J[0] = this.FC[0][s];
		} else {
			l = Math.floor(c[0]);
			r = c[0]-l;
			J[0] = ((((3*this.FA[0][l] * r) + (2*this.FB[0][l])) * r) + this.FC[0][l]);
		}
		s = this.FM[1];
		c[1] *= s;
		if (c[1] <= 0) {
			J[4] = this.FC[1][0];
		} else if (c[1] >= s) {
			J[4] = this.FC[1][s];
		} else {
			l = Math.floor(c[1]);
			r = c[1]-l;
			J[4] = ((((3*this.FA[1][l] * r) + (2*this.FB[1][l])) * r) + this.FC[1][l]);
		}
		s = this.FM[2];
		c[2] *= s;
		if (c[2] <= 0) {
			J[8] = this.FC[2][0];
		} else if (c[2] >= s) {
			J[8] = this.FC[2][s];
		} else {
			l = Math.floor(c[2]);
			r = c[2]-l;
			J[8] = ((((3*this.FA[2][l] * r) + (2*this.FB[2][l])) * r) + this.FC[2][l]);
		}
		// Scale to 0-1 range (from 0-s)
		J[0] *= s;
		J[1] *= s;
		J[2] *= s;
		J[3] *= s;
		J[4] *= s;
		J[5] *= s;
		J[6] *= s;
		J[7] *= s;
		J[8] *= s;
		if (this.sin) {
			var dRGB = this.ins.dRGB(rgbIn.buffer);
			J[0] *= dRGB[0];
			J[1] *= dRGB[1];
			J[2] *= dRGB[2];
			J[3] *= dRGB[0];
			J[4] *= dRGB[1];
			J[5] *= dRGB[2];
			J[6] *= dRGB[0];
			J[7] *= dRGB[1];
			J[8] *= dRGB[2];
		}
		if (this.fS) {
			J[0] /= fLH[0];
			J[1] /= fLH[1];
			J[2] /= fLH[2];
			J[3] /= fLH[0];
			J[4] /= fLH[1];
			J[5] /= fLH[2];
			J[6] /= fLH[0];
			J[7] /= fLH[1];
			J[8] /= fLH[2];
		}
		return J;
	} else {
		return false;
	}
};
LUTRGBSpline.prototype.JInv = function(rgbIn) {
	var M = this.J(rgbIn);
	if (M[0] !== 0 && M[4] !== 0 && M[8] !== 0) {
		return new Float64Array([
			1/M[0],	0,		0,
			0,		1/M[4],	0,
			0,		0,		1/M[8]
		]);
	} else {
		return false;
	}
};
LUTRGBSpline.prototype.getDetails = function(L) {
	var out;
	if (typeof L !== 'undefined' && L ) {
		out = {
			title: this.title,
			format: this.format,
			dims: 1,
			s: this.FM[3]+1,
			min: new Float64Array([this.fL[3],this.fL[3],this.fL[3]]),
			max: new Float64Array([this.fH[3],this.fH[3],this.fH[3]]),
			C: [this.FD[3].buffer],
			meta: this.meta
		};
	} else {
		out = {
			title: this.title,
			format: this.format,
			dims: 1,
			s: this.FM[3]+1,
			min: new Float64Array([this.fL[0],this.fL[1],this.fL[2]]),
			max: new Float64Array([this.fH[0],this.fH[1],this.fH[2]]),
			C: [this.FD[0].buffer,this.FD[1].buffer,this.FD[2].buffer],
			meta: this.meta
		};
	}
	return out;
};
LUTRGBSpline.prototype.getL = function() {
	return this.FD[3].buffer;
};
LUTRGBSpline.prototype.getRGB = function() {
	return [this.FD[0].buffer,this.FD[1].buffer,this.FD[2].buffer];
};
LUTRGBSpline.prototype.getSize = function() {
	return this.FM[3]+1;
};
LUTRGBSpline.prototype.is1D = function() {
	return true;
};
LUTRGBSpline.prototype.is3D = function() {
	return false;
};
LUTRGBSpline.prototype.getTitle = function() {
	return this.title;
};
LUTRGBSpline.prototype.getMetadata = function() {
	return this.meta;
};
LUTRGBSpline.prototype.isClamped = function() {
	if (typeof this.clamped === 'undefined') {
		var mm = this.minMax();
		var min = Math.min(mm[0],mm[1],mm[2]);
		var max = Math.max(mm[3],mm[4],mm[5]);
		if ((min === 0 && max <= 1) || (min >= 0 && max === 1)) {
			this.clamped = true;
		} else {
			this.clamped = false;
		}
	}
	return this.clamped;
};
LUTRGBSpline.prototype.deClamp = function() {
	if (this.isClamped()) {
		var m,c,C,L,H,LH,S;
		var fL,fH,fLH;
		for (var i=0; i<3; i++) {
			c = this.FD[i];
			m = c.length;
			C = false;
			L = 0;
			H = m-1;
			for (var j=0; j<m; j++) {
				if (j>0) {
					if (c[j] === 0) {
						C = true;
						L = j+1;
					}
				}
			}
			for (var j=m-2; j>=0; j--) {
				if (c[j] === 1) {
					C = true;
					H = j-1;
				}
			}
			if (C) {
				if (L > H) {
					var low = H;
					H = Math.min(L-2,m-1);
					L = Math.max(low+2,0);
				}
				LH = H-L;
				S = new LUTQSpline(new Float64Array(c.subarray(L,LH+1)).buffer);
				fL = this.fL[i];
				fH = this.fH[i];
				fLH= fH-fL;
				for (var j=0; j<m; j++) {
					if (j===L) {
						j = H;
					}
					// pass through the splines
					c[j] = S.fCub((j - L)/LH);
				}
			}
		}
		this.buildMesh();
		this.buildL();
		this.clamped = false;
	}
};
//
LUTRGBSpline.prototype.getColourSpace = function() {
	var d = this.d;
	var fL = this.fL;
	var fH = this.fH;
	var fLH = this.fLH;
	var out = {
		title: this.title + 'CS',
		format: this.format,
		fLR: fL[0],
		fLG: fL[1],
		fLB: fL[2],
		fHR: fH[0],
		fHG: fH[1],
		fHB: fH[2]
	};
	var reverse = new LUTRSpline({ buff:this.L.getL(), fH:fH[3], fL:fL[3] });
	var base = this.getRGB();
	reverse.R(base[0]);
	reverse.R(base[1]);
	reverse.R(base[2]);
	out.buffR = base[0];
	out.buffG = base[1];
	out.buffB = base[2];
	return new LUTRGBSpline(out);
};
LUTRGBSpline.prototype.compare = function(tgtBuff,tstBuff,method) {
	// returns the RMS differences in the red channels between a target dataset (tgt) and a test dataset (tst) which 'compare' passes through the lut
	// method sets the interpolation method used on the test set, currently trilinear (1, 'lin' or 'linear') or tricubic (anything else or the default if 'method' is not present.
	var tgt = new Float64Array(tgtBuff.slice(0));
	var tst = new Float64Array(tstBuff.slice(0));
	var m = tgt.length;
	if (m !== tst.length) {
		return false;
	}
	if (typeof method !== 'undefined') {
		method = method.toString().toLowerCase();
		if (method === '1' || method === 'tet') {
			this.RGBTet(tst.buffer);
		} else if (method === '2' || method === 'lin') {
			this.RGBLin(tst.buffer);
		} else {
			this.RGBCub(tst.buffer);
		}
	} else {
		this.RGBCub(tst.buffer);
	} 
	var e = new Float64Array(3);
	for (var j=0; j<m; j += 3) {
		e[0]  += Math.pow(tst[ j ] - tgt[ j ],2);
		e[1]  += Math.pow(tst[j+1] - tgt[j+1],2);
		e[2]  += Math.pow(tst[j+2] - tgt[j+2],2);
	}
	e[0] = Math.pow(e[0]*3/m,0.5);
	e[1] = Math.pow(e[1]*3/m,0.5);
	e[2] = Math.pow(e[2]*3/m,0.5);
	return e;
};
LUTRGBSpline.prototype.minMax = function() {
	var x = new Float64Array([
		 9999, 9999, 9999,	// Absolute min values
		-9999,-9999,-9999	// Absolute max values
	]);
	var c,m;
	for (var i=0; i<3; i++) {
		c = this.FD[i];
		m = c.length;
		for (var j=0; j<m; j++) {
			if (c[j] < x[i]) {
				x[i] = c[j];
			}
			if (c[j] > x[i+3]) {
				x[i+3] = c[j];
			}
		}
	}
	return x;
};
// LUTVolume - 3D mesh object
function LUTVolume(params) {
	// Metadata
	if (typeof params.title === 'string') {
		this.title = params.title;
	} else {
		this.title = '';
	}
	if (typeof params.format === 'string') {
		this.format = params.format;
	} else {
		this.format = '';
	}
	if (typeof params.meta !== 'undefined') {
		this.meta = params.meta;
	} else {
		this.meta = {};
	}
	this.Y = new Float64Array([0.2126,0.7152,0.0722]); // Rec709 luma coefficients
	// Set forward range
	this.fL = new Float64Array(4);
	this.fH = new Float64Array(4);
	this.fS = false;
	if (typeof params.min !== 'undefined' && (params.min[0] !== 0 || params.min[1] !== 0 || params.min[2] !== 0)) {
		params.fL = params.min[0];
		params.fLR = params.min[0];
		params.fLG = params.min[1];
		params.fLB = params.min[2];
	}
	if (typeof params.max !== 'undefined' && (params.max[0] !== 1 || params.max[1] !== 1 || params.max[2] !== 1)) {
		params.fH = params.max[0];
		params.fHR = params.max[0];
		params.fHG = params.max[1];
		params.fHB = params.max[2];
	}
	if (typeof params.fH === 'number') {
		this.fH[0] = params.fH;
		this.fH[1] = params.fH;
		this.fH[2] = params.fH;
	} else {
		this.fH[0] = 1;
		this.fH[1] = 1;
		this.fH[2] = 1;
	}
	if (typeof params.fL === 'number') {
		this.fL[0] = params.fL;
		this.fL[1] = params.fL;
		this.fL[2] = params.fL;
	} else {
		this.fL[0] = 0;
		this.fL[1] = 0;
		this.fL[2] = 0;
	}
	if (typeof params.fLR === 'number' &&
		typeof params.fHR === 'number' &&
		typeof params.fLG === 'number' &&
		typeof params.fHG === 'number' &&
		typeof params.fLB === 'number' &&
		typeof params.fHB === 'number') {
		this.fL[0] = params.fLR;
		this.fH[0] = params.fHR;
		this.fL[1] = params.fLG;
		this.fH[1] = params.fHG;
		this.fL[2] = params.fLB;
		this.fH[2] = params.fHB;
	}
	this.fL[3] = Math.min(this.fL[0],this.fL[1],this.fL[2]);
	this.fH[3] = Math.max(this.fH[0],this.fH[1],this.fH[2]);
	this.fLH = new Float64Array([this.fH[0]-this.fL[0],this.fH[1]-this.fL[1],this.fH[2]-this.fL[2],0]);
	if (this.fL[0] !== 0 || this.fL[1] !== 0 || this.fL[2] !== 0 || this.fH[0] !== 1 || this.fH[1] !== 1 || this.fH[2] !== 1) {
		this.fS = true;
	}
	// Allow for spline input (a bit nuts for 1D, but being robust)
	if (typeof params.inSpline !== 'undefined') {
		this.sin = true;
		this.ins = new LUTQSpline(params.inSpline);
	} else {
		this.sin = false;
	}
	// create a 'mesh' object to do the 3D interpolation
	this.pR = new Float64Array(4);
	this.pG = new Float64Array(4);
	this.pB = new Float64Array(4);
	this.buildMesh(params.buffR,params.buffG,params.buffB);
	// Precalculate Luma arrays
	this.buildL();
	// Store some typed arrays for repeat use to minimise garbage collection
	this.extVars= {
		dc: new Float64Array(this.d),
		r: new Float64Array(this.d),
		J: new Float64Array(this.d*3),
		JtJ: new Float64Array(9),
		JtJI: new Float64Array(9),
		Jtr: new Float64Array(3),
		del: new Float64Array(3)
	};
	this.ABab = new Float64Array([1,0,1,0]);
}
LUTVolume.prototype.buildMesh = function(buffR,buffG,buffB) {
	var red = new Float64Array(buffR);
	var green = new Float64Array(buffG);
	var blue = new Float64Array(buffB);
	var Y = new Float64Array([0.2126,0.7152,0.0722]); // Rec709 luma coefficients
	this.d = Math.round(Math.pow(red.length,1/3)); // dimensions of the base mesh
	var d = this.d;
	this.s = d-1;
	var d2 = d*d;
	var d3 = red.length;
	var nd = d + 2;
	this.nd = nd;
	var nd2 = nd * nd;
	var nd3 = nd2 * nd;
	var sG = nd3;
	var sB = 2 * sG;
	this.mesh = new Float64Array(nd3*3); // the new mesh is two points larger per side, with all three channels in one array for speed
	var k = nd2 + nd + 1; // first point in the new mesh at which to place mesh values
	var l=0;
	// create 4x4x4 array of offsets for quickly getting cubic control points;
	this.off = new Float64Array(64);
	for (var b=0; b<4; b++) {
		for (var g=0; g<4; g++) {
			for (var r=0; r<4; r++) {
				this.off[r + (g*4) + (b*16)] = r + (g*nd) + (b*nd2);
			}
		}
	}
	// populate the core of the new mesh with the old one
	for (var b=0; b<d; b++) {
		for (var g=0; g<d; g++) {
			for (var r=0; r<d; r++) { // typedarray slice and copywithin would allow block copying, but are not generally available in IE and Safari JS
				this.mesh[ k  ] = red[l];
				this.mesh[k+sG] = green[l];
				this.mesh[k+sB] = blue[l];
				l++;
				k++;
			}
			k += 2;
		}
		k += 2 * nd;
	}
	// Fill in the gaps around the larger mesh for quicker extrapolation
	this.fillEdges();
	// create object-scope typed arrays to minimise garbage collection
	this.rgb = new Float64Array(18);
	this.R = new Float64Array(8);
	this.G = new Float64Array(8);
	this.B = new Float64Array(8);
};
LUTVolume.prototype.buildL = function() {
	var fL = this.fL[3];
	var fH = this.fH[3];
	var fLH= fH-fL;
	var m = this.getSize();
	if (m < 65) {
		m = 65;
	}
	var FD = new Float64Array(m);
	var rgb = new Float64Array(m*3);
	var m2 = rgb.length;
	var k;
	for (var j=0; j<m; j++) { // create rgb array of input values
		k = j*3;
		rgb[ k ] = (j*(fLH)/(m-1))+fL;
		rgb[k+1] = rgb[k];
		rgb[k+2] = rgb[k];
	}
	// apply input scaling as required
	if (this.fS) {
		for (var j=0; j<m2; j += 3) {
			rgb[ j ] = (rgb[ j ] - this.fL[0])/(this.fLH[0]);
			rgb[j+1] = (rgb[j+1] - this.fL[1])/(this.fLH[1]);
			rgb[j+2] = (rgb[j+2] - this.fL[2])/(this.fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(rgb.buffer);
	}
	this.RGBCub(rgb.buffer); // calculate output rgb values
	for (var j=0; j<m; j++) {
		k = j*3;
		FD[j] = (rgb[ k ]*this.Y[0]) + (rgb[k+1]*this.Y[1]) + (rgb[k+2]*this.Y[2]);
	}
	this.L = new LUTSpline({ buff:FD.buffer, fH:fH, fL:fL });
};
LUTVolume.prototype.f = function(L) {
	return this.L.f(L);
};
LUTVolume.prototype.df = function(L) {
	return this.L.df(L);
};
LUTVolume.prototype.fCub = function(L) {
	return this.L.fCub(L);
};
LUTVolume.prototype.fTet = function(L) {
	return this.L.fLin(L);
};
LUTVolume.prototype.fLin = function(L) {
	return this.L.fLin(L);
};
LUTVolume.prototype.FCub = function(buff) {
	this.L.FCub(buff);
};
LUTVolume.prototype.FTet = function(buff) {
	this.L.FLin(buff);
};
LUTVolume.prototype.FLin = function(buff) {
	this.L.FLin(buff);
};
LUTVolume.prototype.fRGBCub = function(L) {
	var o = new Float64Array([L,L,L]);
	this.RGBCub(o.buffer);
	return o;
};
LUTVolume.prototype.fRGBTet = function(L) {
	var o = new Float64Array([L,L,L]);
	this.RGBTet(o.buffer);
	return o;
};
LUTVolume.prototype.fRGBLin = function(L) {
	var o = new Float64Array([L,L,L]);
	this.RGBLin(o.buffer);
	return o;
};
LUTVolume.prototype.rgbCub = function(rgbIn) {
	var rgb = new Float64Array(rgbIn.buffer.slice(0));
	this.RGBCub(rgb.buffer);
	return rgb;
};
LUTVolume.prototype.rgbTet = function(rgbIn) {
	var rgb = new Float64Array(rgbIn.buffer.slice(0));
	this.RGBTet(rgb.buffer);
	return rgb;
};
LUTVolume.prototype.rgbLin = function(rgbIn) {
	var rgb = new Float64Array(rgbIn.buffer.slice(0));
	this.RGBLin(rgb.buffer);
	return rgb;
};
LUTVolume.prototype.RGBCub = function(buff) {
	var c = new Float64Array(buff);
	var p = this.mesh;
	var o = this.off;
	var rgb = this.rgb;
	var m = c.length;
	var mm = Math.round(this.mesh.length/3);
	var s = this.s;
	var nd = s + 2;
	var nd1 = nd + 1;
	var k,b;
	var R = this.R;
	var G = this.G;
	var B = this.B;
	var E = false;
	var rE = false;
	var gE = false;
	var bE = false;
	if (this.fS) {
		var fL = this.fL;
		var fLH = this.fLH;
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j +=3) {
		c[ j ] *= s;
		c[j+1] *= s;
		c[j+2] *= s;
		rgb[ 9] = Math.max(0,Math.min(s-1,Math.floor(c[ j ])));
		rgb[10] = Math.max(0,Math.min(s-1,Math.floor(c[j+1])));
		rgb[11] = Math.max(0,Math.min(s-1,Math.floor(c[j+2])));
		c[ j ] -= rgb[ 9];
		c[j+1] -= rgb[10];
		c[j+2] -= rgb[11];
		// clamp values between 0-1.0 for interpolation
		rgb[0] = Math.max(0,Math.min(1,c[ j ]));
		rgb[1] = Math.max(0,Math.min(1,c[j+1]));
		rgb[2] = Math.max(0,Math.min(1,c[j+2]));
		// note that extrapolation will be needed if values were clamped
		if (rgb[0] !== c[ j ]) {
			rE = true;
			E = true;
		}
		if (rgb[1] !== c[j+1]) {
			gE = true;
			E = true;
		}
		if (rgb[2] !== c[j+2]) {
			bE = true;
			E = true;
		}
		// Prep all the squares, cubes and cubics
		rgb[3] = rgb[0]*rgb[0];
		rgb[4] = rgb[1]*rgb[1];
		rgb[5] = rgb[2]*rgb[2];
		rgb[6] = rgb[3]*rgb[0];
		rgb[7] = rgb[4]*rgb[1];
		rgb[8] = rgb[5]*rgb[2];
		R[0] = (-0.5*rgb[6]) + rgb[3] - (0.5*rgb[0]);
		R[1] = (1.5*rgb[6]) - (2.5*rgb[3]) + 1;
		R[2] = (-1.5*rgb[6]) + (2*rgb[3]) + (0.5*rgb[0]);
		R[3] = (0.5*rgb[6]) - (0.5*rgb[3]);
		G[0] = (-0.5*rgb[7]) + rgb[4] - (0.5*rgb[1]);
		G[1] = (1.5*rgb[7]) - (2.5*rgb[4]) + 1;
		G[2] = (-1.5*rgb[7]) + (2*rgb[4]) + (0.5*rgb[1]);
		G[3] = (0.5*rgb[7]) - (0.5*rgb[4]);
		B[0] = (-0.5*rgb[8]) + rgb[5] - (0.5*rgb[2]);
		B[1] = (1.5*rgb[8]) - (2.5*rgb[5]) + 1;
		B[2] = (-1.5*rgb[8]) + (2*rgb[5]) + (0.5*rgb[2]);
		B[3] = (0.5*rgb[8]) - (0.5*rgb[5]);
		// if any or all channels need extrapolation find out the scaling
		if (rE) {
			rgb[12] = c[ j ] - rgb[0];
		}
		if (gE) {
			rgb[13] = c[j+1] - rgb[1];
		}
		if (bE) {
			rgb[14] = c[j+2] - rgb[2];
		}
		// set value for first control point in the mesh - P[-1,-1,-1]
		b = (rgb[9]) + ((rgb[10] + (rgb[11]*nd1))*nd1);
		k = b;
		// multiply and add the cubics and the control points
		c[ j ]  = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[0])+
				  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[3]);
		k += mm;
		c[j+1]  = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[0])+
				  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[3]);
		k += mm;
		c[j+2]  = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[0])+
				  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[3]);
		// find slopes and perform extrapolation as needed
		if (E) {
			if (rE) {
				R[4] = (-1.5*rgb[3]) + (2*rgb[0]) - 0.5;
				R[5] = (4.5*rgb[3]) - (5*rgb[0]);
				R[6] = (-4.5*rgb[3]) + (4*rgb[0]) + 0.5;
				R[7] = (1.5*rgb[3] - rgb[0]);
				k = b;
				rgb[15] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
							(((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
							(((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
							(((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
				  		  (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
							(((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
							(((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
							(((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
						  (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
							(((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
							(((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
							(((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
						  (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
							(((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
							(((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
							(((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
				k += mm;
				rgb[16] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
							(((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
							(((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
							(((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
				  		  (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
							(((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
							(((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
							(((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
						  (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
							(((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
							(((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
							(((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
						  (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
							(((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
							(((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
							(((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
				k += mm;
				rgb[27] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
							(((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
							(((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
							(((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
				  		  (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
							(((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
							(((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
							(((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
						  (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
							(((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
							(((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
							(((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
						  (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
							(((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
							(((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
							(((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
				c[ j ] += rgb[12] * rgb[15];
				c[j+1] += rgb[12] * rgb[16];
				c[j+2] += rgb[12] * rgb[17];
			}
			if (gE) {
				G[4] = (-1.5*rgb[4]) + (2*rgb[1]) - 0.5;
				G[5] = (4.5*rgb[4]) - (5*rgb[1]);
				G[6] = (-4.5*rgb[4]) + (4*rgb[1]) + 0.5;
				G[7] = (1.5*rgb[4] - rgb[1]);
				k = b;
				rgb[15] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
				k += mm;
				rgb[16] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
				k += mm;
				rgb[17] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
				c[ j ] += rgb[13] * rgb[15];
				c[j+1] += rgb[13] * rgb[16];
				c[j+2] += rgb[13] * rgb[17];
			}
			if (bE) {
				B[4] = (-1.5*rgb[5]) + (2*rgb[2]) - 0.5;
				B[5] = (4.5*rgb[5]) - (5*rgb[2]);
				B[6] = (-4.5*rgb[5]) + (4*rgb[2]) + 0.5;
				B[7] = (1.5*rgb[5] - rgb[2]);
				k = b;
				rgb[15] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
				k += mm;
				rgb[16] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
				k += mm;
				rgb[17] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
				c[ j ] += rgb[14] * rgb[15];	
				c[j+1] += rgb[14] * rgb[16];
				c[j+2] += rgb[14] * rgb[17];
			}
			E = false;
			rE = false;
			gE = false;
			bE = false;
		}
	}
};
LUTVolume.prototype.RGBTet = function(buff) {
	var c = new Float64Array(buff);
	var p = this.mesh;
	var o = this.off;
	var rgb = this.rgb;
	var m = c.length;
	var mm = Math.round(this.mesh.length/3);
	var s = this.s;
	var nd = s + 2;
	var nd1 = nd + 1;
	var k,b;
	var R = this.R;
	var G = this.G;
	var B = this.B;
	var E = false;
	var rE = false;
	var gE = false;
	var bE = false;
	if (this.fS) {
		var fL = this.fL;
		var fLH = this.fLH;
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j +=3) {
		c[ j ] *= s;
		c[j+1] *= s;
		c[j+2] *= s;
		rgb[ 9] = Math.max(0,Math.min(s-1,Math.floor(c[ j ])));
		rgb[10] = Math.max(0,Math.min(s-1,Math.floor(c[j+1])));
		rgb[11] = Math.max(0,Math.min(s-1,Math.floor(c[j+2])));
		c[ j ] -= rgb[ 9];
		c[j+1] -= rgb[10];
		c[j+2] -= rgb[11];
		// clamp values between 0-1.0 for interpolation
		rgb[0] = Math.max(0,Math.min(1,c[ j ]));
		rgb[1] = Math.max(0,Math.min(1,c[j+1]));
		rgb[2] = Math.max(0,Math.min(1,c[j+2]));
		// note that extrapolation will be needed if values were clamped
		if (rgb[0] !== c[ j ]) {
			rE = true;
			E = true;
		}
		if (rgb[1] !== c[j+1]) {
			gE = true;
			E = true;
		}
		if (rgb[2] !== c[j+2]) {
			bE = true;
			E = true;
		}
		// if any or all channels need extrapolation find out the scaling
		if (rE) {
			rgb[12] = c[ j ] - rgb[0];
		}
		if (gE) {
			rgb[13] = c[j+1] - rgb[1];
		}
		if (bE) {
			rgb[14] = c[j+2] - rgb[2];
		}
		// set value for first control point in the mesh - P[-1,-1,-1]
		b = (rgb[9]) + ((rgb[10] + (rgb[11]*nd1))*nd1);
		k = b;
		// find which tetrahedron to use
		var tet = (rgb[0]>rgb[1]) + ((rgb[1]>rgb[2])*2) + ((rgb[2]>rgb[0])*4);
		// perform tetrahedral interpolation
		switch (tet) {
			case 0: // rgb[0] === rgb[1] === rgb[2] so straight linear interpolation
				c[ j ] = ((1-rgb[0])*p[k+o[21]]) + (rgb[0]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[1])*p[k+o[21]]) + (rgb[1]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[2])*p[k+o[21]]) + (rgb[2]*p[k+o[42]]);
				break;
			case 1:
				c[ j ] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[2])*p[k+o[22]]) + ((rgb[2]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[2])*p[k+o[22]]) + ((rgb[2]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[2])*p[k+o[22]]) + ((rgb[2]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				break;
			case 2:
				c[ j ] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[0])*p[k+o[25]]) + ((rgb[0]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[0])*p[k+o[25]]) + ((rgb[0]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[0])*p[k+o[25]]) + ((rgb[0]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				break;
			case 3:
				c[ j ] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[1])*p[k+o[22]]) + ((rgb[1]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[1])*p[k+o[22]]) + ((rgb[1]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[1])*p[k+o[22]]) + ((rgb[1]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				break;
			case 4:
				c[ j ] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[1])*p[k+o[37]]) + ((rgb[1]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[1])*p[k+o[37]]) + ((rgb[1]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[1])*p[k+o[37]]) + ((rgb[1]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				break;
			case 5:
				c[ j ] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[0])*p[k+o[37]]) + ((rgb[0]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[0])*p[k+o[37]]) + ((rgb[0]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[0])*p[k+o[37]]) + ((rgb[0]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				break;
			case 6:
				c[ j ] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[2])*p[k+o[25]]) + ((rgb[2]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[2])*p[k+o[25]]) + ((rgb[2]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[2])*p[k+o[25]]) + ((rgb[2]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				break;
			default: // shouldn't be possible, but include fallback to trilinear interpolation
				c[ j ]  = ((((((1-rgb[0])*p[k+o[21]]) + (rgb[0]*p[k+o[22]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[25]]) + (rgb[0]*p[k+o[26]]))*rgb[1]))*(1-rgb[2]))+
						  ((((((1-rgb[0])*p[k+o[37]]) + (rgb[0]*p[k+o[38]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]))*rgb[1]))*rgb[2]);
				k += mm;
				c[j+1]  = ((((((1-rgb[0])*p[k+o[21]]) + (rgb[0]*p[k+o[22]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[25]]) + (rgb[0]*p[k+o[26]]))*rgb[1]))*(1-rgb[2]))+
						  ((((((1-rgb[0])*p[k+o[37]]) + (rgb[0]*p[k+o[38]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]))*rgb[1]))*rgb[2]);
				k += mm;
				c[j+2]  = ((((((1-rgb[0])*p[k+o[21]]) + (rgb[0]*p[k+o[22]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[25]]) + (rgb[0]*p[k+o[26]]))*rgb[1]))*(1-rgb[2]))+
						  ((((((1-rgb[0])*p[k+o[37]]) + (rgb[0]*p[k+o[38]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]))*rgb[1]))*rgb[2]);
		}
		// find slopes and perform extrapolation as needed
		// Actually use Trilinear for EXTRAPOLATION, as tends to be smoother than tetrahedral
		if (E) {
			R[0] = 1-rgb[0];
			R[1] = rgb[0];
			G[0] = 1-rgb[1];
			G[1] = rgb[1];
			B[0] = 1-rgb[2];
			B[1] = rgb[2];
			if (rE) {
				k = b;
				rgb[15] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				k += mm;
				rgb[16] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				k += mm;
				rgb[17] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				c[ j ] += rgb[12] * rgb[15];
				c[j+1] += rgb[12] * rgb[16];
				c[j+2] += rgb[12] * rgb[17];
			}
			if (gE) {
				k = b;
				rgb[15] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				k += mm;
				rgb[16] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				k += mm;
				rgb[17] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				c[ j ] += rgb[13] * rgb[15];
				c[j+1] += rgb[13] * rgb[16];
				c[j+2] += rgb[13] * rgb[17];
			}
			if (bE) {
				k = b;
				rgb[15] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				k += mm;
				rgb[16] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				k += mm;
				rgb[17] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				c[ j ] += rgb[14] * rgb[15];	
				c[j+1] += rgb[14] * rgb[16];
				c[j+2] += rgb[14] * rgb[17];
			}
			E = false;
			rE = false;
			gE = false;
			bE = false;
		}
/* Tetrahedral EXTRAPOLATION is not great - LUTCalc currently uses Trilinear. The following is tetrahedral code
		if (E) {
			// check for and perform extrapolation
			if (rE) {
				k=b;
				switch (tet) {
					case 0: // rgb[0] === rgb[1] === rgb[2]
						rgb[15] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[21]];
						break;
					case 1:
						rgb[15] = p[k+o[22]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[22]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[22]]-p[k+o[21]];
						break;
					case 2:
						rgb[15] = p[k+o[26]]-p[k+o[25]];
						k += mm;
						rgb[16] = p[k+o[26]]-p[k+o[25]];
						k += mm;
						rgb[17] = p[k+o[26]]-p[k+o[25]];
						break;
					case 3:
						rgb[15] = p[k+o[22]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[22]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[22]]-p[k+o[21]];
						break;
					case 4:
						rgb[15] = p[k+o[42]]-p[k+o[41]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[41]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[41]];
						break;
					case 5:
						rgb[15] = p[k+o[38]]-p[k+o[37]];
						k += mm;
						rgb[16] = p[k+o[38]]-p[k+o[37]];
						k += mm;
						rgb[17] = p[k+o[38]]-p[k+o[37]];
						break;
					case 6:
						rgb[15] = p[k+o[42]]-p[k+o[41]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[41]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[41]];
						break;
					default: // shouldn't be possible, but include fallback to trilinear interpolation
						rgb[15] = ((((p[k+o[22]]-p[k+o[21]])*(1-rgb[1])) + ((p[k+o[26]]-p[k+o[25]])*rgb[1]))*(1-rgb[2]))+
								  ((((p[k+o[38]]-p[k+o[37]])*(1-rgb[1])) + ((p[k+o[42]]-p[k+o[41]])*rgb[1]))*rgb[2]);
						k += mm;
						rgb[16] = ((((p[k+o[22]]-p[k+o[21]])*(1-rgb[1])) + ((p[k+o[26]]-p[k+o[25]])*rgb[1]))*(1-rgb[2]))+
								  ((((p[k+o[38]]-p[k+o[37]])*(1-rgb[1])) + ((p[k+o[42]]-p[k+o[41]])*rgb[1]))*rgb[2]);
						k += mm;
						rgb[17] = ((((p[k+o[22]]-p[k+o[21]])*(1-rgb[1])) + ((p[k+o[26]]-p[k+o[25]])*rgb[1]))*(1-rgb[2]))+
								  ((((p[k+o[38]]-p[k+o[37]])*(1-rgb[1])) + ((p[k+o[42]]-p[k+o[41]])*rgb[1]))*rgb[2]);
				}
				c[ j ] += rgb[12] * rgb[15];
				c[j+1] += rgb[12] * rgb[16];
				c[j+2] += rgb[12] * rgb[17];
			}
			if (gE) {
				k = b;
				switch (tet) {
					case 0: // rgb[0] === rgb[1] === rgb[2]
						rgb[15] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[21]];
						break;
					case 1:
						rgb[15] = p[k+o[42]]-p[k+o[38]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[38]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[38]];
						break;
					case 2:
						rgb[15] = p[k+o[25]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[25]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[25]]-p[k+o[21]];
						break;
					case 3:
						rgb[15] = p[k+o[26]]-p[k+o[22]];
						k += mm;
						rgb[16] = p[k+o[26]]-p[k+o[22]];
						k += mm;
						rgb[17] = p[k+o[26]]-p[k+o[22]];
						break;
					case 4:
						rgb[15] = p[k+o[41]]-p[k+o[37]];
						k += mm;
						rgb[16] = p[k+o[41]]-p[k+o[37]];
						k += mm;
						rgb[17] = p[k+o[41]]-p[k+o[37]];
						break;
					case 5:
						rgb[15] = p[k+o[42]]-p[k+o[38]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[38]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[38]];
						break;
					case 6:
						rgb[15] = p[k+o[25]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[25]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[25]]-p[k+o[21]];
						break;
					default: // shouldn't be possible, but include fallback to trilinear interpolation
						rgb[15] = ((((p[k+o[25]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[26]]-p[k+o[22]])*rgb[0]))*(1-rgb[2]))+
								  ((((p[k+o[41]]-p[k+o[37]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[38]])*rgb[0]))*rgb[2]);
						k += mm;
						rgb[16] = ((((p[k+o[25]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[26]]-p[k+o[22]])*rgb[0]))*(1-rgb[2]))+
								  ((((p[k+o[41]]-p[k+o[37]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[38]])*rgb[0]))*rgb[2]);
						k += mm;
						rgb[17] = ((((p[k+o[25]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[26]]-p[k+o[22]])*rgb[0]))*(1-rgb[2]))+
								  ((((p[k+o[41]]-p[k+o[37]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[38]])*rgb[0]))*rgb[2]);
				}
				c[ j ] += rgb[13] * rgb[15];
				c[j+1] += rgb[13] * rgb[16];
				c[j+2] += rgb[13] * rgb[17];
			}
			if (bE) {
				k = b;
				switch (tet) {
					case 0: // rgb[0] === rgb[1] === rgb[2]
						rgb[15] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[21]];
						break;
					case 1:
						rgb[15] = p[k+o[38]]-p[k+o[22]];
						k += mm;
						rgb[16] = p[k+o[38]]-p[k+o[22]];
						k += mm;
						rgb[17] = p[k+o[38]]-p[k+o[22]];
						break;
					case 2:
						rgb[15] = p[k+o[42]]-p[k+o[26]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[26]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[26]];
						break;
					case 3:
						rgb[15] = p[k+o[42]]-p[k+o[26]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[26]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[26]];
						break;
					case 4:
						rgb[15] = p[k+o[37]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[37]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[37]]-p[k+o[21]];
						break;
					case 5:
						rgb[15] = p[k+o[37]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[37]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[37]]-p[k+o[21]];
						break;
					case 6:
						rgb[15] = p[k+o[41]]-p[k+o[25]];
						k += mm;
						rgb[16] = p[k+o[41]]-p[k+o[25]];
						k += mm;
						rgb[17] = p[k+o[41]]-p[k+o[25]];
						break;
					default: // shouldn't be possible, but include fallback to trilinear interpolation
						rgb[15] = ((((p[k+o[37]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[38]]-p[k+o[22]])*rgb[0]))*(1-rgb[1]))+
								  ((((p[k+o[41]]-p[k+o[25]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[26]])*rgb[0]))*rgb[1]);
						k += mm;
						rgb[16] = ((((p[k+o[37]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[38]]-p[k+o[22]])*rgb[0]))*(1-rgb[1]))+
								  ((((p[k+o[41]]-p[k+o[25]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[26]])*rgb[0]))*rgb[1]);
						k += mm;
						rgb[17] = ((((p[k+o[37]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[38]]-p[k+o[22]])*rgb[0]))*(1-rgb[1]))+
								  ((((p[k+o[41]]-p[k+o[25]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[26]])*rgb[0]))*rgb[1]);
				}
				c[ j ] += rgb[14] * rgb[15];	
				c[j+1] += rgb[14] * rgb[16];
				c[j+2] += rgb[14] * rgb[17];
			}
			E = false;
			rE = false;
			gE = false;
			bE = false;
		}
*/
	}
};
LUTVolume.prototype.RGBLin = function(buff) {
	var c = new Float64Array(buff);
	var p = this.mesh;
	var o = this.off;
	var rgb = this.rgb;
	var m = c.length;
	var mm = Math.round(this.mesh.length/3);
	var s = this.s;
	var nd = s + 2;
	var nd1 = nd + 1;
	var k,b;
	var R = this.R;
	var G = this.G;
	var B = this.B;
	var E = false;
	var rE = false;
	var gE = false;
	var bE = false;
	if (this.fS) {
		var fL = this.fL;
		var fLH = this.fLH;
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j +=3) {
		c[ j ] *= s;
		c[j+1] *= s;
		c[j+2] *= s;
		rgb[ 9] = Math.max(0,Math.min(s-1,Math.floor(c[ j ])));
		rgb[10] = Math.max(0,Math.min(s-1,Math.floor(c[j+1])));
		rgb[11] = Math.max(0,Math.min(s-1,Math.floor(c[j+2])));
		c[ j ] -= rgb[ 9];
		c[j+1] -= rgb[10];
		c[j+2] -= rgb[11];
		// clamp values between 0-1.0 for interpolation
		rgb[0] = Math.max(0,Math.min(1,c[ j ]));
		rgb[1] = Math.max(0,Math.min(1,c[j+1]));
		rgb[2] = Math.max(0,Math.min(1,c[j+2]));
		// note that extrapolation will be needed if values were clamped
		if (rgb[0] !== c[ j ]) {
			rE = true;
			E = true;
		}
		if (rgb[1] !== c[j+1]) {
			gE = true;
			E = true;
		}
		if (rgb[2] !== c[j+2]) {
			bE = true;
			E = true;
		}
		// Prep all the squares, cubes and cubics
		R[0] = 1-rgb[0];
		R[1] = rgb[0];
		G[0] = 1-rgb[1];
		G[1] = rgb[1];
		B[0] = 1-rgb[2];
		B[1] = rgb[2];
		// if any or all channels need extrapolation find out the scaling
		if (rE) {
			rgb[12] = c[ j ] - rgb[0];
		}
		if (gE) {
			rgb[13] = c[j+1] - rgb[1];
		}
		if (bE) {
			rgb[14] = c[j+2] - rgb[2];
		}
		// set value for first control point in the mesh - P[-1,-1,-1]
		b = (rgb[9]) + ((rgb[10] + (rgb[11]*nd1))*nd1);
		k = b;
		// multiply and add the cubics and the control points
		c[ j ]  = (((((R[0]*p[k+o[21]]) + (R[1]*p[k+o[22]]))*G[0]) + (((R[0]*p[k+o[25]]) + (R[1]*p[k+o[26]]))*G[1]))*B[0])+
				  (((((R[0]*p[k+o[37]]) + (R[1]*p[k+o[38]]))*G[0]) + (((R[0]*p[k+o[41]]) + (R[1]*p[k+o[42]]))*G[1]))*B[1]);
		k += mm;
		c[j+1]  = (((((R[0]*p[k+o[21]]) + (R[1]*p[k+o[22]]))*G[0]) + (((R[0]*p[k+o[25]]) + (R[1]*p[k+o[26]]))*G[1]))*B[0])+
				  (((((R[0]*p[k+o[37]]) + (R[1]*p[k+o[38]]))*G[0]) + (((R[0]*p[k+o[41]]) + (R[1]*p[k+o[42]]))*G[1]))*B[1]);
		k += mm;
		c[j+2]  = (((((R[0]*p[k+o[21]]) + (R[1]*p[k+o[22]]))*G[0]) + (((R[0]*p[k+o[25]]) + (R[1]*p[k+o[26]]))*G[1]))*B[0])+
				  (((((R[0]*p[k+o[37]]) + (R[1]*p[k+o[38]]))*G[0]) + (((R[0]*p[k+o[41]]) + (R[1]*p[k+o[42]]))*G[1]))*B[1]);
		// find slopes and perform extrapolation as needed
		if (E) {
			if (rE) {
				k = b;
				rgb[15] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				k += mm;
				rgb[16] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				k += mm;
				rgb[17] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				c[ j ] += rgb[12] * rgb[15];
				c[j+1] += rgb[12] * rgb[16];
				c[j+2] += rgb[12] * rgb[17];
			}
			if (gE) {
				k = b;
				rgb[15] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				k += mm;
				rgb[16] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				k += mm;
				rgb[17] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				c[ j ] += rgb[13] * rgb[15];
				c[j+1] += rgb[13] * rgb[16];
				c[j+2] += rgb[13] * rgb[17];
			}
			if (bE) {
				k = b;
				rgb[15] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				k += mm;
				rgb[16] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				k += mm;
				rgb[17] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				c[ j ] += rgb[14] * rgb[15];	
				c[j+1] += rgb[14] * rgb[16];
				c[j+2] += rgb[14] * rgb[17];
			}
			E = false;
			rE = false;
			gE = false;
			bE = false;
		}
	}
};
LUTVolume.prototype.J = function(rgbIn) {
	// calculate the Jacobian matrix at rgbIn
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var J = new Float64Array(9);
		var p = this.mesh;
		var o = this.off;
		var s = this.s;
		var rgb = this.rgb;
		var R = this.R;
		var G = this.G;
		var B = this.B;
		var nd = s + 2;
		var nd1 = nd + 1;
		var b,k;
		var fL = this.fL;
		var fLH = this.fLH;
		if (this.fS) {
			for (var j=0; j<m; j+=3) {
				c[0] = (c[0] - fL[0])/(fLH[0]);
				c[1] = (c[1] - fL[1])/(fLH[1]);
				c[2] = (c[2] - fL[2])/(fLH[2]);
			}
		}
		if (this.sin) {
			this.ins.FCub(c.buffer);
		}
		c[0] *= s;
		c[1] *= s;
		c[2] *= s;
		rgb[ 9] = Math.max(0,Math.min(s-1,Math.floor(c[ j ])));
		rgb[10] = Math.max(0,Math.min(s-1,Math.floor(c[j+1])));
		rgb[11] = Math.max(0,Math.min(s-1,Math.floor(c[j+2])));
		c[0] -= rgb[ 9];
		c[1] -= rgb[10];
		c[2] -= rgb[11];
		// clamp values between 0-1.0 for interpolation
		rgb[0] = Math.max(0,Math.min(1,c[0]));
		rgb[1] = Math.max(0,Math.min(1,c[1]));
		rgb[2] = Math.max(0,Math.min(1,c[2]));
		// Prep all the squares, cubes and cubics
		rgb[3] = rgb[0]*rgb[0];
		rgb[4] = rgb[1]*rgb[1];
		rgb[5] = rgb[2]*rgb[2];
		rgb[6] = rgb[3]*rgb[0];
		rgb[7] = rgb[4]*rgb[1];
		rgb[8] = rgb[5]*rgb[2];
		R[0] = (-0.5*rgb[6]) + rgb[3] - (0.5*rgb[0]);
		R[1] = (1.5*rgb[6]) - (2.5*rgb[3]) + 1;
		R[2] = (-1.5*rgb[6]) + (2*rgb[3]) + (0.5*rgb[0]);
		R[3] = (0.5*rgb[6]) - (0.5*rgb[3]);
		G[0] = (-0.5*rgb[7]) + rgb[4] - (0.5*rgb[1]);
		G[1] = (1.5*rgb[7]) - (2.5*rgb[4]) + 1;
		G[2] = (-1.5*rgb[7]) + (2*rgb[4]) + (0.5*rgb[1]);
		G[3] = (0.5*rgb[7]) - (0.5*rgb[4]);
		B[0] = (-0.5*rgb[8]) + rgb[5] - (0.5*rgb[2]);
		B[1] = (1.5*rgb[8]) - (2.5*rgb[5]) + 1;
		B[2] = (-1.5*rgb[8]) + (2*rgb[5]) + (0.5*rgb[2]);
		B[3] = (0.5*rgb[8]) - (0.5*rgb[5]);
		// set value for first control point in the mesh - P[-1,-1,-1]
		b = (rgb[9]) + ((rgb[10] + (rgb[11]*nd1))*nd1);
		// d/dR
		R[4] = (-1.5*rgb[3]) + (2*rgb[0]) - 0.5;
		R[5] = (4.5*rgb[3]) - (5*rgb[0]);
		R[6] = (-4.5*rgb[3]) + (4*rgb[0]) + 0.5;
		R[7] = (1.5*rgb[3] - rgb[0]);
		k = b;
		J[0] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
				 (((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
				 (((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
				 (((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
			   (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
				 (((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
				 (((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
				 (((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
			   (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
				 (((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
				 (((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
				 (((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
			   (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
				 (((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
				 (((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
				 (((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
		k += mm;
		J[3] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
				 (((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
				 (((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
				 (((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
			   (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
				 (((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
				 (((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
				 (((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
			   (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
				 (((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
				 (((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
				 (((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
			   (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
				 (((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
				 (((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
				 (((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
		k += mm;
		J[6] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
				 (((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
				 (((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
				 (((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
			   (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
				 (((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
				 (((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
				 (((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
			   (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
				 (((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
				 (((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
				 (((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
			   (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
				 (((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
				 (((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
				 (((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
		// d/dG
		G[4] = (-1.5*rgb[4]) + (2*rgb[1]) - 0.5;
		G[5] = (4.5*rgb[4]) - (5*rgb[1]);
		G[6] = (-4.5*rgb[4]) + (4*rgb[1]) + 0.5;
		G[7] = (1.5*rgb[4] - rgb[1]);
		k = b;
		J[1] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
		  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
		k += mm;
		J[4] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
		 		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
		k += mm;
		J[7] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
		  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
		// d/dB
		B[4] = (-1.5*rgb[5]) + (2*rgb[2]) - 0.5;
		B[5] = (4.5*rgb[5]) - (5*rgb[2]);
		B[6] = (-4.5*rgb[5]) + (4*rgb[2]) + 0.5;
		B[7] = (1.5*rgb[5] - rgb[2]);
		k = b;
		J[2] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
		  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
		k += mm;
		J[5] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
		  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
		k += mm;
		J[8] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
		  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
		// Scale to 0-1 range (from 0-s)
		J[0] *= s;
		J[1] *= s;
		J[2] *= s;
		J[3] *= s;
		J[4] *= s;
		J[5] *= s;
		J[6] *= s;
		J[7] *= s;
		J[8] *= s;
		if (this.sin) {
			var dRGB = this.ins.dRGB(rgbIn.buffer);
			J[0] *= dRGB[0];
			J[1] *= dRGB[1];
			J[2] *= dRGB[2];
			J[3] *= dRGB[0];
			J[4] *= dRGB[1];
			J[5] *= dRGB[2];
			J[6] *= dRGB[0];
			J[7] *= dRGB[1];
			J[8] *= dRGB[2];
		}
		if (this.fS) {
			J[0] /= fLH[0];
			J[1] /= fLH[1];
			J[2] /= fLH[2];
			J[3] /= fLH[0];
			J[4] /= fLH[1];
			J[5] /= fLH[2];
			J[6] /= fLH[0];
			J[7] /= fLH[1];
			J[8] /= fLH[2];
		}
		return J;
	} else {
		return false;
	}
};
LUTVolume.prototype.JInv = function(rgbIn) {
	var M = this.J(rgbIn);
	var det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
				(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
				(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	if (det === 0) {
		return false;
	}
	return new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
LUTVolume.prototype.getDetails = function() {
	var out = {
		title: this.title,
		format: this.format,
		dims: 3,
		s: this.d,
		min: new Float64Array([this.fL[0],this.fL[1],this.fL[2]]),
		max: new Float64Array([this.fH[0],this.fH[1],this.fH[2]]),
		C: this.getRGB(),
		meta: this.meta
	};
	return out;
};
LUTVolume.prototype.getL = function() {
	return this.L.getL();
};
LUTVolume.prototype.getRGB = function() {
	var d = this.d;
	var nd = d+2;
	var m = d*d*d;
	var nm = nd*nd*nd;
	var R = new Float64Array(m);
	var G = new Float64Array(m);
	var B = new Float64Array(m);
	var k,l;
	var p = this.mesh;
	for (var b=0; b<d; b++) {
		for (var g=0; g<d; g++) {
			for (var r=0; r<d; r++) {
				k = r + ((g + (b*d))*d);
				l = (r+1) + (((g+1) + ((b+1)*nd))*nd);
				R[k] = p[l];
				l += nm;
				G[k] = p[l];
				l += nm;
				B[k] = p[l];
			}
		}
	}
	return [R.buffer,G.buffer,B.buffer];
};
LUTVolume.prototype.getSize = function() {
	return this.d;
};
LUTVolume.prototype.is1D = function() {
	return false;
};
LUTVolume.prototype.is3D = function() {
	return true;
};
LUTVolume.prototype.getTitle = function() {
	return this.title;
};
LUTVolume.prototype.getMetadata = function() {
	return this.meta;
};
LUTVolume.prototype.isClamped = function() {
	if (typeof this.clamped === 'undefined') {
		var mm = this.minMax();
		var min = Math.min(mm[0],mm[1],mm[2]);
		var max = Math.max(mm[3],mm[4],mm[5]);
		if ((min === 0 && max <= 1) || (min >= 0 && max === 1)) {
			this.clamped = true;
		} else {
			this.clamped = false;
		}
	}
	return this.clamped;
};
LUTVolume.prototype.deClamp = function() {
	if (this.isClamped()) {
		this.deClamp1D();
		this.deClamp3D();
	}
};
//
LUTVolume.prototype.getColourSpace = function() {
	var d = this.d;
	var fL = this.fL;
	var fH = this.fH;
	var fLH = this.fLH;
	var out = {
		title: this.title + 'CS',
		format: this.format,
		fLR: fL[0],
		fLG: fL[1],
		fLB: fL[2],
		fHR: fH[0],
		fHG: fH[1],
		fHB: fH[2]
	};
	var reverse = new LUTRSpline({ buff:this.L.getL(), fH:fH[3], fL:fL[3] });
	var base = this.getRGB();
	reverse.R(base[0]);
	reverse.R(base[1]);
	reverse.R(base[2]);
	out.buffR = base[0];
	out.buffG = base[1];
	out.buffB = base[2];
	return new LUTVolume(out);
};
LUTVolume.prototype.deClamp1D = function() {
	var m = this.d;
	var r = new Float64Array(m);
	var g = new Float64Array(m);
	var b = new Float64Array(m);
	var rL = 0;
	var gL = 0;
	var bL = 0;
	var rH = m-1;
	var gH = m-1;
	var bH = m-1;
	var nd = this.d + 2;
	var nm = nd*nd*nd;
	var k;
	var M = this.mesh;
	var rC = false;
	var gC = false;
	var bC = false;
	var fL = Math.min(this.fL[0],this.fL[1],this.fL[2]);
	var fH = Math.max(this.fH[0],this.fH[1],this.fH[2]);
	var fLH= fH-fL;
	// Fill three arrays with values from the gray diagonal of the mesh, and find the index where the values are not 0 or 1
	for (var j=0; j<m; j++) {
		k = (j+1) + (((j+1) + ((j+1)*nd))*nd);
		r[j] = M[k];
		k += nm;
		g[j] = M[k];
		k += nm;
		b[j] = M[k];
		if (j>0) {
//			if (r[j] === 0 && r[j-1] === 0) {
			if (r[j] === 0) {
				rC = true;
				rL = j+1;
			}
//			if (g[j] === 0 && g[j-1] === 0) {
			if (g[j] === 0) {
				gC = true;
				gL = j+1;
			}
//			if (b[j] === 0 && b[j-1] === 0) {
			if (b[j] === 0) {
				bC = true;
				bL = j+1;
			}
		}
	}
	for (var j=m-2; j>=0; j--) {
//		if (r[j] === 1 && (r[j+1] === 1 || rC)) {
		if (r[j] === 1) {
			rC = true;
			rH = j-1;
		}
//		if (g[j] === 1 && (g[j+1] === 1 || gC)) {
		if (g[j] === 1) {
			gC = true;
			gH = j-1;
		}
//		if (b[j] === 1 && (b[j+1] === 1 || bC)) {
		if (b[j] === 1) {
			bC = true;
			bH = j-1;
		}
	}
	// if the 0 index is greater than 0 or the 1 index less than m-1, make a spline to fill in the gaps
	if (rC || gC || bC) {
		var low;
		if (rL > rH) {
			low = rH;
			rH = Math.min(rL-2,m-1);
			rL = Math.max(low+2,0);
		}
		if (gL > gH) {
			low = gH;
			gH = Math.min(gL-2,m-1);
			gL = Math.max(low+2,0);
		}
		if (bL > bH) {
			low = bH;
			bH = Math.min(bL-2,m-1);
			bL = Math.max(low+2,0);
		}
		var rS,gS,bS;
		if (rC) {
			rS = new LUTQSpline(new Float64Array(r.subarray(rL,rH-rL+1)).buffer);
		} else {
			rS = new LUTQSpline(r.buffer);
		}
		if (gC) {
			gS = new LUTQSpline(new Float64Array(g.subarray(gL,gH-gL+1)).buffer);
		} else {
			gS = new LUTQSpline(g.buffer);
		}
		if (bC) {
			bS = new LUTQSpline(new Float64Array(b.subarray(bL,bH-bL+1)).buffer);
		} else {
			bS = new LUTQSpline(b.buffer);
		}
		// Now built an array to replace the 'L' spline from this.buildL()
		var m2 = m;
		if (m < 65) {
			m2 = 65;
		}
		var FD = new Float64Array(m2);
		var rI = new Float64Array(m2);
		for (var j=0; j<m2; j++) { // create rgb array of input values
			rI[j] = (j*(fLH)/(m2-1))+fL;
		}
		var gI = new Float64Array(rI);
		var bI = new Float64Array(rI);
		// apply input scaling as required
		if (this.fS) {
			for (var j=0; j<m2; j++) {
				rI[j] = (rI[j] - this.fL[0])/(this.fLH[0]);
				gI[j] = (gI[j] - this.fL[1])/(this.fLH[1]);
				bI[j] = (bI[j] - this.fL[2])/(this.fLH[2]);
			}
		}
		if (this.sin) {
			this.ins.FCub(rI.buffer);
			this.ins.FCub(gI.buffer);
			this.ins.FCub(bI.buffer);
		}
		// scale for any clamped splines
		for (var j=0; j<m2; j++) {
			rI[j] = ((rI[j]*(m-1)) - rL)/(rH-rL);
			gI[j] = ((gI[j]*(m-1)) - gL)/(gH-gL);
			bI[j] = ((bI[j]*(m-1)) - bL)/(bH-bL);
		}
		// pass through the splines
		rS.FCub(rI.buffer);
		gS.FCub(gI.buffer);
		bS.FCub(bI.buffer);
		// bring together the results to make the L array
		for (var j=0; j<m2; j++) {
			rI[j] = (rI[j]*this.Y[0]) + (gI[j]*this.Y[1]) + (bI[j]*this.Y[2]);
		}
		// replace the 'L' spline - make it reversible as that will be needed for 3D declamping
		this.L = new LUTSpline({ buff:rI.buffer, fH:fH, fL:fL });
		this.clamped = false;
		return true;
	} else {
		return false;
	}
};
LUTVolume.prototype.deClamp3D = function() {
	var d = this.d;
	var d3 = 3*d;
	var nd = d+2;
	var nd2 = nd * nd;
	var nm = nd*nd*nd;
	var sG = nd2 * nd;
	var sB = 2 * sG;
	var M = this.mesh;
	var r = new Float64Array(d);
	var g = new Float64Array(d);
	var b = new Float64Array(d);
	var l,k;
	var rC,gC,bC;
	var rL,gL,bL;
	var rH,gH,bH;
	var low;
	var minMax = this.minMax();
	var lo = Math.min(0, Math.min(minMax[0],minMax[1],minMax[2])); // 0, or the lowest value in the mesh, whichever the lesser
	var hi = Math.max(1, Math.max(minMax[3],minMax[4],minMax[5])); // 1.0, or the highest value in the mesh, whichever the greater
	var min = lo - 0.1; // 10% below the 'lo' value
	var max = hi + 0.175; // 17.5% above 'hi' value
	var limits = new Float64Array([lo,hi,min,max]);
	// First sort out inner splines
	for (var x=0; x<d; x++) {
		for (var y=0; y<d; y++) {
			rL = 0;
			gL = 0;
			bL = 0;
			rH = d-1;
			gH = d-1;
			bH = d-1;
			rC = false;
			gC = false;
			bC = false;
			for (var z=0; z<d; z++) {
				l = (z+1) + (((y+1) + ((x+1)*nd))*nd);
				r[z] = M[l];
				l = (y+1) + (((z+1) + ((x+1)*nd))*nd) + nm;
				g[z] = M[l];
				l = (y+1) + (((x+1) + ((z+1)*nd))*nd) + (2*nm);
				b[z] = M[l];
				if (z>0) {
//					if (r[z] === 0 && r[z-1] === 0) {
					if (r[z] === 0) {
						rC = true;
						rL = z+1;
					}
//					if (g[z] === 0 && g[z-1] === 0) {
					if (g[z] === 0) {
						gC = true;
						gL = z+1;
					}
//					if (b[z] === 0 && b[z-1] === 0) {
					if (b[z] === 0) {
						bC = true;
						bL = z+1;
					}
				}
			}
			for (var z=d-2; z>=0; z--) {
//				if (r[z] === 1 && (r[z+1] === 1 || rC)) {
				if (r[z] === 1) {
					rC = true;
					rH = z-1;
				}
//				if (g[z] === 1 && (g[z+1] === 1 || gC)) {
				if (g[z] === 1) {
					gC = true;
					gH = z-1;
				}
//				if (b[z] === 1 && (b[z+1] === 1 || bC)) {
				if (b[z] === 1) {
					bC = true;
					bH = z-1;
				}
			}
			if (rC) {
				if (rL > rH) {
					low = rH;
					rH = Math.min(rL-2,m-1);
					rL = Math.max(low+2,0);
				}
				this.extrap(r,rL,rH,limits);
				for (var z=0; z<d; z++) {
					if (z === rL) {
						z = rH;
					}
					l = (z+1) + (((y+1) + ((x+1)*nd))*nd);
					M[l] = r[z];
				}
			}
			if (gC) {
				if (gL > gH) {
					low = gH;
					gH = Math.min(gL-2,m-1);
					gL = Math.max(low+2,0);
				}
				this.extrap(g,gL,gH,limits);
				for (var z=0; z<d; z++) {
					if (z === gL) {
						z = gH;
					}
					l = (y+1) + (((z+1) + ((x+1)*nd))*nd) + nm;
					M[l] = g[z];
				}
			}
			if (bC) {
				if (bL > bH) {
					low = bH;
					bH = Math.min(bL-2,m-1);
					bL = Math.max(low+2,0);
				}
				this.extrap(b,bL,bH,limits);
				for (var z=0; z<d; z++) {
					if (z === bL) {
						z = bH;
					}
					l = (y+1) + (((x+1) + ((z+1)*nd))*nd) + (2*nm);
					M[l] = b[z];
				}
			}
		}
	}
	// Now fill in the edges and corners as with this.fillEdges()
	d--;
	for (var x=1; x<(d); x++) {
		for (var y=0; y<d; y++) {
			this.n3b( x, y, 0);
			this.n3b( x, y, d);
			this.n3b( x, 0, y);
			this.n3b( x, d, y);
			this.n3b( 0, x, y);
			this.n3b( d, x, y);
		}
		this.n3b( x, 0, 0);
		this.n3b( x, 0, d);
		this.n3b( x, d, 0);
		this.n3b( x, d, d);
		this.n3b( 0, x, 0);
		this.n3b( 0, x, d);
		this.n3b( d, x, 0);
		this.n3b( d, x, d);
		this.n3b( 0, 0, x);
		this.n3b( 0, d, x);
		this.n3b( d, 0, x);
		this.n3b( d, d, x);
	}
	this.n3b( 0, 0, 0);
	this.n3b( 0, 0, d);
	this.n3b( 0, d, 0);
	this.n3b( 0, d, d);
	this.n3b( d, 0, 0);
	this.n3b( d, 0, d);
	this.n3b( d, d, 0);
	this.n3b( d, d, d);
	// Repopulate the outer edges of the mesh
	this.fillEdges();
	this.clamped = false;
};
LUTVolume.prototype.extrap = function(c,L,H,limits) {
	var m = c.length;
	var dcLo,dcHi;
	if (H-L > 2) { // more than four points
		dcLo = (0.1*c[L+3]) - (0.8*c[L+2]) + (2.3*c[L+1]) - (1.6*c[L]);
		dcHi = (-0.1*c[H-3]) + (0.8*c[H-2]) - (2.3*c[H-1]) + (1.6*c[H]);
	} else if (H-L > 1) { // three points
		dcLo = 1;
		dcHi = 1;
	} else { // two points
		dcLo = c[L+1] - c[L];
		dcHi = c[H] - c[H-1];
	}
	if (L > 0) {
		for (var j=0; j<L; j++) {
			c[j] = c[L] + ((j-L)*dcLo);
		}
	}
	if (H < m-1) {
		for (var j=H+1; j<m; j++) {
			c[j] = c[H] + ((j-H)*dcHi);
		}
	}
	if (typeof limits !== 'undefined') {
		var lo = limits[0];
		var hi = limits[1];
		var min = limits[2];
		var max = limits[3];
		var numLo = Math.pow(min-lo,2);
		var denLo = min-lo;
		var numHi = Math.pow(max-hi,2);
		var denHi = max-hi;
		for (var j=0; j<m; j++) {
			if (j === L) {
				j = H+1;
			}
			if (c[j] < lo) {
				c[j] = min - (numLo/((dcLo*(c[j]-lo))+denLo));
			} else if (c[j] > hi) {
				c[j] = max - (numHi/((dcHi*(c[j]-hi))+denHi));
			}
		}
	}
};
LUTVolume.prototype.fillEdges = function() {
	var d = this.d;
	// fill in the gaps in the new mesh
	for (var x=0; x<d; x++) {
		for (var y=0; y<d; y++) {
			this.n3( x, y,-1);
			this.n3( x, y, d);
			this.n3( x,-1, y);
			this.n3( x, d, y);
			this.n3(-1, x, y);
			this.n3( d, x, y);
		}
		this.n3( x,-1,-1);
		this.n3( x,-1, d);
		this.n3( x, d,-1);
		this.n3( x, d, d);
		this.n3(-1, x,-1);
		this.n3(-1, x, d);
		this.n3( d, x,-1);
		this.n3( d, x, d);
		this.n3(-1,-1, x);
		this.n3(-1, d, x);
		this.n3( d,-1, x);
		this.n3( d, d, x);
	}
	this.n3(-1,-1,-1);
	this.n3(-1,-1, d);
	this.n3(-1, d,-1);
	this.n3(-1, d, d);
	this.n3( d,-1,-1);
	this.n3( d,-1, d);
	this.n3( d, d,-1);
	this.n3( d, d, d);
};
LUTVolume.prototype.setP = function(rM,gM,bM,rgb) {
	// setP is used to change an individual mesh point. The inputs rM, gM, bM are zero-indexed coordinates on the base mesh
	// rgb is a Float64Array of the r, g and b values to be set at the specified mesh point
	// setP returns a Float64Array of the rgb value before changing
	var M = this.mesh;
	var d = this.d-1;
	var s = d-4;
	var nd = this.nd;
	var nd2 = nd*nd;
	var sG = nd2*nd;
	var sB = 2 * sG;
	var k = (rM + 1) + ((gM + 1)*nd) + ((bM + 1)*nd2);
	var o = new Float64Array([M[ k ], M[k+sG], M[k+sB]]);
	M[ k ] = rgb[0];
	M[k+sG] = rgb[1];
	M[k+sB] = rgb[2];
	// recalculate any edges, faces or corners in the extended mesh affected by the value change
	if (rM < 4) {
		// faces
		this.n3(-1,gM,bM);
		// edges
		if (gM ===   rM) { this.n3(-1,-1,bM); }
		if (gM === s-rM) { this.n3(-1, d,bM); }
		if (bM ===   rM) { this.n3(-1,gM,-1); }
		if (bM === s-rM) { this.n3(-1,gM, d); }
		// corners
		if (gM ===   rM && bM ===   rM) { this.n3(-1,-1,-1); }
		if (gM === s-rM && bM ===   rM) { this.n3(-1, d,-1); }
		if (gM === s-rM && bM === s-rM) { this.n3(-1, d, d); }
		if (gM ===   rM && bM === s-rM) { this.n3(-1,-1, d); }
	}
	if (rM > s) {
		// faces
		this.n3( d,gM,bM);
		// edges
		if (gM ===   rM) { this.n3( d, d,bM); }
		if (gM === rM-s) { this.n3( d,-1,bM); }
		if (bM ===   rM) { this.n3( d,gM, d); }
		if (bM === rM-s) { this.n3( d,gM,-1); }
		// corners
		if (gM ===   rM && bM ===   rM) { this.n3( d, d, d); }
		if (gM === rM-s && bM ===   rM) { this.n3( d,-1, d); }
		if (gM === rM-s && bM === rM-s) { this.n3( d,-1,-1); }
		if (gM ===   rM && bM === rM-s) { this.n3( d, d,-1); }
	}
	if (gM < 4) {
		// faces
		this.n3(rM,-1,bM);
		// edges
		if (bM ===   gM) { this.n3(rM,-1,-1); }
		if (bM === s-gM) { this.n3(rM,-1, d); }
	}
	if (gM > s) {
		// faces
		this.n3(rM, d,bM);
		// edges
		if (bM ===   gM) { this.n3(rM, d,-1); }
		if (bM === gM-s) { this.n3(rM, d, d); }
	}
	if (bM < 4) { this.n3(rM,gM,-1); }
	if (bM > s) { this.n3(rM,gM, d); }
	return o;
};
LUTVolume.prototype.getP = function(rM,gM,bM) {
	var M = this.mesh;
	var nd = this.nd;
	var nd2 = nd*nd;
	var sG = nd2*nd;
	var sB = 2 * sG;
	var k = (rM + 1) + ((gM + 1)*nd) + ((bM + 1)*nd2);
	return new Float64Array([M[ k ],M[k+sG],M[k+sB]]);
};
LUTVolume.prototype.n3 = function(rM,gM,bM,mono) {
	// 3D extrapolation - calculates all colour channels at once
	// rM, gM and bM are mesh point coordinates relative to the base mesh, not the extended, precalculated one
	// ie -1 means the bottom edge of the extended mesh, this.d the top edge
	var rD,gD,bD;
	var d = this.d - 1;
	var pR = this.pR;
	var pG = this.pG;
	var pB = this.pB;
	var o,m;
	// Get the array position on the extended mesh that we are going to fill
	var nd = this.nd;
	var nd2 = nd*nd
	var k = (rM+1) + ((gM + 1)*nd) + ((bM + 1)*nd2);
	// Establish which way the points need to go, and from what base
	if (rM < 0) {
		rD = 1;
	} else if (rM > d) {
		rD = -1;
	} else {
		rD = 0;
	}
	if (gM < 0) {
		gD = 1;
	} else if (gM > d) {
		gD = -1;
	} else {
		gD = 0;
	}
	if (bM < 0) {
		bD = 1;
	} else if (bM > d) {
		bD = -1;
	} else {
		bD = 0;
	}
	// Fill in the points to be extrapolated
	var M = this.mesh;
	var sG = nd2*nd;
	var sB = 2 * sG;
	var l = k + rD + (gD*nd) + (bD*nd2);
	pR[3] = M[l];
	pG[3] = M[l + sG];
	pB[3] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[2] = M[l];
	pG[2] = M[l + sG];
	pB[2] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[1] = M[l];
	pG[1] = M[l + sG];
	pB[1] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[0] = M[l];
	pG[0] = M[l + sG];
	pB[0] = M[l + sB];
	// Now calculate the values
	// Red
	m = 0;
	if (pR[3] === pR[1]) {
		M[k] = pR[2];
//	} else if (typeof mono !== 'undefined') {
//		m = -mono*rD;
	} else if (pR[3] > pR[1]) {
		m = 1;
	} else {
		m = -1;
	}

	if (m !== 0) {
		o = (-0.4*pR[0]) + (2.2*pR[1]) - (4.2*pR[2]) + (3.4*pR[3]);
		if ((o-pR[2])*m <= 0) { // make sure that the slope at y(1) doesn't change sign
			o = pR[1] - (3*pR[2]) + (3*pR[3]);
			if ((o-pR[2])*m <= 0) { // if it is still swapping signs, use a slope of 0, ie y(2) = y(1)
				o = pR[2]; // this allows for a completely flat extrapolation, ie slope = 0 at y(1)
			}
		}
		M[k] = o;
	}
	// Green
	m = 0;
	if (pG[3] === pG[1]) {
		M[k + sG] = pG[2];
//	} else if (typeof mono !== 'undefined') {
//		m = -mono*gD;
	} else if (pG[3] > pG[1]) {
		m = 1;
	} else {
		m = -1;
	}
	if (m !== 0) {
		o = (-0.4*pG[0]) + (2.2*pG[1]) - (4.2*pG[2]) + (3.4*pG[3]);
		if ((o-pG[2])*m <= 0) { // make sure that the slope at y(1) doesn't change sign
			o = pG[1] - (3*pG[2]) + (3*pG[3]);
			if ((o-pG[2])*m <= 0) { // if it is still swapping signs, use a slope of 0, ie y(2) = y(1)
				o = pG[2]; // this allows for a completely flat extrapolation, ie slope = 0 at y(1)
			}
		}
		M[k + sG] = o;
	}
	// Blue
	m = 0;
	if (pB[3] === pB[1]) {
		M[k + sB] = pB[2];
//	} else if (typeof mono !== 'undefined') {
//		m = -mono*bD;
	} else if (pB[3] > pB[1]) {
		m = 1;
	} else {
		m = -1;
	}
	if (m !== 0) {
		o = (-0.4*pB[0]) + (2.2*pB[1]) - (4.2*pB[2]) + (3.4*pB[3]);
		if ((o-pB[2])*m <= 0) { // make sure that the slope at y(1) doesn't change sign
			o = pB[1] - (3*pB[2]) + (3*pB[3]);
			if ((o-pB[2])*m <= 0) { // if it is still swapping signs, use a slope of 0, ie y(2) = y(1)
				o = pB[2]; // this allows for a completely flat extrapolation, ie slope = 0 at y(1)
			}
		}
		M[k + sB] = o;
	}
};
LUTVolume.prototype.n3b = function(rM,gM,bM) {
	// 3D extrapolation - calculates all colour channels at once
	// rM, gM and bM are mesh point coordinates relative to the base mesh, not the extended, precalculated one
	// this differs from the basic n3 as it is for filling in the edges, corners and faces of the base mesh
	// after a declamp, to allow for interaction of colour channels, ie 0 is to bottom, this.d-1 the top.
	var rD,gD,bD;
	var d = this.d - 1;
	var pR = this.pR;
	var pG = this.pG;
	var pB = this.pB;
	var o,m;
	// Get the array position on the extended mesh that we are going to fill
	var nd = this.nd;
	var nd2 = nd*nd
	var k = (rM+1) + ((gM + 1)*nd) + ((bM + 1)*nd2);
	// Establish which way the points need to go, and from what base
	if (rM <= 0) {
		rD = 1;
	} else if (rM >= d) {
		rD = -1;
	} else {
		rD = 0;
	}
	if (gM <= 0) {
		gD = 1;
	} else if (gM >= d) {
		gD = -1;
	} else {
		gD = 0;
	}
	if (bM <= 0) {
		bD = 1;
	} else if (bM >= d) {
		bD = -1;
	} else {
		bD = 0;
	}
	// Fill in the points to be extrapolated
	var M = this.mesh;
	var sG = nd2*nd;
	var sB = 2 * sG;
	var l = k + rD + (gD*nd) + (bD*nd2);
	pR[3] = M[l];
	pG[3] = M[l + sG];
	pB[3] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[2] = M[l];
	pG[2] = M[l + sG];
	pB[2] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[1] = M[l];
	pG[1] = M[l + sG];
	pB[1] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[0] = M[l];
	pG[0] = M[l + sG];
	pB[0] = M[l + sB];
	// Now calculate the values
	M[ k  ] = - (0.1*pR[0]) + (0.8*pR[1]) - (2.3*pR[2]) + (2.6*pR[3]);
	M[k+sG] = - (0.1*pG[0]) + (0.8*pG[1]) - (2.3*pG[2]) + (2.6*pG[3]);
	M[k+sB] = - (0.1*pB[0]) + (0.8*pB[1]) - (2.3*pB[2]) + (2.6*pB[3]);
};
LUTVolume.prototype.compare = function(tgtBuff,tstBuff,method) {
	// returns the RMS differences in the red channels between a target dataset (tgt) and a test dataset (tst) which 'compare' passes through the lut
	// method sets the interpolation method used on the test set, currently trilinear (1, 'lin' or 'linear') or tricubic (anything else or the default if 'method' is not present.
	var tgt = new Float64Array(tgtBuff.slice(0));
	var tst = new Float64Array(tstBuff.slice(0));
	var m = tgt.length;
	if (m !== tst.length) {
		return false;
	}
	if (typeof method !== 'undefined') {
		method = method.toString().toLowerCase();
		if (method === '1' || method === 'tet') {
			this.RGBTet(tst.buffer);
		} else if (method === '2' || method === 'lin') {
			this.RGBLin(tst.buffer);
		} else {
			this.RGBCub(tst.buffer);
		}
	} else {
		this.RGBCub(tst.buffer);
	} 
	var e = new Float64Array(3);
	for (var j=0; j<m; j += 3) {
		e[0]  += Math.pow(tst[ j ] - tgt[ j ],2);
		e[1]  += Math.pow(tst[j+1] - tgt[j+1],2);
		e[2]  += Math.pow(tst[j+2] - tgt[j+2],2);
	}
	e[0] = Math.pow(e[0]*3/m,0.5);
	e[1] = Math.pow(e[1]*3/m,0.5);
	e[2] = Math.pow(e[2]*3/m,0.5);
	return e;
};
LUTVolume.prototype.NR3D = function(tgt,tolerence,maxIterations,seed) { // Multivariate (3D) Newton-Raphson
	if (tgt.length === 3) {
		var tol,m,x;
		if (typeof tolerence === 'number') { // tolerence for what is considered close enough
			tol = tolerence;
		} else {
			tol = 0.00000001;
		}
		tol *= tol; // saves putting a square root into the convergence test
		if (typeof maxItrss === 'number') { // maximum number of iterations before giving up (ie poor convergence)
			m = maxItrs;
		} else {
			m = 50;
		}
		if (typeof seed !== 'undefined' && seed.length === 3) { // initial 'seed' value - if none given use the target
			x = new Float64Array([seed[0],seed[1],seed[2]],0);
		} else {
			x = new Float64Array([tgt[0],tgt[1],tgt[2]],0);
		}
		var f,Jinv,d;
		for (var j=0; j<m; j++) {
			f = this.rgbCub(x);
			JInv = this.JInv(x);
			if (JInv) {
				// Newton-Raphson is a root (0) finder, so subtract the target values
				f[0] -= tgt[0];
				f[1] -= tgt[1];
				f[2] -= tgt[2];
				// Test for convergence
				x[3] = (f[0]*f[0]) + (f[1]*f[1]) + (f[2]*f[2]);
				if (x[3] < tol) {
					x[3] = 0;
					return x;
				} else if (j === m-1) { // last pass - it's not converging
					x[3] = Math.pow(x[3],0.5); // distance from target 
					return x;
				} else {
					x[0] -= (Jinv[0]*f[0]) + (JInv[1]*f[1]) + (JInv[2]*f[2]);
					x[1] -= (Jinv[3]*f[0]) + (JInv[4]*f[1]) + (JInv[5]*f[2]);
					x[2] -= (Jinv[6]*f[0]) + (JInv[7]*f[1]) + (JInv[8]*f[2]);
				}
			} else {
				return false;
			}
		}
	} else {
		return false
	}
};
LUTVolume.prototype.minMax = function() {
	var p = this.mesh;
	var x = new Float64Array([
		 9999, 9999, 9999,	// Absolute min values
		-9999,-9999,-9999	// Absolute max values
	]);
	var rgb = new Float64Array(3);
	var m = this.d;
	var nd = this.d+2;
	var nm = nd*nd*nd;
	var l;
	// First find the minimum and maximum values in the mesh, independent of each other
	for (var b=0; b<m; b++) {
		for (var g=0; g<m; g++) {
			for (var r=0; r<m; r++) {
				l = (r+1) + (((g+1) + ((b+1)*nd))*nd);
				if (p[l] < x[0]) {
					x[0] = p[l];
				} else if (p[l] > x[3]) {
					x[3] = p[l];
				}
				l += nm;
				if (p[l] < x[1]) {
					x[1] = p[l];
				} else if (p[l] > x[4]) {
					x[4] = p[l];
				}
				l += nm;
				if (p[l] < x[2]) {
					x[2] = p[l];
				} else if (p[l] > x[5]) {
					x[5] = p[l];
				}
			}
		}
	}
	return x;
};
LUTVolume.prototype.getLimits = function(minMax) {
	var p = this.mesh;
	var x;
	if (typeof minMax !== 'undefined') {
		x = minMax;
	} else {
		x = this.minMax();
	}
	var o = new Float64Array([
		 9999, 9999, 9999,	// Black
		-9999, 9999, 9999,	// Red
		-9999,-9999, 9999,	// Yellow
		 9999,-9999, 9999,	// Green
		 9999,-9999,-9999,	// Cyan
		 9999, 9999,-9999,	// Blue
		-9999, 9999,-9999,	// Magenta
		-9999,-9999,-9999	// White
	]);
	var i = new Float64Array(24);
	var d = new Float64Array([
		9999,9999,9999,9999,9999,9999,9999,9999
	]);
	var rgb = new Float64Array(3);
	var m = this.d;
	var nd = this.d+2;
	var nm = nd*nd*nd;
	var s = m-1;
	var D;
	var l;
	// Now go back through the mesh, comparing distances from the absolute corners
	for (var b=0; b<m; b++) {
		for (var g=0; g<m; g++) {
			for (var r=0; r<m; r++) {
				l = (r+1) + (((g+1) + ((b+1)*nd))*nd);
				rgb[0] = p[l];
				l += nm;
				rgb[1] = p[l];
				l += nm;
				rgb[2] = p[l];
				D = Math.pow(rgb[0]-x[0],2)+Math.pow(rgb[1]-x[1],2)+Math.pow(rgb[2]-x[2],2);	// Black
				if (D < d[0]) {
					o[ 0] = rgb[0];
					o[ 1] = rgb[1];
					o[ 2] = rgb[2];
					i[ 0] = r;
					i[ 1] = g;
					i[ 2] = b;
					d[0] = D;
				}
				D = Math.pow(rgb[0]-x[3],2)+Math.pow(rgb[1]-x[1],2)+Math.pow(rgb[2]-x[2],2);	// Red
				if (D < d[1]) {
					o[ 3] = rgb[0];
					o[ 4] = rgb[1];
					o[ 5] = rgb[2];
					i[ 3] = r;
					i[ 4] = g;
					i[ 5] = b;
					d[1] = D;
				}
				D = Math.pow(rgb[0]-x[3],2)+Math.pow(rgb[1]-x[4],2)+Math.pow(rgb[2]-x[2],2);	// Yellow
				if (D < d[2]) {
					o[ 6] = rgb[0];
					o[ 7] = rgb[1];
					o[ 8] = rgb[2];
					i[ 6] = r;
					i[ 7] = g;
					i[ 8] = b;
					d[2] = D;
				}
				D = Math.pow(rgb[0]-x[0],2)+Math.pow(rgb[1]-x[4],2)+Math.pow(rgb[2]-x[2],2);	// Green
				if (D < d[3]) {
					o[ 9] = rgb[0];
					o[10] = rgb[1];
					o[11] = rgb[2];
					i[ 9] = r;
					i[10] = g;
					i[11] = b;
					d[3] = D;
				}
				D = Math.pow(rgb[0]-x[0],2)+Math.pow(rgb[1]-x[4],2)+Math.pow(rgb[2]-x[5],2);	// Cyan
				if (D < d[4]) {
					o[12] = rgb[0];
					o[13] = rgb[1];
					o[14] = rgb[2];
					i[12] = r;
					i[13] = g;
					i[14] = b;
					d[4] = D;
				}
				D = Math.pow(rgb[0]-x[0],2)+Math.pow(rgb[1]-x[1],2)+Math.pow(rgb[2]-x[5],2);	// Blue
				if (D < d[5]) {
					o[15] = rgb[0];
					o[16] = rgb[1];
					o[17] = rgb[2];
					i[15] = r;
					i[16] = g;
					i[17] = b;
					d[5] = D;
				}
				D = Math.pow(rgb[0]-x[3],2)+Math.pow(rgb[1]-x[1],2)+Math.pow(rgb[2]-x[5],2);	// Magenta
				if (D < d[6]) {
					o[18] = rgb[0];
					o[19] = rgb[1];
					o[20] = rgb[2];
					i[18] = r;
					i[19] = g;
					i[20] = b;
					d[6] = D;
				}
				D = Math.pow(rgb[0]-x[3],2)+Math.pow(rgb[1]-x[4],2)+Math.pow(rgb[2]-x[5],2);	// White
				if (D < d[7]) {
					o[21] = rgb[0];
					o[22] = rgb[1];
					o[23] = rgb[2];
					i[21] = r;
					i[22] = g;
					i[23] = b;
					d[7] = D;
				}
			}
		}
	}
	for (var j=0; j<24; j++) {
		i[j] /= s
	}
	if (this.sin) {
		var rev = new LUTRSpline({
			buff: this.ins.getL()
		});
		rev.R(i.buffer);
	}
	if (this.fS) {
		var fL = this.fL;
		var fLH = this.fLH;
		for (var j=0; j<24; j += 3) {
			i[ j ] = (i[ j ]*fLH[0]) + fL[0];
			i[j+1] = (i[j+1]*fLH[1]) + fL[1];
			i[j+2] = (i[j+2]*fLH[2]) + fL[2];
		}
	}
	return {minMax:x, i:i, o:o};
};
// Stringify for inline Web Workers
function getLUTString() {
	var out = "";
	// LUTs
	out += LUTs.toString() + "\n";
	for (var j in LUTs.prototype) {
		out += 'LUTs.prototype.' + j + '=' + LUTs.prototype[j].toString() + "\n";
	}
	// LUTSpline
	out += LUTSpline.toString() + "\n";
	for (var j in LUTSpline.prototype) {
		out += 'LUTSpline.prototype.' + j + '=' + LUTSpline.prototype[j].toString() + "\n";
	}
	// LUTRGBSpline
	out += LUTRGBSpline.toString() + "\n";
	for (var j in LUTRGBSpline.prototype) {
		out += 'LUTRGBSpline.prototype.' + j + '=' + LUTRGBSpline.prototype[j].toString() + "\n";
	}
	// LUTRSpline
	out += LUTRSpline.toString() + "\n";
	for (var j in LUTRSpline.prototype) {
		out += 'LUTRSpline.prototype.' + j + '=' + LUTRSpline.prototype[j].toString() + "\n";
	}
	// LUTQSpline
	out += LUTQSpline.toString() + "\n";
	for (var j in LUTQSpline.prototype) {
		out += 'LUTQSpline.prototype.' + j + '=' + LUTQSpline.prototype[j].toString() + "\n";
	}
	// LUTVolume
	out += LUTVolume.toString() + "\n";
	for (var j in LUTVolume.prototype) {
		out += 'LUTVolume.prototype.' + j + '=' + LUTVolume.prototype[j].toString() + "\n";
	}
	return out;
}
var workerLUTString = getLUTString();
/* ring.js
* LUT handling object for the LUTCalc Web App.
* 31st December 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function Ring() {
	this.title = '';
	this.s = 1024; // Dimension - eg 1024 or 4096 for 1D, 17, 33 or 65 for 3D
	this.r = 1; // increase in output value for each multiple of input 1
	this.p = false; // Specify if the output is monotonal (eg conversion to PSST angle)
	this.mod = false; // Specify if output reaches a modulus (eg colour). False or numeric value;
}
Ring.prototype.getSize = function() {
	return this.s;
};
Ring.prototype.getDetails = function() {
	var out = {
			title: this.title,
			s: this.s,
			r: this.r,
			p: this.p,
			L: this.L.buffer
	};
	return out;
};
Ring.prototype.setDetails = function(d) {
	this.title = d.title;
	if (typeof d.L !== 'undefined') {
		this.L = new Float64Array(d.L);
		this.s = this.L.length;
		if (typeof d.p === 'boolean') {
			if (typeof d.r === 'number') {
				this.r = d.r;
			} else {
				this.r = this.L[this.s-1] - this.L[0];
			}
			this.p = d.p;
		} else {
			this.p = false;
			this.r = 0;
		}
	}
	if (typeof d.mod === 'number') {
		this.mod = d.mod;
	} else {
		this.mod = false;
	}
};
Ring.prototype.reset = function() {
	this.title = '';
	this.s = 1024;
	this.r = 1;
	this.p = false;
};
Ring.prototype.setL = function(bufL) {
	this.L = new Float64Array(bufL);
	this.s = this.L.length;
};
Ring.prototype.getL = function() {
	return this.L.buffer;
};
Ring.prototype.f = function(L) {
	var top = (this.s - 1);
	L = L%1;
	if (L<0) {
		L += 1;
	}
	L = L * top;
	var f = Math.floor(L);
	var p0,p1;
	var d0,d1;
	p0 = this.L[f];
	if (f === top) {
		p1 = this.L[1] + this.r;
		d0 = (p1 - this.L[f-1])/2;
	} else if (f === 0) {
		p1 = this.L[1];
		d0 = (p1 - this.L[top-1] + this.r)/2;
	} else {
		p1 = this.L[f+1];
		d0 = (p1 - this.L[f - 1])/2;
	}
	if (f > top-2) {
		d1 = (this.L[(f + 3)%top] + this.r - this.L[f])/2;
	} else {
		d1 = (this.L[f + 2] - this.L[f])/2;
	}
	var a = (2 * p0) + d0 - (2 * p1) + d1;
	var b = - (3 * p0) - (2 * d0) + (3 * p1) - d1;
	var c = d0;
	var d = p0;
	L -= f;
	return (((((a * L) + b) * L) + c) * L) + d;
};
Ring.prototype.fCub = function(L) {
	if (this.mod) {
		return this.cubMod(L);
	} else {
		return this.cub(L);
	}
};
Ring.prototype.fLin = function(L) {
	if (this.mod) {
		return this.linMod(L);
	} else {
		return this.lin(L);
	}
};
Ring.prototype.cub = function(L) {
	var top = (this.s - 1);
	L = L%1;
	if (L<0) {
		L += 1;
	}
	L = L * top;
	var f = Math.floor(L);
	var p0,p1;
	var d0,d1;
	p0 = this.L[f];
	if (f === top) {
		p1 = this.L[1] + this.r;
		d0 = (p1 - this.L[f-1])/2;
	} else if (f === 0) {
		p1 = this.L[1];
		d0 = (p1 - this.L[top-1] + this.r)/2;
	} else {
		p1 = this.L[f+1];
		d0 = (p1 - this.L[f - 1])/2;
	}
	if (f > top-2) {
		d1 = (this.L[(f + 3)%top] + this.r - this.L[f])/2;
	} else {
		d1 = (this.L[f + 2] - this.L[f])/2;
	}
	var a = (2 * p0) + d0 - (2 * p1) + d1;
	var b = - (3 * p0) - (2 * d0) + (3 * p1) - d1;
	var c = d0;
	var d = p0;
	L -= f;
	return (((((a * L) + b) * L) + c) * L) + d;
};
Ring.prototype.cubMod = function(L) {
	var top = (this.s - 1);
	L = L%1;
	if (L<0) {
		L += 1;
	}
	L = L * top;
	var f = Math.floor(L);
	var mod = this.mod;
	var sp = mod * 0.5;
	var p0,p1;
	var pm1,p2;
	var d0,d1;
	p0 = this.L[f];
	if (f === top) {
		p1 = this.L[1] + this.r;
		pm1 = this.L[f-1];
	} else if (f === 0) {
		p1 = this.L[1];
		pm1 = this.L[top-1] - this.r;
	} else {
		p1 = this.L[f+1];
		pm1 = this.L[f - 1];
	}
	if (f > top-2) {
		p2 = this.L[(f + 3)%top] + this.r;
	} else {
		p2 = this.L[f + 2];
	}
	if (p0-pm1 > sp) {
		pm1 += mod;
	} else if (pm1-p0 > sp) {
		pm1 -= mod;
	}
	if (p0-p1 > sp) {
		p1 += mod;
	} else if (p1-p0 > sp) {
		p1 -= mod;
	}
	if (p0-p2 > sp) {
		p2 += mod;
	} else if (p2-p0 > sp) {
		p2 -= mod;
	}
	pm1 = pm1%mod;
	p0 = p0%mod;
	p1 = p1%mod;
	p2 = p2%mod;
	d0 = (p1 - pm1)/2;
	d1 = (p2 - p0)/2;
	var a = (2 * p0) + d0 - (2 * p1) + d1;
	var b = - (3 * p0) - (2 * d0) + (3 * p1) - d1;
	var c = d0;
	var d = p0;
	L -= f;
	return (((((a * L) + b) * L) + c) * L) + d;
};
Ring.prototype.lin = function(L) {
	var top = this.s - 1;
	L = L%1;
	if (L<0) {
		L += 1;
	}
	L *= top;
	var f = Math.floor(L);
	var dy = L - f;
	if (f === top) {
		return (this.L[f] * (1 - dy)) + ((this.L[1]+this.r) * dy);
	} else {
		return (this.L[f] * (1 - dy)) + (this.L[f + 1] * dy);
	}
};
Ring.prototype.linMod = function(L) {
	var top = this.s - 1;
	var mod = this.mod;
	var sp = mod * 0.5;
	L = L%1;
	if (L<0) {
		L += 1;
	}
	L *= top;
	var f = Math.floor(L);
	var dy = L - f;
	var p0 = this.L[f];
	var p1;
	if (f === top) {
		p1 = this.L[1]+this.r;
	} else {
		p1 = this.L[f + 1];
	}
	if (p0-p1 > sp) {
		p1 += mod;
	} else if (p1-p0 > sp) {
		p1 -= mod;
	}
	p1 = p1%mod;
	return (p0 * (1 - dy)) + (p1 * dy);
};
Ring.prototype.lLsCub = function(buff) {
	if (this.mod) {
		this.cubsMod(buff);
	} else {
		this.cubs(buff);
	}
};
Ring.prototype.cubs = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	var max = this.s - 1;
	var f;
	var p0,p1;
	var d0,d1;
	var a,b,c,d;
	for (var j=0; j<m; j++) {
		o[j] = o[j]%1;
		if (o[j]<0) {
			o[j] += 1;
		}
		o[j] *= max;
		f = Math.floor(o[j]);
		p0 = this.L[f];
		if (f === max) {
			p1 = this.L[1] + this.r;
			d0 = (p1 - this.L[f-1])/2;
		} else if (f === 0) {
			p1 = this.L[1];
			d0 = (p1 - this.L[max-1] + this.r)/2;
		} else {
			p1 = this.L[f+1];
			d0 = (this.L[f+1] - this.L[f - 1])/2;
		}
		if (f > max-2) {
			d1 = (this.L[(f + 3)%max] + this.r - this.L[f])/2;
		} else {
			d1 = (this.L[f + 2] - this.L[f])/2;
		}
		a = (2 * p0) + d0 - (2 * p1) + d1;
		b = - (3 * p0) - (2 * d0) + (3 * p1) - d1;
		c = d0;
		d = p0;
		o[j] -= f;
		o[j] = (((((a * o[j]) + b) * o[j]) + c) * o[j]) + d;
	}
};
Ring.prototype.cubsMod = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	var max = this.s - 1;
	var f;
	var p0,p1;
	var pm1,p2;
	var d0,d1;
	var a,b,c,d;
	var mod = this.mod;
	var sp = mod * 0.5;
	for (var j=0; j<m; j++) {
		o[j] = o[j]%1;
		if (o[j]<0) {
			o[j] += 1;
		}
		o[j] *= max;
		f = Math.floor(o[j]);
		p0 = this.L[f];
		if (f === max) {
			p1 = this.L[1] + this.r;
			pm1 = this.L[f-1];
		} else if (f === 0) {
			p1 = this.L[1];
			pm1 = this.L[max-1] - this.r;
		} else {
			p1 = this.L[f+1];
			pm1 = this.L[f - 1];
		}
		if (f > max-2) {
			p2 = this.L[(f + 3)%max] + this.r;
		} else {
			p2 = this.L[f + 2];
		}
		if (p0-pm1 > sp) {
			pm1 += mod;
		} else if (pm1-p0 > sp) {
			pm1 -= mod;
		}
		if (p0-p1 > sp) {
			p1 += mod;
		} else if (p1-p0 > sp) {
			p1 -= mod;
		}
		if (p0-p2 > sp) {
			p2 += mod;
		} else if (p2-p0 > sp) {
			p2 -= mod;
		}
		pm1 = pm1%mod;
		p0 = p0%mod;
		p1 = p1%mod;
		p2 = p2%mod;
		d0 = (p1 - pm1)/2;
		d1 = (p2 - p0)/2;
		a = (2 * p0) + d0 - (2 * p1) + d1;
		b = - (3 * p0) - (2 * d0) + (3 * p1) - d1;
		c = d0;
		d = p0;
		o[j] -= f;
		o[j] = (((((a * o[j]) + b) * o[j]) + c) * o[j]) + d;
	}
};
Ring.prototype.lLsLin = function(buff) {
	if (this.mod) {
		this.linsMod(buff);
	} else {
		this.lins(buff);
	}
};
Ring.prototype.lins = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	var max = this.s - 1;
	var f, dy;
	for (var j=0; j<m; j++) {
		o[j] = o[j]%1;
		if (o[j]<0) {
			o[j] += 1;
		}
		o[j] *= max;
		var f = Math.floor(o[j]);
		var dy = o[j] - f;
		if (f === top) {
			o[j] = (this.L[f] * (1 - dy)) + ((this.L[1]+this.r) * dy);
		} else {
			o[j] = (this.L[f] * (1 - dy)) + (this.L[f + 1] * dy);
		}
	}
};
Ring.prototype.linMod = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	var max = this.s - 1;
	var f, dy;
	var p0,p1;
	var mod = this.mod;
	var sp = mod * 0.5;
	for (var j=0; j<m; j++) {
		o[j] = o[j]%1;
		if (o[j]<0) {
			o[j] += 1;
		}
		o[j] *= top;
		f = Math.floor(o[j]);
		dy = o[j] - f;
		p0 = this.L[f];
		if (f === max) {
			p1 = this.L[1]+this.r;
		} else {
			p1 = this.L[f + 1];
		}
		if (p0-p1 > sp) {
			p1 += mod;
		} else if (p1-p0 > sp) {
			p1 -= mod;
		}
		p1 = p1%mod;
		o[j] = (p0 * (1 - dy)) + (p1 * dy);
	}
};
// Stringify for inline Web Workers
function getRingString() {
	var out = "";
	// Ring
	out += Ring.toString() + "\n";
	for (var j in Ring.prototype) {
		out += 'Ring.prototype.' + j + '=' + Ring.prototype[j].toString() + "\n";
	}
	return out;
}
var workerRingString = getRingString();
/* lutmessage.js
* messaging object between UI and calculations / web workers for LUTCalc Web App.
* 28th December 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTMessage(inputs) {
	this.inputs = inputs;
	this.ui = []; // Links to UI objects for function returns
	this.p = 0;
	this.ui[0] = this;
	this.go = false;
	// 0 - LUTMessage
	// 1 - camerabox
	// 2 - gammabox
	// 3 - tweaksbox
	// 4 - lutbox
	// 5 - generatebox
	// 6 - infobox
	// 7 - LUTAnalyst
	// 8 - preview
	// 9 - twkHG
	// 10 - twkLA
	// 11 - formats
	// 12 - twkWHITE
	// 13 - twkCS
	// 14 - twkMulti
	// 15 - twkSampler
	// 16 - mobile
	// 17 - twkDisplay
	if (typeof this.inputs.blobWorkers !== 'undefined') {
		this.blobWorkers = this.inputs.blobWorkers;
	} else {
		this.blobWorkers = false;
	}
//		this.blobWorkers = false;
	this.gas = []; // Array of gamma web workers
	this.gaT = 2; // Gamma threads
	this.gaN = 0; // Next web worker to send data to
	this.gaV = 0; // Counter keeping tabs on 'freshness' of returned data
	this.gaU = 0; // Counter keeping tabs on how many of the threads are up-to-date
	this.gaL = 0;
	this.gaPQ = 0;
	this.startGaThreads();
	this.gts = []; // Array of gamma web workers
	this.gtT = 2; // Gamut threads
	this.gtN = 0; // Next web worker to send data to
	this.gtV = 0; // Counter keeping tabs on 'freshness' of returned data
	this.gtU = 0; // Counter keeping tabs on how many of the threads are up-to-date
	this.gtL = 0;
	this.startGtThreads();
	this.precision = 8;
    this.gaReady = false;
    this.gtReady = false;
    this.gagtReady = false;
}
LUTMessage.prototype.addUI = function(code,ui) {
	this.ui[code] = ui;
};
LUTMessage.prototype.getGammaThreads = function() {
	return this.gaT;
};
LUTMessage.prototype.getGamutThreads = function() {
	return this.gtT;
};
LUTMessage.prototype.getWorker = function() {
	return this.gas[0];
};
LUTMessage.prototype.setReady = function() {
	this.go = true;
};
// Gamma Message Handling
LUTMessage.prototype.startGaThreads = function() {
	var max = this.gaT;
	var windowURL,workerString,gammaWorkerBlob;
	if (this.blobWorkers) {
		windowURL = window.URL || window.webkitURL;
		workerString = (workerLUTString + workerGammaString).replace('"use strict";', '');
		gammaWorkerBlob = new Blob([ workerString ], { type: 'text/javascript' } );
	}
	for (var i=0; i<max; i++) {
		var _this = this;
		if (this.blobWorkers) {
			try {
				var blobURL = windowURL.createObjectURL(gammaWorkerBlob);
				this.gas[i] = new Worker(blobURL);
//				URL.revokeObjectURL(blobURL);
			} catch (e) { // Fallback for - IE10 and 11
console.log('No Inline Web Workers');
				this.blobWorkers = false;
				this.gas[i] = new Worker('gammaworker.js');
			}
		} else {
			this.gas[i] = new Worker('gammaworker.js');
		}
		this.gas[i].onmessage = function(e) {
			_this.gaRx(e.data);
		};
	}
};
LUTMessage.prototype.stopGaThreads = function() {
	var max = this.gas.length;
	for (var i=0; i<max; i++) {
		this.gas[i].terminate();
	}
	this.gas = [];
};
LUTMessage.prototype.changeGaThreads = function(T) {
	if (typeof T==='number' && (T%1)===0) {
		this.gaT = T;
		var max = this.gas.length;
		if (T > max) {
			var windowURL,workerString,gammaWorkerBlob;
			if (this.blobWorkers) {
				windowURL = window.URL || window.webkitURL;
				workerString = (workerLUTString + workerGammaString).replace('"use strict";', '');
				gammaWorkerBlob = new Blob([ workerString ], { type: 'text/javascript' } );
			}
			for (var i=max; i<T; i++) {
				var _this = this;
				if (this.blobWorkers) {
					try {
						var blobURL = windowURL.createObjectURL(gammaWorkerBlob);
						this.gas[i] = new Worker(blobURL);
//						URL.revokeObjectURL(blobURL);
					} catch (e) { // Fallback for - IE10 and 11
						this.blobWorkers = false;
console.log('No Inline Web Workers');
						this.gas[i] = new Worker('gammaworker.js');
					}
				} else {
					this.gas[i] = new Worker('gammaworker.js');
				}
				this.gas[i].onmessage = function(e) {
					_this.gaRx(e.data);
				};
			}
		} else if (T < max) {
			for (var i=T-1; i<max; i++) {
				this.gas[i].terminate();
			}
			this.gas = this.gas.slice(0,T);
			this.gaN = 0;
			this.gaU = 0;
		}
	}
};
LUTMessage.prototype.gaSetParams = function() {
	if (this.go) {
		this.gaV++;
		var d = {
			v: this.gaV,
			inGamma: parseInt(this.inputs.inGamma.options[this.inputs.inGamma.options.selectedIndex].value),
			inLinGamma: parseInt(this.inputs.inLinGamma.options[this.inputs.inLinGamma.options.selectedIndex].value),
			outGamma: parseInt(this.inputs.outGamma.options[this.inputs.outGamma.options.selectedIndex].value),
			outLinGamma: parseInt(this.inputs.outLinGamma.options[this.inputs.outLinGamma.options.selectedIndex].value),
			contrast: {
				rec: parseInt(this.inputs.inConGamma.options[this.inputs.inConGamma.options.selectedIndex].value),
				out: parseInt(this.inputs.outConGamma.options[this.inputs.outConGamma.options.selectedIndex].value),
			},

			pqLwIn: parseFloat(this.inputs.inPQLw.value),
			pqLwOut: parseFloat(this.inputs.outPQLw.value),
			pqEOTFLwIn: parseFloat(this.inputs.inPQEOTFLw.value),
			pqEOTFLwOut: parseFloat(this.inputs.outPQEOTFLw.value),
			hlgLwIn: parseFloat(this.inputs.inHLGLw.value),
			hlgLwOut: parseFloat(this.inputs.outHLGLw.value),
			hlgBBCIn: this.inputs.hlgBBCScaleIn[1].checked,
			hlgBBCOut: this.inputs.hlgBBCScaleOut[1].checked,
			arriLegalIn: !this.inputs.arriLegalIn[1].checked,
			arriLegalOut: !this.inputs.arriLegalOut[1].checked,

			defGamma: this.inputs.defGammaIn,
			newISO: parseFloat(this.inputs.cineEI.value),
			natISO: parseFloat(this.inputs.nativeISO.innerHTML),
			camType: parseInt(this.inputs.cameraType.value),
			stopShift: parseFloat(this.inputs.stopShift.value),
			camClip: Math.pow(2,parseFloat(this.inputs.wclip)+parseFloat(this.inputs.stopShift.value))*0.18,
//			clip: this.inputs.clipCheck.checked,
			clipSelect: parseInt(this.inputs.clipSelect.options[this.inputs.clipSelect.selectedIndex].value),
			clipLegal: this.inputs.clipLegalCheck.checked,
			isTrans: this.inputs.isTrans
		};
		if (this.inputs.inRange[0].checked) {
			d.inL = true;
		} else {
			d.inL = false;
		}
		if (this.inputs.outRange[0].checked) {
			d.outL = true;
		} else {
			d.outL = false;
		}
		if (typeof this.inputs.bClip !== 'undefined') {
			d.bClip = this.inputs.bClip;
			d.wClip = this.inputs.wClip;
		}
		if (typeof this.inputs.scaleCheck !== 'undefined' && this.inputs.scaleCheck && typeof this.inputs.scaleMin.value !== 'undefined') {
			d.scaleMin = parseFloat(this.inputs.scaleMin.value);
			d.scaleMax = parseFloat(this.inputs.scaleMax.value);
			if (d.scaleMin !== 0.0 || d.scaleMax !== 1.0) {
				d.scaleCheck = true;
			} else {
				d.scaleCheck = false;
			}
		} else {
			d.scaleCheck = false;
		}
		this.ui[3].getTFParams(d);
		var max = this.gas.length;
		for (var i=0; i<max; i++) {
			this.gas[i].postMessage({t: 0, d: d});
		}
	}
};
LUTMessage.prototype.gaTx = function(p,t,d) { // parent (sender), type, data
	if (typeof p !== 'undefined') {
		if (this.inputs.isTrans && d !== null && typeof d.to !== 'undefined') {
			var max = d.to.length;
			var objArray = [];
			for (var j=0; j < max; j++) {
				objArray.push(d[d.to[j]]);
			}
			this.gas[this.gaN].postMessage({p: p, t: t, v: this.gaV, d: d},objArray);
			this.gaN = (this.gaN + 1) % this.gaT;
		} else {
			this.gas[this.gaN].postMessage({p: p, t: t, v: this.gaV, d: d});
			this.gaN = (this.gaN + 1) % this.gaT;
		}
	}
};
LUTMessage.prototype.gaTxAll = function(p,t,d) { // parent (sender), type, data
	if (typeof p !== 'undefined') {
		if (this.inputs.isTrans && d !== null && typeof d.to !== 'undefined') {
			var max = d.to.length;
			var objArray = [];
			for (var j=0; j < max; j++) {
				objArray.push(d[d.to[j]]);
			}
			max = this.gas.length;
			for (var j=0; j<max; j++) {
				this.gas[j].postMessage({p: p, t: t, v: this.gaV, d: d}, objArray);
			}
		} else {
			var max = this.gas.length;
			for (var j=0; j<max; j++) {
				this.gas[j].postMessage({p: p, t: t, v: this.gaV, d: d});
			}
		}
	}
};
LUTMessage.prototype.gaRx = function(d) {
	if (d.msg) {
		console.log(d.details);
	} else if (d.err) {
		console.log(d.details);
	} else if (d.resend) {
		console.log('Resending gamma - ' + d.t + ' to ' + d.p);
		this.gaTx(d.p,d.t,d.d);
	} else if (d.v === this.gaV) {
		switch(d.t) {
			case 20: // Set Parameters
					this.gammaParamsSet(d);
					break;
			case 21: // 1D input to output
					this.ui[5].got1D(d);
					break;
			case 22: // LUTAnalyst SL3 input to linear
					this.ui[d.p].setCSInputData(d.o,d.natTF,d.legIn);
					this.gtTx(d.p,2,{
						p:d.p,
						t:d.t,
						v:d.v,
						dim:d.dim,
						gamma:d.gamma,
						gamut:d.gamut
					});
					break;
			case 23: // RGB input to linear
					this.gtTx(d.p,1,d);
					break;
			case 24: // RGB linear to output
					this.ui[5].got3D(d);
					break;
			case 25: // Get lists of gammas
					this.gotGammaLists(d);
					break;
			case 26: // Set LA LUT
					this.gaL++;
					if (this.gaL === this.gaT) {
						this.gaL = 0;
						this.ui[10].doneStuff();
						this.ui[6].updateGamma();
					}
					break;
			case 27: // Set LA Title
					break;
			case 28: // LUTAnalyst SLog3 data value from given transfer function
					this.ui[d.p].gotInputVals(d.o,d.dim);
					break;
			case 29: // LUTAnalyst Slog3/S-Gamut3.cine values to LUT input colourspace
					this.ui[d.p].gotInputVals(d.o,d.dim);
					break;
			case 30: // Get IRE values for output from a list of linear values
					this.gotIOGammaNames(d);
					break;
			case 31: // Get IRE values for output from a list of linear values
					this.gotChartVals(d);
					break;
			case 32: // Get 8-bit corrected values for preview image
					this.ui[d.p].gotLine(d);
					break;
			case 34: // Get linear / S-Gamut3.cine value for preview image
					this.gtTx(d.p,14,d);
					break;
			case 35: // Get primaries of current colour space for preview
					this.ui[d.p].updatePrimaries(d.o);
					break;
			case 36: // Get PSST-CDL colours
					this.ui[3].psstColours(d);
					if (this.inputs.isMobile) {
						this.ui[16].updateUI();
					}
					break;
			case 37: // Get Multi Colours
					this.ui[3].multiColours(d);
					break;
			case 38: // Get LUT in to LUT out values for primaries
					this.ui[6].updateRGBChart(d);
					break;
			case 39: // Update PQ LMax level
					this.gaPQ++;
					if (this.gaPQ === this.gaT) {
						this.gaPQ = 0;
						this.gaSetParams();
					}
					break;
		}
	}
};
LUTMessage.prototype.showArray = function(o,dim) {
	var temp = new Float64Array(o);
	var max = Math.round(temp.length/3);
	var R = new Float64Array(max);
	var G = new Float64Array(max);
	var B = new Float64Array(max);
	for (var j=0; j<max; j++) {
		R[j] = temp[j*3];
		G[j] = temp[(j*3)+1];
		B[j] = temp[(j*3)+2];
	}
	console.log(max);
	console.log(R);
	console.log(G);
	console.log(B);
};
LUTMessage.prototype.gammaParamsSet = function(d) {
	this.gaU++;
	if (this.gaU === this.gaT) {
		this.gaU = 0;
		this.gtTx(3,16,{});
		this.gtTx(8,15,{});
		this.ui[3].setParams(d);
		this.ui[6].updateGamma();
		this.ui[8].isChanged(d.eiMult);
		if (this.inputs.isMobile) {
			this.ui[16].updateUI();
		}
        if (!this.gagtReady) {
            this.gaReady = true;
            if (this.gtReady) {
                this.gagtReady = true;
                if (this.inputs.appleApp) {
                    var data = { version: this.inputs.versionNum }
                    window.webkit.messageHandlers.appReady.postMessage(JSON.stringify(data));
                }
            }
        }
	}
};
LUTMessage.prototype.gotGammaLists = function(d) {
	this.inputs.addInput('gammaLA',d.LA);
	this.inputs.addInput('gammaPQ',d.PQ);
	this.inputs.addInput('gammaHLG',d.HLG);
	this.inputs.addInput('gammaPQOOTF',d.PQOOTF);
	this.inputs.addInput('gammaPQEOTF',d.PQEOTF);
	this.inputs.addInput('gammaHLGOOTF',d.HLGOOTF);
	this.inputs.addInput('gammaArriList', d.ARRIList)
	this.inputs.addInput('gammaDLogM',d.DLogM);
	this.inputs.addInput('gammaInList',d.inList);
	this.inputs.addInput('gammaOutList',d.outList);
	this.inputs.addInput('gammaLinList',d.linList);
	this.inputs.addInput('gammaCatList',d.catList);
	this.inputs.addInput('gammaDisList',d.disList);
	this.inputs.addInput('gammaDisBaseGamuts',d.baseDisGamuts);
	this.inputs.addInput('gammaBaseGamuts',d.baseGamuts);
	this.inputs.addInput('gammaSubNames',d.subNames);
	this.inputs.addInput('gammaDataLevel',d.gammaDat);
	this.inputs.addInput('gammaExt',d.gammaExt);
	var subLists = [];
	var m = d.subNames.length;
	var allIdx = m-1;
	for (var j=0; j<m; j++) {
		subLists[j] = [];
		if (d.subNames[j] === 'All') {
			allIdx = j;
		}
	}

	m = d.subList.length;
	var m2;
	for (var j=0; j<m; j++) {
		m2 = d.subList[j].length;
		for (var k=0; k<m2; k++) {
			subLists[d.subList[j][k]].push(j);
		}
	}
	subLists[allIdx].length = 0;
	for (var j=0; j<m; j++) {
		subLists[allIdx].push(j);
	}
	this.inputs.addInput('gammaSubLists',subLists);
	this.ui[2].gotGammaLists(); // Gamma Box
	this.ui[3].gotGammaLists(); // Tweaks Box
	this.ui[4].gotGammaLists(); // LUT Box
	this.gaSetParams();
};
LUTMessage.prototype.gotBaseIRE = function(d) {
	this.ui[3].gotBaseIRE(d.o); // Tweaks Box
	this.ui[5].gotBaseIRE(d.o); // Generate Box
};
LUTMessage.prototype.gotIREs = function(d) {
	this.ui[d.p].gotIREs(d.i,d.o);
};
LUTMessage.prototype.gotIOGammaNames = function(d) {
	this.ui[d.p].gotIOGammaNames(d.o);
};
LUTMessage.prototype.gotChartVals = function(d) {
//	this.gtTx(d.p,11,{ colIn:d.colIn, colOut:d.colOut, eiMult:d.eiMult, to:['colIn','colOut']});
	this.ui[d.p].gotChartVals(d);
};
LUTMessage.prototype.gotHighLevelDefault = function(d) {
	this.ui[3].gotHighLevelDefault(d.rec,d.map);
};
// Gamut Message Handling
LUTMessage.prototype.startGtThreads = function() {
	var max = this.gtT;
	var windowURL,workerString,csWorkerBlob;
	if (this.blobWorkers) {
		windowURL = window.URL || window.webkitURL;
		workerString = (workerLUTString + workerRingString + workerBrentString + workerCSString).replace('"use strict";', '');
		csWorkerBlob = new Blob([ workerString ], { type: 'text/javascript' } );
	}
	for (var i=0; i<max; i++) {
		var _this = this;
		if (this.blobWorkers) {
			try {
				var blobURL = windowURL.createObjectURL(csWorkerBlob);
				this.gts[i] = new Worker(blobURL);
//				URL.revokeObjectURL(blobURL);
			} catch (e) { // Fallback for - IE10 and 11
console.log('No Inline Web Workers');
				this.blobWorkers = false;
				this.gts[i] = new Worker('colourspaceworker.js');
			}
		} else {
			this.gts[i] = new Worker('colourspaceworker.js');
		}
		this.gts[i].onmessage = function(e) {
			_this.gtRx(e.data);
		};
	}
};
LUTMessage.prototype.stopGtThreads = function() {
	var max = this.gts.length;
	for (var i=0; i<max; i++) {
		this.gts[i].terminate();
	}
	this.gts = [];
};
LUTMessage.prototype.changeGtThreads = function(T) {
	if (typeof T==='number' && (T%1)===0) {
		this.gtT = T;
		var max = this.gts.length;
		if (T > max) {
			var windowURL,workerString,csWorkerBlob;
			if (this.blobWorkers) {
				windowURL = window.URL || window.webkitURL;
				workerString = (workerLUTString + workerRingString + workerBrentString + workerCSString).replace('"use strict";', '');
				csWorkerBlob = new Blob([ workerString ], { type: 'text/javascript' } );
			}
			for (var i=max; i<T; i++) {
				var _this = this;
				if (this.blobWorkers) {
					try {
						var blobURL = windowURL.createObjectURL(csWorkerBlob);
						this.gts[i] = new Worker(blobURL);
//						URL.revokeObjectURL(blobURL);
					} catch (e) { // Fallback for - IE10 and 11
						this.blobWorkers = false;
						this.gts[i] = new Worker('colourspaceworker.js');
					}
				} else {
					this.gts[i] = new Worker('colourspaceworker.js');
				}
				this.gts[i].onmessage = function(e) {
					_this.gtRx(e.data);
				};
			}
		} else if (T < max) {
			for (var i=T-1; i<max; i++) {
				this.gts[i].terminate();
			}
			this.gts = this.gts.slice(0,T);
			this.gtN = 0;
			this.gtU = 0;
		}
	}
};
LUTMessage.prototype.gtSetParams = function() {
	if (this.go) {
		this.gtV++;
		var d = {
			v: this.gtV,
			inGamut: parseInt(this.inputs.inGamut.options[this.inputs.inGamut.selectedIndex].value),
			outGamut: parseInt(this.inputs.outGamut.options[this.inputs.outGamut.selectedIndex].value),
			isTrans: this.inputs.isTrans
		};
		this.ui[3].getCSParams(d);
		var max = this.gts.length;
		for (var i=0; i<max; i++) {
			this.gts[i].postMessage({t: 0, d: d});
		}
	}
};
LUTMessage.prototype.gtTx = function(p,t,d) { // parent (sender), type, data
	if (typeof p !== 'undefined') {
		if (this.inputs.isTrans && d !== null && typeof d.to !== 'undefined') {
			var max = d.to.length;
			var objArray = [];
			for (var j=0; j < max; j++) {
				objArray.push(d[d.to[j]]);
			}
			this.gts[this.gtN].postMessage({p: p, t: t, v: this.gtV, d: d}, objArray);
			this.gtN = (this.gtN + 1) % this.gtT;
		} else {
			this.gts[this.gtN].postMessage({p: p, t: t, v: this.gtV, d: d});
			this.gtN = (this.gtN + 1) % this.gtT;
		}
	}
};
LUTMessage.prototype.gtTxAll = function(p,t,d) { // parent (sender), type, data
	if (typeof p !== 'undefined') {
		if (this.inputs.isTrans && d !== null && typeof d.to !== 'undefined') {
			var max = d.to.length;
			var objArray = [];
			for (var j=0; j < max; j++) {
				objArray.push(d[d.to[j]]);
			}
			max = this.gts.length;
			for (var j=0; j<max; j++) {
				this.gts[j].postMessage({p: p, t: t, v: this.gtV, d: d}, objArray);
			}
		} else {
			var max = this.gts.length;
			for (var j=0; j<max; j++) {
				this.gts[j].postMessage({p: p, t: t, v: this.gtV, d: d});
			}
		}
	}
};
LUTMessage.prototype.gtRx = function(d) {
	if (d.msg) {
		console.log(d.details);
	} else if (d.err) {
		console.log(d.details);
	} else if (d.resend) {
		console.log('Resending gamut - ' + d.t + ' to ' + d.p);
		if (d.t === 1) {
			this.gaTx(d.p,d.t,{R:d.d.R,G:d.d.G,B:d.d.B,vals:d.d.vals,dim:d.d.dim,to:d.d.to});
		} else {
			this.gtTx(d.p,d.t,d.d);
		}
	} else if (d.v === this.gtV || d.t === 37) {
		switch(d.t) {
			case 20: // Set params
					this.gamutParamsSet(d);
					break;
			case 21: // RGB input to output
					this.gaTx(5,4,d);
					break;
			case 22: // RGB S-Gamut3.cine to LA input gamut
					// console.log(new Float64Array(d.inputMatrix));
					// this.gaTx(d.p,9,d);
					this.ui[d.p].gotInputVals(d.inputMatrix,d.dim);
					break;
			case 23: // Recalculated custom matrix for changed colourspace
					this.ui[d.p].recalcMatrix(d.idx,d.wcs,d.matrix);
					break;
			case 24: // Send Default LUT-based Gamuts from file to Worker
					splashProg(5);
					break;
			case 25: // Get lists of gamuts
					this.loadGamutLUTs();
					this.gotGamutLists(d);
					break;
			case 26: // Set LA LUT
					this.gtL++;
					if (this.gtL === this.gtT) {
						this.gtL = 0;
						this.ui[8].isChanged();
					}
					break;
			case 27: // Set LA Title
					break;
			case 28: // Get Colour Square
					this.ui[d.p].gotColSqr(d.o,d.tIdx);
					break;
			case 29: // Get Multi Colours
					if (d.doGamutLim) {
						if (typeof d.og !== 'undefined') {
							this.gaTx(d.p,17,{o: d.o, hs: d.hs, cb:d.cb, doGamutLim: true, og: d.og, gLimY: d.gLimY, gLimL: d.gLimL, gLimB: d.gLimB, to:['o','hs','og']});
						} else {
							this.gaTx(d.p,17,{o: d.o, hs: d.hs, cb:d.cb, doGamutLim: true, gLimY: d.gLimY, gLimL: d.gLimL, to:['o','hs']});
						}
					} else {
						this.gaTx(d.p,17,{ o: d.o, hs: d.hs, cb:d.cb, doGamutLim: false, to:['o','hs']});
					}
					break;
			case 30: //
					this.gotIOGamutNames(d);
					break;
			case 31: // Get LUT In / LUT Out values for primaries
					if (typeof d.rIn !== 'undefined') {
						this.gaTx(d.p,18,{ rIn:d.rIn, gIn:d.gIn, bIn:d.bIn, rOut:d.rOut, gOut:d.gOut, bOut:d.bOut, cb:d.cb, to:['rIn', 'gIn', 'bIn','rOut','gOut','bOut']});
					}
					break;
			case 32: // Get preview colour correction
					this.gaTx(d.p,12,d);
					break;
			case 34: // Get linear / S-Gamut3.cine value for preview image
					this.ui[d.p].preppedPreview(d.o);
					break;
			case 35: // Get primaries of current colour space for preview
					this.gaTx(d.p,15,d);
					break;
			case 36: // Get PSST-CDL colours
					this.gaTx(3,16,{b:d.b,a:d.a,cb:d.cb,to:['b','a']});
					break;
			case 37: // Get Chromatic Adaptation Transform options
					this.ui[3].gotCATs(d.o);
					break;
			case 38: // Get CCT and Dxy for white point dropper
					this.ui[12].gotPreCCTDuv(d);
					break;
			case 39: // Calculate primaries and white point for current output
					this.ui[8].updateXY(d.xy);
					break;
		}
	}
};
LUTMessage.prototype.gamutParamsSet = function(d) {
	this.gtU++;
	if (this.gtU === this.gtT) {
		this.gtU = 0;
		this.gtTx(3,16,{});
		this.gtTx(8,15,{});
		this.ui[3].setParams(d);
//		this.ui[6].updateGamma();
		this.ui[8].isChanged();
		this.ui[8].testXY();
		if (this.inputs.isMobile) {
			this.ui[16].updateUI();
		}
        if (!this.gagtReady) {
            this.gtReady = true;
            if (this.gaReady) {
                this.gagtReady = true;
                if (this.inputs.appleApp) {
                    window.webkit.messageHandlers.appReady.postMessage("");
                }
            }
        }
    }
};
LUTMessage.prototype.gotGamutLists = function(d) {
	this.inputs.addInput('gamutPass',d.pass);
	this.inputs.addInput('gamutLA',d.LA);
	this.inputs.addInput('gamutInList',d.inList);
	this.inputs.addInput('gamutOutList',d.outList);
	this.inputs.addInput('gamutLAList',d.laList);
	this.inputs.addInput('gamutMatrixList',d.matList);
	this.inputs.addInput('gamutCATList',d.CATList);
	this.inputs.addInput('gamutSubNames',d.subNames);
	var inSubs = [];
	var outSubs = [];
	var laSubs = [];
	var m = d.subNames.length;
	var allIdx = m-1;
	for (var j=0; j<m; j++) {
		inSubs[j] = [];
		outSubs[j] = [];
		laSubs[j] = [];
		if (d.subNames[j] === 'All') {
			allIdx = j;
		}
	}
	m = d.inSub.length;
	var m2;
	for (var j=0; j<m; j++) {
		m2 = d.inSub[j].length;
		for (var k=0; k<m2; k++) {
			inSubs[d.inSub[j][k]].push(j);
		}
	}
	inSubs[allIdx].length = 0;
	for (var j=0; j<m; j++) {
		inSubs[allIdx].push(j);
	}
	m = d.outSub.length;
	var m2;
	for (var j=0; j<m; j++) {
		m2 = d.outSub[j].length;
		for (var k=0; k<m2; k++) {
			outSubs[d.outSub[j][k]].push(j);
		}
	}
	outSubs[allIdx].length = 0;
	for (var j=0; j<m; j++) {
		outSubs[allIdx].push(j);
	}
	m = d.laSub.length;
	var m2;
	for (var j=0; j<m; j++) {
		m2 = d.laSub[j].length;
		for (var k=0; k<m2; k++) {
			laSubs[d.laSub[j][k]].push(j);
		}
	}
	laSubs[allIdx].length = 0;
	for (var j=0; j<m; j++) {
		laSubs[allIdx].push(j);
	}
	this.inputs.addInput('gamutInSubLists',inSubs);
	this.inputs.addInput('gamutOutSubLists',outSubs);
	this.inputs.addInput('gamutLASubLists',laSubs);
	this.ui[2].gotGamutLists(d.pass,d.LA); // Gamma Box
	this.ui[3].gotGamutLists(); // Tweaks Box
	this.gtSetParams();
};
LUTMessage.prototype.gotIOGamutNames = function(d) {
	this.ui[d.p].gotIOGamutNames(d.inName,d.outName,d.hgName);
};
// Get Info For LUT Generation
LUTMessage.prototype.getInfo = function(info) {
	info.version = this.inputs.version;
	info.date = this.inputs.date;
	this.ui[4].getInfo(info); // LUT Box (Dimensions, MLUTs, etc..)
	this.ui[1].getInfo(info); // Camera Box (Stop Correction)
	this.ui[2].getInfo(info); // Gamma Box (Gamma In / Out, Gamut In / Out)
	this.ui[3].getInfo(info); // Tweaks Box - notes for in the LUT file
};
// Inter-object messages
LUTMessage.prototype.changeCamera = function() {
	this.ui[2].defaultGam();
	this.gaSetParams();
	this.ui[4].changeGamma();
	this.gtSetParams();
};
LUTMessage.prototype.updateGammaInList = function() {
	this.ui[2].updateGammaInList(false);
};
LUTMessage.prototype.changeGamma = function() {
	if (this.go) {
		this.ui[4].changeGamma();
		this.gaSetParams();
	}
};
LUTMessage.prototype.updateGammaIn = function() {
	if (this.go) {
		this.ui[11].updateGammaIn();
	}
};
LUTMessage.prototype.updateGammaOut = function() {
	if (this.go) {
		this.ui[11].updateGammaOut();
		this.ui[17].updateGammaOut();
		this.ui[3].updateGammaOut();
	}
};
LUTMessage.prototype.updateARRIRangeIn = function() {
	this.ui[11].updateARRIRangeIn();
};
LUTMessage.prototype.updateARRIRangeOut = function() {
	this.ui[11].updateARRIRangeOut();
};
LUTMessage.prototype.hideGammaSubsOut = function() {
	this.ui[2].hideGammaSubsOut();
};
LUTMessage.prototype.changeGamut = function() {
	if (this.go) {
		this.ui[3].changeGamut();
		this.gtSetParams();
		this.ui[8].testXY();
	}
};
LUTMessage.prototype.changeFormat = function() {
	this.ui[2].oneOrThree();
	this.ui[3].toggleTweaks();
//	this.ui[8].testXY();
	this.gaSetParams();
	this.gtSetParams();
};
LUTMessage.prototype.oneOrThree = function() {
	this.ui[11].oneOrThree();
	this.ui[2].oneOrThree();
	this.ui[3].toggleTweaks();
	this.gtSetParams();
	this.gaSetParams();
};
LUTMessage.prototype.showPreview = function() {
	this.ui[3].toggleTweaks();
};
LUTMessage.prototype.getPreCCTDuv = function(xcoord,ycoord) {
	var rgb = this.ui[8].getCanVal(xcoord, ycoord);
	this.gtTx(12,18,{rgb: rgb.buffer, to:['rgb']});
};
LUTMessage.prototype.getSettings = function() {
	var data = {};
	data.version = this.inputs.version;
	this.ui[1].getSettings(data);
	this.ui[2].getSettings(data);
	this.ui[3].getSettings(data);
 	this.ui[5].getSettings(data);
	this.ui[11].getSettings(data);
	this.ui[4].getSettings(data);
	return JSON.stringify(data,null,"\t");
};
LUTMessage.prototype.setSettings = function() {
	var data = JSON.parse(this.inputs.settingsData.text.join(''));
    if (typeof data.lutBox !== 'undefined' && typeof data.lutBox.oneD === 'boolean') {
        this.inputs.d[0].checked = data.oneD;
        this.inputs.d[1].checked = !data.oneD;
    }
	this.ui[1].setSettings(data);
	this.ui[2].setSettings(data);
	this.ui[3].setSettings(data);
	this.ui[5].setSettings(data);
	this.ui[11].setSettings(data);
	this.ui[4].setSettings(data);
	this.gtSetParams();
	this.gaSetParams();
};
LUTMessage.prototype.checkFormat = function() {
	this.ui[11].updateGammaOut();
};
LUTMessage.prototype.isCustomGamma = function() {
	return this.ui[3].isCustomGamma();
};
LUTMessage.prototype.isCustomGamut = function() {
	return this.ui[3].isCustomGamut();
};
LUTMessage.prototype.displayCLC = function() {
	this.ui[4].displayCLC();
};
LUTMessage.prototype.saved = function(source, success) {
	switch (source) {
		case 0: break; // LALutss or LABins - don't need a further response
		case 1: this.ui[5].saved(success); // LUTs saved using the Generate buttons
				break;
		case 2: break; // RGB Sampler files - don't need a further response
		case 3: break; // Settings files - don't need a further response
		default: break;
	}
};
LUTMessage.prototype.loadGamutLUTs = function() {
	var fileNames = [
		'LC709',
		'LC709A',
		's709',
		'cpouttungsten',
		'cpoutdaylight',
		'Amira709',
		'AlexaX2',
		'V709',
		'Cine709'
	];
	var m = fileNames.length;
	var isLE;
	if ((new Int8Array(new Int16Array([1]).buffer)[0]) > 0) {
		isLE = true;
	} else {
		isLE = false;
	}
	for (var j=0; j<m; j++) {
		var xhr = new XMLHttpRequest();
		xhr.open('GET', fileNames[j] + '.labin', true);
		xhr.responseType = 'arraybuffer';
		xhr.onload = (function(here) {
			return function(e) {
				var buff = this.response;
	  			var lutArr = new Uint8Array(buff);
	  			if (!here.isLE) { // files are little endian, swap if system is big endian
					// console.log('Gamut LUTs: Big Endian System');
	  				var max = Math.round(lutArr.length / 4); // Float32s === 4 bytes
	  				var i,b0,b1,b2,b3;
	  				for (var j=0; j<max; j++) {
	  					i = j*4;
	  					b0=lutArr[ i ];
	  					b1=lutArr[i+1];
	  					b2=lutArr[i+2];
	  					b3=lutArr[i+3];
	  					lutArr[ i ] = b3;
	  					lutArr[i+1] = b2;
	  					lutArr[i+2] = b1;
	  					lutArr[i+3] = b0;
	  				}
	  			}
	  			var in32 = new Int32Array(buff);
	  			var tfS = in32[0];
		  		var dim = in32[1];
	 			var csS = dim*dim*dim;
				// Internal processing is Float64, files are scaled Int32
	 			var C = [	new Float64Array(csS),
	 						new Float64Array(csS),
	 						new Float64Array(csS) ];
	 			for (var j=0; j<csS; j++){
	 				C[0][j] = parseFloat(in32[((2+tfS)) + j])/1073741824;
	 				C[1][j] = parseFloat(in32[((2+tfS+csS)) + j])/1073741824;
	 				C[2][j] = parseFloat(in32[((2+tfS+(2*csS))) + j])/1073741824;
	 			}
				var dataEnd = 2+tfS+(3*csS);
				// get input matrix details (all zeros means no matrix defined)
				var inputMatrix = new Float64Array(9);
				var imM = false;
				if (dataEnd < in32.length) {
					for (var j=0; j<9; j++) {
						if (in32[dataEnd+j] !== 0) {
							imM = true;
							inputMatrix[j] = parseFloat(in32[dataEnd+j])/107374182.4;
						}
					}
					dataEnd += 9;
				}
				if (!imM) {
					inputMatrix = false;
				}
				// look for input matrix, colourspace and transfer function info at the end of the file if present
				var in1DTF = 'S-Log3'; // system default
				var in3DTF = 'S-Log3'; // system default
				var sysCS = 'Sony S-Gamut3.cine'; // system default
				var in3DCS = 'Sony S-Gamut3.cine'; // system default
				var in1DEX = true; // system default
				var in3DEX = true; // system default
				var in1DMin = [0,0,0];
				var in1DMax = [1,1,1];
				var in3DMin = [0,0,0];
				var in3DMax = [1,1,1];
				var interpolation = false;
				var baseISO = false;
				if (dataEnd < in32.length) {
					dataEnd *= 4;
					var fileEnd = lutArr.length;
					var metaString = '';
					for (var j=dataEnd; j<fileEnd; j++) {
						metaString += String.fromCharCode(lutArr[j]).replace('^','γ');
					}
					if (metaString.search('|') >= 0) {
						var meta = metaString.split('|');
						var m = meta.length;
						if (m > 2) {
							for (var j=0; j<m; j +=2) {
								switch (meta[j]) {
									case '1DTF':
										in1DTF = meta[j+1].trim();
										break;
							 		case '1DRG':
							 			if (meta[j+1].toLowerCase() === '100') {
											in1DEX = false;
										}
										break;
							 		case '1DMIN':
										in1DMin[0] = parseFloat(meta[j+1]);
										if (isNaN(in1DMin[0])) {
											in1DMin[0] = 0;
										} else {
											in1DMin[1] = in1DMin[0];
											in1DMin[2] = in1DMin[0];
										}
										break;
							 		case '1DMAX':
										in1DMax[0] = parseFloat(meta[j+1]);
										if (isNaN(in1DMax[0])) {
											in1DMax[0] = 1;
										} else {
											in1DMax[1] = in1DMax[0];
											in1DMax[2] = in1DMax[0];
										}
										break;
							 		case 'SYSCS':
										sysCS = meta[j+1].trim();
										break;
							 		case '3DTF':
							 			in3DTF = meta[j+1].trim();
										break;
							 		case '3DCS':
							 			in3DCS = meta[j+1].trim();
										break;
							 		case '3DRG':
							 			if (meta[j+1].toLowerCase() === '100') {
											in3DEX = false;
										}
										break;
							 		case '3DMIN':
										in3DMin[0] = parseFloat(meta[j+1]);
										if (isNaN(in3DMin[0])) {
											in3DMin[0] = 0;
										} else {
											in3DMin[1] = in3DMin[0];
											in3DMin[2] = in3DMin[0];
										}
										break;
							 		case '3DMAX':
										in3DMax[0] = parseFloat(meta[j+1]);
										if (isNaN(in3DMax[0])) {
											in3DMax[0] = 1;
										} else {
											in3DMax[1] = in3DMax[0];
											in3DMax[2] = in3DMax[0];
										}
										break;
							 		case 'INTERPOLATION':
										switch (meta[j+1].trim().toLowerCase()) {
											case 'tricubic': interpolation = 0;
												break;
											case 'tetrahedral': interpolation = 1;
												break;
											case 'trilinear': interpolation = 2;
												break;
										}
										break;
				 					case 'BASEISO':
				 						if (meta[j+1].trim().toLowerCase() !== 'unknown') {
					 						baseISO = parseInt(meta[j+1].trim());
					 					}
				 						break;
								}
							}			
						} else {
							in1DTF = meta[0].trim();
							in3DCS = meta[1].trim();
						}
					} else {
						in3DCS = metaString;
					}
				}
	  			here.messages.gtTxAll(0, 4, {
					fileName: here.fileName,
					format: 'cube',
					dims: 3,
					s: dim,
					min: in3DMin,
					max: in3DMax,
					C: [ C[0].buffer, C[1].buffer, C[2].buffer ],
					meta: {
						systemCS: sysCS,
						inputTF: in3DTF,
						inputCS: in3DCS,
						inputEX: in3DEX,
						interpolation: interpolation,
						baseISO: baseISO,
						inputMatrix: inputMatrix
					}
				});
			};
		})({
			fileName: fileNames[j],
			isLE: isLE,
			messages: this
		});
		xhr.send();
	}
};
LUTMessage.prototype.takePreviewClick = function(twk) {
	if (twk === 1 && this.ui[12].sample) { // RGB Sampler wants to take charge - check if White Balance needs turning off
		this.ui[12].toggleSample();
	} else if (twk === 0 && this.ui[15].setSample) { // White Balance wants to take charge - check if sampler needs turning off
		this.ui[15].toggleSample();
	}
};
LUTMessage.prototype.previewSample = function(x,y) {
	if (this.ui[12].sample) {
		this.ui[12].previewSample(x,y);
	} else if (this.ui[15].setSample) {
		this.ui[15].previewSample(x,y);
	}
};
LUTMessage.prototype.getSamples = function(gridX,gridY) {
	return this.ui[8].rgbSamples(gridX,gridY);
};
LUTMessage.prototype.mobileOpt = function(opt) {
	this.ui[16].desktopCur(opt);
};
LUTMessage.prototype.setPrecision = function(precision) {
	this.precision = precision;
};
LUTMessage.prototype.getPrecision = function() {
	return this.precision;
};
LUTMessage.prototype.getCamera = function() {
    return this.ui[1].getCamera();
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* lut-cube.js
* .cube LUT building / parsing for the LUTCalc Web App.
* 3rd June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function cubeLUT(messages, isLE, flavour) {
	this.messages = messages;
	this.isLE = isLE;
	this.flavour = flavour;
}
cubeLUT.prototype.build = function(buff, fileName, ext) {
	var lut = new Float64Array(buff);
	var max = lut.length;
	var precision = this.messages.getPrecision();
	var d = '';
	for (var j=0; j<max; j += 3) {
		d +=	lut[ j ].toFixed(precision).toString() + ' ' +
				lut[j+1].toFixed(precision).toString() + ' ' +
				lut[j+2].toFixed(precision).toString() + "\n";
	}
	return {
		lut: this.header() + d,
		fileName: fileName,
		ext: ext
	};
};
cubeLUT.prototype.header = function() {
	var info = {};
	this.messages.getInfo(info);
	var out = 'TITLE "' + info.name + '"' + "\n";
	if (info.oneD) {
		out += 'LUT_1D_SIZE ' + info.dimension.toString() + "\n";
	} else {
		out += 'LUT_3D_SIZE ' + info.dimension.toString() + "\n";
	}
	if (this.flavour !== 1 && info.scaleCheck && (info.scaleMin !== 0 || info.scaleMax !== 1)) {
		if (this.flavour === 2) {
			if (info.oneD) {
				out += 'LUT_1D_INPUT_RANGE ' + info.scaleMin + ' ' + info.scaleMax + "\n";
			} else {
				out += 'LUT_3D_INPUT_RANGE ' + info.scaleMin + ' ' + info.scaleMax + "\n";
			}
		} else if (this.flavour === 3) {
			out += 'DOMAIN_MIN ' + info.scaleMin + ' ' + info.scaleMin + ' ' + info.scaleMin + "\n";
			out += 'DOMAIN_MAX ' + info.scaleMax + ' ' + info.scaleMax + ' ' + info.scaleMax + "\n";
		}
	}
	if (info.nul) {
		out += '# Null LUT';
	} else {
		out += '# ';
		if (info.mlut) {
			out += 'MLUT';
		}
		if (info.doFC) {
			out += '*** FALSE COLOUR - DO NOT BAKE IN *** ';
		}
		if (info.oneD) {
			out += info.inGammaName + ' -> ' + info.outGammaName;
		} else if (this.doHG) {
			out += info.inGammaName + '/' + info.inGamutName + ' -> ' + info.outGammaName + '/' + info.outGamutName + '(' + info.hgGamutName + ' in the highlights)';
		} else {
			out += info.inGammaName + '/' + info.inGamutName + ' -> ' + info.outGammaName + '/' + info.outGamutName;
		}
		out += ', CineEI Shift ' + info.cineEI.toFixed(2).toString();
		out += ', Black Level ' + info.blackLevel + '% IRE';
		if (info.legalIn) {
			out += ', Input 100% -> ';
		} else {
			out += ', Input 109% -> ';
		}
		if (info.legalOut) {
			out += 'Output 100%';
		} else {
			out += 'Output 109%';
		}
	}
	out += ' - ' + 'Created with LUTCalc ' + info.version + ' by Ben Turley ' + info.date + "\n";
	return out;
};
cubeLUT.prototype.parse = function(title, text, lutMaker, lutDest) {
	var dimensions = false;
	var size = false;
	var minimum = [0,0,0];
	var maximum = [1,1,1];
	var sysCS = '';
	var laCS = '';
	var laTF = '';
	var laRG = '';
	var laEX = true;
	var laMin,laMax;
	var baseISO = false;
	var interpolation = false;
	var laMX = false;
	var laMLines = 0;
	var max = text.length;
	if (max === 0) {
		return false;
	}
	var i;
	for (i=0; i<max; i++) {
		var line = text[i].trim();
		var lower = line.toLowerCase();
		var j = line.charAt(0);
		if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
			break;
		} else if (lower.search('title') >= 0) {
			title = line.substr(lower.search('title') + 5).trim().replace(/"/g, '');
		} else if (lower.search('lut_3d_size') >= 0) {
			var dim = line.substr(lower.search('lut_3d_size') + 11).trim();
			if (!isNaN(dim)) {
				dimensions = 3;
				size = parseInt(dim);
			}
		} else if (lower.search('lut_1d_size') >= 0) {
			var dim = line.substr(parseInt(lower.search('lut_1d_size')) + 11).trim();
			if (!isNaN(dim)) {
				dimensions = 1;
				size = parseInt(dim);
			}
		} else if (lower.search('domain_min') >= 0) {
			var dom = line.substr(parseInt(lower.search('domain_min')) + 10).trim().split(/\s+/g);
			if (!isNaN(dom[0]) && !isNaN(dom[1]) && !isNaN(dom[2])) {
				minimum[0] = parseFloat(dom[0]);
				minimum[1] = parseFloat(dom[1]);
				minimum[2] = parseFloat(dom[2]);
			}
		} else if (lower.search('domain_max') >= 0) {
			var dom = line.substr(parseInt(lower.search('domain_max')) + 10).trim().split(/\s+/g);
			if (!isNaN(dom[0]) && !isNaN(dom[1]) && !isNaN(dom[2])) {
				maximum[0] = parseFloat(dom[0]);
				maximum[1] = parseFloat(dom[1]);
				maximum[2] = parseFloat(dom[2]);
			}
		} else if (lower.search('lut_3d_input_range') >= 0) {
			var ran = line.substr(parseInt(lower.search('lut_3d_input_range')) + 18).trim().split(/\s+/g);
			if (!isNaN(ran[0]) && !isNaN(ran[1])) {
				minimum[0] = parseFloat(ran[0]);
				minimum[1] = minimum[0];
				minimum[2] = minimum[0];
				maximum[0] = parseFloat(ran[1]);
				maximum[1] = maximum[0];
				maximum[2] = maximum[0];
			}
		} else if (lower.search('lut_1d_input_range') >= 0) {
			var ran = line.substr(parseInt(lower.search('lut_1d_input_range')) + 18).trim().split(/\s+/g);
			if (!isNaN(ran[0]) && !isNaN(ran[1])) {
				minimum[0] = parseFloat(ran[0]);
				minimum[1] = minimum[0];
				minimum[2] = minimum[0];
				maximum[0] = parseFloat(ran[1]);
				maximum[1] = maximum[0];
				maximum[2] = maximum[0];
			}
		} else if (lower.search('# la_system_colourspace') >= 0) {
			sysCS = line.substr(parseInt(lower.search('# la_system_colourspace')) + 23).trim();
		} else if (lower.search('# la_input_colourspace') >= 0) {
			laCS = line.substr(parseInt(lower.search('# la_input_colourspace')) + 22).trim();
		} else if (lower.search('# la_input_transfer_function') >= 0) {
			laTF = line.substr(parseInt(lower.search('# la_input_transfer_function')) + 28).trim();
		} else if (lower.search('# la_base_iso') >= 0) {
			baseISO = parseInt(line.substr(parseInt(lower.search('# la_base_iso')) + 13).trim());
			if (isNaN(baseISO)) {
				baseISO = false;
			}
		}  else if (lower.search('# la_interpolation') >= 0) {
			switch (line.substr(parseInt(lower.search('# la_interpolation')) + 18).trim().toLowerCase()) {
				case 'tricubic': interpolation = 0;
					break;
				case 'tetrahedral': interpolation = 1;
					break;
				case 'trilinear': interpolation = 2;
					break;
			}
		} else if (lower.search('# la_input_range') >= 0) {
			laRG = line.substr(parseInt(lower.search('# la_input_range')) + 16).trim();
			if (laRG === '100') {
				laEX = false;
			}
		} else if (lower.search('# la_input_min') >= 0) {
			minimum[0] = parseFloat(line.substr(parseInt(lower.search('# la_input_min')) + 14).trim());
			if (isNaN(minimum[0])) {
				minimum[0] = 0;
			} else {
				minimum[1] = minimum[0];
				minimum[2] = minimum[0];
			}
		} else if (lower.search('# la_input_max') >= 0) {
			maximum[0] = parseFloat(line.substr(parseInt(lower.search('# la_input_max')) + 14).trim());
			if (isNaN(maximum[0])) {
				minimum[0] = 1;
			} else {
				maximum[1] = maximum[0];
				maximum[2] = maximum[0];
			}
		} else if (lower.search('# la_input_matrix_r') >= 0) {
			var mat = line.substr(parseInt(lower.search('# la_input_matrix_r')) + 19).trim().split(/\s+/g);
			if (!isNaN(mat[0]) && !isNaN(mat[1]) && !isNaN(mat[2])) {
				if (laMLines === 0) {
					laMX = new Float64Array([1,0,0,0,1,0,0,0,1]);
				}
				laMX[0] = mat[0];
				laMX[1] = mat[1];
				laMX[2] = mat[2];
				laMLines++;
			}
		} else if (lower.search('# la_input_matrix_g') >= 0) {
			var mat = line.substr(parseInt(lower.search('# la_input_matrix_g')) + 19).trim().split(/\s+/g);
			if (!isNaN(mat[0]) && !isNaN(mat[1]) && !isNaN(mat[2])) {
				if (laMLines === 0) {
					laMX = new Float64Array([1,0,0,0,1,0,0,0,1]);
				}
				laMX[3] = mat[0];
				laMX[4] = mat[1];
				laMX[5] = mat[2];
				laMLines++;
			}
		} else if (lower.search('# la_input_matrix_b') >= 0) {
			var mat = line.substr(parseInt(lower.search('# la_input_matrix_b')) + 19).trim().split(/\s+/g);
			if (!isNaN(mat[0]) && !isNaN(mat[1]) && !isNaN(mat[2])) {
				if (laMLines === 0) {
					laMX = new Float64Array([1,0,0,0,1,0,0,0,1]);
				}
				laMX[6] = mat[0];
				laMX[7] = mat[1];
				laMX[8] = mat[2];
				laMLines++;
			}
		}
	}
	if (dimensions && size) {
		var arraySize = size;
		if (dimensions === 3) {
			arraySize = size*size*size;
		}
		var R = new Float64Array(arraySize);
		var G = new Float64Array(arraySize);
		var B = new Float64Array(arraySize);
		var s=0;
		for (var k=i; k<max; k++) {
			var line = text[k].trim();
			var j = line.charAt(0);
			if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
				var vals = line.split(/\s+/g);
				if (!isNaN(vals[0]) && !isNaN(vals[1]) && !isNaN(vals[2])) {
					R[s] = parseFloat(vals[0]);
					G[s] = parseFloat(vals[1]);
					B[s] = parseFloat(vals[2]);
					s++;
				}
			}
		}
		var meta = {};
		if (laTF !== '') {
			meta.inputTF = laTF;
		}
		if (sysCS !== '') {
			meta.systemCS = sysCS;
		}
		if (laCS !== '') {
			meta.inputCS = laCS;
		}
		if (laRG !== '') {
			meta.inputEX = laEX;
		}
		if (laMLines === 3) {
			meta.inputMatrix = laMX;
		}
		if (interpolation) {
			meta.interpolation = interpolation;
		}
		if (baseISO) {
			meta.baseISO = baseISO;
		}
		var params = {
				title: title,
				format: 'cube',
				dims: dimensions,
				s: size,
				min: minimum,
				max: maximum,
				C: [R.buffer,G.buffer,B.buffer],
				meta: meta
		};
		return lutMaker.setLUT(
			lutDest,
			params
		);
	} else {
		return false;
	}
};
/* lut-davinci.js
* DaVinci Resolve 1D ilut / olut LUT building / parsing for the LUTCalc Web App.
* 3rd June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function davinciiLUT(messages, isLE) {
	this.messages = messages;
	this.isLE = isLE;
}
davinciiLUT.prototype.build = function(buff, fileName, ext) {
	var lut = new Float64Array(buff);
	var max = lut.length;
	var d = '';
	for (var j=0; j<max; j += 3) {
		d +=	Math.round(lut[ j ]*16383).toString() + ',' +
				Math.round(lut[j+1]*16383).toString() + ',' +
				Math.round(lut[j+2]*16383).toString() + ',' +
				"0\n";
	}
	return {
		lut: d,
		fileName: fileName,
		ext: ext
	};
};
davinciiLUT.prototype.parse = function(title, text, lutMaker, lutDest) {
	var dimensions = 1;
	var size = 16384;
	var max = text.length;
	if (max === 0) {
		return false;
	}
	var i;
	for (i=0; i<max; i++) {
		var line = text[i].trim();
		var lower = line.toLowerCase();
		var j = line.charAt(0);
		if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
			break;
		}
	}
	var arraySize = size;
	var R = new Float64Array(arraySize);
	var G = new Float64Array(arraySize);
	var B = new Float64Array(arraySize);
	var s=0;
	for (var k=i; k<max; k++) {
		var line = text[k].trim();
		var j = line.charAt(0);
		if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
			var vals = line.split(/,\s*/g);
			if (!isNaN(vals[0]) && !isNaN(vals[1]) && !isNaN(vals[2])) {
				R[s] = parseFloat(vals[0])/16383;
				G[s] = parseFloat(vals[1])/16383;
				B[s] = parseFloat(vals[2])/16383;
				s++;
			}
		}
	}
	if (s === size) {
		return lutMaker.setLUT(
			lutDest,
			{
				title: title,
				format: 'davinci',
				dims: dimensions,
				s: size,
				min: [0,0,0],
				max: [1,1,1],
				C: [R.buffer,G.buffer,B.buffer]
			}
		);
/*
		lut.setDetails({
			title: title,
			format: 'davinci',
			dims: dimensions,
			s: size,
			min: [0,0,0],
			max: [1,1,1],
			C: [R.buffer,G.buffer,B.buffer]
		});
		return true;
*/
	} else {
		return false;
	}
};
function davincioLUT(messages, isLE) {
	this.messages = messages;
	this.isLE = isLE;
}
davincioLUT.prototype.build = function(buff, fileName, ext) {
	var lut = new Float64Array(buff);
	var max = lut.length;
	var d = '';
	for (var j=0; j<max; j += 3) {
		d +=	Math.round(lut[ j ]*16383).toString() + ',' +
				Math.round(lut[j+1]*16383).toString() + ',' +
				Math.round(lut[j+2]*16383).toString() + ',' +
				Math.round(lut[ j ]*16383).toString() + ',' +
				Math.round(lut[j+1]*16383).toString() + ',' +
				Math.round(lut[j+2]*16383).toString() + "\n";
	}
	return {
		lut: d,
		fileName: fileName,
		ext: ext
	};
};
davincioLUT.prototype.parse = function(title, text, lutMaker, lutDest) {
	var dimensions = 1;
	var size = 4096;
	var max = text.length;
	if (max === 0) {
		return false;
	}
	var i;
	for (i=0; i<max; i++) {
		var line = text[i].trim();
		var lower = line.toLowerCase();
		var j = line.charAt(0);
		if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
			break;
		}
	}
	var arraySize = size;
	var R = new Float64Array(arraySize);
	var G = new Float64Array(arraySize);
	var B = new Float64Array(arraySize);
	var s=0;
	for (var k=i; k<max; k++) {
		var line = text[k].trim();
		var j = line.charAt(0);
		if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
			var vals = line.split(/,\s*/g);
			if (!isNaN(vals[0]) && !isNaN(vals[1]) && !isNaN(vals[2])) {
				R[s] = parseFloat(vals[0])/4095;
				G[s] = parseFloat(vals[1])/4095;
				B[s] = parseFloat(vals[2])/4095;
				s++;
			}
		}
	}
	if (s === size) {
		return lutMaker.setLUT(
			lutDest,
			{
				title: title,
				format: 'davinci',
				dims: dimensions,
				s: size,
				min: [0,0,0],
				max: [1,1,1],
				C: [R.buffer,G.buffer,B.buffer]
			}
		);
/*
		lut.setDetails({
			title: title,
			format: 'davinci',
			dims: dimensions,
			s: size,
			min: [0,0,0],
			max: [1,1,1],
			C: [R.buffer,G.buffer,B.buffer]
		});
		return true;
*/
	} else {
		return false;
	}
};
/* lut-vlt.js
* Panasonic Varicam .vlt LUT building / parsing for the LUTCalc Web App.
* 3rd June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function vltLUT(messages, isLE) {
	this.messages = messages;
	this.isLE = isLE;
}
vltLUT.prototype.build = function(buff, fileName, ext) {
	var lut = new Float64Array(buff);
	var max = lut.length;
	var d = '';
	for (var j=0; j<max; j += 3) {
		d +=	Math.min(4095,Math.max(0,Math.round(lut[ j ]*4095))).toString() + ' ' +
				Math.min(4095,Math.max(0,Math.round(lut[j+1]*4095))).toString() + ' ' +
				Math.min(4095,Math.max(0,Math.round(lut[j+2]*4095))).toString() + "\n";
	}
	return {
		lut: this.header() + d,
		fileName: fileName,
		ext: ext
	};
};
vltLUT.prototype.header = function() {
	var info = {};
	this.messages.getInfo(info);
	var out = '# panasonic vlt file version 1.0' + "\n";
	out += '# source vlt file ""' + "\n";
	out += 'LUT_3D_SIZE ' + info.dimension.toString() + "\n\n";
	return out;
};
vltLUT.prototype.parse = function(title, text, lutMaker, lutDest) {
	var dimensions = false;
	var size = false;
	var minimum = [0,0,0];
	var maximum = [1,1,1];
	var max = text.length;
	if (max === 0) {
		return false;
	}
	var i;
	for (i=0; i<max; i++) {
		var line = text[i].trim();
		var lower = line.toLowerCase();
		var j = line.charAt(0);
		if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
			break;
		} else if (lower.search('title') >= 0) {
			title = line.substr(lower.search('title') + 5).trim().replace(/"/g, '');
		} else if (lower.search('lut_3d_size') >= 0) {
			var dim = line.substr(lower.search('lut_3d_size') + 11).trim();
			if (!isNaN(dim)) {
				dimensions = 3;
				size = parseInt(dim);
			}
		} else if (lower.search('lut_1d_size') >= 0) {
			var dim = line.substr(parseInt(lower.search('lut_1d_size')) + 11).trim();
			if (!isNaN(dim)) {
				dimensions = 1;
				size = parseInt(dim);
			}
		} else if (lower.search('domain_min') >= 0) {
			var dom = line.substr(parseInt(lower.search('domain_min')) + 10).trim().split(/\s+/g);
			if (!isNaN(dom[0]) && !isNaN(dom[1]) && !isNaN(dom[2])) {
				minimum[0] = parseInt(dom[0]);
				minimum[1] = parseInt(dom[1]);
				minimum[2] = parseInt(dom[2]);
			}
		} else if (lower.search('domain_max') >= 0) {
			var dom = line.substr(parseInt(lower.search('domain_max')) + 10).trim().split(/\s+/g);
			if (!isNaN(dom[0]) && !isNaN(dom[1]) && !isNaN(dom[2])) {
				maximum[0] = parseInt(dom[0]);
				maximum[1] = parseInt(dom[1]);
				maximum[2] = parseInt(dom[2]);
			}
		} else if (lower.search('lut_3d_input_range') >= 0) {
			var ran = line.substr(parseInt(lower.search('lut_3d_input_range')) + 18).trim().split(/\s+/g);
			if (!isNaN(ran[0]) && !isNaN(ran[1])) {
				minimum[0] = parseInt(ran[0]);
				minimum[1] = minimum[0];
				minimum[2] = minimum[0];
				maximum[0] = parseInt(ran[1]);
				maximum[1] = maximum[0];
				maximum[2] = maximum[0];
			}
		} else if (lower.search('lut_1d_input_range') >= 0) {
			var ran = line.substr(parseInt(lower.search('lut_1d_input_range')) + 18).trim().split(/\s+/g);
			if (!isNaN(ran[0]) && !isNaN(ran[1])) {
				minimum[0] = parseInt(ran[0]);
				minimum[1] = minimum[0];
				minimum[2] = minimum[0];
				maximum[0] = parseInt(ran[1]);
				maximum[1] = maximum[0];
				maximum[2] = maximum[0];
			}
		}
	}
	if (dimensions && size) {
		var arraySize = size;
		if (dimensions === 3) {
			arraySize = size*size*size;
		}
		var R = new Float64Array(arraySize);
		var G = new Float64Array(arraySize);
		var B = new Float64Array(arraySize);
		var s=0;
		for (var k=i; k<max; k++) {
			var line = text[k].trim();
			var j = line.charAt(0);
			if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
				var vals = line.split(/\s+/g);
				if (!isNaN(vals[0]) && !isNaN(vals[1]) && !isNaN(vals[2])) {
					R[s] = parseFloat(vals[0])/4095;
					G[s] = parseFloat(vals[1])/4095;
					B[s] = parseFloat(vals[2])/4095;
					s++;
				}
			}
		}
		return lutMaker.setLUT(
			lutDest,
			{
				title: title,
				format: 'vlt',
				dims: dimensions,
				s: size,
				min: minimum,
				max: maximum,
				C: [R.buffer,G.buffer,B.buffer]
			}
		);
/*
		lut.setDetails({
			title: title,
			format: 'vlt',
			dims: dimensions,
			s: size,
			min: minimum,
			max: maximum,
			C: [R.buffer,G.buffer,B.buffer]
		});
		return true;
*/
	} else {
		return false;
	}
};
/* lut-3dl.js
* .3dl LUT building / parsing for the LUTCalc Web App.
* 3rd June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function threedlLUT(messages, isLE, flavour) {
	this.messages = messages;
	this.isLE = isLE;
	this.flavour = flavour;
}
threedlLUT.prototype.build = function(buff, fileName, ext) {
	var info = {};
	this.messages.getInfo(info);
	var lut = new Float64Array(buff);
	var max = lut.length;
	var d = '';
	max = info.dimension;
	var mult = (Math.pow(2,info.inBits)-1)/(max-1);
	for (var j=0; j<max; j++) {
		d += Math.ceil(j*mult) + ' ';
	}
	d = d.slice(0,d.length - 1);
	d += "\n";
	var t;
	mult = Math.pow(2,info.outBits)-1;
	for (var r=0; r<max; r++) {
		for (var g=0; g<max; g++) {
			for (var b=0; b<max; b++) {
				t = (r + (g*max) + (b*max*max))*3;
				if (lut[ t ] > 0) {
					d += Math.round(lut[ t ]*mult).toString() + ' ';
				} else {
					d += '0 ';
				}
				if (lut[t+1] > 0) {
					d += Math.round(lut[t+1]*mult).toString() + ' ';
				} else {
					d += '0 ';
				}
				if (lut[t+2] > 0) {
					d += Math.round(lut[t+2]*mult).toString() + "\n";
				} else {
					d += '0' + "\n";
				}
			}
		}
	}
	switch (this.flavour) {
		case 1: // Flame
			return {
				lut: this.header(info) + d,
				fileName: fileName,
				ext: ext
			};
		case 2: // Lustre
			return {
				lut: this.header(info) + d + this.footer(info),
				fileName: fileName,
				ext: ext
			};
		case 3: // Kodak
			return {
				lut: this.header(info) + d,
				fileName: fileName,
				ext: ext
			};
	}
};
threedlLUT.prototype.header = function(info) {
	var out = '';
	var date = new Date();
	out += '# Created with LUTCalc ' + info.version + ' by Ben Turley ' + info.date + ' #' + "\n";
	out += '# IDENTIFICATION: LUTCalc - 3DLUT' + "\n";
	out += '# CREATOR: LUTCalc ' + info.version + "\n";
	out += '# USER: LUTCalc' + "\n";
	out += '# DATA: ' +
			date.getUTCFullYear() + '-' +
			this.addZero(date.getUTCMonth()) + '-' +
			this.addZero(date.getUTCDate()) + 'T' +
			this.addZero(date.getUTCHours()) + ':' +
			this.addZero(date.getUTCMinutes()) + ':' +
			this.addZero(date.getUTCSeconds()) + ' #' + "\n";
	out += '# NUMBER OF COLUMNS: 3' + "\n";
	out += '# NUMBER OF ROWS: ' + Math.pow(info.dimension,3).toString() + "\n";
	out += '# NUMBER OF NODES: ' + info.dimension.toString() + "\n";
	out += '# INPUT RANGE: ' + info.inBits.toString() + "\n";
	out += '# OUTPUT RANGE: ' + info.outBits.toString() + "\n";
	out += '# TITLE : ' + info.name + "\n";
	out += '# DESCRIPTION : ';
	if (info.nul) {
		out += ' Null LUT';
	} else {
		if (info.mlut) {
			out += 'MLUT';
		}
		if (info.doFC) {
			out += '*** FALSE COLOUR - DO NOT BAKE IN *** ';
		}
		if (this.doHG) {
			out += info.inGammaName + '/' + info.inGamutName + ' -> ' + info.outGammaName + '/' + info.outGamutName + '(' + info.hgGamutName + ' in the highlights)';
		} else {
			out += info.inGammaName + '/' + info.inGamutName + ' -> ' + info.outGammaName + '/' + info.outGamutName;
		}
		out += ', Stop Shift ' + info.cineEI.toFixed(2).toString();
		out += ', Black Level ' + info.blackLevel + '% IRE';
		if (info.legalIn) {
			out += ', Legal Input -> ';
		} else {
			out += ', Data Input -> ';
		}
		if (info.legalOut) {
			out += 'Legal Output';
		} else {
			out += 'Data Output';
		}
	}
	out += "\n";
	if (this.flavour === 2) {
		out += '3DMESH' + "\n";
		out += 'Mesh ';
		switch (info.dimension) {
			case 9: out += '3 ';
					break;
			case 17: out += '4 ';
					break;
			case 33: out += '5 ';
					break;
			case 65: out += '6 ';
					break;
			case 129: out += '7 ';
					break;
		}
		out += info.outBits.toString() + "\n";
	}
	return out;
};
threedlLUT.prototype.addZero = function(i) {
    if (i < 10) {
        i = '0' + i;
    }
    return i;
};
threedlLUT.prototype.footer = function(info) {
	var out = '';
	out += 'LUT8' + "\n";
	out += 'gamma 1.0' + "\n";
	return out;
};
threedlLUT.prototype.parse = function(title, text, lutMaker, lutDest) {
	var size = false;
	var minimum = [0,0,0];
	var maximum = [1,1,1];
	var maxIn = 0;
	var setMaxIn = false;
	var maxOut = false;
	var mOut = 0;
	var format = 'threedl1';
	var mesh = false;
	var outBits = false;
	var shaper;
	var max = text.length;
	if (max === 0) {
		return false;
	}
	var i;
	for (i=0; i<max; i++) {
		var line = text[i].trim();
		var lower = line.toLowerCase();
		var j = line.charAt(0);
		if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
			// The first line with just numbers will be the shaper
			var shape = line.trim().split(/\s+/g);
			var m = shape.length;
			shaper = new Float64Array(m);
			for (var l=0; l<m; l++) {
				shaper[l] = parseFloat(shape[l]);
				if (!setMaxIn && shaper[l] > maxIn) {
					maxIn = shaper[l];
				}
				if (isNaN(shaper[l])) {
					return false;
				}
			}
			i++;
			break;
		} else if (lower.search('3dmesh') >= 0) {
			// 3DMESH line distinguishes two types
			mesh = true;
			format = 'threedl2';
		} else if (lower.search('mesh') >= 0) {
			mesh = true;
			format = 'threedl2';
			var bits = line.substr(lower.search('mesh') + 4).trim().split(/\s+/g);
			if (!isNaN(bits[0]) && !isNaN(bits[1])) {
				size = Math.pow(2,parseInt(bits[0]))+1;
				outBits = parseInt(bits[1]);
				maxOut = Math.pow(2,outBits)-1;
			}
		} else if (lower.search('number of rows:') >= 0) {
			var val = parseFloat(line.substr(lower.search('number of rows:') + 15));
			if (!isNaN(val)) {
				size = Math.round(Math.pow(val, 1/3));
			}
		} else if (lower.search('number of nodes:') >= 0) {
			var val = parseInt(line.substr(lower.search('number of nodes:') + 16));
			if (!isNaN(val)) {
				size = val;
			}
		} else if (lower.search('input range:') >= 0) {
			var val = parseInt(line.substr(lower.search('input range:') + 12).trim());
			if (!isNaN(val)) {
				maxIn = Math.pow(2,val)-1;
			}
		} else if (lower.search('output range:') >= 0) {
			var val = parseInt(line.substr(lower.search('output range:') + 13).trim());
			if (!isNaN(val)) {
				outBits = val;
				maxOut = Math.pow(2,outBits)-1;
			}
		} else if (lower.search('title:') >= 0) {
			title = line.substr(lower.search('title:') + 6).trim();
		} else if (lower.search('gamma') >= 0) {
			// Unused at the moment
		} else if (lower.search('lut8') >= 0) {
			// Unused at the moment
		}
	}
	if (!size) {
		// 3D LUT dimension does not need to match shaper, without 'Mesh', must be gauged from the number of entries. Yuck!
		size = 0;
		for (var k=i; k<max; k++) {
			var line = text[k].trim();
			var j = line.charAt(0);
			if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
				size++;
			}
		}
		size = Math.round(Math.pow(size, 1/3));
	}
	if (size > 0) {
		var spline = false;
		var doShaper = false;
		var m = shaper.length;
		if (!setMaxIn) {
			if (maxIn < 511) {
				maxIn = 255;
			} else if (maxIn < 2047) {
				maxIn = 1023;
			} else if (maxIn < 8191) {
				maxIn = 4095;
			} else if (maxIn < 32767) {
				maxIn = 16383;
			} else {
				maxIn = 65535;
			}
		}
		for (var j=0; j<m; j++) {
			if (Math.round(shaper[j]) !== Math.ceil(maxIn*j/(m-1))) {
				doShaper = true;
			}
		}
		if (doShaper) {
			for (var j=0; j<m; j++) {
				shaper[j] /= maxIn;
			}
//			var lutSpline = new LUTRSpline(shaper.buffer);
//			spline = new Float64Array(lutSpline.getReverse());
			spline = shaper;
		}
		var arraySize = size*size*size;
		var R = new Float64Array(arraySize);
		var G = new Float64Array(arraySize);
		var B = new Float64Array(arraySize);
		var s=0;
		var r=0;
		var g=0;
		var b=0;
		var t;
		for (var k=i; k<max; k++) {
			var line = text[k].trim();
			var j = line.charAt(0);
			if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
				var vals = line.split(/\s+/g);
				if (!isNaN(vals[0]) && !isNaN(vals[1]) && !isNaN(vals[2])) {
					t = r + (g*size) + (b*size*size);
					R[t] = parseFloat(vals[0]);
					G[t] = parseFloat(vals[1]);
					B[t] = parseFloat(vals[2]);
					if (maxOut) {
						R[t] /= maxOut;
						G[t] /= maxOut;
						B[t] /= maxOut;
					} else {
						if (R[s] > mOut) {
							mOut = R[s];
						}
						if (G[s] > mOut) {
							mOut = G[s];
						}
						if (B[s] > mOut) {
							mOut = B[s];
						}
					}
					b++;
					if (b === size) {
						b=0;
						g++;
					}
					if (g === size) {
						g=0;
						r++;
					}
					s++;
				}
			}
/*
			 else if (lower.search('gamma') >= 0) {
				// Unused at the moment
			} else if (lower.search('lut8') >= 0) {
				// Unused at the moment
			}
*/
		}
		if (s === arraySize) {
			if (!maxOut) {
				if (mOut < 511) {
					maxOut = 255;
				} else if (mOut < 2047) {
					maxOut = 1023;
				} else if (mOut < 8191) {
					maxOut = 4095;
				} else if (mOut < 32767) {
					maxOut = 16383;
				} else {
					maxOut = 65535;
				}
				for (var j=0; j<arraySize; j++) {
					R[j] /= maxOut;
					G[j] /= maxOut;
					B[j] /= maxOut;
				}
			}
			if (doShaper) {
				return lutMaker.setLUT(
					lutDest,
					{
						title: title,
						format: format,
						dims: 3,
						s: size,
						min: minimum,
						max: maximum,
						spline: spline.buffer,
						C: [R.buffer,G.buffer,B.buffer]
					}
				);
/*
				lut.setDetails({
					title: title,
					format: format,
					dims: 3,
					s: size,
					min: minimum,
					max: maximum,
					spline: spline.buffer,
					C: [R.buffer,G.buffer,B.buffer]
				});
*/
			} else {
				return lutMaker.setLUT(
					lutDest,
					{
						title: title,
						format: format,
						dims: 3,
						s: size,
						min: minimum,
						max: maximum,
						C: [R.buffer,G.buffer,B.buffer]
					}
				);
/*
				lut.setDetails({
					title: title,
					format: format,
					dims: 3,
					s: size,
					min: minimum,
					max: maximum,
					C: [R.buffer,G.buffer,B.buffer]
				});
*/
			}
//			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
};
/* lut-lut.js
* .lut LUT building / parsing for the LUTCalc Web App.
* 3rd June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function lutLUT(messages, isLE) {
	this.messages = messages;
	this.isLE = isLE;
}
lutLUT.prototype.build = function(buff, fileName, ext) {
	var lut = new Float64Array(buff);
	var max = lut.length;
	var s = Math.round(max / 3)-1;
	var r = '';
	var g = '';
	var b = '';
	for (var j=0; j<max; j += 3) {
		r += Math.round(lut[ j ]*s).toString() + "\n";
		g += Math.round(lut[j+1]*s).toString() + "\n";
		b += Math.round(lut[j+2]*s).toString() + "\n";
	}
	return {
		lut: this.header() + r + g + b,
		fileName: fileName,
		ext: ext
	};
};
lutLUT.prototype.header = function() {
	var info = {};
	this.messages.getInfo(info);
	var out = '# Created with LUTCalc ' + info.version + ' by Ben Turley ' + info.date + "\n";
	out += '# "' + info.name + '"' + "\n";
	if (info.nul) {
		out += '# Null LUT' + "\n";
	} else {
		out += '# ';
		if (info.mlut) {
			out += 'MLUT';
		}
		if (info.doFC) {
			out += '*** FALSE COLOUR - DO NOT BAKE IN *** ';
		}
		if (info.oneD) {
			out += info.inGammaName + ' -> ' + info.outGammaName;
		} else if (this.doHG) {
			out += info.inGammaName + '/' + info.inGamutName + ' -> ' + info.outGammaName + '/' + info.outGamutName + '(' + info.hgGamutName + ' in the highlights)';
		} else {
			out += info.inGammaName + '/' + info.inGamutName + ' -> ' + info.outGammaName + '/' + info.outGamutName;
		}
		out += ', CineEI Shift ' + info.cineEI.toFixed(2).toString();
		out += ', Black Level ' + info.blackLevel + '% IRE';
		if (info.legalIn) {
			out += ', Legal Input -> ';
		} else {
			out += ', Data Input -> ';
		}
		if (info.legalOut) {
			out += 'Legal Output' + "\n";
		} else {
			out += 'Data Output' + "\n";
		}
	}
	out += 'LUT: 3 ' + info.dimension.toString() + "\n";
	return out;
};
lutLUT.prototype.parse = function(title, text, lutMaker, lutDest) {
	var dimensions = 1;
	var channels = false;
	var size = false;
	var max = text.length;
	if (max === 0) {
		return false;
	}
	var i;
	for (i=0; i<max; i++) {
		var line = text[i].trim();
		var lower = line.toLowerCase();
		var j = line.charAt(0);
		if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
			break;
		} else if (lower.search('lut:') >= 0) {
			var data = line.substr(parseInt(lower.search('lut:')) + 4).trim().split(/\s+/g);
			channels = parseInt(data[0]);
			size = parseInt(data[1]);
		}
	}
	if (channels && size) {
		var arraySize = size;
		var div = size-1;
		if (channels === 1) {
			var L = new Float64Array(arraySize);
			var s=0;
			max = i+size;
			for (var k=i; k<max; k++) {
				var line = text[k].trim();
				if ((!isNaN(parseFloat(line)) && isFinite(line))) {
					L[s] = parseFloat(line)/div;
					s++;
				}
			}
			if (s === size) {
				return lutMaker.setLUT(
					lutDest,
					{
						title: title,
						format: 'lut',
						dims: 1,
						s: size,
						min: [0,0,0],
						max: [1,1,1],
						C: [L.buffer]
					}
				);
/*
				lut.setDetails({
					title: title,
					format: 'lut',
					dims: 1,
					s: size,
					min: [0,0,0],
					max: [1,1,1],
					C: [L.buffer]
				});
				return true;
*/
			} else {
				return false;
			}
		} else if (channels >= 3) {
			var R = new Float64Array(arraySize);
			var G = new Float64Array(arraySize);
			var B = new Float64Array(arraySize);
			var s=0;
			max = i+size;
			for (var k=i; k<max; k++) {
				var r = text[k].trim();
				var g = text[k+size].trim();
				var b = text[k+(2*size)].trim();
				if ((!isNaN(parseFloat(r)) && isFinite(r)) && (!isNaN(parseFloat(g)) && isFinite(g)) && (!isNaN(parseFloat(b)) && isFinite(b))) {
					R[s] = parseFloat(r)/div;
					G[s] = parseFloat(g)/div;
					B[s] = parseFloat(b)/div;
					s++;
				}
			}
			if (s === size) {
				return lutMaker.setLUT(
					lutDest,
					{
						title: title,
						format: 'lut',
						dims: 1,
						s: size,
						min: [0,0,0],
						max: [1,1,1],
						C: [R.buffer,G.buffer,B.buffer]
					}
				);
/*
				lut.setDetails({
					title: title,
					format: 'lut',
					dims: 1,
					s: size,
					min: [0,0,0],
					max: [1,1,1],
					C: [R.buffer,G.buffer,B.buffer]
				});
				return true;
*/
			} else {
				return false;
			}
		} else {
			return false;
		}
	} else {
		return false;
	}
};
/* lut-spi1d.js
* .3dl LUT building / parsing for the LUTCalc Web App.
* 3rd June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function spi1dLUT(messages, isLE) {
	this.messages = messages;
	this.isLE = isLE;
}
spi1dLUT.prototype.build = function(buff, fileName, ext) {
	var lut = new Float64Array(buff);
	var info = {};
	this.messages.getInfo(info);
	var max = lut.length;
	var d = '{' + "\n";
	for (var j=0; j<max; j += 3) {
		d += "\t" + lut[ j ].toFixed(12).toString();
		if (info.doASCCDL) {
			d += ' ' + lut[j+1].toFixed(12).toString();
			d += ' ' + lut[j+2].toFixed(12).toString();
		}
		d += "\n";
	}
	d += '}' + "\n";
	return {
		lut: this.header(info) + d,
		fileName: fileName,
		ext: ext
	};
};
spi1dLUT.prototype.header = function(info) {
	var out = '';
	out += 'Version 1' + "\n";
	if (this.scaleCheck) {
		out += 'From ' + info.scaleMin.toString() + ' '  + info.scaleMax.toString() + "\n";
	} else {
		out += 'From 0 1' + "\n";
	}
	out += 'Length ' + info.dimension.toString() + "\n";
	if (info.doASCCDL) {
		out += 'Components 3' + "\n";
	} else {
		out += 'Components 1' + "\n";
	}
	return out;
};
spi1dLUT.prototype.parse = function(title, text, lutMaker, lutDest) {
	var dimensions = 1;
	var channels = false;
	var size = false;
	var version = false;
	var from = 0;
	var to = 1;
	var max = text.length;
	if (max === 0) {
		return false;
	}
	var i;
	for (i=0; i<max; i++) {
		var line = text[i].trim();
		var lower = line.toLowerCase();
		if (lower.search('{') >= 0) {
			break;
		} else if (lower.search('version') >= 0) {
			version = parseInt(line.substr(parseInt(lower.search('version')) + 7).trim());
		} else if (lower.search('from') >= 0) {
			var data = line.substr(parseInt(lower.search('from')) + 4).trim().split(/\s+/g);
			from = parseFloat(data[0]);
			to = parseFloat(data[1]);
		} else if (lower.search('length') >= 0) {
			size = parseInt(line.substr(parseInt(lower.search('length')) + 6).trim());
		} else if (lower.search('components') >= 0) {
			channels = parseInt(line.substr(parseInt(lower.search('components')) + 10).trim());
		}
	}
	if (channels && size) {
		var arraySize = size;
		i++;
		if (channels === 1) {
			var L = new Float64Array(arraySize);
			var s=0;
			for (var k=i; k<max; k++) {
				var line = text[k].trim();
				if ((!isNaN(parseFloat(line)) && isFinite(line))) {
					L[s] = parseFloat(line);
					s++;
				}
			}
			if (s === size) {
			return lutMaker.setLUT(
				lutDest,
				{
					title: title,
					format: 'spi1d',
					dims: 1,
					s: size,
					min: [from,from,from],
					max: [to,to,to],
					C: [L.buffer]
				}
			);
/*
				lut.setDetails({
					title: title,
					format: 'spi1d',
					dims: 1,
					s: size,
					min: [from,from,from],
					max: [to,to,to],
					C: [L.buffer]
				});
				return true;
*/			} else {
				return false;
			}
		} else if (channels < 4) {
			var R = new Float64Array(arraySize);
			var G = new Float64Array(arraySize);
			var B = new Float64Array(arraySize);
			var s=0;
			for (var k=i; k<max; k++) {
				var line = text[k].trim();
				var j = line.charAt(0);
				if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
					var vals = line.split(/\s+/g);
					if (channels === 2 && !isNaN(vals[0]) && !isNaN(vals[1])) {
						R[s] = parseFloat(vals[0]);
						G[s] = parseFloat(vals[1]);
						B[s] = 0;
						s++;
					} else if (channels === 3 && !isNaN(vals[0]) && !isNaN(vals[1]) && !isNaN(vals[2])) {
						R[s] = parseFloat(vals[0]);
						G[s] = parseFloat(vals[1]);
						B[s] = parseFloat(vals[2]);
						s++;
					}
				}
			}
		} else {
			return false;
		}
	} else {
		return false;
	}
};
/* lut-spi3d.js
* .spi3d LUT building / parsing for the LUTCalc Web App.
* 3rd June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function spi3dLUT(messages, isLE) {
	this.messages = messages;
	this.isLE = isLE;
}
spi3dLUT.prototype.build = function(buff, fileName, ext) {
	var lut = new Float64Array(buff);
	var info = {};
	this.messages.getInfo(info);
	var m = parseInt(info.dimension);
	var d = '';
	var precision = this.messages.getPrecision();	
	var j;
	for (var r=0; r<m; r++) {
		for (var g=0; g<m; g++) {
			for (var b=0; b<m; b++) {
				j = (r + (g*m) + (b*m*m))*3;
				d +=	r.toString() + ' ' + g.toString() + ' ' + b.toString() + ' ' +
						lut[ j ].toFixed(precision).toString() + ' ' +
						lut[j+1].toFixed(precision).toString() + ' ' +
						lut[j+2].toFixed(precision).toString() + "\n";
			}
		}
	}
	return {
		lut: this.header(info) + d,
		fileName: fileName,
		ext: ext
	};
};
spi3dLUT.prototype.header = function(info) {
	var out = 'SPILUT 1.0' + "\n";
	out += '3 3' + "\n";
	out += info.dimension.toString() + ' ' + info.dimension.toString() + ' ' + info.dimension.toString() + "\n";
	return out;
};
spi3dLUT.prototype.parse = function(title, text, lutMaker, lutDest) {
	var dimensions = false;
	var size = false;
	var minimum = [0,0,0];
	var maximum = [1,1,1];
	var max = text.length;
	if (max === 0) {
		return false;
	}
	var line = text[0].trim();
	var lower = line.toLowerCase();
	if (lower.search('spilut') >= 0) {
		var i;
		for (i=0; i<max; i++) {
			line = text[i].trim();
			lower = line.toLowerCase();
			j = line.charAt(0);
			if ((!isNaN(parseFloat(j)) && isFinite(j))) {
				var vals = line.split(/\s+/g);
				if (vals.length === 2) {
					// currently unknown now to handle '3 3' line
					dimensions = 3;
				} else if (vals.length === 3) {
					if (!isNaN(vals[0]) && !isNaN(vals[1]) && !isNaN(vals[2])) {
						// can have different sizes for each colour channel - hmmmm.
						size = [parseInt(vals[0]),parseInt(vals[1]),parseInt(vals[2])];
						// for now, LUTCalc can't handle 3D LUTs with multiple sizes
						if (size[0] !== size[1] || size[1] !== size[2] || size[2] !== size[0]) {
							return false;
						}
					}
				} else if (vals.length > 3) {
					// stop parsing when the LUT data is reached
					break;
				}
			}
		}
		if (dimensions && size) {
			var arraySize = size;
			if (dimensions === 3) {
				arraySize = size[0]*size[1]*size[2];
			}
			var R = new Float64Array(arraySize);
			var G = new Float64Array(arraySize);
			var B = new Float64Array(arraySize);
			var s;
			var t=0;
			for (var k=i; k<max; k++) {
				var line = text[k].trim();
				var j = line.charAt(0);
				if ((!isNaN(parseFloat(j)) && isFinite(j)) || j === '-') {
					var vals = line.split(/\s+/g);
					if (vals.length === 6 && (!isNaN(vals[0]) && !isNaN(vals[1]) && !isNaN(vals[2]) && !isNaN(vals[3]) && !isNaN(vals[4]) && !isNaN(vals[5]))) {
						s = parseInt(vals[0]) + (parseInt(vals[1])*size[0]) + (parseInt(vals[2])*size[0]*size[1]);
						R[s] = parseFloat(vals[3]);
						G[s] = parseFloat(vals[4]);
						B[s] = parseFloat(vals[5]);
						t++;
					}
				}
			}
			if (t === arraySize) {
				return lutMaker.setLUT(
					lutDest,
					{
						title: title,
						format: 'spi3d',
						dims: dimensions,
						s: size[0],
						min: minimum,
						max: maximum,
						C: [R.buffer,G.buffer,B.buffer]
					}
				);
/*
				lut.setDetails({
					title: title,
					format: 'spi3d',
					dims: dimensions,
					s: size[0],
					min: minimum,
					max: maximum,
					C: [R.buffer,G.buffer,B.buffer]
				});
				return true;
*/
			} else {
				return false;
			}
		} else {
			return false;
		}
	} else {
		return false;
	}
};
/* lut-ncp.js
* Nikon custom picture .ncp building for the LUTCalc Web App.
* 3rd June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*
* NCP file structure suggested by 'coderat' on this thread: https://nikonhacker.com/viewtopic.php?t=1803
*/
function ncpLUT(messages, isLE) {
	this.messages = messages;
	this.isLE = isLE;
	this.profileName = [
		'Nikon Vivid',
		'Nikon Standard',
		'Nikon Neutral',
		'Nikon D2X Mode 1',
		'Nikon D2X Mode 2',
		'Nikon D2X Mode 3',
		'Nikon Portrait',
		'Nikon Landscape',
		'Nikon Monochrome'
	];
	this.profileCode = new Uint16Array([
		0x00C3,
		0x0001,
		0x03C2,
		0x0014,
		0x03D5,
		0x00D6,
		0x0486,
		0x04C7,
		0x064D
	]);
}
ncpLUT.prototype.build = function(buff, fileName, ext) {
	var lut = new Float64Array(buff);
	var info = {};
	this.messages.getInfo(info);
	var m = lut.length;
	var y;
	var yMin = 999;
	var yMax = -999;
	for (var j=0; j<m; j += 3) {
		y = (0.2126 * lut[ j ]) + (0.7152 * lut[j+1]) + (0.0722 * lut[j+2]);
		if (y < yMin) {
			yMin = y;
		}
		if (y > yMax) {
			yMax = y;
		}
	}
	if (yMin < 0) {
		yMin = 0;
	}
	if (yMax > 1) {
		yMax = 1;
	}
	var yScale = 1/(yMax - yMin);
	var h = new Uint8Array(64);
	this.header(h, Math.round(yMin*255), Math.round(yMax*255), info);
	var p = new Uint8Array(58);
	p[0] = 18;
	var k = 0;
	var i = 0;
	for (var j=0; j<18; j++) {
		i = j * 15;
		p[k+1] = i;
		p[k+2] = Math.min(255,Math.max(0,Math.round(((
			(0.2126 * (lut[ (i*3) ])) +
			(0.7152 * (lut[(i*3)+1])) +
			(0.0722 * (lut[(i*3)+2]))
		)-yMin)*yScale*255)));
		k += 2;
	}
	var d = new Uint8Array(512);
	k=0;
	for (var j=0; j<m; j += 3) {
		d.set(this.beShort(Math.min(32767,Math.max(0,Math.round((
			(0.2126 * lut[ j ]) +
			(0.7152 * lut[j+1]) +
			(0.0722 * lut[j+2])
		)*32767)))),k);
		k += 2;
	}
	var out = new Uint8Array(h.length + p.length + d.length + 4);
	out.set(h);
	out.set(p,h.length);
	out.set(d,h.length + p.length);
	var bank;
	if (info.nikonBank < 10) {
		bank = '0' + info.nikonBank.toString();
	} else {
		bank = info.nikonBank.toString();
	}
	return {
		lut: out,
		fileName: 'PICCON' + bank,
		ext: 'NCP'
	};
};
ncpLUT.prototype.header = function(out, yMin, yMax, info) {
	var t = new Uint32Array(out.buffer);
	var s = new Uint16Array(out.buffer);
	var k = 0;
// Signature - hex codes for padded 'NCP' in 32-bit big endian
	out.set(this.beWord(0x4E435000),k);
	k += 4;
// First block head
	out.set(this.beWord(1),k);					// Block of data number 1
	k += 4;
	out.set(this.beWord(36),k); 				// Size of this block
	k += 4;
// Data
	this.beString('0100',out,k);				// Version
	k += 4;
	var title = info.name;
	if (title.length > 20) {
		title = title.substr(0,20);
	} else if (title.length === 0) {
		title = 'LUTCalc';
	}
	this.beString(title,out,k);					// Title
	k += 20;
	var profile = 2;
	var m = this.profileName.length;
	for (var j=0; j<m; j++) {
		if (info.inGammaName === this.profileName[j]) {
			profile = j;
			break;
		}
	}
	out.set(this.beShort(this.profileCode[profile]),k);	// Nikon profile code
	k += 2;
	out.set(this.beShort(0x02FF),k);			// Tell camera that the values have been modified
	k += 2;
	out[k] = info.nikonSharp + 0x80;			// Sharpening 0
	k++;
	out[k] = 1;									// Use LUT table for contrast
	k++;
	out[k] = 1;									// Use LUT table for brightness
	k++;
	out[k] = info.nikonSat + 0x80;				// Saturation 0
	k++;
	out[k] = info.nikonHue + 0x80;				// Hue 0
	k++;
	out[k] = 0xFF;								// Monochrome Filter N/A
	k++;
	out[k] = 0xFF;								// Monochrome Toning N/A
	k++;
	out[k] = 0xFF;								// Monochrome Toning Strength N/A
	k++;
// Second block head
	out.set(this.beWord(2),k);					// Block of data number 2
	k += 4;
	out.set(this.beWord(578),k); 				// Size of this block
	k += 4;
// Data
	out[k] = 0x49;								// ** Got to find out what these ones mean - 'I'? **
	k++;
	out[k] = 0x30;								// ** As above - '0'? **
	k++;
	out[k] = 0;									// Input Black = 0
	k++;
	out[k] = 0xFF;								// Input White = 255
	k++;
	out[k] = yMin;								// Output Black = lowest value in LUT data * 255
	k++;
	out[k] = yMax;								// Output White = highest value in LUT data * 255
	k++;
	out[k] = 1;									// Gamma value integer part (halftone point) - keep it simple!
	k++;
	out[k] = 0;									// Gamma value decimal part (halftone point)
	k++;
// The rest is the polynomial table (compressed LUT) and full 255-point LUT so return the header
	return out;
};
ncpLUT.prototype.beWord = function(input) {
// Turn values into 4-byte big-endian words
	var t = new Uint32Array([input]);
	var e = new Uint8Array(t.buffer);
	if (this.isLE) {
		return new Uint8Array([e[3],e[2],e[1],e[0]]);
	} else {
		return e;
	}
};
ncpLUT.prototype.beShort = function(input) {
// Turn values into 16-bit big-endian short
	var t = new Uint16Array([input]);
	var e = new Uint8Array(t.buffer);
	if (this.isLE) {
		return new Uint8Array([e[1],e[0]]);
	} else {
		return e;
	}
};
ncpLUT.prototype.beString = function(text,out,idx) {
	var m = text.length;
	for (var j=0; j<m; j++) {
		out[idx + j] = text.charCodeAt(j);
	}
};
/* lut-la.js
* .lacube and .labin building / parsing for the LUTCalc Web App.
* 3rd June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function lacubeLUT(messages, isLE) {
	this.messages = messages;
	this.isLE = isLE;
}
lacubeLUT.prototype.build = function(title, tfBuff, csBuff, params) {
	var tf = new Float64Array(tfBuff);
	var cs;
	// Metadata defaults
	var in1DTF = 'S-Log3'; // system default
	var in1DRG = '109'; // system default
	var in3DTF = 'S-Log3'; // system default
	var in3DCS = 'Sony S-Gamut3.cine'; // system default
	var sysCS = 'Sony S-Gamut3.cine'; // system default
	var in3DRG = '109'; // system default
	// Precision
	var precision = this.messages.getPrecision();	
	// 1D Transfer function
	if (typeof params.in1DTF !== 'undefined') {
		in1DTF = params.in1DTF;
	}
	if (typeof params.in1DEX === 'boolean' && !params.in1DEX) {
		in1DRG = '100';
	}
	var out =	'# LUT Analyst LA LUT File -------------------------------------------------------' + "\n";
	out +=		'TITLE "' + title + '"' + "\n" +
				'LUT_1D_SIZE ' + tf.length.toString() + "\n" +
				'# LUT Analyst - 1D Transfer Function Shaper - ' + in1DTF + '->' + title + ' Gamma' + "\n";
	if (typeof params.baseISO === 'number') {
		out +=	'# LA_BASE_ISO ' + params.baseISO + "\n";
	}
	out +=  '# LA_INPUT_TRANSFER_FUNCTION ' + params.in1DTF + "\n";
	out +=  '# LA_INPUT_RANGE ' + in1DRG + "\n";
	if (typeof params.in1DMin === 'number') {
		out +=	'# LA_INPUT_MIN ' + params.in1DMin + "\n";
	}
	if (typeof params.in1DMax === 'number') {
		out +=	'# LA_INPUT_MAX ' + params.in1DMax + "\n";
	}
	var m = tf.length;
	for (var j=0; j<m; j++) {
		out += tf[j].toFixed(precision).toString() + "\t" + tf[j].toFixed(precision).toString() + "\t" + tf[j].toFixed(precision).toString() + "\n";
	}
	// 3D Colourspace if present
	if (typeof csBuff !== 'undefined' && csBuff) {
		if (typeof params.in3DTF !== 'undefined') {
			in3DTF = params.in3DTF;
		}
		if (typeof params.in3DCS !== 'undefined') {
			in3DCS = params.in3DCS;
		}
		if (typeof params.sysCS !== 'undefined') {
			in3DCS = params.sysCS;
		}
		if (typeof params.in3DEX === 'boolean' && !params.in3DEX) {
			in3DRG = '100';
		}
		cs = [	new Float64Array(csBuff[0]),
				new Float64Array(csBuff[1]),
				new Float64Array(csBuff[2])];
		out +=		'# -------------------------------------------------------------------------------' + "\n";
		out +=  	'TITLE "' + title + '"' + "\n" +
					'LUT_3D_SIZE ' + Math.round(Math.pow(cs[0].length,1/3)).toString() + "\n" +
					'# LUT Analyst - 3D Colour Space Transform - ' + in3DCS + '->' + title + ' Colour' + "\n";
		if (typeof params.interpolation === 'number') {
			switch (params.interpolation) {
				case 0: out +=	'# LA_INTERPOLATION TRICUBIC' + "\n";
					break;
				case 1: out +=	'# LA_INTERPOLATION TETRAHEDRAL' + "\n";
					break;
				case 2: out +=	'# LA_INTERPOLATION TRILINEAR' + "\n";
					break;
			}
		}
		if (typeof params.baseISO === 'number') {
			out +=	'# LA_BASE_ISO ' + params.baseISO + "\n";
		}
		out +=  '# LA_INPUT_TRANSFER_FUNCTION ' + in3DTF + "\n";
		out +=  '# LA_SYSTEM_COLOURSPACE ' + sysCS + "\n";
		out +=  '# LA_INPUT_COLOURSPACE ' + in3DCS + "\n";
		out +=  '# LA_INPUT_RANGE ' + in3DRG + "\n";
		if (typeof params.in3DMin === 'number') {
			out +=	'# LA_INPUT_MIN ' + params.in3DMin + "\n";
		}
		if (typeof params.in3DMax === 'number') {
			out +=	'# LA_INPUT_MAX ' + params.in3DMax + "\n";
		}
		if (typeof params.inputMatrix !== 'undefined') {
			out +=  '# LA_INPUT_MATRIX_R ' + params.inputMatrix[0] + "\t" + params.inputMatrix[1] + "\t" + params.inputMatrix[2] + "\n";
			out +=  '# LA_INPUT_MATRIX_G ' + params.inputMatrix[3] + "\t" + params.inputMatrix[4] + "\t" + params.inputMatrix[5] + "\n";
			out +=  '# LA_INPUT_MATRIX_B ' + params.inputMatrix[6] + "\t" + params.inputMatrix[7] + "\t" + params.inputMatrix[8] + "\n";
		}
		m = cs[0].length;
		for (var j=0; j<m; j++) {
			out += cs[0][j].toFixed(precision).toString() + "\t" + cs[1][j].toFixed(precision).toString() + "\t" + cs[2][j].toFixed(precision).toString() + "\n";
		}
	}
	return out;
};
lacubeLUT.prototype.parse = function(title, text, lutMaker, gammaDest, gamutDest) {
	var max = text.length;
	var parsed = false;
	if (max === 0) {
		return false;
	}
	var gammaText = '';
	var gamutText = '';
	var both = true;
	for (var i = 0; i < max; i++) {
		if (text[i].search('# -------------------------------------------------------------------------------') >= 0) {
			gammaText = text.slice(1,i);
			gamutText = text.slice(i+1,max);
			break;
		} else if (i === max - 1) {
			gammaText = text.slice(0);
			both = false;
		}
	}
	var gammaCube = new cubeLUT(this.messages, this.isLE);
	parsed = gammaCube.parse(title, gammaText, lutMaker, gammaDest);
	if (parsed) {
		if (both) {
			var gamutCube = new cubeLUT(this.messages, this.isLE);
			parsed = gamutCube.parse(title, gamutText, lutMaker, gamutDest);
		} else {
			lutMaker.noCS();
		}
	}
	return parsed;
};
function labinLUT(messages, isLE) {
	this.messages = messages;
	this.isLE = isLE;
}
labinLUT.prototype.build = function(title, tfBuff, csBuff, params) {
	var tf = new Float64Array(tfBuff);
	var tfSize = tf.length;
	var out64;
	var cs,csSize;
	if (typeof csBuff !== 'undefined' && csBuff) {
		cs = [	new Float64Array(csBuff[0]),
				new Float64Array(csBuff[1]),
				new Float64Array(csBuff[2]) ];
		csSize = cs[0].length;
		out64 = new Float64Array(2 + tfSize + (3*csSize));
	} else {
		csSize = 0;
		out64 = new Float64Array(2 + tfSize);
	}
	var dim = out64.length;
// Prep input matrix as required (all zeros means no matrix specified)
	var inputMatrix = new Int32Array(9);
	if (typeof params.inputMatrix !== 'undefined') {
		for (var j=0; j<9; j++) {
			if (params.inputMatrix[j] > 19.9) {
				inputMatrix[j] = 2136746230;
				// maximum value for a signed 32-bit int is 2147483647, so leaves a bit of room
				// - and eight digits precision.
			} else if (params.inputMatrix[j] < -19.9) {
				inputMatrix[j] = -2136746230;
			} else {
				inputMatrix[j] = Math.round(params.inputMatrix[j]*107374182.4);
			}
		}
	}
// Prep input transfer function and colourspace info to add to the end of the file as required
	var in1DTF = 'S-Log3'; // system default
	var in1DRG = '109';
	var in1DMin = '0';
	var in1DMax = '1';
	var in3DTF = 'S-Log3'; // system default
	var sysCS = 'Sony S-Gamut3.cine'; // system default
	var in3DCS = 'Sony S-Gamut3.cine'; // system default
	var in3DRG = '109';
	var in3DMin = '0';
	var in3DMax = '1';
	var interpolation = 'unknown';
	var baseISO = 'unknown';
	if (typeof params.in1DTF !== 'undefined') {
		in1DTF = params.in1DTF.replace(/γ/gi,'^');
	}
	if (typeof params.in1DEX === 'boolean' && !params.in1DEX) {
		in1DRG = '100';
	}
	if (typeof params.in1DMin === 'number') {
		in1DMin = params.in1DMin.toFixed(10).toString();
	}
	if (typeof params.in1DMax === 'number') {
		in1DMax = params.in1DMax.toFixed(10).toString();
	}
	if (typeof params.sysCS !== 'undefined') {
		sysCS = params.sysCS;
	}
	if (typeof params.in3DTF !== 'undefined') {
		in3DTF = params.in3DTF.replace(/γ/gi,'^');
	}
	if (typeof params.in3DCS !== 'undefined') {
		in3DCS = params.in3DCS;
	}
	if (typeof params.in3DEX === 'boolean' && !params.in3DEX) {
		in3DRG = '100';
	}
	if (typeof params.in3DMin === 'number') {
		in3DMin = params.in3DMin.toFixed(10).toString();
	}
	if (typeof params.in3DMax === 'number') {
		in3DMax = params.in3DMax.toFixed(10).toString();
	}
	if (typeof params.interpolation === 'number') {
		switch (params.interpolation) {
			case 0: interpolation = 'tricubic';
				break;
			case 1: interpolation = 'tetrahedral';
				break;
			case 2: interpolation = 'trilinear';
				break;
		}
	}
	if (typeof params.baseISO === 'number') {
		baseISO = params.baseISO.toString();
	}
	var inMeta = '1DTF|' + in1DTF +
				 '|1DRG|' + in1DRG +
				 '|1DMIN|' + in1DMin +
				 '|1DMAX|' + in1DMax +
				 '|SYSCS|' + sysCS +
				 '|3DTF|' + in3DTF +
				 '|3DCS|' + in3DCS +
				 '|3DRG|' + in3DRG +
				 '|3DMIN|' + in3DMin +
				 '|3DMAX|' + in3DMax +
				 '|INTERPOLATION|' + interpolation +
				 '|BASEISO|' + baseISO;
	var curChar;
	var m = inMeta.length;
	var metaArray =	[];
	for (var j=0; j<m; j++) { // convert colourspace title string to ASCII code values (ie remove all above code 127);
		curChar = inMeta.charCodeAt(j);
		if (curChar < 128) {
			metaArray.push(curChar);
		}
	}
	var pad = metaArray.length%4;
	if (pad !== 0) {
		pad = 4-pad;
		var space = ' ';
		for (var j=0; j<pad; j++) {
			metaArray.push(space.charCodeAt(0));
		}
	}
	var meta = new Uint8Array(metaArray);
	var metaLength = meta.length;
//
	var out = new Int32Array(dim + 9 + Math.round(metaLength/4)); // internal processing is done on Float64s, files are scaled Int32s for same precision / smaller size
	out64.set(tf,2);
	out[0] = tfSize;
	if (csBuff) {
		out64.set(cs[0], 2 + tfSize);
		out64.set(cs[1], 2 + tfSize + csSize);
		out64.set(cs[2], 2 + tfSize + (2*csSize));
		out[1] = Math.round(Math.pow(csSize,1/3));
	} else {
		out[1] = 0;
	}
	for (var j=2; j<dim; j++) {
		if (out64[j] > 1.99) {
			out[j] = 2136746230;
			// maximum value for a signed 32-bit int is 2147483647, so leaves a bit of room
			// - and nine digits precision - roughly two more than Float32 within -2<x<2.
		} else if (out64[j] < -1.99) {
			out[j] = -2136746230;
		} else {
			out[j] = Math.round(out64[j]*1073741824);
		}
	}
	for (var j=0; j<9; j++) {
		out[j+dim] = inputMatrix[j];
	}
	var byteOut = new Uint8Array(out.buffer);
	var i;
  	if (!this.isLE) { // files are little endian, swap if system is big endian
		console.log('Big Endian System');
  		var lutArr = byteOut;
  		var max = Math.round(lutArr.length / 4); // Float32s === 4 bytes
  		var b0,b1,b2,b3;
  		for (var j=0; j<max; j++) {
  			i = j*4;
  			b0=lutArr[ i ];
  			b1=lutArr[i+1];
  			b2=lutArr[i+2];
  			b3=lutArr[i+3];
  			lutArr[ i ] = b3;
  			lutArr[i+1] = b2;
  			lutArr[i+2] = b1;
  			lutArr[i+3] = b0;
  		}
  	}
// Append TF / CS titles to the end of the file
	i = byteOut.length - metaLength;
	for (var j=0; j<metaLength; j++) {
		byteOut[i+j] = meta[j];
	}
// Send back the complete byte array
  	return byteOut;
//  	return out.buffer;
};
labinLUT.prototype.parse = function(title, buff, lutMaker, gammaDest, gamutDest) {
	var lutArr = new Uint8Array(buff);
	if (!this.isLE) { // files are little endian, swap if system is big endian
		console.log('Gamut LUTs: Big Endian System');
		var max = Math.round(lutArr.length / 4); // Float32s === 4 bytes
		var i,b0,b1,b2,b3;
		for (var j=0; j<max; j++) {
			i = j*4;
			b0=lutArr[ i ];
			b1=lutArr[i+1];
			b2=lutArr[i+2];
			b3=lutArr[i+3];
			lutArr[ i ] = b3;
			lutArr[i+1] = b2;
			lutArr[i+2] = b1;
			lutArr[i+3] = b0;
		}
	}
	var in32 = new Int32Array(buff);
	// Internal processing is Float64, files are scaled Int32
	// 1D Transfer function
	var tfS = in32[0];
	var T = new Float64Array(tfS);
	for (var j=0; j<tfS; j++){
		T[j] = parseFloat(in32[2 + j])/1073741824;
	}
	var dataEnd = 2+tfS;
	// 3D Colourspace if present
	var dim = in32[1];
	var csS,C;
	if (dim > 0) {
		csS = dim*dim*dim;
		C = [	new Float64Array(csS),
				new Float64Array(csS),
				new Float64Array(csS) ];
		for (var j=0; j<csS; j++){
			C[0][j] = parseFloat(in32[((2+tfS)) + j])/1073741824;
			C[1][j] = parseFloat(in32[((2+tfS+csS)) + j])/1073741824;
			C[2][j] = parseFloat(in32[((2+tfS+(2*csS))) + j])/1073741824;
		}
		dataEnd = 2+tfS+(3*csS);
	}
	// get input matrix details (all zeros means no matrix defined)
	var inMX = new Float64Array(9);
	var imM = false;
	if (dataEnd < in32.length) {
		for (var j=0; j<9; j++) {
			if (in32[dataEnd+j] !== 0) {
				imM = true;
				inMX[j] = parseFloat(in32[dataEnd+j])/107374182.4;
			}
		}
		dataEnd += 9;
	}
	if (!imM) {
		inMX = false;
	}
	// look for metadata info at the end of the file if present
	var in1DTF = 'S-Log3'; // system default
	var in3DTF = 'S-Log3'; // system default
	var sysCS = 'Sony S-Gamut3.cine'; // system default
	var in3DCS = 'Sony S-Gamut3.cine'; // system default
	var in1DEX = true; // system default
	var in3DEX = true; // system default
	var in1DMin = [0,0,0];
	var in1DMax = [1,1,1];
	var in3DMin = [0,0,0];
	var in3DMax = [1,1,1];
	var interpolation = false;
	var baseISO = false;
	if (dataEnd < in32.length) {
		dataEnd *= 4;
		var fileEnd = lutArr.length;
		var metaString = '';
		for (var j=dataEnd; j<fileEnd; j++) {
			metaString += String.fromCharCode(lutArr[j]).replace('^','γ');
		}
		if (metaString.search('|') >= 0) {
			var meta = metaString.split('|');
			var m = meta.length;
			if (m > 2) {
				for (var j=0; j<m; j +=2) {
					switch (meta[j]) {
						case '1DTF':
							in1DTF = meta[j+1].trim();
							break;
				 		case '1DRG':
				 			if (meta[j+1].toLowerCase() === '100') {
								in1DEX = false;
							}
							break;
				 		case '1DMIN':
							in1DMin[0] = parseFloat(meta[j+1]);
							if (isNaN(in1DMin[0])) {
								in1DMin[0] = 0;
							} else {
								in1DMin[1] = in1DMin[0];
								in1DMin[2] = in1DMin[0];
							}
							break;
				 		case '1DMAX':
							in1DMax[0] = parseFloat(meta[j+1]);
							if (isNaN(in1DMax[0])) {
								in1DMax[0] = 1;
							} else {
								in1DMax[1] = in1DMax[0];
								in1DMax[2] = in1DMax[0];
							}
							break;
				 		case 'SYSCS':
							sysCS = meta[j+1].trim();
							break;
				 		case '3DTF':
				 			in3DTF = meta[j+1].trim();
							break;
				 		case '3DCS':
				 			in3DCS = meta[j+1].trim();
							break;
				 		case '3DRG':
				 			if (meta[j+1].toLowerCase() === '100') {
								in3DEX = false;
							}
							break;
				 		case '3DMIN':
							in3DMin[0] = parseFloat(meta[j+1]);
							if (isNaN(in3DMin[0])) {
								in3DMin[0] = 0;
							} else {
								in3DMin[1] = in3DMin[0];
								in3DMin[2] = in3DMin[0];
							}
							break;
				 		case '3DMAX':
							in3DMax[0] = parseFloat(meta[j+1]);
							if (isNaN(in3DMax[0])) {
								in3DMax[0] = 1;
							} else {
								in3DMax[1] = in3DMax[0];
								in3DMax[2] = in3DMax[0];
							}
							break;
				 		case 'INTERPOLATION':
							switch (meta[j+1].trim().toLowerCase()) {
								case 'tricubic': interpolation = 0;
									break;
								case 'tetrahedral': interpolation = 1;
									break;
								case 'trilinear': interpolation = 2;
									break;
							}
							break;
				 		case 'BASEISO':
				 			if (meta[j+1].trim().toLowerCase() !== 'unknown') {
					 			baseISO = parseInt(meta[j+1].trim());
					 		}
				 			break;
					}
				}
			} else {
				in1DTF = meta[0].trim();
				in3DCS = meta[1].trim();
			}
		} else {
			in3DCS = metaString;
		}
	}
	// generate the LUT(s)
	var tfOut = {
		title: title,
		format: 'cube',
		dims: 1,
		s: tfS,
		min: in1DMin,
		max: in1DMax,
		C: [T.buffer],
		meta: {
			inputTF: in1DTF,
			inputEX: in1DEX,
			baseISO: baseISO
		}
	};
	if (!lutMaker.setLUT(gammaDest,tfOut)) {
		return false;
	}
	if (dim > 0) {
		var csOut = {
			title: 'cs',
			format: 'cube',
			dims: 3,
			s: dim,
			min: in3DMin,
			max: in3DMax,
			C: [	C[0].buffer,
					C[1].buffer,
					C[2].buffer],
			meta: {
				inputTF: in3DTF,
				systemCS: sysCS,
				inputCS: in3DCS,
				inputEX: in3DEX,
				interpolation: interpolation,
				baseISO: baseISO,
				inputMatrix: inMX
			}
		};
		if (!lutMaker.setLUT(gamutDest,csOut)) {
			return false;
		}
	} else {
		lutMaker.noCS();
	}
	return true;
};
/* lutformats.js
* General LUT file format building / parsing object for the LUTCalc Web App.
* 3rd June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTFormats(inputs, messages, file) {
	this.inputs = inputs;
	this.messages = messages;
	this.p = 11;
	this.messages.addUI(this.p,this);
	this.file = file;
	this.curIdx = 0;
	this.curType = 0;
	this.lastGamma = -1;
	this.formats = [];
	this.types = [];
	this.exts = [];
	this.txt = [];
	this.mluts = [];
	this.grades = [];
	this.formatsList();
	this.mlutsList();
	this.gradesList();
	this.io();
}
LUTFormats.prototype.io = function() {
	this.inputs.addInput('laCube', new lacubeLUT(this.messages, this.inputs.isLE));
	this.inputs.addInput('laBin', new labinLUT(this.messages, this.inputs.isLE));
	var gradeSelect = document.createElement('select');
	var max = this.grades.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = j;
		option.appendChild(document.createTextNode(this.grades[j].title));
		gradeSelect.appendChild(option);
	}
	gradeSelect.className = 'lut-opt';
	this.inputs.addInput('gradeSelect', gradeSelect);
	var mlutSelect = document.createElement('select');
	max = this.mluts.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = j;
		option.appendChild(document.createTextNode(this.mluts[j].title));
		mlutSelect.appendChild(option);
	}
	mlutSelect.className = 'lut-opt-hide';
	this.inputs.addInput('mlutSelect', mlutSelect);
	this.inputs.addInput('bClip', 0);
	this.inputs.addInput('wClip', 67025937); // 1023 * 65519 (the largest integer representable with a 16-bit half float)
};
LUTFormats.prototype.events = function() {
	this.inputs.lutUsage[0].onclick = function(here){ return function(){
		here.gradeMLUT();
		here.messages.changeFormat();
	};}(this);
	this.inputs.lutUsage[1].onclick = function(here){ return function(){
		here.gradeMLUT();
		here.messages.changeFormat();
	};}(this);
	this.inputs.gradeSelect.onchange = function(here){ return function(){
		here.updateOptions();
		here.messages.changeFormat();
	};}(this);
	this.inputs.mlutSelect.onchange = function(here){ return function(){
		here.updateOptions();
		here.messages.changeFormat();
	};}(this);
};
LUTFormats.prototype.formatsList = function() {
	this.addFormat('cube1','cube',true,new cubeLUT(this.messages, this.inputs.isLE, 1));
	this.addFormat('cube2','cube',true,new cubeLUT(this.messages, this.inputs.isLE, 2));
	this.addFormat('cube3','cube',true,new cubeLUT(this.messages, this.inputs.isLE, 3));
	this.addFormat('vlt','vlt',true,new vltLUT(this.messages, this.inputs.isLE));
	this.addFormat('threedl1','3dl',true,new threedlLUT(this.messages, this.inputs.isLE, 1));
	this.addFormat('threedl2','3dl',true,new threedlLUT(this.messages, this.inputs.isLE, 2));
	this.addFormat('threedl3','3dl',true,new threedlLUT(this.messages, this.inputs.isLE, 3));
	this.addFormat('ilut','ilut',true,new davinciiLUT(this.messages, this.inputs.isLE));
	this.addFormat('olut','olut',true,new davincioLUT(this.messages, this.inputs.isLE));
	this.addFormat('lut','lut',true,new lutLUT(this.messages, this.inputs.isLE));
	this.addFormat('spi1d','spi1d',true,new spi1dLUT(this.messages, this.inputs.isLE));
	this.addFormat('spi3d','spi3d',true,new spi3dLUT(this.messages, this.inputs.isLE));
	this.addFormat('ncp','ncp',false,new ncpLUT(this.messages, this.inputs.isLE));
};
LUTFormats.prototype.addFormat = function(type,ext,txt,format) {
	this.types.push(type);
	this.exts.push(ext);
	this.txt.push(txt);
	this.formats.push(format);
};
LUTFormats.prototype.gradesList = function() {
	this.grades.push({
		title: 'General cube LUT (.cube)', type: 'cube1',
		oneD: true, threeD: true, defThree: true,
		oneDim: [1024,4096,16384], threeDim: [17,33,65],
		defDim: 33,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: false,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 0, wClip: 67025937, hard: false
	});
/*
	this.grades.push({
		title: 'LOGCalc', type: 'cube1',
		oneD: true, threeD: false, defThree: false,
		oneDim: [64,256,1024], threeDim: [],
		defDim: 256,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: false,
		defLegDat: false,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: -1023, wClip: 67025937, hard: false
	});
*/
/*
	this.grades.push({
		title: '1D List (.cube)', type: 'cube1',
		oneD: true, threeD: false, defThree: false,
		oneDim: [64,128,256], threeDim: [],
		defDim: 64,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: false,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 0, wClip: 67025937, hard: false
	});
*/
	this.grades.push({
		title: 'DaVinci Resolve 12+ (.cube)', type: 'cube2',
		oneD: true, threeD: true, defThree: true,
		oneDim: [1024,4096,16384], threeDim: [17,33,65],
		defDim: 65,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: false,
		defLegDat: false,
		scaling: true,
		setBits: false,
		resSDI: false,
		defMin: 0, defMax: 1.095,
		bClip: -1023, wClip: 67025937, hard: false
	});
	this.grades.push({
		title: 'DaVinci Resolve Old (.cube)', type: 'cube2',
		oneD: true, threeD: true, defThree: true,
		oneDim: [1024,4096,16384], threeDim: [17,33,65],
		defDim: 65,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: false,
		scaling: true,
		setBits: false,
		resSDI: false,
		bClip: -1023, wClip: 67025937, hard: false
	});
	this.grades.push({
		title: 'Lumetri / Speedgrade (.cube)', type: 'cube3',
		oneD: true, threeD: true, defThree: true,
		oneDim: [1024,4096,16384], threeDim: [16,32,64],
		defDim: 65,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: false,
		defLegDat: false,
		scaling: true,
		setBits: false,
		resSDI: false,
		defMin: 0, defMax: 1.095,
		bClip: -1023, wClip: 67025937, hard: false
	});
	this.grades.push({
		title: 'FCPX - Color Finale / LUT Utility (.cube)', type: 'cube3',
		oneD: false, threeD: true, defThree: true,
		oneDim: [], threeDim: [16,32,64],
		defDim: 32,
		someGammas: false,
		legIn: true, datIn: false, defLegIn: true,
		legOut: true, datOut: false, defLegOut: true,
		defLegDat: true,
		scaling: true,
		setBits: false,
		resSDI: false,
		bClip: 0, wClip: 67025937, hard: false
	});
	this.grades.push({
		title: 'AVID (.cube)', type: 'cube1',
		oneD: true, threeD: true, defThree: true,
		oneDim: [1024,4096,16384], threeDim: [17,33,65],
		defDim: 65,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: false,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 0, wClip: 1023, hard: false
	});
	this.grades.push({
		title: 'Display gamma correction (.cube)', type: 'cube1',
		oneD: true, threeD: true, defThree: false,
		oneDim: [1024,4096], threeDim: [17,33,65],
		defDim: 4096,
		someGammas: [
			'Linear / Basic Gamma',
			'PQ (90% Ref=300nits)','PQ (90% Ref=500nits)','PQ (90% Ref=800nits)','PQ (90% Ref=1000nits)','PQ (90% Ref=2000nits)','PQ (90% Ref=4000nits)',
			'ITU Proposal (400%)','ITU Proposal (800%)',
			'BBC WHP283 (400%)','BBC WHP283 (800%)'
		],
		someGammasSub: 'All',
		legIn: true, datIn: true, defLegIn: true,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 64, wClip: 67025937, hard: false
	});
	this.grades.push({
		title: 'DaVinci Resolve 1D (.ilut)', type: 'ilut',
		oneD: true, threeD: false, defThree: false,
		oneDim: [16384], threeDim: [],
		defDim: 16384,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: false,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 0, wClip: 67025937, hard: false
	});
	this.grades.push({
		title: 'DaVinci Resolve 1D (.olut)', type: 'olut',
		oneD: true, threeD: false, defThree: false,
		oneDim: [4096], threeDim: [],
		defDim: 4096,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: true,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 0, wClip: 1023, hard: false
	});
	this.grades.push({
		title: 'Assimilate 1D (.lut)', type: 'lut',
		oneD: true, threeD: false, defThree: false,
		oneDim: [4096], threeDim: [],
		defDim: 4096,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: false,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 0, wClip: 1023, hard: true
	});
	this.grades.push({
		title: 'Assimilate 3D (.3dl)', type: 'threedl1',
		oneD: false, threeD: true, defThree: true,
		oneDim: [], threeDim: [16,32,64],
		defDim: 32,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: false,
		scaling: false,
		setBits: true, inBits: 10, outBits: 12,
		resSDI: false,
		bClip: 0, wClip: 1023, hard: true
	});
	this.grades.push({
		title: 'SPI 3D (.spi3d)', type: 'spi3d',
		oneD: false, threeD: true, defThree: true,
		oneDim: [], threeDim: [16,32,64],
		defDim: 32,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: false,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 0, wClip: 67025937, hard: false
	});
	this.grades.push({
		title: 'SPI 1D (.spi1d)', type: 'spi1d',
		oneD: true, threeD: false, defThree: false,
		oneDim: [4096,16384], threeDim: [],
		defDim: 4096,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: false,
		scaling: true,
		setBits: false,
		resSDI: false,
		bClip: -1023, wClip: 67025937, hard: false
	});
	this.grades.push({
		title: 'Flame 3D (.3dl)', type: 'threedl1',
		oneD: false, threeD: true, defThree: true,
		oneDim: [], threeDim: [17,33,65],
		defDim: 17,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: false,
		scaling: false,
		setBits: true, inBits: 10, outBits: 12,
		resSDI: false,
		bClip: 0, wClip: 1023, hard: true
	});
	this.grades.push({
		title: 'Lustre 3D (.3dl)', type: 'threedl2',
		oneD: false, threeD: true, defThree: true,
		oneDim: [], threeDim: [17,33,65],
		defDim: 33,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: false,
		scaling: false,
		setBits: true, inBits: 10, outBits: 12,
		resSDI: false,
		bClip: 0, wClip: 1023, hard: true
	});
	this.grades.push({
		title: 'Kodak 3D (.3dl)', type: 'threedl3',
		oneD: false, threeD: true, defThree: true,
		oneDim: [], threeDim: [17,33,65],
		defDim: 17,
		someGammas: false,
		legIn: true, datIn: true, defLegIn: false,
		legOut: true, datOut: true, defLegOut: true,
		defLegDat: false,
		scaling: false,
		setBits: true, inBits: 10, outBits: 12,
		resSDI: false,
		bClip: 0, wClip: 1023, hard: true
	});
	var max = this.grades.length;
	var max2 = this.types.length;
	for (var j=0; j<max; j++) {
		for (var k=0; k<max2; k++) {
			if (this.grades[j].type === this.types[k]) {
				this.grades[j].idx = k;
				break;
			}
		}
	}
};
LUTFormats.prototype.mlutsList = function() {
	this.mluts.push({
		title: 'Sony User 3D MLUT (.cube)', type: 'cube1',
		oneD: false, threeD: true, defThree: true,
		oneDim: [], threeDim: [17,33],
		defDim: 33,
		someGammas: ['S-Log3','S-Log2','S-Log'],
		someGammasSub: 'Sony',
		legIn: false, datIn: true, defLegIn: false,
		legOut: true, datOut: false, defLegOut: true,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: 1,
		bClip: 64, wClip: 1019, hard: false
	});
	this.mluts.push({
		title: 'SmallHD 3D MLUT (.cube)', type: 'cube1',
		oneD: false, threeD: true, defThree: true,
		oneDim: [], threeDim: [17, 33],
		defDim: 33,
		someGammas: false,
		legIn: false, datIn: true, defLegIn: false,
		legOut: false, datOut: true, defLegOut: false,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 64, wClip: 1019, hard: true
	});
	this.mluts.push({
		title: 'Zacuto Gratical 1D MLUT (.cube)', type: 'cube1',
		oneD: true, threeD: false, defThree: false,
		oneDim: [1024], threeDim: [],
		defDim: 1024,
		someGammas: false,
		legIn: false, datIn: true, defLegIn: false,
		legOut: false, datOut: true, defLegOut: false,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 64, wClip: 1019, hard: true
	});
	this.mluts.push({
		title: 'AJA LUT-box SMPTE (.cube)', type: 'cube3',
		oneD: true, threeD: true, defThree: true,
		oneDim: [1024,4096], threeDim: [16,17],
		defDim: 17,
		someGammas: false,
		legIn: true, datIn: false, defLegIn: true,
		legOut: true, datOut: false, defLegOut: true,
		defLegDat: true,
		scaling: true,
		setBits: false,
		resSDI: false,
		bClip: 64, wClip: 1019, hard: true
	});
	this.mluts.push({
		title: 'Scopebox Clipped MLUT (.cube)', type: 'cube1',
		oneD: true, threeD: true, defThree: true,
		oneDim: [256,1024], threeDim: [17,33],
		defDim: 33,
		someGammas: false,
		legIn: true, datIn: false, defLegIn: true,
		legOut: true, datOut: false, defLegOut: true,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 64, wClip: 1019, hard: true
	});
	this.mluts.push({
		title: 'Scopebox Unclipped MLUT (.cube)', type: 'cube1',
		oneD: true, threeD: true, defThree: true,
		oneDim: [256,1024], threeDim: [17,33],
		defDim: 33,
		someGammas: false,
		legIn: true, datIn: false, defLegIn: true,
		legOut: true, datOut: false, defLegOut: true,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 64, wClip: 1019, hard: false
	});
	this.mluts.push({
		title: 'Varicam 3D MLUT (.vlt)', type: 'vlt',
		oneD: false, threeD: true, defThree: true,
		oneDim: [], threeDim: [17],
		defDim: 17,
		someGammas: false,
		legIn: false, datIn: true, defLegIn: false,
		legOut: false, datOut: true, defLegOut: false,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 64, wClip: 1019, hard: true
	});
	this.mluts.push({
		title: 'Nikon Custom Picture (.ncp)', type: 'ncp',
		oneD: true, threeD: false, defThree: false,
		oneDim: [256], threeDim: [],
		defDim: 256,
		someGammas: ['Nikon Standard','Nikon Neutral','Nikon Vivid','Nikon Monochrome','Nikon Portrait','Nikon Landscape'],
		someGammasSub: 'Nikon',
		legIn: true, datIn: false, defLegIn: true,
		legOut: true, datOut: false, defLegOut: true,
		defLegDat: true,
		scaling: false,
		setBits: false,
		resSDI: false,
		bClip: 64, wClip: 1019, hard: true
	});
	var max = this.mluts.length;
	var max2 = this.types.length;
	for (var j=0; j<max; j++) {
		for (var k=0; j<max2; k++) {
			if (this.mluts[j].type === this.types[k]) {
				this.mluts[j].idx = k;
				break;
			}
		}
	}
};
LUTFormats.prototype.validExts = function() {
	return this.exts.slice(0);
};
LUTFormats.prototype.isTxt = function() {
	return this.txt.slice(0);
};
LUTFormats.prototype.gradeMLUT = function() {
	if (this.inputs.lutUsage[0].checked) {
		this.inputs.gradeSelect.className = 'lut-opt';
		this.inputs.mlutSelect.className = 'lut-opt-hide';
	} else {
		this.inputs.gradeSelect.className = 'lut-opt-hide';
		this.inputs.mlutSelect.className = 'lut-opt';
	}
	this.updateOptions();
};
LUTFormats.prototype.oneOrThree = function() {
	var cur;
	if (this.inputs.lutUsage[0].checked) {
		var idx = parseInt(this.inputs.gradeSelect.options[this.inputs.gradeSelect.selectedIndex].value);
		cur = this.grades[idx];
	} else {
		var idx = parseInt(this.inputs.mlutSelect.options[this.inputs.mlutSelect.selectedIndex].value);
		cur = this.mluts[idx];
	}
	// 1D or 3D
	if (this.inputs.d[0].checked) {
		this.inputs.oneDBox.className = 'graybox';
		this.inputs.threeDBox.className = 'graybox-hide';
		if (!cur.defThree) {
			var max = cur.oneDim.length;
			for (var j=0; j<max; j++) {
				if (cur.oneDim[j] === cur.defDim) {
					this.inputs.dimension[j].checked = true;
				}
			}
		} else {
			var oneM = cur.oneDim.length;
			if (oneM > 2) {
				this.inputs.dimension[1].checked = true;
			} else {
				this.inputs.dimension[cur.oneDim.length-1].checked = true;
			}
		}
	} else {
		this.inputs.oneDBox.className = 'graybox-hide';
		this.inputs.threeDBox.className = 'graybox';
		if (cur.defThree) {
			var max = cur.threeDim.length;
			for (var j=0; j<max; j++) {
				if (cur.threeDim[j] === cur.defDim) {
					this.inputs.dimension[j+3].checked = true;
				}
			}
		} else {
			if (cur.threeDim.length > 1) {
					this.inputs.dimension[4].checked = true;
			} else {
					this.inputs.dimension[3].checked = true;
			}
		}
	}
};
LUTFormats.prototype.clearSelect = function(sel) {
	var m = sel.options.length;
	for (var j=0; j<m; j++) {
		sel.remove(0);
	}
};
LUTFormats.prototype.updateOptions = function() {
	var curIdx = this.curIdx;
	var changedType = false;
	var cur, idx;
	if (this.inputs.lutUsage[0].checked) {
		if (this.curType === 1) {
			changedType = true;
			this.curType = 0;
		}
		idx = parseInt(this.inputs.gradeSelect.options[this.inputs.gradeSelect.selectedIndex].value);
		cur = this.grades[idx];
	} else {
		if (this.curType === 0) {
			changedType = true;
			this.curType = 1;
		}
		idx = parseInt(this.inputs.mlutSelect.options[this.inputs.mlutSelect.selectedIndex].value);
		cur = this.mluts[idx];
	}
	// Special settings for particular formats
	if (cur.type === 'ncp') {
		this.inputs.nikonBox.className = 'emptybox';
	} else {
		this.inputs.nikonBox.className = 'emptybox-hide';
	}	
	// Check if all input gamma options are allowed and enable / disable as appropriate
	if (cur.someGammas) {
		var max = this.inputs.inGammaSubOpts.length;
		for (var j=0; j<max; j++) {
			if (this.inputs.inGammaSubOpts[j].lastChild.nodeValue === cur.someGammasSub) {
				this.clearSelect(this.inputs.inGammaSubs);
				this.inputs.inGammaSubs.appendChild(this.inputs.inGammaSubOpts[j]);
				break;
			}
		}
		this.messages.updateGammaInList();
		max = this.inputs.inGamma.options.length-1;
		var max2 = cur.someGammas.length;
		var drop;
		for (var j=max; j>=0; j--) {
			drop = true;
			for (var k=0; k<max2; k++) {
				if (this.inputs.inGamma.options[j].lastChild.nodeValue === cur.someGammas[k]) {
					drop = false;
					break;
				}
			}
			if (drop) {
				this.inputs.inGamma.remove(j);
			}
		}
	} else {
		var max = this.inputs.inGammaSubOpts.length;
		var curInSub = this.inputs.inGammaSubs.options[this.inputs.inGammaSubs.selectedIndex].lastChild.nodeValue;
		var curInSubIdx = 0;
		this.clearSelect(this.inputs.inGammaSubs);
		for (var j=0; j<max; j++) {
			this.inputs.inGammaSubs.appendChild(this.inputs.inGammaSubOpts[j]);
			if (this.inputs.inGammaSubOpts[j].lastChild.nodeValue === curInSub) {
				curInSubIdx = j;
			}
		}
		this.inputs.inGammaSubOpts[curInSubIdx].selected = true;
		this.messages.updateGammaInList();
	}
	// 1D or 3D
	this.inputs.d[0].disabled = !cur.oneD;
	this.inputs.d[1].disabled = !cur.threeD;
	if (idx !== curIdx || changedType) { // Set to default only if the LUT format has changed
		if (cur.defThree) {
			this.inputs.oneDBox.className = 'graybox-hide';
			this.inputs.threeDBox.className = 'graybox';
			this.inputs.d[1].checked = true;
		} else {
			this.inputs.oneDBox.className = 'graybox';
			this.inputs.threeDBox.className = 'graybox-hide';
			this.inputs.d[0].checked = true;
		}
	}
	// 1D size options
	if (idx !== curIdx || changedType) { // Set to default only if the LUT format has changed
		var dim;	
		this.inputs.dimension[0].className = 'lut-opt-hide';
		this.inputs.dimensionLabel[0].className = 'lut-opt-hide';
		this.inputs.dimension[1].className = 'lut-opt-hide';	
		this.inputs.dimensionLabel[1].className = 'lut-opt-hide';
		this.inputs.dimension[2].className = 'lut-opt-hide';	
		this.inputs.dimensionLabel[2].className = 'lut-opt-hide';
		if (cur.oneDim.length > 0) {
			dim = cur.oneDim[0].toString();
			this.inputs.dimension[0].value = dim;
			if (cur.defDim === cur.oneDim[0]) {
				this.inputs.dimension[0].checked = true;
			}
			this.inputs.dimensionLabel[0].removeChild(this.inputs.dimensionLabel[0].firstChild);
			this.inputs.dimensionLabel[0].appendChild(document.createTextNode(dim));
			this.inputs.dimension[0].className = 'lut-opt';
			this.inputs.dimensionLabel[0].className = 'lut-opt';
		}
		if (cur.oneDim.length > 1) {
			dim = cur.oneDim[1].toString();
			this.inputs.dimension[1].value = dim;
			if (cur.defDim === cur.oneDim[1]) {
				this.inputs.dimension[1].checked = true;
			}
			this.inputs.dimensionLabel[1].removeChild(this.inputs.dimensionLabel[1].firstChild);
			this.inputs.dimensionLabel[1].appendChild(document.createTextNode(dim));
			this.inputs.dimension[1].className = 'lut-opt';
			this.inputs.dimensionLabel[1].className = 'lut-opt';
		}
		if (cur.oneDim.length === 3) {
			dim = cur.oneDim[2].toString();
			this.inputs.dimension[2].value = dim;
			if (cur.defDim === cur.oneDim[2]) {
				this.inputs.dimension[2].checked = true;
			}
			this.inputs.dimensionLabel[2].removeChild(this.inputs.dimensionLabel[2].firstChild);
			this.inputs.dimensionLabel[2].appendChild(document.createTextNode(dim));
			this.inputs.dimension[2].className = 'lut-opt';
			this.inputs.dimensionLabel[2].className = 'lut-opt';
		}
	}
	// 3D size options
	if (idx !== curIdx || changedType) { // Set to default only if the LUT format has changed
		var dim;
		this.inputs.dimension[3].className = 'lut-opt-hide';
		this.inputs.dimensionLabel[3].className = 'lut-opt-hide';
		this.inputs.dimension[4].className = 'lut-opt-hide';	
		this.inputs.dimensionLabel[4].className = 'lut-opt-hide';	
		this.inputs.dimension[5].className = 'lut-opt-hide';	
		this.inputs.dimensionLabel[5].className = 'lut-opt-hide';
		if (cur.threeDim.length > 0) {
			dim = cur.threeDim[0].toString();
			this.inputs.dimension[3].value = dim;
			if (cur.defDim === cur.threeDim[0]) {
				this.inputs.dimension[3].checked = true;
			}
			this.inputs.dimensionLabel[3].removeChild(this.inputs.dimensionLabel[3].firstChild);
			this.inputs.dimensionLabel[3].appendChild(document.createTextNode(dim + 'x' + dim + 'x' + dim));
			this.inputs.dimension[3].className = 'lut-opt';
			this.inputs.dimensionLabel[3].className = 'lut-opt';
		}
		if (cur.threeDim.length > 1) {
			dim = cur.threeDim[1].toString();
			this.inputs.dimension[4].value = dim;
			if (cur.defDim === cur.threeDim[1]) {
				this.inputs.dimension[4].checked = true;
			}
			this.inputs.dimensionLabel[4].removeChild(this.inputs.dimensionLabel[4].firstChild);
			this.inputs.dimensionLabel[4].appendChild(document.createTextNode(dim + 'x' + dim + 'x' + dim));
			this.inputs.dimension[4].className = 'lut-opt';
			this.inputs.dimensionLabel[4].className = 'lut-opt';
		}
		if (cur.threeDim.length === 3) {
			dim = cur.threeDim[2].toString();
			this.inputs.dimension[5].value = dim;
			if (cur.defDim === cur.threeDim[2]) {
				this.inputs.dimension[5].checked = true;
			}
			this.inputs.dimensionLabel[5].removeChild(this.inputs.dimensionLabel[5].firstChild);
			this.inputs.dimensionLabel[5].appendChild(document.createTextNode(dim + 'x' + dim + 'x' + dim));
			this.inputs.dimension[5].className = 'lut-opt';
			this.inputs.dimensionLabel[5].className = 'lut-opt';
		}
	}
	// Input range
	if (idx !== curIdx || changedType || parseInt(this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].value) !== this.lastGamma) { // Set to default only if the LUT format has changed
		this.inputs.inRange[0].disabled = !cur.legIn;
		this.inputs.inRange[1].disabled = !cur.datIn;
		this.updateGammaIn();
	}
	// Output range
	if (idx !== curIdx || changedType || parseInt(this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].value) !== this.lastGamma) { // Set to default only if the LUT format has changed
		this.inputs.outRange[0].disabled = !cur.legOut;
		this.inputs.outRange[1].disabled = !cur.datOut;
		this.updateGammaOut();
	} else {
		this.lastGamma = parseInt(this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].value);
	}
	// Custom input scaling
	if (idx !== curIdx || changedType) { // Set to default only if the LUT format has changed
		this.inputs.scaleCheck.checked = false;
		this.inputs.scaleInputs.className = 'emptybox-hide';
		if (cur.scaling) {
			this.inputs.scaleBox.className = 'emptybox';
			if (typeof cur.defMin !== 'undefined') {
				this.inputs.scaleMin.value = cur.defMin.toString();
			} else {
				this.inputs.scaleMin.value = '0';
			}
			if (typeof cur.defMax !== 'undefined') {
				this.inputs.scaleMax.value = cur.defMax.toString();
			} else {
				this.inputs.scaleMax.value = '1.0';
			}
		} else {
			this.inputs.scaleBox.className = 'emptybox-hide';
			this.inputs.scaleMin.value = '0';
			this.inputs.scaleMax.value = '1.0';
		}
	}
	// set LUT bit depth (3dl etc.)
	if (idx !== curIdx || changedType) { // Set to default only if the LUT format has changed
		if (cur.setBits) {
			this.inputs.bitsBox.className = 'emptybox';
			this.inputs.inBitsSelect.options[(cur.inBits - 10)/2].selected = true;
			this.inputs.outBitsSelect.options[(cur.outBits - 10)/2].selected = true;
		} else {
			this.inputs.bitsBox.className = 'emptybox-hide';
		}
	}
	// Set black clip and white clip levels for the format
	if (idx !== curIdx || changedType) { // Set to default only if the LUT format has changed
		this.inputs.bClip = cur.bClip;
		this.inputs.wClip = cur.wClip;
	}
	// Release hard clip option
	if (idx !== curIdx || changedType) { // Set to default only if the LUT format has changed
		if (cur.hard) {
//			this.inputs.clipCheck.disabled = true;
//			this.inputs.clipCheck.checked = true;
			this.inputs.clipSelect.disabled = true;
			this.inputs.clipSelect.options[1].selected = true;
		} else {
//			this.inputs.clipCheck.disabled = false;
//			this.inputs.clipCheck.checked = false;
			this.inputs.clipSelect.disabled = false;
			this.inputs.clipSelect.options[2].selected = true;
		}
	}
	this.messages.displayCLC();
	// Line up current and changed indeces
	this.curIdx = idx;
};
LUTFormats.prototype.updateARRIRangeIn = function() {
	var cur, idx;
	if (this.inputs.lutUsage[0].checked) {
		idx = parseInt(this.inputs.gradeSelect.options[this.inputs.gradeSelect.selectedIndex].value);
		cur = this.grades[idx];
	} else {
		idx = parseInt(this.inputs.mlutSelect.options[this.inputs.mlutSelect.selectedIndex].value);
		cur = this.mluts[idx];
	}
	var curIn = parseInt(this.inputs.inGamma.options[this.inputs.inGamma.selectedIndex].value);
	if (curIn === 9999) {
		curIn = parseInt(this.inputs.inLinGamma.options[this.inputs.inLinGamma.selectedIndex].value);
	}
	// Allow for Arri codec range legal / full
	if (this.inputs.gammaArriList.indexOf(curIn) > -1) {
		if (this.inputs.arriLegalIn[1].checked && cur.datIn) {
			this.inputs.inRange[1].checked = true;
		} else if ((!this.inputs.arriLegalIn[1].checked) && cur.legIn) {
			this.inputs.inRange[0].checked = true;
		}
	}
};
LUTFormats.prototype.updateARRIRangeOut = function() {
	var cur, idx;
	if (this.inputs.lutUsage[0].checked) {
		idx = parseInt(this.inputs.gradeSelect.options[this.inputs.gradeSelect.selectedIndex].value);
		cur = this.grades[idx];
	} else {
		idx = parseInt(this.inputs.mlutSelect.options[this.inputs.mlutSelect.selectedIndex].value);
		cur = this.mluts[idx];
	}
	var curOut = parseInt(this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].value);
	if (curOut === 9999) {
		curOut = parseInt(this.inputs.outLinGamma.options[this.inputs.outLinGamma.selectedIndex].value);
	}
	// Allow for Arri codec range legal / full
	if (this.inputs.gammaArriList.indexOf(curOut) > -1) {
		if (this.inputs.arriLegalOut[1].checked && cur.datOut) {
			this.inputs.outRange[1].checked = true;
		} else if ((!this.inputs.arriLegalOut[1].checked) && cur.legOut) {
			this.inputs.outRange[0].checked = true;
		}
	}
};
LUTFormats.prototype.updateGammaIn = function() {
	var cur,idx;
	if (this.inputs.lutUsage[0].checked) {
		idx = parseInt(this.inputs.gradeSelect.options[this.inputs.gradeSelect.selectedIndex].value);
		cur = this.grades[idx];
	} else {
		idx = parseInt(this.inputs.mlutSelect.options[this.inputs.mlutSelect.selectedIndex].value);
		cur = this.mluts[idx];
	}
	var curIn = parseInt(this.inputs.inGamma.options[this.inputs.inGamma.selectedIndex].value);
	if (curIn === 9999) {
		curIn = parseInt(this.inputs.inLinGamma.options[this.inputs.inLinGamma.selectedIndex].value);
	}
	var gamDat = this.inputs.gammaDataLevel[curIn];
	// Allow for Arri codec range legal / full
	var override = false;
	if (this.inputs.gammaArriList.indexOf(curIn) > -1) {
		if (this.inputs.arriLegalIn[1].checked && cur.datIn) {
			this.inputs.inRange[1].checked = true;
			override = true;
		} else if ((!this.inputs.arriLegalIn[1].checked) && cur.legIn) {
			this.inputs.inRange[0].checked = true;
			override = true;
		}
	}
	if (!override) {
		if (!cur.defLegDat) {
			if (gamDat && cur.datIn) {
				this.inputs.inRange[1].checked = true;
			} else if (!gamDat && cur.legIn) {
				this.inputs.inRange[0].checked = true;
			}
		} else {
			if (cur.defLegIn) {
				this.inputs.inRange[0].checked = true;
			} else {
				this.inputs.inRange[1].checked = true;
			}
		}
	}
	if (this.inputs.gammaExt[curIn] && !gamDat) {
		this.inputs.scaleMin.value = 0.0;
		this.inputs.scaleMax.value = 1.095;
		if (this.inputs.scaleBox.className == 'emptybox') {
			this.inputs.scaleCheck.checked = true;
			this.inputs.scaleInputs.className = 'emptybox';
		}
	} else if (parseFloat(this.inputs.scaleMax.value) === 1.095 || this.inputs.scaleCheck.checked === false){
		this.inputs.scaleMin.value = 0.0;
		this.inputs.scaleMax.value = 1.0;
		if (this.inputs.scaleBox.className == 'emptybox') {
			this.inputs.scaleCheck.checked = false;
			this.inputs.scaleInputs.className = 'emptybox-hide';
		}
	}
};
LUTFormats.prototype.updateGammaOut = function() {
	var cur,idx;
	if (this.inputs.lutUsage[0].checked) {
		idx = parseInt(this.inputs.gradeSelect.options[this.inputs.gradeSelect.selectedIndex].value);
		cur = this.grades[idx];
	} else {
		idx = parseInt(this.inputs.mlutSelect.options[this.inputs.mlutSelect.selectedIndex].value);
		cur = this.mluts[idx];
	}
	var curOut = parseInt(this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].value);
	if (curOut === 9999) {
		curOut = parseInt(this.inputs.outLinGamma.options[this.inputs.outLinGamma.selectedIndex].value);
	}
	var gamDat = this.inputs.gammaDataLevel[curOut];
	// Allow for Arri codec range legal / full
	var override = false;
	if (this.inputs.gammaArriList.indexOf(curOut) > -1) {
		if (this.inputs.arriLegalOut[1].checked && cur.datOut) {
			this.inputs.outRange[1].checked = true;
			override = true;
		} else if ((!this.inputs.arriLegalOut[1].checked) && cur.legOut) {
			this.inputs.outRange[0].checked = true;
			override = true;
		}
	}
	if (!override) {
		if (!cur.defLegDat) {
			if (gamDat && cur.datOut) {
				this.inputs.outRange[1].checked = true;
			} else if (!gamDat && cur.legOut) {
				this.inputs.outRange[0].checked = true;
			}
		} else {
			if (cur.defLegOut) {
				this.inputs.outRange[0].checked = true;
			} else {
				this.inputs.outRange[1].checked = true;
			}
		}
	}
	this.messages.displayCLC();
	this.lastGamma = parseInt(this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].value);
};
LUTFormats.prototype.resetOptions = function() {
	// 1D or 3D
	this.inputs.d[0].disabled = false;
	this.inputs.d[1].disabled = false;
	this.inputs.d[1].checked = true;
	// 1D size options
	this.inputs.dimension[0].value = '1024';
	this.inputs.dimension[0].className = 'lut-opt';
	this.inputs.dimensionLabel[0].removeChild(this.inputs.dimensionLabel[0].firstChild);
	this.inputs.dimensionLabel[0].appendChild(document.createTextNode('1024'));
	this.inputs.dimensionLabel[0].className = 'lut-opt';
	this.inputs.dimension[1].value = '4096';
	this.inputs.dimension[1].className = 'lut-opt';
	this.inputs.dimensionLabel[1].removeChild(this.inputs.dimensionLabel[1].firstChild);
	this.inputs.dimensionLabel[1].appendChild(document.createTextNode('4096'));
	this.inputs.dimensionLabel[1].className = 'lut-opt';
	this.inputs.dimension[2].value = '16384';
	this.inputs.dimension[2].className = 'lut-opt';
	this.inputs.dimensionLabel[2].removeChild(this.inputs.dimensionLabel[2].firstChild);
	this.inputs.dimensionLabel[2].appendChild(document.createTextNode('16384'));
	this.inputs.dimensionLabel[2].className = 'lut-opt';
	// 3D size options
	this.inputs.dimension[3].value = '17';
	this.inputs.dimension[3].className = 'lut-opt';
	this.inputs.dimensionLabel[3].removeChild(this.inputs.dimensionLabel[3].firstChild);
	this.inputs.dimensionLabel[3].appendChild(document.createTextNode('17x17x17'));
	this.inputs.dimensionLabel[3].className = 'lut-opt';
	this.inputs.dimension[4].value = '33';
	this.inputs.dimension[4].checked = true;
	this.inputs.dimension[4].className = 'lut-opt';
	this.inputs.dimensionLabel[4].removeChild(this.inputs.dimensionLabel[4].firstChild);
	this.inputs.dimensionLabel[4].appendChild(document.createTextNode('33x33x33'));
	this.inputs.dimensionLabel[4].className = 'lut-opt';
	this.inputs.dimension[5].value = '65';
	this.inputs.dimension[5].className = 'lut-opt';
	this.inputs.dimensionLabel[5].removeChild(this.inputs.dimensionLabel[5].firstChild);
	this.inputs.dimensionLabel[5].appendChild(document.createTextNode('65x65x65'));
	this.inputs.dimensionLabel[5].className = 'lut-opt';
	// Input Range
	this.inputs.inRange[0].disabled = false;
	this.inputs.inRange[1].disabled = false;
	this.inputs.inRange[1].checked = true;
	// Output Range
	this.inputs.outRange[0].disabled = false;
	this.inputs.outRange[1].disabled = false;
	var curOut = parseInt(this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].value);
	if (curOut === 9999) {
		curOut = parseInt(this.inputs.outLinGamma.options[this.inputs.outLinGamma.selectedIndex].value);
	}
	if (this.inputs.gammaCatList[curOut] === 0 || this.inputs.gammaCatList[curOut] === 3 || this.inputs.gammaCatList[curOut] === 7) {
		this.inputs.outRange[1].checked = true;
	} else {
		this.inputs.outRange[0].checked = true;
	}
	// Set black clip and white clip levels for the format
	this.inputs.bClip = cur.bClip;
	this.inputs.wClip = cur.wClip;
	// Release hard clip option
//	this.inputs.clipCheck.disabled = false;
//	this.inputs.clipCheck.checked = false;
	this.inputs.clipSelect.disabled = false;
	this.inputs.clipSelect.options[2].selected = true;
	this.messages.displayCLC();
};
LUTFormats.prototype.output = function(buff) {
	var idx;
	if (this.inputs.lutUsage[0].checked) {
		idx = this.grades[parseInt(this.inputs.gradeSelect.options[this.inputs.gradeSelect.selectedIndex].value)].idx;
	} else {
		idx = this.mluts[parseInt(this.inputs.mlutSelect.options[this.inputs.mlutSelect.selectedIndex].value)].idx;
	}
	var out = this.formats[idx].build(buff, this.inputs.name.value, this.exts[idx]);
	if (out) {
		if (this.txt[idx]) {
			this.file.save(out.lut, out.fileName, out.ext, 1);
		} else {
			this.file.saveBinary(out.lut, out.fileName, out.ext, 1);
		}
	}
};
LUTFormats.prototype.getSettings = function(data) {
	data.formats = {
		grading: this.inputs.lutUsage[0].checked,
		gradeOption: this.inputs.gradeSelect.options[this.inputs.gradeSelect.selectedIndex].lastChild.nodeValue.replace(/ *\([^)]*\) */g, ""),
		mlutOption: this.inputs.mlutSelect.options[this.inputs.mlutSelect.selectedIndex].lastChild.nodeValue.replace(/ *\([^)]*\) */g, ""),
	};
};
LUTFormats.prototype.setSettings = function(settings) {
	if (typeof settings.formats !== 'undefined') {
		var data = settings.formats;
		if (typeof data.gradeOption === 'string') {
			var m = this.inputs.gradeSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.inputs.gradeSelect.options[j].lastChild.nodeValue.replace(/ *\([^)]*\) */g, "") === data.gradeOption) {
					this.inputs.gradeSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.mlutOption === 'string') {
			var m = this.inputs.mlutSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.inputs.mlutSelect.options[j].lastChild.nodeValue.replace(/ *\([^)]*\) */g, "") === data.mlutOption) {
					this.inputs.mlutSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.grading === 'boolean') {
			this.inputs.lutUsage[0].checked = data.grading;
		}
		this.gradeMLUT();
	}
};
LUTFormats.prototype.build = function(type,buff) {
	var max = this.types.length;
	for (var j=0; j<max; j++) {
		if (this.types[j] === type) {
			return this.formats[j].build(buff);
		}
	}
	return false;
};
LUTFormats.prototype.parse = function(ext, title, data, lutMaker, lutDest) {
	var max = this.types.length;
 	for (var j=0; j<max; j++) {
		if (this.exts[j] === ext) {
			return this.formats[j].parse(title, data, lutMaker, lutDest);
		}
	}
	return false;
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* brent.js
* JS implementation of the Brent's method of root finding
*
* 6th February 2015
*
* The 'findRoot' method tries to find the tightest bracket (sign change) to one side or the other of an initial guess 'I'
* and then performs Brent's method. If a given bracket distance suggests roots on either side of 'I', both brackets are
* evaluated and then the root closest to 'I' is returned. If no root is found, extremes are returned which can then be
* replaced with minimum and maximum values found across the set.
*
* Sources of information:
*	Wikipedia: http://en.wikipedia.org/wiki/Brent%27s_method
*	Matlab Script by David Eagle: http://uk.mathworks.com/matlabcentral/fileexchange/39973-a-matlab-script-for-earth-to-mars-mission-design/content/brent.m
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
*/
function Brent(func, a, b) {
	this.func = func;		// Object providing function / data set for analysis - requires a method 'f' which supplies f(x)
	if (typeof a === 'number' && typeof b === 'number') {
		this.setRange(a,b);
	} else {
		this.setRange(0,1);
	}
	this.delta = 1;
	this.tol = 0.00000001; // tolerence - OK for Float64s, too small for Float32s
}
Brent.prototype.setRange = function(a,b) {
	this.a = a;			// For f(x), minimum value of x
	this.fMin = this.func.f(a);
	this.b = b;			// For f(x), maximum value of x
	this.fMax = this.func.f(b);
	this.mid = this.func.f((a+b)/2);
};
Brent.prototype.setDelta = function(d) {
	this.delta = d;
};
Brent.prototype.setTolerance = function(tol) {
	this.tol = tol;
};
Brent.prototype.minMax = function(x) {
	if (x < this.a) {
		this.a = x;
		this.fMin = this.o;
	} else if (x > this.b) {
		this.b = x;
		this.fMax = this.o;
	}
};
Brent.prototype.getMinMax = function() {
	return { a: this.a, fMin: this.fMin, b: this.b, fMax: this.fMax };
};
Brent.prototype.findRoot = function(I,O) { // Public single root method, O is the f(x) to match to if not zero (root), finds closest root to I
	var tol = this.tol;
	if (typeof O === 'number') {
		this.o = O;
	} else {
		this.o = 0;
	}
	var y0 = this.func.f(I) - this.o;
	if (Math.abs(y0)<tol) {
		this.minMax(I);
		return I;
	}
	var dx;
	var yl,yh;
	var dl,dh;
	for (var j=1; j<25; j++) {
		dx = this.delta * (Math.pow(1.04,j) - 1);
		yl = this.func.f(I-dx) - this.o;
		yh = this.func.f(I+dx) - this.o;
		if (Math.abs(yl)<tol) {
			this.minMax(I-dx);
			return I-dx;
		} else if (Math.abs(yh)<tol) {
			this.minMax(I+dx);
			return I+dx;
		} else {
			dl = yl*y0;
			dh = yh*y0;
			if (dl<0 && dh<0) { // Bracket on both sides of the first guess
				var rl = this.brent(I, y0, I-dx, yl, tol);
				var rh = this.brent(I, y0, I+dx, yh, tol);
				if (Math.abs(rl - I) < Math.abs(rh - I)) {
					this.minMax(rl);
					return this.clamp(rl);
				} else {
					this.minMax(rh);
					return this.clamp(rh);
				}
			} else if (dl<0) { // Bracket below first guess
				var r = this.brent(I, y0, I-dx, yl, tol);
				this.minMax(r);
				return this.clamp(r);
			} else if (dh<0) { // Bracket above first guess
				var r = this.brent(I, y0, I+dx, yh, tol);
				this.minMax(r);
				return this.clamp(r);
			}
		}
	}
// If a bracket can't be found, set to an extreme based on the f(x) value halfway within a<x<b,
// then when finished, iterate through the arrays swapping the extremes for the min and max
// values of x calculated.
	if (O<this.mid) {
		return -65536;
	} else {
		return 65536;
	}
};
Brent.prototype.clamp = function(i) {
	if (i > 65536) {
		return 65536;
	} else if (i < -65536) {
		return -65536;
	} else {
		return i;
	}
};
Brent.prototype.brent = function(a,fa,b,fb,rtol) {
	var eps = 2.22e-16; // Machine epsilon for Float64Arrays
	var e = 0;
	var tol1, xm, min, tmp;
	var p, q, r, s;
	var fc = fb;
	for (var j=0; j<80; j++) {
		if (fb * fc > 0) {
    		c = a;
    		fc = fa;
    		d = b - a;
    		e = d;
    	}
    	if (Math.abs(fc) < Math.abs(fb)) {
    		a = b;
    		b = c;
    		c = a;
    		fa = fb;
    		fb = fc;
    		fc = fa;
    	}
    	tol1 = (2*eps*Math.abs(b))+(0.5*rtol);
    	xm = 0.5 * (c - b);
    	if (Math.abs(xm) <= tol1 || fb === 0) {
    		return b;
    	}
    	if (Math.abs(e) >= tol1 && Math.abs(fa) > Math.abs(fb)) {
    		s = fb / fa;
    		if (a === c) {
    			p = 2*xm*s;
    			q = 1-s;
    		} else {
    			q = fa/fc;
    			r = fb/fc;
    			p = s*((2*xm*q*(q - r))-((b - a)*(r - 1)));
    			q = (q - 1)*(r - 1)*(s - 1);
    		}
    		if (p > 0) {
    			q = -q;
    		}
    		p = Math.abs(p);
    		min = Math.abs(e * q);
    		tmp = (3*xm*q) - Math.abs(tol1*q);
    		if (min < tmp) {
    			min = tmp;
    		}
    		if (2*p < min) {
    			e = d;
    			d = p / q;
    		} else {
    			d = xm;
    			e = d;
    		}
    	} else {
    		d = xm;
    		e = d;
    	}
    	a = b;
    	fa = fb;
    	if (Math.abs(d) > tol1) {
    		b = b + d;
    	} else {
    		if (xm >=0) {
    			b = b + tol1;
    		} else {
    			b = b - tol1;
    		}
    	}
    	fb = this.func.f(b) - this.o;
    }
console.log('none');
    return b;
};
// Stringify for inline Web Workers
function getBrentString() {
	var out = "";
	// Brent
	out += Brent.toString() + "\n";
	for (var j in Brent.prototype) {
		out += 'Brent.prototype.' + j + '=' + Brent.prototype[j].toString() + "\n";
	}
	return out;
}
var workerBrentString = getBrentString();
/* lutanalyst.js
* LA LUT calculation object for the LUTCalc Web App.
* 31st December 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTAnalyst(inputs, messages) {
	this.inputs = inputs;
	this.messages = messages;
	this.p = 7;
	this.messages.addUI(this.p,this);
	this.lutMaker = new LUTs();
	this.natTF = false;
	this.inputEX = true;
	this.showGt = true;
	this.lutRange();
	this.reset();
	lutcalcReady(this.p);
}
LUTAnalyst.prototype.getTitle = function(lut) {
	switch(lut) {
		case 'in':  this.title = this.inLUT.getTitle();
					break;
		case 'tf':  this.title = this.tf.getTitle();
					break;
	}
	return this.title;
};
LUTAnalyst.prototype.reset = function() {
	this.title = 'LUT Analyst';
	this.inLUT = false;
	this.tf = false;
	this.cs = false;
};
LUTAnalyst.prototype.lutRange = function() {
	if (this.inputs.laRange[3].checked || this.inputs.laRange[2].checked) {
		this.legIn = true;
	} else {
		this.legIn = false;
	}
	if (this.inputs.laRange[0].checked || this.inputs.laRange[2].checked) {
		this.legOut = true;
	} else {
		this.legOut = false;
	}
};
LUTAnalyst.prototype.is1D = function() {
	return this.inLUT.is1D();
};
LUTAnalyst.prototype.is3D = function() {
	return this.inLUT.is3D();
};
LUTAnalyst.prototype.getTF = function() {
	this.lutRange();
	this.pass = 0;
	this.gammaIn = parseInt(this.inputs.laGammaSelect.options[this.inputs.laGammaSelect.selectedIndex].value);
	if (this.gammaIn === 9999) {
		this.gammaIn = parseInt(this.inputs.laLinGammaSelect.options[this.inputs.laLinGammaSelect.selectedIndex].value);
	}
	var dim = this.inLUT.getSize();
	if (dim < 65) {
		dim = 65;
	}
	this.messages.gaTx(this.p,8,{
		dim: dim,
		legIn: this.legIn,
		gamma: this.gammaIn
	});
};
LUTAnalyst.prototype.updateLATF = function(laFile) {
	this.gaT = this.messages.getGammaThreads();
	var dets = this.tf.getDetails(true);
	if (typeof laFile !== 'undefined' && laFile) {
		this.tfSpline = new LUTRSpline({buff:dets.C[0], fL:0, fH:1});
	}
	var HL = this.tfSpline.getHighLow();
	dets.R = [this.tfSpline.getReverse()];
	dets.sr = this.tfSpline.getRM();
	dets.minR = new Float64Array([HL.revL,HL.revL,HL.revL]);
	dets.maxR = new Float64Array([HL.revH,HL.revH,HL.revH]);
	this.messages.gaTxAll(this.p,6,dets);
};
LUTAnalyst.prototype.getL = function() {
	return this.tf.getL();
};
LUTAnalyst.prototype.getCS = function() {
	this.gamutIn = parseInt(this.inputs.laGamutSelect.options[this.inputs.laGamutSelect.selectedIndex].value);
	var dim;
	if (this.inputs.laDim[0].checked) {
		dim = 33;
	} else {
		dim = 65;
	}
	this.messages.gaTx(this.p,2,{
		dim: dim,
		legIn: this.legIn,
		gamma: this.gammaIn,
		gamut: this.gamutIn
	});
};
LUTAnalyst.prototype.setCSInputData = function(buff,natTF,legIn) {
	this.natTF = natTF;
	this.inputEX = !legIn;
	this.inputData = new Float64Array(buff);
};
LUTAnalyst.prototype.getCSInputMatrix = function() {
	var dets = this.cs.getMetadata();
	if (typeof dets.inputMatrix !== 'undefined') {
		return dets.inputMatrix;
	} else {
		return false;
	}
};
LUTAnalyst.prototype.gotInputVals = function(buff,dim) {
	var inputTF;
	if (parseInt(this.inputs.laGammaSelect.options[this.inputs.laGammaSelect.selectedIndex].value) === 9999) {
		inputTF = this.inputs.laLinGammaSelect.options[this.inputs.laLinGammaSelect.selectedIndex].text.trim();
	} else {
		inputTF = this.inputs.laGammaSelect.options[this.inputs.laGammaSelect.selectedIndex].text.trim();
	}
	if (this.pass === 0) { // Transfer function pass
		var C = new Float64Array(buff);
		var m = C.length;
		this.inLUT.FCub(buff);
		if (this.legOut) {
			for (var j=0; j<m; j++) {
				C[j] = ((C[j]*876)+64)/1023;
			}
		}
		var mono = C[m-1] - C[0];
		if (mono >= 0) {
			mono = 1;
		} else if (mono < 0) {
			mono = -1;
		}
		if ((C[1]-C[0])*mono <= 0) {
			C[0] = (2*C[1]) - C[2];
			if ((C[1]-C[0])*mono <= 0) { // still opposite slope to monotonic
				C[0] = C[1] - (0.0075 * mono / (m-1));
			}
		}
		if ((C[m-1]-C[m-2])*mono <= 0) {
			C[m-1] = (2*C[m-2]) - C[m-3];
			if ((C[m-1]-C[m-2])*mono <= 0) { // still opposite slope to monotonic
				C[m-1] = C[m-2] + (0.0075 * mono / (m-1));
			}
		}
		this.tf = this.lutMaker.newLUT({
			title: 'Transfer Function',
			format: 'cube',
			dims: 1,
			s: m,
			min: [0,0,0],
			max: [1,1,1],
			C: [buff.slice(0)],
			meta: {
				inputTF: inputTF
			}
		});
		this.tfSpline = new LUTRSpline({buff:buff, fL:0, fH:1});
		this.pass = 1;
		this.getCS();
	} else if (this.inLUT.is3D()) { // Colour Space Pass
		var m = dim*dim*dim;
		var R = new Float64Array(m);
		var G = new Float64Array(m);
		var B = new Float64Array(m);
		var rgb = this.inputData;
		var inputMatrix = new Float64Array(buff);
		// Run the test data through the input LUT
		var method;
		if (this.inputs.laIntMethod[0].checked) {
			method = 0;
			this.inLUT.RGBCub(rgb.buffer);
		} else if (this.inputs.laIntMethod[1].checked) {
			method = 1;
			this.inLUT.RGBTet(rgb.buffer);
		} else {
			method = 2;
			this.inLUT.RGBLin(rgb.buffer);
		}
		for (var j=0; j<m; j++) {
			k = j*3;
			R[j] = rgb[ k ];
			G[j] = rgb[k+1];
			B[j] = rgb[k+2];
		}
		// Set the reversible spline
		var Y = new Float64Array(dim);
		if (this.natTF === 0) {
			if (this.legIn) {
				for (var j=0; j<dim; j++) {
					Y[j] = ((j*876/(dim-1))+64)/1023;
				}
			} else {
				for (var j=0; j<dim; j++) {
					Y[j] = j/(dim-1);
				}
			}
			this.tfSpline.FCub(Y.buffer); // this.tfSpline is always data in to data out
			if (this.legOut) {
				for (var j=0; j<dim; j++) {
					Y[j] = ((Y[j]*1023)-64)/876;
				}
			}
		} else {
			for (var j=0; j<dim; j++) {
				Y[j] = j/(dim-1);
			}
			this.inLUT.FCub(Y.buffer);
			var mono = Y[dim-1] - Y[0];
			if (mono >= 0) {
				mono = 1;
			} else if (mono < 0) {
				mono = -1;
			}
			if ((Y[1]-Y[0])*mono <= 0) {
				Y[0] = (2*Y[1]) - Y[2];
				if ((Y[1]-Y[0])*mono <= 0) { // still opposite slope to monotonic
					Y[0] = Y[1] - (0.0075 * mono / (dim-1));
				}
			}
			if ((Y[dim-1]-Y[dim-2])*mono <= 0) {
				Y[dim-1] = (2*Y[dim-2]) - Y[dim-3];
				if ((Y[dim-1]-Y[dim-2])*mono <= 0) { // still opposite slope to monotonic
					Y[dim-1] = Y[dim-2] + (0.0075 * mono / (dim-1));
				}
			}
		}
		var tfSpline = new LUTRSpline({buff:Y.buffer, fL:0, fH:1});
		tfSpline.setMethod(method);
		// Find the reverse of the LUTTed data
		tfSpline.R(R.buffer);
		tfSpline.R(G.buffer);
		tfSpline.R(B.buffer);
		// Limit the results
		var minMax = this.inLUT.minMax();
		var lo = Math.min( 0, tfSpline.r(Math.min(minMax[0],minMax[1],minMax[2]))); // 0, or the lowest value in the mesh, whichever the greater
		var hi = Math.max( 1, tfSpline.r(Math.max(minMax[3],minMax[4],minMax[5]))); // 1.0, or the highest value in the mesh, whichever the lesser
		var min = lo - (87.6/1023); // 10% IRE below the 'lo' value
		var max = hi + (175.2/1023); // 20% IRE above 'hi' value
		var dcLo = tfSpline.df(lo);
		var dcHi = tfSpline.df(hi);
		var numLo = Math.pow(min-lo,2);
		var denLo = min-lo;
		var numHi = Math.pow(max-hi,2);
		var denHi = max-hi;
		for (var j=0; j<m; j++) {
			if (R[j] < lo) {
				R[j] = min - (numLo/((dcLo*(R[j]-lo))+denLo));
			} else if (R[j] > hi) {
				R[j] = max - (numHi/((dcHi*(R[j]-hi))+denHi));
			}
			if (G[j] < lo) {
				G[j] = min - (numLo/((dcLo*(G[j]-lo))+denLo));
			} else if (G[j] > hi) {
				G[j] = max - (numHi/((dcHi*(G[j]-hi))+denHi));
			}
			if (B[j] < lo) {
				B[j] = min - (numLo/((dcLo*(B[j]-lo))+denLo));
			} else if (B[j] > hi) {
				B[j] = max - (numHi/((dcHi*(B[j]-hi))+denHi));
			}
		}
		var inputCS = this.inputs.laGamutSelect.options[this.inputs.laGamutSelect.selectedIndex].text.trim();
		var meta =  {
			inputTF: inputTF,
			systemCS: 'Sony S-Gamut3.cine',
			inputCS: inputCS,
			inputEX: !this.legIn,
			nativeTF: this.natTF,
			interpolation: method,
			inputMatrix: inputMatrix
		};
		if (inputTF.indexOf('LogC') !== -1) {
			meta.baseISO = parseInt(this.inputs.cineEI.value);
		}
		this.cs = this.lutMaker.newLUT({
			title: 'Colour Space',
			format: 'cube',
			dims: 3,
			s: dim,
			min: [0,0,0],
			max: [1,1,1],
			C: [R.buffer,G.buffer,B.buffer],
			meta: meta
		});
		this.showGt = true;
		this.updateLATF();
		this.updateLACS();
	} else {
		this.showGt = false;
		this.updateLATF();
	}
};
LUTAnalyst.prototype.updateLACS = function() {
	this.gtT = this.messages.getGamutThreads();
	var d = this.cs.getDetails();
	var meta = d.meta;
	if (typeof d.min === 'undefined') {
		d.min = new Float64Array([0,0,0]);
	}
	if (typeof d.max === 'undefined') {
		d.max = new Float64Array([1,1,1]);
	}
	var details = {
		title: d.title,
		format: d.format,
		dims: d.dims,
		s: d.s,
		min: d.min,
		max: d.max,
		meta: meta
	};
	if (d.d === 3 || d.C.length === 3) {
		details.C = [
			d.C[0].slice(0),
			d.C[1].slice(0),
			d.C[2].slice(0)
		];
	} else {
		details.C = [d.C[0].slice(0)];
	}
//set LUT here
	this.messages.gtTxAll(this.p,6,details);
};
LUTAnalyst.prototype.getRGB = function() {
	if (this.showGt) {
		return this.cs.getRGB();
	} else {
		return false;
	}
};
LUTAnalyst.prototype.setLUT = function(lut, data) {
	this[lut] = this.lutMaker.newLUT(data);
	if (typeof this[lut] !== 'undefined') {
		this.showGt = true;
		return true;
	} else {
		return false;
	}
};
LUTAnalyst.prototype.noCS = function() {
	this.showGt = false;
};
LUTAnalyst.prototype.showGamut = function() {
	return this.showGt;
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* lutfile.js
* File I/O handling object for the LUTCalc Web App.
* 7th October 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTFile(inputs, messages) {
	this.inputs = inputs;
	this.messages = messages;
	this.filesaver = true;
	try {
		var isFileSaverSupported = !!new Blob();
	} catch(e){
		this.filesaver = false;
	}
	this.inputs.addInput('doSaveDialog',1);
}
LUTFile.prototype.save = function(data, fileName, extension, source) {
     if (this.inputs.appleApp) {
        var data = {
            data: data,
            filename: this.filename(fileName),
            extension: extension,
            doDialog: this.inputs.doSaveDialog,
            source: source
        }
        window.webkit.messageHandlers.saveText.postMessage(JSON.stringify(data));
    } else if (this.inputs.isApp) { // From native app detection in lutcalc.js
        return window.lutCalcApp.saveLUT(data, this.filename(fileName), extension, this.inputs.doSaveDialog, source);
    } else if (this.inputs.isChromeApp) { // Use Chrome App fileSystem API to select destination
		chrome.fileSystem.chooseEntry(
			{
				type: 'saveFile', 
				suggestedName: this.filename(fileName) + '.' + extension,
				accepts: [{
					extensions: [extension]
				}],
				acceptsAllTypes: false
			}, 
			function(writableFileEntry) {
				writableFileEntry.createWriter(
					function(writer) {
						writer.onwriteend = function(e) {
							savedFromApp(source, 1);
							notifyUser('LUTCalc',source + writableFileEntry.name + ' saved');
						};
						writer.write(new Blob([data],{type: 'text/plain;charset=UTF-8'})); 
					},
					function() {
						savedFromApp(source, 0);
						notifyUser('LUTCalc','File could not be saved');
					}
				);
			}
		);
    } else if (this.filesaver) { // Detect FileSaver.js applicability for browsers other than Safari and older IE
		saveAs(new Blob([data], {type: 'text/plain;charset=UTF-8'}), this.filename(fileName) + '.' + extension,true);
        this.messages.saved(source, true);
		return true;
	} else { // Fall back to opening LUT in a new tab for user to save with 'Save As...'
		window.open("data:text/plain," + encodeURIComponent(data),"_blank");
		this.messages.saved(source, true);
		return true;
	}
};
LUTFile.prototype.saveBinary = function(data, fileName, extension, source) {
    if (this.inputs.appleApp) { // WKWebView uses a different mechanism to WebView, so appleApp triggers the 'new' approach
        var data = {
            data: btoa(new Uint8Array(data).reduce((data, byte)=> {
                    return data + String.fromCharCode(byte);
                }, '')),
            filename: this.filename(fileName),
            extension: extension,
            doDialog: this.inputs.doSaveDialog,
            source: source
        }
        window.webkit.messageHandlers.saveBIN.postMessage(JSON.stringify(data));
    } else if (this.inputs.isApp) { // From native app detection in lutcalc.js
        return window.lutCalcApp.saveBIN(data, this.filename(fileName), extension, this.inputs.doSaveDialog, source);
    } else if (this.inputs.isChromeApp) { // Use Chrome App fileSystem API to select destination
		chrome.fileSystem.chooseEntry(
			{
				type: 'saveFile', 
				suggestedName: this.filename(fileName) + '.' + extension,
				accepts: [{
					extensions: [extension]
				}],
				acceptsAllTypes: false
			}, 
			function(writableFileEntry) {
				writableFileEntry.createWriter(
					function(writer) {
						writer.onwriteend = function(e) {
							savedFromApp(source, 1);
							notifyUser('LUTCalc',writableFileEntry.name + ' saved');
						};
						writer.write(new Blob([data],{type: 'application/octet-stream'})); 
					},
					function() {
						savedFromApp(source, 0);
						notifyUser('LUTCalc','File could not be saved');
					}
				);
			}
		);
    } else if (this.filesaver) { // Detect FileSaver.js applicability for browsers other than Safari and older IE
		saveAs(new Blob([data], {type: 'application/octet-stream'}), this.filename(fileName) + '.' + extension,true);
    	this.messages.saved(source, true);
		return true;
	} else { 
		console.log('Browser does not support file saving.');
    	this.messages.saved(source, false);
		return false;
	}
};
LUTFile.prototype.loadLUTFromInput = function(fileInput, extensions, isTxt, destination, parentObject, next) {
    if (this.inputs.appleApp) {
        var data = {
            extensions: extensions.toString(),
            destination: destination,
            parent: parentObject.p,
            next: next
        }
        window.webkit.messageHandlers.loadLUT.postMessage(JSON.stringify(data));
    } else if (this.inputs.isApp) {
		window.lutCalcApp.loadLUT(extensions.toString(), destination, parentObject.p, next);
	} else {
		var file = fileInput.files[0];
		var valid = false;
		var dot = file.name.lastIndexOf('.');
		var ext = '';
		var isBin = false;
		if (dot != -1) {
			dot++;
			ext = file.name.substr(dot).toLowerCase();
			var max = extensions.length;
			for (var i=0; i<max; i++) {
				if (ext === extensions[i]) {
					valid = true;
					isBin = !isTxt[i];
					break;
				}
			}
		}
		if (valid) {
			if (window.File && window.FileReader && window.FileList && window.Blob) {
				var reader = new FileReader();
				var localDestination = this.inputs[destination];
				localDestination.format = ext;
				localDestination.title = file.name.substr(0,file.name.length-ext.length-1);
				if (isBin) {
					reader.onload = (function(theFile){
						var theDestination = localDestination;
    					return function(e){
 	  						theDestination.isTxt = false;
    						theDestination.buff = e.target.result;
							parentObject.followUp(next);
    					};
    				})(file);
					reader.onerror = function(theFile) { return function() {
						alert("Error reading file.");
						inputBox.value = '';
					}; }(file);
					reader.readAsArrayBuffer(file);
				} else {
					reader.onload = (function(theFile){
						var theDestination = localDestination;
    					return function(e){
    						theDestination.isTxt = true;
    						theDestination.text = e.target.result.split(/[\n\u0085\u2028\u2029]|\r\n?/);
							parentObject.followUp(next);
    					};
    				})(file);
					reader.onerror = function(theFile) { return function() {
						alert("Error reading file.");
						inputBox.value = '';
					}; }(file);
					reader.readAsText(file);
				}
			} else {
				alert("Can't load LUT - your browser is not set to support Javascript File APIs.");
				fileInput.value = '';
			}
		} else {
			fileInput.value = '';
			alert("LUTCalc does not understand this file.");
		}
	}
};
LUTFile.prototype.loadImgFromInput = function(fileInput, extensions, destination, parentObject, next) {
    if (this.inputs.appleApp) {
        var data = {
            extensions: extensions.toString(),
            destination: destination,
            parent: parentObject.p,
            next: next
        }
        window.webkit.messageHandlers.loadImg.postMessage(JSON.stringify(data));
    } else 	if (this.inputs.isApp) {
		window.lutCalcApp.loadImg(extensions.toString(), destination, parentObject.p, next);
	} else {
		var file = fileInput.files[0];
		var valid = false;
		var dot = file.name.lastIndexOf('.');
		var ext = '';
		if (dot != -1) {
			dot++;
			ext = file.name.substr(dot).toLowerCase();
			var max = extensions.length;
			for (var i=0; i<max; i++) {
				if (ext === extensions[i]) {
					valid = true;
					break;
				}
			}
		}
		if (valid) {
			if (window.File && window.FileReader && window.FileList && window.Blob) {
				var reader = new FileReader();
				var localDestination = this.inputs[destination];
				localDestination.format = ext;
				localDestination.title = file.name.substr(0,file.name.length-ext.length-1);
				reader.onload = (function(theFile){
					var theDestination = localDestination;
    				return function(e){
    					theDestination.pic = new Image();
    					theDestination.pic.onload = function(e){
    						theDestination.w = theDestination.pic.width;
	    					theDestination.h = theDestination.pic.height;
	 						parentObject.followUp(next);
    					};
    					theDestination.pic.src = e.target.result;
    				};
    			})(file);
				reader.onerror = function(theFile) { return function() {
					alert("Error reading file.");
					inputBox.value = '';
				}; }(file);
				reader.readAsDataURL(file);
			} else {
				alert("Can't load image - your browser is not set to support Javascript File APIs.");
				fileInput.value = '';
			}
		} else {
			fileInput.value = '';
			alert("LUTCalc does not understand this image type.");
		}
	}
};
LUTFile.prototype.filename = function(filename) {
	return filename.replace(/[^a-z0-9_\-\ ]/gi, '').replace(/[^a-z0-9_\-]/gi, '_');
};
// Functions available to native apps
function loadLUTFromAppleApp(fileName, format, content64, destination, parentIdx, next) {
    lutInputs[destination].format = format;
    var content = atob(content64);
    if (format.toLowerCase() === 'labin') {
        var max = content.length;
        var data = new Uint8Array(max);
        for (var j=0; j<max; j++) {
            data[j] = content.charCodeAt(j);
        }
        lutInputs[destination].title = fileName;
        lutInputs[destination].buff = data.buffer;
        lutInputs[destination].isTxt = false;
    } else {
        lutInputs[destination].title = fileName;
        lutInputs[destination].text = content.split(/[\n\u0085\u2028\u2029]|\r\n?/);
        lutInputs[destination].isTxt = true;
    }
    switch (parseInt(parentIdx)) {
        case 5: lutGenerate.followUp(parseInt(next));
                break;
        case 10: lutTweaksBox.followUp(parseInt(parentIdx),parseInt(next));
                 break;
    }
}
function loadLUTFromApp(fileName, format, content, destination, parentIdx, next) {
    format = format.toLowerCase();
	lutInputs[destination].format = format;
	if (format.toLowerCase() === 'labin') {
        var max = content.length;
        var data = new Uint8Array(max);
        for (var j=0; j<max; j++) {
            data[j] = content[j];
        }
        lutInputs[destination].title = fileName;
		lutInputs[destination].buff = data.buffer;
		lutInputs[destination].isTxt = false;
	} else {
        lutInputs[destination].title = fileName;
		lutInputs[destination].text = content.split(/[\n\u0085\u2028\u2029]|\r\n?/);
		lutInputs[destination].isTxt = true;
	}
	switch (parseInt(parentIdx)) {
		case 5: lutGenerate.followUp(parseInt(next));
				break;
		case 10: lutTweaksBox.followUp(parseInt(parentIdx),parseInt(next));
				break;
	}
}
function loadImgFromAppleApp(format, title, content64, destination, parentIdx, next) {
    var theDestination = lutInputs[destination];
    var nextObject;
    switch (parseInt(parentIdx)) {
        case 8: nextObject = lutPreview;
                break;
    }
    theDestination.title = title;
    var contentString = atob(content64);

    var max = contentString.length;
    var data = new Uint8Array(max);
    for (var j=0; j<max; j++) {
        data[j] = contentString.charCodeAt(j);
    }
    var content = new Uint16Array(data.buffer);
    max = content.length;
    theDestination.imageData = new Float64Array(max);
    var sample;
     for (var j=0; j<max; j++) {
         sample = parseFloat(content[ j ])/65535;
         theDestination.imageData[ j ] = sample;
     }
     nextObject.followUp(parseInt(next));
}
function loadImgFromApp(format, title, content, destination, parentIdx, next) {
    var theDestination = lutInputs[destination];
    var nextObject;
    switch (parseInt(parentIdx)) {
        case 8: nextObject = lutPreview;
                break;
    }
    theDestination.title = title;
     var max = content.length;
     theDestination.imageData = new Float64Array(max);
    var sample;
     for (var j=0; j<max; j++) {
         sample = parseFloat(content[ j ])/65535;
         theDestination.imageData[ j ] = sample;
     }
     nextObject.followUp(parseInt(next));
}
function savedFromApp(source, success) {
    if (parseInt(success) === 1) {
        lutMessage.saved(parseInt(source), true);
    } else {
        lutMessage.saved(parseInt(source), false);
    }
}
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* lutcamerabox.js
* Camera and ISO options UI object for the LUTCalc Web App.
* 7th October 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTCameraBox(fieldset, inputs, messages) {
	this.inputs = inputs;
	this.messages = messages;
	this.p = 1;
	this.messages.addUI(this.p,this);
	this.box = document.createElement('fieldset');
	fieldset.appendChild(this.box);
	this.build();
	lutcalcReady(this.p);
}
LUTCameraBox.prototype.build = function() {
	this.io();
	this.ui();
};
LUTCameraBox.prototype.io = function() {
	this.cameras = [];
	this.cameraList();
	this.current = 0;
	this.manufacturerSelect = document.createElement('select');
	this.cameraSelect = document.createElement('select');
	this.manufacturerOptions();
	this.cameraOptions();
	this.inputs.addInput('bclip',this.cameras[this.current].bclip);
	this.inputs.addInput('wclip',this.cameras[this.current].wclip);
//	this.cameraSelect.options[this.current].selected = true;
	this.inputs.addInput('camera',this.cameraSelect);
	this.cameraType = document.createElement('input');
	this.cameraType.setAttribute('type','hidden');
	this.cameraType.value = this.cameras[this.current].type.toString();
	this.inputs.addInput('cameraType',this.cameraType);
	this.nativeLabel = document.createElement('label');
	this.inputs.addInput('nativeISO',this.nativeLabel);
	this.cineeiInput = document.createElement('input');
	this.cineeiInput.setAttribute('type','number');
	this.cineeiInput.className = 'iso-input';
	this.cineeiInput.value = this.cameras[this.current].iso.toString();
	this.inputs.addInput('cineEI',this.cineeiInput);
	this.shiftInput = document.createElement('input');
	this.shiftInput.setAttribute('type','number');
	this.shiftInput.setAttribute('step','any');
	this.shiftInput.className = 'shift-input';
	this.shiftInput.value = '0';
	this.inputs.addInput('stopShift',this.shiftInput);
	this.inputs.addInput('defGammaIn',this.cameras[this.current].defgamma);
	this.inputs.addInput('defGamutIn',this.cameras[this.current].defgamut);
};
LUTCameraBox.prototype.ui = function() {
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Camera')));
	this.box.appendChild(this.manufacturerSelect);
	this.box.appendChild(this.cameraSelect);
	this.box.appendChild(this.cameraType);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Native ISO:')));
	this.nativeLabel.innerHTML = this.cameras[this.current].iso.toString();
	this.box.appendChild(this.nativeLabel);
	this.recorded = document.createElement('div');
	this.cineeiLabel = document.createElement('label');
	this.cineeiLabel.innerHTML = 'CineEI ISO';
	this.recorded.appendChild(this.cineeiLabel);
	this.recorded.appendChild(this.cineeiInput);
	this.box.appendChild(this.recorded);
	this.shifted = document.createElement('div');
	this.shifted.appendChild(document.createElement('label').appendChild(document.createTextNode('Stop Correction')));
	this.shifted.appendChild(this.shiftInput);
	this.box.appendChild(this.shifted);
};
LUTCameraBox.prototype.events = function() {
	this.manufacturerSelect.onchange = function(here){ return function(){
		here.cameraOptions();
		here.changeCamera();
		here.messages.changeCamera();
	};}(this);
	this.cameraSelect.onchange = function(here){ return function(){
		here.changeCamera();
		here.messages.changeCamera();
	};}(this);
	this.cineeiInput.onchange = function(here){ return function(){
		here.changeCineEI();
		here.messages.gaSetParams();
	};}(this);
	this.shiftInput.onchange = function(here){ return function(){
		here.changeShift();
		here.messages.gaSetParams();
	};}(this);
};
// Set Up Data
LUTCameraBox.prototype.cameraList = function() {
// Type: 0 == CineEI, 1 == Variable Parameters (Arri), 2 == Baked In Gain (Canon)
	this.cameras.push({make:"Sony",model:"Venice",iso:500,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine (Venice)",bclip:-9,wclip:6});
	this.cameras.push({make:"Sony",model:"Venice (High Base)",iso:2500,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine (Venice)",bclip:-9,wclip:6});
	this.cameras.push({make:"Sony",model:"PXW-FX9",iso:800,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
	this.cameras.push({make:"Sony",model:"PXW-FX9 (High Base)",iso:4000,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
    this.cameras.push({make:"Sony",model:"PXW-FX6 CineEI",iso:800,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
    this.cameras.push({make:"Sony",model:"PXW-FX6 CineEI (High)",iso:12800,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
    this.cameras.push({make:"Sony",model:"PXW-FX6 Flexible ISO",iso:800,type:2,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
    this.cameras.push({make:"Sony",model:"PXW-FX3 CineEI",iso:800,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
    this.cameras.push({make:"Sony",model:"PXW-FX3 CineEI (High)",iso:12800,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
    this.cameras.push({make:"Sony",model:"PXW-FX3 Flexible ISO",iso:800,type:2,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
    this.cameras.push({make:"Sony",model:"PXW-FX30 CineEI",iso:800,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
    this.cameras.push({make:"Sony",model:"PXW-FX30 CineEI (High)",iso:2500,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
    this.cameras.push({make:"Sony",model:"PXW-FX30 Flexible ISO",iso:800,type:2,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
	this.cameras.push({make:"Sony",model:"PMW-F55",iso:1250,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
	this.cameras.push({make:"Sony",model:"PMW-F5",iso:2000,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
	this.cameras.push({make:"Sony",model:"PXW-FS7",iso:2000,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
	this.cameras.push({make:"Sony",model:"PXW-FS5",iso:3200,type:2,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
	this.cameras.push({make:"Sony",model:"NEX-FS700",iso:2000,type:2,defgamma:"S-Log2",defgamut:"Sony S-Gamut",bclip:-8,wclip:6});
	this.cameras.push({make:"Sony",model:"a7s mkII",iso:1600,type:2,defgamma:"S-Log3",defgamut:"Sony S-Gamut3.cine",bclip:-8,wclip:6});
	this.cameras.push({make:"Sony",model:"a7s",iso:3200,type:2,defgamma:"S-Log2",defgamut:"Sony S-Gamut",bclip:-8,wclip:6});
	this.cameras.push({make:"Sony",model:"F65",iso:800,type:0,defgamma:"S-Log3",defgamut:"Sony S-Gamut3",bclip:-8,wclip:6});
	this.cameras.push({make:"Sony",model:"PMW-F3",iso:800,type:0,defgamma:"S-Log",defgamut:"Sony S-Gamut",bclip:-6.6,wclip:5.5});
	this.cameras.push({make:"Sony",model:"F35",iso:500,type:0,defgamma:"S-Log",defgamut:"Sony S-Gamut",bclip:-6.6,wclip:5.5});
	this.cameras.push({make:"ARRI",model:"Alexa 35",iso:800,type:2,defgamma:"LogC4",defgamut:"ARRI Wide Gamut 4",bclip:-9.3,wclip:7.7});
	this.cameras.push({make:"ARRI",model:"Alexa / Amira",iso:800,type:1,defgamma:"LogC (Sup 3.x & 4.x)",defgamut:"Alexa Wide Gamut",bclip:-6.6,wclip:7.4});
	this.cameras.push({make:"RED",model:"Epic DRAGON",iso:800,type:0,defgamma:"REDLogFilm",defgamut:"DRAGONColor2",bclip:-10,wclip:6.3});
	this.cameras.push({make:"Canon",model:"C300mkIII",iso:800,type:2,defgamma:"Canon C-Log2",defgamut:"Canon Cinema Gamut",bclip:-8.7,wclip:6.3});
	this.cameras.push({make:"Canon",model:"C300mkII",iso:800,type:2,defgamma:"Canon C-Log2",defgamut:"Canon Cinema Gamut",bclip:-8.7,wclip:6.3});
	this.cameras.push({make:"Canon",model:"C300",iso:850,type:2,defgamma:"C-Log",defgamut:"Canon CP IDT (Daylight)",bclip:-6.7,wclip:5.3});
	this.cameras.push({make:"Canon",model:"C500",iso:850,type:2,defgamma:"C-Log",defgamut:"Canon Cinema Gamut",bclip:-6.7,wclip:5.3});
	this.cameras.push({make:"Canon",model:"C500mkIII",iso:800,type:2,defgamma:"Canon C-Log2",defgamut:"Canon Cinema Gamut",bclip:-8.7,wclip:6.3});
	this.cameras.push({make:"Apple",model:"iPhone 15 Pro",iso:55,type:2,defgamma:"Apple Log",defgamut:"Rec2020",bclip:-6.2,wclip:6});
	this.cameras.push({make:"Panasonic",model:"Varicam 35",iso:800,type:2,defgamma:"Panasonic V-Log",defgamut:"Panasonic V-Gamut",bclip:-7.5,wclip:6.5});
	this.cameras.push({make:"Panasonic",model:"Varicam 35 (High Base)",iso:5000,type:2,defgamma:"Panasonic V-Log",defgamut:"Panasonic V-Gamut",bclip:-7.5,wclip:6.5});
	this.cameras.push({make:"Panasonic",model:"AU-EVA1",iso:800,type:2,defgamma:"Panasonic V-Log",defgamut:"Panasonic V-Gamut",bclip:-7.5,wclip:6.5});
	this.cameras.push({make:"Panasonic",model:"AU-EVA1 (High Base)",iso:2500,type:2,defgamma:"Panasonic V-Log",defgamut:"Panasonic V-Gamut",bclip:-7.5,wclip:6.5});
	this.cameras.push({make:"Panasonic",model:"GH4",iso:200,type:2,defgamma:"Panasonic V-Log",defgamut:"Panasonic V-Gamut",bclip:-8,wclip:4});
	this.cameras.push({make:"Panasonic",model:"GH5",iso:200,type:2,defgamma:"Panasonic V-Log",defgamut:"Panasonic V-Gamut",bclip:-8,wclip:4});
	this.cameras.push({make:"Blackmagic",model:"URSA Mini Pro 12k",iso:800,type:2,defgamma:"BMDFilm Gen5",defgamut:"Blackmagic Wide Gamut",bclip:-7.5,wclip:6.7});
	this.cameras.push({make:"Blackmagic",model:"URSA Cine",iso:800,type:2,defgamma:"BMDFilm Gen5",defgamut:"Blackmagic Wide Gamut",bclip:-7.5,wclip:6.7});
	this.cameras.push({make:"Blackmagic",model:"PYXIS",iso:400,type:2,defgamma:"BMDFilm Gen5",defgamut:"Blackmagic Wide Gamut",bclip:-7.6,wclip:5.9});
	this.cameras.push({make:"Blackmagic",model:"PYXIS (High Base)",iso:3200,type:2,defgamma:"BMDFilm Gen5",defgamut:"Blackmagic Wide Gamut",bclip:-7.6,wclip:5.9});
	this.cameras.push({make:"Blackmagic",model:"Pocket Cinema 6k",iso:400,type:2,defgamma:"BMD Pocket Film",defgamut:"Passthrough",bclip:-7.5,wclip:5.9});
	this.cameras.push({make:"Blackmagic",model:"Pocket Cinema 6k (High Base)",iso:3200,type:2,defgamma:"BMD Pocket Film",defgamut:"Passthrough",bclip:-6.5,wclip:5.6});
	this.cameras.push({make:"Blackmagic",model:"Pocket Cinema 4k",iso:400,type:2,defgamma:"BMD Pocket Film",defgamut:"Passthrough",bclip:-7.6,wclip:5.5});
	this.cameras.push({make:"Blackmagic",model:"Pocket Cinema 4k (High Base)",iso:3200,type:2,defgamma:"BMD Pocket Film",defgamut:"Passthrough",bclip:-7.2,wclip:5.1});
    this.cameras.push({make:"Fujifilm",model:"Mirrorless (F-Log2)",iso:1250,type:2,defgamma:"Fujifilm F-Log2",defgamut:"Fujifilm F-Log Gamut",bclip:-7.6,wclip:6.4});
    this.cameras.push({make:"Fujifilm",model:"Mirrorless (F-Log)",iso:640,type:2,defgamma:"Fujifilm F-Log",defgamut:"Fujifilm F-Log Gamut",bclip:-7.6,wclip:5.4});
	this.cameras.push({make:"GoPro",model:"Hero",iso:400,type:2,defgamma:"Protune",defgamut:"Protune Native",bclip:-9,wclip:3.3});
	this.cameras.push({make:"DJI",model:"4D 6k",iso:800,type:2,defgamma:"DJI X5/X7/X9 DLog",defgamut:"DJI D-Gamut",bclip:-7.2,wclip:7.1});
	this.cameras.push({make:"DJI",model:"4D 6k (High Base)",iso:5000,type:2,defgamma:"DJI X5/X7/X9 DLog",defgamut:"DJI D-Gamut",bclip:-7.0,wclip:7.1});
	this.cameras.push({make:"DJI",model:"4D 8k",iso:800,type:2,defgamma:"DJI X5/X7/X9 DLog",defgamut:"DJI D-Gamut",bclip:-7.6,wclip:7.1});
	this.cameras.push({make:"DJI",model:"4D 8k (High Base)",iso:4000,type:2,defgamma:"DJI X5/X7/X9 DLog",defgamut:"DJI D-Gamut",bclip:-7.4,wclip:7.1});
	this.cameras.push({make:"DJI",model:"Mavic 2",iso:400,type:2,defgamma:"DJI DLog-M",defgamut:"Passthrough",bclip:-10.3,wclip:3.7});
	this.cameras.push({make:"DJI",model:"Mini 2",iso:100,type:2,defgamma:"DJI Mini 2",defgamut:"Rec709",bclip:-7,wclip:2.8});
	this.cameras.push({make:"DJI",model:"Zenmuse X9-6k",iso:800,type:2,defgamma:"DJI X5/X7/X9 DLog",defgamut:"DJI D-Gamut",bclip:-7.2,wclip:7.1});
	this.cameras.push({make:"DJI",model:"Zenmuse X9-6k (High Base)",iso:5000,type:2,defgamma:"DJI X5/X7/X9 DLog",defgamut:"DJI D-Gamut",bclip:-7.0,wclip:7.1});
	this.cameras.push({make:"DJI",model:"Zenmuse X9-8k",iso:800,type:2,defgamma:"DJI X5/X7/X9 DLog",defgamut:"DJI D-Gamut",bclip:-7.6,wclip:7.1});
	this.cameras.push({make:"DJI",model:"Zenmuse X9-8k (High Base)",iso:4000,type:2,defgamma:"DJI X5/X7/X9 DLog",defgamut:"DJI D-Gamut",bclip:-7.4,wclip:7.1});
	this.cameras.push({make:"DJI",model:"Zenmuse X7",iso:400,type:2,defgamma:"DJI X5/X7/X9 DLog",defgamut:"Passthrough",bclip:-9.2,wclip:4.8});
	this.cameras.push({make:"DJI",model:"Zenmuse X5S",iso:500,type:2,defgamma:"DJI X5/X7/X9 DLog",defgamut:"Passthrough",bclip:-7.7,wclip:5.13});
	this.cameras.push({make:"DJI",model:"Zenmuse X3",iso:100,type:2,defgamma:"DJI X3 DLog",defgamut:"Passthrough",bclip:-7,wclip:3});
	this.cameras.push({make:"Nikon",model:"Z6",iso:800,type:2,defgamma:"Nikon N-Log",defgamut:"Rec2020",bclip:-6,wclip:6});
	this.cameras.push({make:"Nikon",model:"Z7",iso:800,type:2,defgamma:"Nikon N-Log",defgamut:"Rec2020",bclip:-6,wclip:6});
//	this.cameras.push({make:"Nikon",model:"Z780",iso:800,type:2,defgamma:"NLog",defgamut:"Rec2020",bclip:-6,wclip:6});
	this.cameras.push({make:"Nikon",model:"D800",iso:100,type:2,defgamma:"Nikon Neutral",defgamut:"Passthrough",bclip:-10.9,wclip:3.5});
	this.cameras.push({make:"",model:"Generic",iso:800,type:2,defgamma:"Cineon",defgamut:"Rec709",bclip:-9,wclip:9});
};
LUTCameraBox.prototype.clearSelect = function(sel) {
	var m = sel.options.length;
	for (var j=0; j<m; j++) {
		sel.remove(0);
	}
};
LUTCameraBox.prototype.manufacturerOptions = function() {
	var manufacturers = ["Sony", "ARRI", "RED", "Canon", "Apple", "Panasonic", "Blackmagic", "Fujifilm", "GoPro", "DJI", "Nikon", "All"];
	var max = manufacturers.length;
	for (var i=0; i<max; i++) {
		var option = document.createElement('option');
		option.value = manufacturers[i];
		option.appendChild(document.createTextNode(manufacturers[i]));
		if (manufacturers[i] === 'Sony') {
			option.selected = true;
		}
		this.manufacturerSelect.appendChild(option);
	}
}
LUTCameraBox.prototype.cameraOptions = function() {
	this.clearSelect(this.cameraSelect);
	var max = this.cameras.length;
	var currentMake = this.manufacturerSelect.options[this.manufacturerSelect.selectedIndex].value;
	if (currentMake === "All") {
		for (var i=0; i<max; i++) {
			var option = document.createElement('option');
			option.value = i;
			option.appendChild(document.createTextNode(this.cameras[i].make + " " + this.cameras[i].model));
			if (this.cameraSelect.options.length === 0) {
				this.current = i;
				option.selected = true;
			}
			this.cameraSelect.appendChild(option);
		}
	} else {
		for (var i=0; i<max; i++) {
			if (this.cameras[i].make === currentMake || this.cameras[i].make === "") {
				var option = document.createElement('option');
				option.value = i;
				option.appendChild(document.createTextNode(this.cameras[i].model));
				if (this.cameraSelect.options.length === 0) {
					this.current = i;
					option.selected = true;
				}
				this.cameraSelect.appendChild(option);
			}
		}
	}
};
// Event Responses
LUTCameraBox.prototype.changeCamera = function() {
	this.current = parseInt(this.cameraSelect.options[this.cameraSelect.selectedIndex].value);
	this.inputs.defGammaIn = this.cameras[this.current].defgamma;
	this.inputs.defGamutIn = this.cameras[this.current].defgamut;
	var m = this.inputs.inGammaSubs.options.length;
	var found = false;
	var allIdx = m-1;
	for (var j=0; j<m; j++) {
		if (this.inputs.inGammaSubs.options[j].lastChild.nodeValue === this.cameras[this.current].make) {
			this.inputs.inGammaSubs.options[j].selected = true;
			found = true;
			break;
		} else if (this.inputs.inGammaSubs.options[j].lastChild.nodeValue === 'All') {
			allIdx = j;
		}
	}
	if (!found) {
		this.inputs.inGammaSubs.options[allIdx].selected = true;
	}
	found = false;
	allIdx = m-1;
	m = this.inputs.inGamutSubs.options.length;
	for (var j=0; j<m; j++) {
		if (this.inputs.inGamutSubs.options[j].lastChild.nodeValue === this.cameras[this.current].make) {
			this.inputs.inGamutSubs.options[j].selected = true;
			found = true;
			break;
		} else if (this.inputs.inGamutSubs.options[j].lastChild.nodeValue === 'All') {
			allIdx = j;
		}
	}
	if (!found) {
		this.inputs.inGamutSubs.options[allIdx].selected = true;
	}
	this.inputs.bclip = this.cameras[this.current].bclip;
	this.inputs.wclip = this.cameras[this.current].wclip;
	if (this.cameras[this.current].model === 'Generic') {
		this.nativeLabel.innerHTML = 'N/A';
	} else {
		this.nativeLabel.innerHTML = this.cameras[this.current].iso.toString();
	}
	this.cineeiInput.value = this.cameras[this.current].iso.toString();
	this.shiftInput.value = '0';
	this.cameraType.value = this.cameras[this.current].type.toString();
	if (this.cameras[this.current].type === 2) {
		this.recorded.className = 'base-inputbox-hide';
		this.shifted.className = 'base-inputbox';
	} else if (this.cameras[this.current].type === 1) {
		this.recorded.className = 'base-inputbox';
		this.shifted.className = 'base-inputbox';
		this.cineeiLabel.innerHTML = 'Recorded ISO';
	} else {
		this.recorded.className = 'base-inputbox';
		this.shifted.className = 'base-inputbox';
		this.cineeiLabel.innerHTML = 'CineEI ISO';
	}
	this.cameraType.value = this.cameras[this.current].type;
};
LUTCameraBox.prototype.changeCineEI = function(){
	if (/^([1-9]\d*)$/.test(this.cineeiInput.value)) {
	} else {
		this.cineeiInput.value = this.cameras[this.current].iso.toString();
	}
	if (this.cameras[this.current].type === 0) {
		var stopShift = (Math.log(parseFloat(this.cineeiInput.value)/parseFloat(this.nativeLabel.innerHTML))/Math.LN2);
		this.shiftInput.value = stopShift.toFixed(4).toString();
	}
};
LUTCameraBox.prototype.changeShift = function() {
	if (!isNaN(parseFloat(this.shiftInput.value)) && isFinite(this.shiftInput.value)) {
	} else {
		this.shiftInput.value = '0';
	}
	if (this.cameras[this.current].type === 0) {
		this.cineeiInput.value = Math.round((Math.pow(2,parseFloat(this.shiftInput.value)))*parseFloat(this.nativeLabel.innerHTML)).toString();
	}

};
LUTCameraBox.prototype.getCamera = function() {
    var idx = parseInt(this.cameraSelect.options[this.cameraSelect.selectedIndex].value);
    return this.cameras[idx].make + " " + this.cameras[idx].model;
};
LUTCameraBox.prototype.getInfo = function(info) {
	var idx = parseInt(this.cameraSelect.options[this.cameraSelect.selectedIndex].value);
	info.camera = this.cameras[idx].make + " " + this.cameras[idx].model;
	info.camera = info.camera.trim();
	info.cineEI = parseFloat(this.shiftInput.value);
};
LUTCameraBox.prototype.getSettings = function(data) {
	var camIdx = parseInt(this.cameraSelect.options[this.cameraSelect.selectedIndex].value);
	data.cameraBox = {
		make: this.cameras[camIdx].make,
		model: this.cameras[camIdx].model,
		shift: parseFloat(this.shiftInput.value)
	};
};
LUTCameraBox.prototype.setSettings = function(settings) {
	if (typeof settings.cameraBox !== 'undefined') {
		var data = settings.cameraBox;

        if (typeof data.model === 'string') {
			var m = this.cameras.length;
            var idx = 0;
			for (var j=0; j<m; j++) {
				if (this.cameras[j].model === data.model) {
                    idx = j;
					break;
				}
			}
            m = this.manufacturerSelect.options.length;
            this.manufacturerSelect.options[m - 1].selected = true;
            for (var j=0; j<m; j++) {
                if (this.manufacturerSelect.options[j].lastChild.nodeValue === this.cameras[idx].make) {
                    this.manufacturerSelect.options[j].selected = true;
                    break;
                }
            }
            this.cameraOptions();
            m = this.cameraSelect.length;
            for (var j=0; j<m; j++) {
                if (parseInt(this.cameraSelect.options[j].value) === idx) {
                    this.cameraSelect.options[j].selected = true;
                    break;
                }
            }
			this.changeCamera();
		}
		if (typeof data.shift === 'number') {
			this.shiftInput.value = data.shift.toString();
			this.changeShift();
		}
	}
};
LUTCameraBox.prototype.getHeight = function() {
	return this.box.clientHeight;
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* lutgammabox.js
* Transfer curve and colour space conversion (Gamma and Gamut) options UI object for the LUTCalc Web App.
* 9th January 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTGammaBox(fieldset,inputs,messages) {
	this.box = document.createElement('fieldset');
	this.inputs = inputs;
	this.messages = messages;
	this.p = 2;
	this.messages.addUI(this.p,this);
	this.gamutPass = 0;
	this.gamutLA = 0;
	this.build();
	fieldset.appendChild(this.box);
	lutcalcReady(this.p);
}
LUTGammaBox.prototype.build = function() {
	this.io();
	this.ui();
};
LUTGammaBox.prototype.io = function() {
	this.inGammaOpts = [];
	this.inputs.addInput('inGammaOpts',this.inGammaOpts);
	this.inLinGammaOpts = [];
	this.inputs.addInput('inLinGammaOpts',this.inLinGammaOpts);
	this.outGammaOpts = [];
	this.inputs.addInput('outGammaOpts',this.outGammaOpts);
	this.outLinGammaOpts = [];
	this.inputs.addInput('outLinGammaOpts',this.outLinGammaOpts);
	this.inGammaSubOpts = [];
	this.inputs.addInput('inGammaSubOpts',this.inGammaSubOpts);
	this.outGammaSubOpts = [];
	this.inputs.addInput('outGammaSubOpts',this.outGammaSubOpts);
	this.inGamutOpts = [];
	this.inputs.addInput('inGamutOpts',this.inGamutOpts);
	this.outGamutOpts = [];
	this.inputs.addInput('outGamutOpts',this.outGamutOpts);
	this.inGamutSubOpts = [];
	this.inputs.addInput('inGamutSubOpts',this.inGamutSubOpts);
	this.outGamutSubOpts = [];
	this.inputs.addInput('outGamutSubOpts',this.outGamutSubOpts);
	this.inGammaSubs = document.createElement('select');
	this.inputs.addInput('inGammaSubs',this.inGammaSubs);
	this.inGammaSelect = document.createElement('select');
	this.inputs.addInput('inGamma',this.inGammaSelect);
	this.inLinSelect = document.createElement('select');
	this.inputs.addInput('inLinGamma',this.inLinSelect);
	this.inConSelect = document.createElement('select');
	this.inputs.addInput('inConGamma',this.inConSelect);
	this.inGamutSubs = document.createElement('select');
	this.inputs.addInput('inGamutSubs',this.inGamutSubs);
	this.inGamutSelect = document.createElement('select');
	this.inputs.addInput('inGamut',this.inGamutSelect);
	this.outGammaSubs = document.createElement('select');
	this.inputs.addInput('outGammaSubs',this.outGammaSubs);
	this.outGammaSelect = document.createElement('select');
	this.inputs.addInput('outGamma',this.outGammaSelect);
	this.outLinSelect = document.createElement('select');
	this.inputs.addInput('outLinGamma',this.outLinSelect);
	this.outConSelect = document.createElement('select');
	this.inputs.addInput('outConGamma',this.outConSelect);
	this.buildContrast();
	this.outGamutSubs = document.createElement('select');
	this.inputs.addInput('outGamutSubs',this.outGamutSubs);
	this.outGamutSelect = document.createElement('select');
	this.inputs.addInput('outGamut',this.outGamutSelect);

	this.pqOOTFLwIn = document.createElement('input');
	this.inputs.addInput('inPQLw',this.pqOOTFLwIn);
	this.pqOOTFLwIn.setAttribute('type','number');
	this.pqOOTFLwIn.setAttribute('step',1);
	this.pqOOTFLwIn.className = 'base-input';
	this.pqOOTFLwIn.value = 10000;
	this.pqOOTFLwOut = document.createElement('input');
	this.inputs.addInput('outPQLw',this.pqOOTFLwOut);
	this.pqOOTFLwOut.setAttribute('type','number');
	this.pqOOTFLwOut.setAttribute('step',1);
	this.pqOOTFLwOut.className = 'base-input';
	this.pqOOTFLwOut.value = this.pqOOTFLwIn.value;

	this.pqEOTFLwIn = document.createElement('input');
	this.inputs.addInput('inPQEOTFLw',this.pqEOTFLwIn);
	this.pqEOTFLwIn.setAttribute('type','number');
	this.pqEOTFLwIn.setAttribute('step',1);
	this.pqEOTFLwIn.className = 'base-input';
	this.pqEOTFLwIn.value = 10000;
	this.pqEOTFLwOut = document.createElement('input');
	this.inputs.addInput('outPQEOTFLw',this.pqEOTFLwOut);
	this.pqEOTFLwOut.setAttribute('type','number');
	this.pqEOTFLwOut.setAttribute('step',1);
	this.pqEOTFLwOut.className = 'base-input';
	this.pqEOTFLwOut.value = this.pqEOTFLwIn.value;

	this.hlgOOTFLwIn = document.createElement('input');
	this.inputs.addInput('inHLGLw',this.hlgOOTFLwIn);
	this.hlgOOTFLwIn.setAttribute('type','number');
	this.hlgOOTFLwIn.setAttribute('step',1);
	this.hlgOOTFLwIn.className = 'base-input';
	this.hlgOOTFLwIn.value = 1000;
	this.hlgOOTFLbIn = document.createElement('input');
	this.inputs.addInput('inHLGLb',this.hlgOOTFLbIn);
	this.hlgOOTFLbIn.setAttribute('type','number');
	this.hlgOOTFLbIn.setAttribute('step',1);
	this.hlgOOTFLbIn.className = 'base-input';
	this.hlgOOTFLbIn.value = 0;
	this.hlgOOTFLwOut = document.createElement('input');
	this.inputs.addInput('outHLGLw',this.hlgOOTFLwOut);
	this.hlgOOTFLwOut.setAttribute('type','number');
	this.hlgOOTFLwOut.setAttribute('step','any');
	this.hlgOOTFLwOut.className = 'base-input';
	this.hlgOOTFLwOut.value = this.hlgOOTFLwIn.value;
	this.hlgOOTFLbOut = document.createElement('input');
	this.inputs.addInput('outHLGLb',this.hlgOOTFLbOut);
	this.hlgOOTFLbOut.setAttribute('type','number');
	this.hlgOOTFLbOut.setAttribute('step','any');
	this.hlgOOTFLbOut.className = 'base-input';
	this.hlgOOTFLbOut.value = this.hlgOOTFLbIn.value;

	this.hlgScaleIn = [];
	this.hlgScaleIn[0] = lutRadioElement('hlgScaleIn', true); // NHK / Base Spec (90% maps to 50% IRE)
	this.hlgScaleIn[1] = lutRadioElement('hlgScaleIn', false); // BBC (90% maps to 75% IRE)
	this.inputs.addInput('hlgBBCScaleIn',this.hlgScaleIn);
	this.hlgScaleOut = [];
	this.hlgScaleOut[0] = lutRadioElement('hlgScaleOut', true); // NHK / Base Spec (90% maps to 50% IRE)
	this.hlgScaleOut[1] = lutRadioElement('hlgScaleOut', false); // BBC (90% maps to 75% IRE)
	this.inputs.addInput('hlgBBCScaleOut',this.hlgScaleOut);
	
	this.arriLegalIn = [];
	this.arriLegalIn[0] = lutRadioElement('arriLegalIn', true); // ARRI recording legal / full range
	this.arriLegalIn[1] = lutRadioElement('arriLegalIn', false); 
	this.inputs.addInput('arriLegalIn',this.arriLegalIn);
	this.arriLegalOut = [];
	this.arriLegalOut[0] = lutRadioElement('arriLegalOut', true); // ARRI recording legal / full range
	this.arriLegalOut[1] = lutRadioElement('arriLegalOut', false);
	this.inputs.addInput('arriLegalOut',this.arriLegalOut);
};
LUTGammaBox.prototype.ui = function() {
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Rec Gamma')));
	var inGaBox = document.createElement('div');
	inGaBox.className = 'gam-selects-box';
	this.box.appendChild(inGaBox);
	inGaBox.appendChild(this.inGammaSubs);
	inGaBox.appendChild(this.inGammaSelect);
	this.box.appendChild(document.createElement('br'));
	this.inLin = document.createElement('div');
	this.inLin.className = 'smallerbox';
	this.inLin.appendChild(document.createElement('label').appendChild(document.createTextNode('γ Correction')));
	this.inLin.appendChild(this.inLinSelect);
	this.box.appendChild(this.inLin);

	this.inCon = document.createElement('div');
	this.inCon.className = 'smallerbox';
	this.inCon.appendChild(document.createElement('label').appendChild(document.createTextNode('Contrast')));
	this.inCon.appendChild(this.inConSelect);
	this.box.appendChild(this.inCon);
	
	this.pqOOTFInBox = document.createElement('div');
	this.pqOOTFInBox.className = 'smallerbox';
	this.pqOOTFInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Display: Peak Mastering Level (Lw)')));
	this.pqOOTFInBox.appendChild(this.pqOOTFLwIn);
	this.pqOOTFInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('nits')));
	this.box.appendChild(this.pqOOTFInBox);

	this.pqEOTFInBox = document.createElement('div');
	this.pqEOTFInBox.className = 'smallerbox';
	this.pqEOTFInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Display: Peak Mastering Level (Lw)')));
	this.pqEOTFInBox.appendChild(this.pqEOTFLwIn);
	this.pqEOTFInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('nits')));
	this.box.appendChild(this.pqEOTFInBox);
	
	this.hlgOOTFInBox = document.createElement('div');
	this.hlgOOTFInBox.className = 'smallerbox';
	this.hlgOOTFInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Display: Peak Mastering Level (Lw)')));
	this.hlgOOTFInBox.appendChild(this.hlgOOTFLwIn);
	this.hlgOOTFInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('nits')));
//	this.hlgOOTFInBox.appendChild(this.hlgOOTFLbIn);
	this.box.appendChild(this.hlgOOTFInBox);

	this.hlgOETFInBox = document.createElement('div');
	this.hlgOETFInBox.className = 'smallerbox';
	this.hlgOETFInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Reference White Scaling')));
	this.hlgOETFInBox.appendChild(this.hlgScaleIn[0]);
	this.hlgOETFInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('NHK / Spec. Base')));
	this.hlgOETFInBox.appendChild(this.hlgScaleIn[1]);
	this.hlgOETFInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('BBC')));
	this.box.appendChild(this.hlgOETFInBox);
	
	this.arriLegalInBox = document.createElement('div');
	this.arriLegalInBox.className = 'smallerbox';
	this.arriLegalInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Codec Range')));
	this.arriLegalInBox.appendChild(this.arriLegalIn[0]);
	this.arriLegalInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Legal')));
	this.arriLegalInBox.appendChild(this.arriLegalIn[1]);
	this.arriLegalInBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Full Range')));
	this.box.appendChild(this.arriLegalInBox);
	
	this.inGamutBox = document.createElement('div');
	this.inGamutBox.className = 'base-inputbox';
	this.inGamutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Rec Gamut')));
	var inGtBox = document.createElement('div');
	inGtBox.className = 'gam-selects-box';
	this.inGamutBox.appendChild(inGtBox);
	inGtBox.appendChild(this.inGamutSubs);
	inGtBox.appendChild(this.inGamutSelect);
	this.box.appendChild(this.inGamutBox);

	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Out Gamma')));
	var outGaBox = document.createElement('div');
	outGaBox.className = 'gam-selects-box';
	this.box.appendChild(outGaBox);
	outGaBox.appendChild(this.outGammaSubs);
	outGaBox.appendChild(this.outGammaSelect);
	this.box.appendChild(document.createElement('br'));
	this.outLin = document.createElement('div');
	this.outLin.className = 'smallerbox';
	this.outLin.appendChild(document.createElement('label').appendChild(document.createTextNode('γ Correction')));
	this.outLin.appendChild(this.outLinSelect);
	this.box.appendChild(this.outLin);

	this.outCon = document.createElement('div');
	this.outCon.className = 'smallerbox';
	this.outCon.appendChild(document.createElement('label').appendChild(document.createTextNode('Contrast')));
	this.outCon.appendChild(this.outConSelect);
	this.box.appendChild(this.outCon);

	this.pqOOTFOutBox = document.createElement('div');
	this.pqOOTFOutBox.className = 'smallerbox';
	this.pqOOTFOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Display: Peak Mastering Level (Lw)')));
	this.pqOOTFOutBox.appendChild(this.pqOOTFLwOut);
	this.pqOOTFOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('nits')));
	this.box.appendChild(this.pqOOTFOutBox);

	this.pqEOTFOutBox = document.createElement('div');
	this.pqEOTFOutBox.className = 'smallerbox';
	this.pqEOTFOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Display: Peak Mastering Level (Lw)')));
	this.pqEOTFOutBox.appendChild(this.pqEOTFLwOut);
	this.pqEOTFOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('nits')));
	this.box.appendChild(this.pqEOTFOutBox);
	
	this.hlgOOTFOutBox = document.createElement('div');
	this.hlgOOTFOutBox.className = 'smallerbox';
	this.hlgOOTFOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Display: Peak Mastering Level (Lw)')));
	this.hlgOOTFOutBox.appendChild(this.hlgOOTFLwOut);
	this.hlgOOTFOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('nits')));
//	this.hlgOOTFInBox.appendChild(this.hlgOOTFLbOut);
	this.box.appendChild(this.hlgOOTFOutBox);

	this.hlgOETFOutBox = document.createElement('div');
	this.hlgOETFOutBox.className = 'smallerbox';
	this.hlgOETFOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Reference White Scaling')));
	this.hlgOETFOutBox.appendChild(this.hlgScaleOut[0]);
	this.hlgOETFOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('NHK / Spec. Base')));
	this.hlgOETFOutBox.appendChild(this.hlgScaleOut[1]);
	this.hlgOETFOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('BBC')));
	this.box.appendChild(this.hlgOETFOutBox);

	this.arriLegalOutBox = document.createElement('div');
	this.arriLegalOutBox.className = 'smallerbox';
	this.arriLegalOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Codec Range')));
	this.arriLegalOutBox.appendChild(this.arriLegalOut[0]);
	this.arriLegalOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Legal')));
	this.arriLegalOutBox.appendChild(this.arriLegalOut[1]);
	this.arriLegalOutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Full Range')));
	this.box.appendChild(this.arriLegalOutBox);

	this.outGamutBox = document.createElement('div');
	this.outGamutBox.className = 'base-inputbox';
	this.outGamutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Out Gamut')));
	var outGtBox = document.createElement('div');
	outGtBox.className = 'gam-selects-box';
	this.outGamutBox.appendChild(outGtBox);
	outGtBox.appendChild(this.outGamutSubs);
	outGtBox.appendChild(this.outGamutSelect);
	this.box.appendChild(this.outGamutBox);
	this.inLin.className = 'smallerbox-hide';
	this.inGamutBox.className = 'base-inputbox-hide';
	this.outLin.className = 'smallerbox-hide';
	this.outGamutBox.className = 'base-inputbox-hide';
};
LUTGammaBox.prototype.events = function() {
	this.inGammaSubs.onchange = function(here){ return function(){
		here.updateGammaInList(true);
		maxHeights();
	};}(this);
	this.inGamutSubs.onchange = function(here){ return function(){
		here.updateGamutInList(true);
	};}(this);
	this.inGammaSelect.onchange = function(here){ return function(){
		here.changeGammaIn();
		maxHeights();
		here.messages.gaSetParams();
	};}(this);
	this.inLinSelect.onchange = function(here){ return function(){
		here.changeGammaIn();
		here.messages.gaSetParams();
	};}(this);
	this.inConSelect.onchange = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.outGammaSubs.onchange = function(here){ return function(){
		here.updateGammaOutList(true);
		maxHeights();
	};}(this);
	this.outGamutSubs.onchange = function(here){ return function(){
		here.updateGamutOutList(true);
	};}(this);
	this.outGammaSelect.onchange = function(here){ return function(){
		here.changeGammaOut();
		maxHeights();
		here.messages.gaSetParams();
	};}(this);
	this.outLinSelect.onchange = function(here){ return function(){
		here.changeGammaOut();
		here.messages.gaSetParams();
	};}(this);
	this.outConSelect.onchange = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.inGamutSelect.onchange = function(here){ return function(){
		here.changeInGamut();
		here.messages.gtSetParams();
	};}(this);
	this.outGamutSelect.onchange = function(here){ return function(){
		here.changeOutGamut();
		here.messages.gtSetParams();
	};}(this);

	this.pqOOTFLwIn.onchange = function(here){ return function(){
		here.testPQLw(true);
		here.messages.gaSetParams();
	};}(this);
	this.pqOOTFLwOut.onchange = function(here){ return function(){
		here.testPQLw(false);
		here.messages.gaSetParams();
	};}(this);

	this.hlgOOTFLwIn.onchange = function(here){ return function(){
		here.testHLGLw(true);
		here.messages.gaSetParams();
	};}(this);
	this.hlgOOTFLwOut.onchange = function(here){ return function(){
		here.testHLGLw(false);
		here.messages.gaSetParams();
	};}(this);

	this.pqEOTFLwIn.onchange = function(here){ return function(){
		here.testPQEOTFLw(true);
		here.messages.gaSetParams();
	};}(this);
	this.pqEOTFLwOut.onchange = function(here){ return function(){
		here.testPQEOTFLw(false);
		here.messages.gaSetParams();
	};}(this);
	
	this.hlgScaleIn[0].onchange = function(here){ return function(){
//		here.testNHKBBC(true);
		here.messages.gaSetParams();
	};}(this);
	this.hlgScaleIn[1].onchange = function(here){ return function(){
//		here.testNHKBBC(true);
		here.messages.gaSetParams();
	};}(this);
	this.hlgScaleOut[0].onchange = function(here){ return function(){
//		here.testNHKBBC(false);
		here.messages.gaSetParams();
	};}(this);
	this.hlgScaleOut[1].onchange = function(here){ return function(){
//		here.testNHKBBC(false);
		here.messages.gaSetParams();
	};}(this);

	this.arriLegalIn[0].onchange = function(here){ return function(){
		here.messages.updateARRIRangeIn();
		here.messages.gaSetParams();
	};}(this);
	this.arriLegalIn[1].onchange = function(here){ return function(){
		here.messages.updateARRIRangeIn();
		here.messages.gaSetParams();
	};}(this);
	this.arriLegalOut[0].onchange = function(here){ return function(){
		here.messages.updateARRIRangeOut();
		here.messages.gaSetParams();
	};}(this);
	this.arriLegalOut[1].onchange = function(here){ return function(){
		here.messages.updateARRIRangeOut();
		here.messages.gaSetParams();
	};}(this);
};
// Set Up Data
LUTGammaBox.prototype.gotGammaLists = function() {
	var inList = this.inputs.gammaInList;
	var outList = this.inputs.gammaOutList;
	var linList = this.inputs.gammaLinList;
	var subNames = this.inputs.gammaSubNames;
	this.inGammaSubs.length = 0;
	this.inGammaSelect.length = 0;
	this.outGammaSubs.length = 0;
	this.outGammaSelect.length = 0;
	this.inLinSelect.length = 0;
	this.outLinSelect.length = 0;
	var max = inList.length;
	for (var i=0; i < max; i++) {
		this.inGammaOpts[i] = document.createElement('option');
		if (inList[i].name === this.inputs.defGammaIn) {
			this.inGammaOpts[i].selected = true;
		}
		this.inGammaOpts[i].value = inList[i].idx;
		this.inGammaOpts[i].appendChild(document.createTextNode(inList[i].name));
		this.inGammaSelect.appendChild(this.inGammaOpts[i]);
	}
	max = outList.length;
	for (var i=0; i < max; i++) {
		this.outGammaOpts[i] = document.createElement('option');
		this.outGammaOpts[i].value = outList[i].idx;
		this.outGammaOpts[i].appendChild(document.createTextNode(outList[i].name));
		this.outGammaSelect.appendChild(this.outGammaOpts[i]);
	}
	max = linList.length;
	for (var i=0; i < max; i++) {
		this.inLinGammaOpts[i] = document.createElement('option');
		this.inLinGammaOpts[i].value = linList[i].idx;
		this.inLinGammaOpts[i].appendChild(document.createTextNode(linList[i].name));
		this.inLinSelect.appendChild(this.inLinGammaOpts[i]);
		this.outLinGammaOpts[i] = document.createElement('option');
		this.outLinGammaOpts[i].value = linList[i].idx;
		this.outLinGammaOpts[i].appendChild(document.createTextNode(linList[i].name));
		this.outLinSelect.appendChild(this.outLinGammaOpts[i]);
	}
	max = subNames.length;
	for (var i=0; i < max; i++) {
		this.inGammaSubOpts[i] = document.createElement('option');
		this.inGammaSubOpts[i].value = i;
		this.inGammaSubOpts[i].appendChild(document.createTextNode(subNames[i]));
		this.inGammaSubs.appendChild(this.inGammaSubOpts[i]);
		this.outGammaSubOpts[i] = document.createElement('option');
		this.outGammaSubOpts[i].value = i;
		this.outGammaSubOpts[i].appendChild(document.createTextNode(subNames[i]));
		if (subNames[i] === 'All') {
			this.outGammaSubOpts[i].selected = true;
		}
		this.outGammaSubs.appendChild(this.outGammaSubOpts[i]);
	}
	this.updateGammaInList(false);
	this.updateGammaOutList(true);
};
LUTGammaBox.prototype.gotGamutLists = function(pass,LA) {
	var inList = this.inputs.gamutInList;
	var outList = this.inputs.gamutOutList;
	var subNames = this.inputs.gamutSubNames;
	var inSubs = this.inputs.gamutInSubLists;
	var outSubs = this.inputs.gamutOutSubLists;
	max = inList.length;
	for (var i=0; i < max; i++) {
		this.inGamutOpts[i] = document.createElement('option');
		this.inGamutOpts[i].value = inList[i].idx;
		if (inList[i].name === 'Custom In') {
			this.inputs.addInput('custGamInIdx',i);
			inList[i].name = 'Custom';
		}
		this.inGamutOpts[i].appendChild(document.createTextNode(inList[i].name));
		if (inList[i].name === this.inputs.defGamutIn) {
			this.inGamutOpts[i].selected = true;
		}
		this.inGamutSelect.appendChild(this.inGamutOpts[i]);
	}
	max = outList.length;
	for (var i=0; i < max; i++) {
		this.outGamutOpts[i] = document.createElement('option');
		this.outGamutOpts[i].value = outList[i].idx;
		if (outList[i].name === 'Custom Out') {
			this.inputs.addInput('custGamOutIdx',i);
			outList[i].name = 'Custom';
		}
		this.outGamutOpts[i].appendChild(document.createTextNode(outList[i].name));
		this.outGamutSelect.appendChild(this.outGamutOpts[i]);
	}
	this.gamutPass = pass;
	this.gamutLA = LA;
	max = subNames.length;
	for (var i=0; i < max; i++) {
		this.inGamutSubOpts[i] = document.createElement('option');
		this.inGamutSubOpts[i].value = i;
		this.inGamutSubOpts[i].appendChild(document.createTextNode(subNames[i]));
		this.inGamutSubs.appendChild(this.inGamutSubOpts[i]);
		this.outGamutSubOpts[i] = document.createElement('option');
		this.outGamutSubOpts[i].value = i;
		this.outGamutSubOpts[i].appendChild(document.createTextNode(subNames[i]));
		if (subNames[i] === 'All') {
			this.outGamutSubOpts[i].selected = true;
		}
		this.outGamutSubs.appendChild(this.outGamutSubOpts[i]);
	}
	
	this.updateGamutInList(false);
	this.updateGamutOutList(true);
};
LUTGammaBox.prototype.defaultGam = function() {
	var max = this.inGammaSelect.options.length;
	var defGamma = this.inputs.defGammaIn;
	for (var i = 0; i < max; i++) {
		if (defGamma === this.inGammaSelect.options[i].lastChild.nodeValue) {
			this.inGammaSelect.options[i].selected = true;
			break;
		}
	}
	this.changeGammaIn();
	max = this.inGamutSelect.options.length;
	var defGamut = this.inputs.defGamutIn;

	for (var i = 0; i < max; i++) {
		if (defGamut === this.inGamutSelect.options[i].lastChild.nodeValue) {
			this.inGamutSelect.options[i].selected = true;
			break;
		}
	}
	if (defGamut === "Passthrough") {
		max = this.outGamutSelect.options.length;
		for (var i = 0; i < max; i++) {
			if (defGamut === this.outGamutSelect.options[i].lastChild.nodeValue) {
				this.outGamutSelect.options[i].selected = true;
				break;
			}
		}
	} else if (this.outGamutSelect.options[this.outGamutSelect.selectedIndex].lastChild.nodeValue === "Passthrough") {
		this.outGamutSelect.options[0].selected = true;
	}
	this.updateGammaInList(false);
	this.updateGamutInList(false);
};
LUTGammaBox.prototype.buildContrast = function() {
	for (var i = -3; i < 4; i++) {
		var optIn = document.createElement('option');
		var optOut = document.createElement('option');
		optIn.value = i;
		optOut.value = i;
		if (i < 0) {
			optIn.appendChild(document.createTextNode(i));
			optOut.appendChild(document.createTextNode(i));
		} else if (i === 0) {
			optIn.appendChild(document.createTextNode('0'));
			optIn.selected = true;
			optOut.appendChild(document.createTextNode('0'));
			optOut.selected = true;
		} else {
			optIn.appendChild(document.createTextNode('+' + i));
			optOut.appendChild(document.createTextNode('+' + i));
		}
		this.inConSelect.appendChild(optIn);
		this.outConSelect.appendChild(optOut);
	}
};
// Event Responses
LUTGammaBox.prototype.testPQLw = function(isIn) {
	var Lw;
	if (isIn) {
		Lw = parseFloat(this.pqOOTFLwIn.value);
	} else {
		Lw = parseFloat(this.pqOOTFLwOut.value);
	}
	if (isNaN(Lw)) {
		Lw = 10000;
	} else {
		Lw = Math.round(Math.max(100,Math.min(10000,Lw)));
	}
	if (isIn) {
		this.pqOOTFLwIn.value = Lw;
	} else {
		this.pqOOTFLwOut.value = Lw;
	}
};
LUTGammaBox.prototype.testPQEOTFLw = function(isIn) {
	var Lw;
	if (isIn) {
		Lw = parseFloat(this.pqEOTFLwIn.value);
	} else {
		Lw = parseFloat(this.pqEOTFLwOut.value);
	}
	if (isNaN(Lw)) {
		Lw = 10000;
	} else {
		Lw = Math.round(Math.max(100,Math.min(10000,Lw)));
	}
	if (isIn) {
		this.pqEOTFLwIn.value = Lw;
	} else {
		this.pqEOTFLwOut.value = Lw;
	}
};
LUTGammaBox.prototype.testHLGLw = function(isIn) {
	var Lw;
	if (isIn) {
		Lw = parseFloat(this.hlgOOTFLwIn.value);
	} else {
		Lw = parseFloat(this.hlgOOTFLwOut.value);
	}
	if (isNaN(Lw)) {
		Lw = 1000;
	} else {
		Lw = Math.round(Lw);
	}
	if (isIn) {
		this.hlgOOTFLwIn.value = Lw;
	} else {
		this.hlgOOTFLwOut.value = Lw;
	}
};
/*
LUTGammaBox.prototype.testNHKBBC = function(isIn) {
	if (isIn) {
		this.hlgScaleOut[0].checked = this.hlgScaleIn[0].checked
		this.hlgScaleOut[1].checked = this.hlgScaleIn[1].checked
	} else {
		this.hlgScaleIn[0].checked = this.hlgScaleOut[0].checked
		this.hlgScaleIn[1].checked = this.hlgScaleOut[1].checked
	}
};
*/
LUTGammaBox.prototype.changeGammaIn = function() {
	// Hide Everything
	this.inLin.className = 'smallerbox-hide';
	this.inCon.className = 'smallerbox-hide';
	this.pqOOTFInBox.className = 'smallerbox-hide';
	this.pqEOTFInBox.className = 'smallerbox-hide';
	this.hlgOOTFInBox.className = 'smallerbox-hide';
	this.hlgOETFInBox.className = 'smallerbox-hide';
	this.arriLegalInBox.className = 'smallerbox-hide';
	// Show As Required
	var idx = parseInt(this.inGammaSelect.options[this.inGammaSelect.options.selectedIndex].value);
	if (idx === 9999) {
		this.inLin.className = 'smallerbox';
		idx = parseInt(this.inLinSelect.options[this.inLinSelect.options.selectedIndex].value);
		if (idx === this.inputs.gammaPQOOTF || idx === this.inputs.gammaPQOOTF + 1) {
			this.pqOOTFInBox.className = 'smallerbox';
		} else if (idx === this.inputs.gammaHLGOOTF || idx === this.inputs.gammaHLGOOTF + 1) {
			this.hlgOOTFInBox.className = 'smallerbox';
			this.hlgOETFInBox.className = 'smallerbox';
		}
	} else if (idx === this.inputs.gammaPQ || idx === this.inputs.gammaPQOOTF || idx === this.inputs.gammaPQOOTF + 1) {
		this.pqOOTFInBox.className = 'smallerbox';
	} else if (idx === this.inputs.gammaPQ + 1 || idx === this.inputs.gammaHLGOOTF || idx === this.inputs.gammaHLGOOTF + 1) {
		this.hlgOOTFInBox.className = 'smallerbox';
		this.hlgOETFInBox.className = 'smallerbox';
	} else if (idx === this.inputs.gammaPQEOTF) {
		this.pqEOTFInBox.className = 'smallerbox';
	} else if (idx === this.inputs.gammaHLG) {
		this.hlgOETFInBox.className = 'smallerbox';
	} else if (idx === this.inputs.gammaDLogM) {
		this.inCon.className = 'smallerbox';
	} else if (this.inputs.gammaArriList.indexOf(idx) > -1) {
		this.arriLegalInBox.className = 'smallerbox';
	}
	this.messages.updateGammaIn();
};
LUTGammaBox.prototype.hideGammaSubsOut = function() {
	this.outLin.className = 'smallerbox-hide';
	this.outCon.className = 'smallerbox-hide';
	this.pqOOTFOutBox.className = 'smallerbox-hide';
	this.pqEOTFOutBox.className = 'smallerbox-hide';
	this.hlgOOTFOutBox.className = 'smallerbox-hide';
	this.hlgOETFOutBox.className = 'smallerbox-hide';
	this.arriLegalOutBox.className = 'smallerbox-hide';
};
LUTGammaBox.prototype.changeGammaOut = function() {
	// Hide Everything
	this.outLin.className = 'smallerbox-hide';
	this.outCon.className = 'smallerbox-hide';
	this.pqOOTFOutBox.className = 'smallerbox-hide';
	this.pqEOTFOutBox.className = 'smallerbox-hide';
	this.hlgOOTFOutBox.className = 'smallerbox-hide';
	this.hlgOETFOutBox.className = 'smallerbox-hide';
	this.arriLegalOutBox.className = 'smallerbox-hide';
	// Show As Required
	var idx = parseInt(this.outGammaSelect.options[this.outGammaSelect.options.selectedIndex].value);
	if (idx === 9999) {
		this.outLin.className = 'smallerbox';
		idx = parseInt(this.outLinSelect.options[this.outLinSelect.options.selectedIndex].value);
		if (idx === this.inputs.gammaPQOOTF || idx === this.inputs.gammaPQOOTF + 1) {
			this.pqOOTFOutBox.className = 'smallerbox';
		} else if (idx === this.inputs.gammaHLGOOTF || idx === this.inputs.gammaHLGOOTF + 1) {
			this.hlgOOTFOutBox.className = 'smallerbox';
			this.hlgOETFOutBox.className = 'smallerbox';
		}
	} else if (idx === this.inputs.gammaPQ || idx === this.inputs.gammaPQOOTF || idx === this.inputs.gammaPQOOTF + 1) {
		this.pqOOTFOutBox.className = 'smallerbox';
	} else if (idx === this.inputs.gammaPQ + 1 || idx === this.inputs.gammaHLGOOTF || idx === this.inputs.gammaHLGOOTF + 1) {
		this.hlgOOTFOutBox.className = 'smallerbox';
		this.hlgOETFOutBox.className = 'smallerbox';
	} else if (idx === this.inputs.gammaPQEOTF) {
		this.pqEOTFOutBox.className = 'smallerbox';
	} else if (idx === this.inputs.gammaHLG) {
		this.hlgOETFOutBox.className = 'smallerbox';
	} else if (idx === this.inputs.gammaDLogM) {
		this.outCon.className = 'smallerbox';
	} else if (this.inputs.gammaArriList.indexOf(idx) > -1) {
		this.arriLegalOutBox.className = 'smallerbox';
	}
	this.messages.updateGammaOut();
};
LUTGammaBox.prototype.clearSelect = function(sel) {
	var m = sel.options.length;
	for (var j=0; j<m; j++) {
		sel.remove(0);
	}
};
LUTGammaBox.prototype.updateGammaInList = function(setParams) {
	var sub = parseInt(this.inGammaSubs.options[this.inGammaSubs.selectedIndex].value);
	var showList = this.inputs.gammaSubLists[sub];
	var m = this.inGammaOpts.length;
	var m2 = showList.length;
	var val;
	var cur = parseInt(this.inGammaSelect.options[this.inGammaSelect.selectedIndex].value);
	var curOK = false;
	var linIdx = 0;
	var showLA = false;
	if (this.inGammaSelect.options[this.inGammaSelect.length - 1].lastChild.nodeValue.slice(0,4) === 'LA -') {
		showLA = this.inGammaSelect.options[this.inGammaSelect.length - 1];
	}
	this.clearSelect(this.inGammaSelect);
	for (var j=0; j<m; j++) {
		val = parseInt(this.inGammaOpts[j].value);
		for (var k=0; k<m2; k++) {
			if (val === showList[k] || val === 9999) {
				this.inGammaSelect.appendChild(this.inGammaOpts[j]);
				if (val === cur) {
					curOK = this.inGammaSelect.options.length-1;
				}
				if (val === 9999) {
					linIdx = this.inGammaSelect.length;
				}
				break;
			}
		}
	}
	if (showLA) {
		this.inGammaSelect.appendChild(showLA);
	}
	if (curOK) {
		this.inGammaSelect.options[curOK].selected = true;
	} else {
		this.inGammaSelect.options[0].selected = true;
		this.changeGammaIn();
		if (setParams) {
			this.messages.gaSetParams();
		}
	}
};
LUTGammaBox.prototype.updateGammaOutList = function(setParams) {
	var sub = parseInt(this.outGammaSubs.options[this.outGammaSubs.selectedIndex].value);
	var showList = this.inputs.gammaSubLists[sub];
	var m = this.outGammaOpts.length;
	var m2 = showList.length;
	var val;
	var cur = parseInt(this.outGammaSelect.options[this.outGammaSelect.selectedIndex].value);
	var curOK = false;
	var showLA = false;
	if (this.outGammaSelect.options[this.outGammaSelect.length - 1].lastChild.nodeValue.slice(0,4) === 'LA -') {
		showLA = this.outGammaSelect.options[this.outGammaSelect.length - 1];
	}
	this.clearSelect(this.outGammaSelect);
	for (var j=0; j<m; j++) {
		val = parseInt(this.outGammaOpts[j].value);
		for (var k=0; k<m2; k++) {
			if (val === showList[k] || val === 9999) {
				this.outGammaSelect.appendChild(this.outGammaOpts[j]);
				if (val === cur) {
					curOK = this.outGammaSelect.options.length-1;
				}
				break;
			}
		}
	}
	if (showLA) {
		this.outGammaSelect.appendChild(showLA);
	}
	if (curOK) {
		this.outGammaSelect.options[curOK].selected = true;
	} else {
		this.outGammaSelect.options[0].selected = true;
		this.changeGammaOut();
		if (setParams) {
			this.messages.gaSetParams();
		}
	}
};
LUTGammaBox.prototype.updateGamutInList = function(setParams) {
	var sub = parseInt(this.inGamutSubs.options[this.inGamutSubs.selectedIndex].value);
	var showList = this.inputs.gamutInSubLists[sub];
	var m = this.inGamutOpts.length;
	var m2 = showList.length;
	var val;
	var cur = parseInt(this.inGamutSelect.options[this.inGamutSelect.selectedIndex].value);
	var curOK = false;
	this.clearSelect(this.inGamutSelect);
	for (var j=0; j<m; j++) {
		val = parseInt(this.inGamutOpts[j].value);
		for (var k=0; k<m2; k++) {
			if (val === showList[k] || val === 9999) {
				if (this.inGamutOpts[j].lastChild.nodeValue.slice(0,6) === 'Custom') {
					this.inputs.custGamInIdx = this.inGamutSelect.options.length;
				}
				this.inGamutSelect.appendChild(this.inGamutOpts[j]);
				if (val === cur) {
					curOK = this.inGamutSelect.options.length-1;
				}
				break;
			}
		}
	}
	if (curOK) {
		this.inGamutSelect.options[curOK].selected = true;
	} else {
		this.inGamutSelect.options[0].selected = true;
		this.changeInGamut();
		if (setParams) {
			this.messages.gtSetParams();
		}
	}
};
LUTGammaBox.prototype.updateGamutOutList = function(setParams) {
	var sub = parseInt(this.outGamutSubs.options[this.outGamutSubs.selectedIndex].value);
	var showList = this.inputs.gamutOutSubLists[sub];
	var m = this.outGamutOpts.length;
	var m2 = showList.length;
	var val;
	var cur = parseInt(this.outGamutSelect.options[this.outGamutSelect.selectedIndex].value);
	var curOK = false;
	var showLA = false;
	if (this.outGamutSelect.options[this.outGamutSelect.length - 1].lastChild.nodeValue.slice(0,4) === 'LA -') {
		showLA = this.outGamutSelect.options[this.outGamutSelect.length - 1];
	}
	this.clearSelect(this.outGamutSelect);
	for (var j=0; j<m; j++) {
		val = parseInt(this.outGamutOpts[j].value);
		for (var k=0; k<m2; k++) {
			if (val === showList[k] || val === 9999) {
				if (this.outGamutOpts[j].lastChild.nodeValue.slice(0,6) === 'Custom') {
					this.inputs.custGamOutIdx = this.outGamutSelect.options.length;
				}
				this.outGamutSelect.appendChild(this.outGamutOpts[j]);
				if (val === cur) {
					curOK = this.outGamutSelect.options.length-1;
				}
				break;
			}
		}
	}
	if (showLA) {
		this.outGamutSelect.appendChild(showLA);
	}
	if (curOK) {
		this.outGamutSelect.options[curOK].selected = true;
	} else {
		this.outGamutSelect.options[0].selected = true;
		this.changeOutGamut();
		if (setParams) {
			this.messages.gtSetParams();
		}
	}
};
LUTGammaBox.prototype.changeInGamut = function() {
	if (this.inGamutSelect.options[this.inGamutSelect.options.length - 1].selected) {
		var max = this.outGamutSelect.options.length;
		for (var i=0; i<max; i++) {
			if (parseInt(this.outGamutSelect.options[i].value) === this.gamutPass) {
				this.outGamutSelect.options[i].selected = true;
				break;
			}
		}
	} else if (parseInt(this.outGamutSelect.options[this.outGamutSelect.options.selectedIndex].value) === this.gamutPass) {
		this.outGamutSelect.options[0].selected = true;
	}
	this.messages.changeGamut();
};
LUTGammaBox.prototype.changeOutGamut = function() {
	if (parseInt(this.outGamutSelect.options[this.outGamutSelect.options.selectedIndex].value) === this.gamutPass) {
		this.inGamutSelect.options[this.inGamutSelect.options.length - 1].selected = true;
	} else if (this.inGamutSelect.options[this.inGamutSelect.options.length - 1].selected) {
		var max = this.inGamutSelect.options.length;
		var defGamut = this.inputs.defGamutIn;
		for (var i = 0; i < max; i++) {
			if (defGamut === this.inGamutSelect.options[i].lastChild.nodeValue) {
				this.inGamutSelect.options[i].selected = true;
				break;
			}
		}
	}
	this.messages.changeGamut();
};
LUTGammaBox.prototype.oneOrThree = function() {
	if (this.inputs.d[0].checked) {
		this.inGamutBox.className = 'base-inputbox-hide';
		this.outGamutBox.className = 'base-inputbox-hide';
	} else {
		this.inGamutBox.className = 'base-inputbox';
		this.outGamutBox.className = 'base-inputbox';
	}
	if (typeof this.inGammaSelect.options[this.inGammaSelect.options.selectedIndex] !== 'undefined') {
		this.changeGammaIn();
	}
};
LUTGammaBox.prototype.getInfo = function(info) {
	if (this.inGammaSelect.options[this.inGammaSelect.selectedIndex].value !== '9999') {
		info.inGammaName = this.inGammaSelect.options[this.inGammaSelect.selectedIndex].lastChild.nodeValue;
	} else {
		info.inGammaName = this.inLinSelect.options[this.inLinSelect.selectedIndex].lastChild.nodeValue;
	}
	if (this.outGammaSelect.options[this.outGammaSelect.selectedIndex].value !== '9999') {
		info.outGammaName = this.outGammaSelect.options[this.outGammaSelect.selectedIndex].lastChild.nodeValue;
	} else {
		info.outGammaName = this.outLinSelect.options[this.outLinSelect.selectedIndex].lastChild.nodeValue;
	}
	if (this.outGammaSelect.options[this.outGammaSelect.selectedIndex].lastChild.nodeValue === 'Null') {
		info.nul = true;
	} else {
		info.nul = false;
	}
	info.inGamutName = this.inGamutSelect.options[this.inGamutSelect.selectedIndex].lastChild.nodeValue;
	info.outGamutName = this.outGamutSelect.options[this.outGamutSelect.selectedIndex].lastChild.nodeValue;
};
LUTGammaBox.prototype.getSettings = function(data) {
	var inLin, outLin;
	var inLinHyphen = this.inLinSelect.options[this.inLinSelect.options.selectedIndex].lastChild.nodeValue.indexOf('-');
	if (inLinHyphen > 0) {
		inLin = this.inLinSelect.options[this.inLinSelect.options.selectedIndex].lastChild.nodeValue.substring(0, inLinHyphen - 1);
	} else {
		inLin = this.inLinSelect.options[this.inLinSelect.options.selectedIndex].lastChild.nodeValue;
	}
	var outLinHyphen = this.outLinSelect.options[this.outLinSelect.options.selectedIndex].lastChild.nodeValue.indexOf('-');
	if (outLinHyphen > 0) {
		outLin = this.outLinSelect.options[this.outLinSelect.options.selectedIndex].lastChild.nodeValue.substring(0, outLinHyphen - 1);
	} else {
		outLin = this.outLinSelect.options[this.outLinSelect.options.selectedIndex].lastChild.nodeValue;
	}
	data.gammaBox = {
		recGammaSub: this.inGammaSubs.options[this.inGammaSubs.selectedIndex].lastChild.nodeValue,
		recGamma: this.inGammaSelect.options[this.inGammaSelect.options.selectedIndex].lastChild.nodeValue,
		recLinGamma: inLin,
		recContrast: this.inConSelect.options[this.inConSelect.options.selectedIndex].lastChild.nodeValue,
		recGamutSub: this.inGamutSubs.options[this.inGamutSubs.selectedIndex].lastChild.nodeValue,
		recGamut: this.inGamutSelect.options[this.inGamutSelect.options.selectedIndex].lastChild.nodeValue,
		outGammaSub: this.outGammaSubs.options[this.outGammaSubs.selectedIndex].lastChild.nodeValue,
		outGamma: this.outGammaSelect.options[this.outGammaSelect.options.selectedIndex].lastChild.nodeValue,
		outLinGamma: outLin,
		outContrast: this.outConSelect.options[this.outConSelect.options.selectedIndex].lastChild.nodeValue,
		outGamutSub: this.outGamutSubs.options[this.outGamutSubs.selectedIndex].lastChild.nodeValue,
		outGamut: this.outGamutSelect.options[this.outGamutSelect.options.selectedIndex].lastChild.nodeValue,
	};
};
LUTGammaBox.prototype.setSettings = function(settings) {
	if (typeof settings.gammaBox !== 'undefined') {
		var data = settings.gammaBox;
		if (typeof data.recGamma !== 'undefined') {
			this.inGammaSubs.options[this.inGammaSubs.options.length-1].selected = true;
			this.updateGammaInList(false);
			var m = this.inGammaSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.inGammaSelect.options[j].lastChild.nodeValue === data.recGamma) {
					this.inGammaSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.recLinGamma !== 'undefined') {
			var m = this.inLinSelect.options.length;
			var inLinLen = data.recLinGamma.length;
			for (var j=0; j<m; j++) {
				if (this.inLinSelect.options[j].lastChild.nodeValue.substring(0, inLinLen) === data.recLinGamma) {
					this.inLinSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.recContrast !== 'undefined') {
			var m = this.inConSelect.options.length;
			var inConLen = data.recContrast.length;
			for (var j=0; j<m; j++) {
				if (this.inConSelect.options[j].lastChild.nodeValue.substring(0, inConLen) === data.recContrast) {
					this.inConSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.recGamut !== 'undefined') {
			this.inGamutSubs.options[this.inGamutSubs.options.length-1].selected = true;
			this.updateGamutInList(false);
			var m = this.inGamutSelect.options.length;
			for (var j=0; j<m; j++) {
				if (
					this.inGamutSelect.options[j].lastChild.nodeValue === data.recGamut ||
					(this.inGamutSelect.options[j].lastChild.nodeValue.substring(0,6) === 'Custom' && data.recGamut.substring(0,6) === 'Custom')
				) {
					this.inGamutSelect.options[j].selected = true;
					break;
				}
			}
			this.changeInGamut();
		}
		if (typeof data.outGamma !== 'undefined') {
			this.outGammaSubs.options[this.outGammaSubs.options.length-1].selected = true;
			this.updateGammaOutList(false);
			var m = this.outGammaSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.outGammaSelect.options[j].lastChild.nodeValue === data.outGamma) {
					this.outGammaSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.outLinGamma !== 'undefined') {
			var m = this.outLinSelect.options.length;
			var outLinLen = data.outLinGamma.length;
			for (var j=0; j<m; j++) {
				if (this.outLinSelect.options[j].lastChild.nodeValue.substring(0, outLinLen) === data.outLinGamma) {
					this.outLinSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.outContrast !== 'undefined') {
			var m = this.outConSelect.options.length;
			var outConLen = data.outContrast.length;
			for (var j=0; j<m; j++) {
				if (this.outConSelect.options[j].lastChild.nodeValue.substring(0, outConLen) === data.outContrast) {
					this.outConSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.outGamut !== 'undefined') {
			this.outGamutSubs.options[this.outGamutSubs.options.length-1].selected = true;
			this.updateGamutOutList(false);
			var m = this.outGamutSelect.options.length;
			for (var j=0; j<m; j++) {
				if (
					this.outGamutSelect.options[j].lastChild.nodeValue === data.outGamut ||
					(this.outGamutSelect.options[j].lastChild.nodeValue.substring(0,6) === 'Custom' && data.outGamut.substring(0,6) === 'Custom')
				) {
					this.outGamutSelect.options[j].selected = true;
					break;
				}
			}
			this.changeOutGamut();
		}
		if (typeof data.recGammaSub !== 'undefined') {
			var m = this.inGammaSubs.options.length;
			for (var j=0; j<m; j++) {
				if (this.inGammaSubs.options[j].lastChild.nodeValue === data.recGammaSub) {
					this.inGammaSubs.options[j].selected = true;
					this.updateGammaInList(false);
				}
			}
		}
		if (typeof data.recGamutSub !== 'undefined') {
			var m = this.inGamutSubs.options.length;
			for (var j=0; j<m; j++) {
				if (this.inGamutSubs.options[j].lastChild.nodeValue === data.recGamutSub) {
					this.inGamutSubs.options[j].selected = true;
					this.updateGamutInList(false);
				}
			}
		}
		if (typeof data.outGammaSub !== 'undefined') {
			var m = this.outGammaSubs.options.length;
			for (var j=0; j<m; j++) {
				if (this.outGammaSubs.options[j].lastChild.nodeValue === data.outGammaSub) {
					this.outGammaSubs.options[j].selected = true;
					this.updateGammaOutList(false);
				}
			}
		}
		if (typeof data.outGamutSub !== 'undefined') {
			var m = this.outGamutSubs.options.length;
			for (var j=0; j<m; j++) {
				if (this.outGamutSubs.options[j].lastChild.nodeValue === data.outGamutSub) {
					this.outGamutSubs.options[j].selected = true;
					this.updateGamutOutList(false);
				}
			}
		}
		this.changeGammaIn();
		this.changeGammaOut();
	}
};
LUTGammaBox.prototype.getHeight = function() {
	return this.box.clientHeight;
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-cs.js
* Custom colour space / gamut object for the LUTCalc Web App.
* 29th September 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKCS(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.p = 13;
	this.messages.addUI(this.p,this);
	this.io();
	this.ui();
	this.events();
}
TWKCS.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox-hide';
	this.tweakCheck.checked = false;
	// Tweak - Specific Inputs
	// Gamuts
	this.xyVals = new Float64Array([
		0.64, 0.33,
		0.30, 0.60,
		0.15, 0.06
	]);
	this.count = 1;
	this.gamuts = [];
	this.gamuts.push({
		cat: 0,
		matrix: false, lock: false,
		std: 'D65',
		wx: 0.31270,wy: 0.32900,
		rx: this.xyVals[0],	ry: this.xyVals[1],
		gx: this.xyVals[2],	gy: this.xyVals[3],
		bx: this.xyVals[4],	by: this.xyVals[5],
		wcs: 'Rec709',
		inMatrix: new Float64Array([1,0,0, 0,1,0, 0,0,1]),
		outMatrix: new Float64Array([1,0,0, 0,1,0, 0,0,1])
	});
	// List of custom gamuts
	this.gamList = document.createElement('select');
	var listOption = document.createElement('option');
	listOption.appendChild(document.createTextNode('Rec709'));
	this.gamList.appendChild(listOption);
	// Store / Remove buttons
	this.newButton = document.createElement('input');
	this.newButton.setAttribute('type','button');
	this.newButton.value = 'New';
	this.removeButton = document.createElement('input');
	this.removeButton.setAttribute('type','button');
	this.removeButton.value = 'Remove';
	// Matrix / Colour Space
	this.clspOpt = this.createRadioElement('mcOpt', true);
	this.matxOpt = this.createRadioElement('mcOpt', false);	
	// Title
	this.title = document.createElement('input');
	this.title.setAttribute('type','text');
	this.title.className = 'text-input';
	this.title.value = 'Rec709';
	// White Point
	this.stdWP = this.createRadioElement('wpOpt', true);
	this.cstWP = this.createRadioElement('wpOpt', false);
	this.stdIll = document.createElement('select');
	this.stdIll.className = 'side-item';
	this.setIlluminants();
	// Primaries
	this.xWP = document.createElement('input');
	this.xWP.setAttribute('type','text');
	this.xWP.className = 'base-input';
	this.xWP.value = this.gamuts[0].wx.toString();
	this.xWP.disabled = true;
	this.yWP = document.createElement('input');
	this.yWP.setAttribute('type','text');
	this.yWP.className = 'base-input';
	this.yWP.value = this.gamuts[0].wy.toString();
	this.yWP.disabled = true;
	this.xR = document.createElement('input');
	this.xR.setAttribute('type','text');
	this.xR.className = 'base-input';
	this.xR.value = this.gamuts[0].rx.toString();
	this.yR = document.createElement('input');
	this.yR.setAttribute('type','text');
	this.yR.className = 'base-input';
	this.yR.value = this.gamuts[0].ry.toString();
	this.xG = document.createElement('input');
	this.xG.setAttribute('type','text');
	this.xG.className = 'base-input';
	this.xG.value = this.gamuts[0].gx.toString();
	this.yG = document.createElement('input');
	this.yG.setAttribute('type','text');
	this.yG.className = 'base-input';
	this.yG.value = this.gamuts[0].gy.toString();
	this.xB = document.createElement('input');
	this.xB.setAttribute('type','text');
	this.xB.className = 'base-input';
	this.xB.value = this.gamuts[0].bx.toString();
	this.yB = document.createElement('input');
	this.yB.setAttribute('type','text');
	this.yB.className = 'base-input';
	this.yB.value = this.gamuts[0].by.toString();
	// Matrix inputs
	this.matIn = [];
	this.matOut = [];
	for (var j=0; j<9; j++) {
		var inInput = document.createElement('input');
		inInput.setAttribute('type','text');
		inInput.className = 'wide-input';
		inInput.disabled = false;
		this.matIn.push(inInput);
		var outInput = document.createElement('input');
		outInput.setAttribute('type','text');
		outInput.className = 'wide-input';
		outInput.disabled = true;
		this.matOut.push(outInput);
		if (j === 0 || j === 4 || j === 8) {
			inInput.value = '1';
			outInput.value = '1';
		} else {
			inInput.value = '0';
			outInput.value = '0';
		}
	}
	this.matInOpt = this.createRadioElement('matInOutOpt', true);
	this.matOutOpt = this.createRadioElement('matInOutOpt', false);	
	this.wrkspcSelect = document.createElement('select');
	var m = this.inputs.gamutMatrixList.length;
	for (var j=0; j<m; j++) {
		var matrixOpt = document.createElement('option');
		matrixOpt.appendChild(document.createTextNode(this.inputs.gamutMatrixList[j].name));
		if (this.inputs.gamutMatrixList[j].name === 'Rec709') {
			matrixOpt.selected = true;
		}
		matrixOpt.value = this.inputs.gamutMatrixList[j].idx;
		this.wrkspcSelect.appendChild(matrixOpt);
	}
	this.matCalcCheck = document.createElement('input');
	this.matCalcCheck.setAttribute('type','checkbox');
	this.matCalcCheck.className = 'twk-checkbox';
	this.matCalcCheck.checked = true;
	this.xyButton = document.createElement('input');
	this.xyButton.setAttribute('type','button');
	this.xyButton.disabled = true;
	this.xyButton.value = 'Set Primaries';
	// CAT Selection
	this.CATSelect = document.createElement('select');
	m = this.inputs.gamutCATList.length;
	for (var j=0; j<m; j++) {
		var CATOption = document.createElement('option');
		if (j === 0) {
			CATOption.selected = true;
		}
		CATOption.value = j;
		CATOption.appendChild(document.createTextNode(this.inputs.gamutCATList[j]));
		this.CATSelect.appendChild(CATOption);
	}
	// Input and output choices
	this.inSelect = document.createElement('select');
	var inOption = document.createElement('option');
	inOption.appendChild(document.createTextNode('Rec709'));
	this.inSelect.appendChild(inOption);
	this.outSelect = document.createElement('select');
	var outOption = document.createElement('option');
	outOption.appendChild(document.createTextNode('Rec709'));
	this.outSelect.appendChild(outOption);
};
TWKCS.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('Custom Colour Space')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak';
	// Tweak - Specific UI Elements
	this.box.appendChild(this.gamList);
	this.box.appendChild(this.newButton);
	this.box.appendChild(this.removeButton);
	this.box.appendChild(document.createElement('br'));
	this.box.appendChild(this.clspOpt);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('White Point & Primaries')));
	this.box.appendChild(this.matxOpt);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Matrix')));
	this.box.appendChild(document.createElement('br'));
	var editBox = document.createElement('div');
	editBox.className = 'twk-sub-box';
	editBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Title')));
	editBox.appendChild(this.title);
	this.wppBox = document.createElement('div');
	this.wppBox.className = 'twk-tab';
	editBox.appendChild(document.createElement('br'));
	editBox.appendChild(this.stdWP);
	editBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Standard Illuminant')));
	editBox.appendChild(this.stdIll);
	editBox.appendChild(this.cstWP);
	editBox.appendChild(document.createElement('label').appendChild(document.createTextNode('White Point')));
	editBox.appendChild(document.createElement('br'));
	editBox.appendChild(document.createElement('label').appendChild(document.createTextNode('x')));
	editBox.appendChild(this.xWP);
	editBox.appendChild(document.createElement('label').appendChild(document.createTextNode('y')));
	editBox.appendChild(this.yWP);
//	this.wppBox.appendChild(document.createElement('br'));
	this.wppBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Red Primary:   x')));
	this.wppBox.appendChild(this.xR);
	this.wppBox.appendChild(document.createElement('label').appendChild(document.createTextNode('y')));
	this.wppBox.appendChild(this.yR);
	this.wppBox.appendChild(document.createElement('br'));
	this.wppBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Green Primary: x')));
	this.wppBox.appendChild(this.xG);
	this.wppBox.appendChild(document.createElement('label').appendChild(document.createTextNode('y')));
	this.wppBox.appendChild(this.yG);
	this.wppBox.appendChild(document.createElement('br'));
	this.wppBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Blue Primary:  x')));
	this.wppBox.appendChild(this.xB);
	this.wppBox.appendChild(document.createElement('label').appendChild(document.createTextNode('y')));
	this.wppBox.appendChild(this.yB);
	editBox.appendChild(this.wppBox);
	this.matxBox = document.createElement('div');
	this.matxBox.className = 'twk-tab-hide';
	this.matxBox.appendChild(this.matInOpt);
	this.matxBox.appendChild(document.createElement('label').appendChild(document.createTextNode('To Working Colourspace')));
	this.matxBox.appendChild(document.createElement('br'));
	for (var j=0; j<9; j++) {
		this.matxBox.appendChild(this.matIn[j]);
		if ((j+1)%3 === 0) {
			this.matxBox.appendChild(document.createElement('br'));
		}
	}
	this.matxBox.appendChild(this.matOutOpt);
	this.matxBox.appendChild(document.createElement('label').appendChild(document.createTextNode('From Working Colourspace')));
	this.matxBox.appendChild(document.createElement('br'));
	for (var j=0; j<9; j++) {
		this.matxBox.appendChild(this.matOut[j]);
		if ((j+1)%3 === 0) {
			this.matxBox.appendChild(document.createElement('br'));
		}
	}
	var spacer = document.createElement('div');
	spacer.className = 'spacer';
	this.matxBox.appendChild(spacer);
	this.matxBox.appendChild(this.xyButton);
	this.matxBox.appendChild(document.createElement('br'));
	this.matxBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Working Colourspace')));
	this.matxBox.appendChild(this.wrkspcSelect);
	this.matxBox.appendChild(document.createElement('br'));
	this.matxBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Update With Colourspace')));
	this.matxBox.appendChild(this.matCalcCheck);
	editBox.appendChild(this.matxBox);
	editBox.appendChild(document.createElement('label').appendChild(document.createTextNode('CAT Model')));
	editBox.appendChild(this.CATSelect);
	this.box.appendChild(editBox);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Input Choice')));
	this.box.appendChild(this.inSelect);
	this.box.appendChild(document.createElement('br'));
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Output Choice')));
	this.box.appendChild(this.outSelect);
	this.box.appendChild(document.createElement('br'));

	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKCS.prototype.toggleTweaks = function() {
	// Visibility dictated by 3D LUT and Gamut choice, not checkbox
	this.toggleTweak();
};
TWKCS.prototype.toggleTweak = function() {
	if ( this.inputs.d[1].checked && (
		this.inputs.inGamut.selectedIndex === this.inputs.custGamInIdx ||
		this.inputs.outGamut.selectedIndex === this.inputs.custGamOutIdx
	)) {
		this.holder.className = 'tweakholder';
	} else {
		this.holder.className = 'tweakholder-hide';
	}
};
TWKCS.prototype.getTFParams = function(params) {
	// No parameters are relevent
};
TWKCS.prototype.getCSParams = function(params) {
	var out = {};
	out.doCS = true;
	var i = this.gamList.selectedIndex;
	out.editIdx = i;
	out.matrix = this.gamuts[i].matrix;
	out.lock = this.gamuts[i].lock;
	out.edit = {
		wx: this.gamuts[i].wx, wy: this.gamuts[i].wy,
		rx: this.gamuts[i].rx, ry: this.gamuts[i].ry,
		gx: this.gamuts[i].gx, gy: this.gamuts[i].gy,
		bx: this.gamuts[i].bx, by: this.gamuts[i].by,
		wcs: this.getWCS(this.gamuts[i].wcs),
		isMatrix: this.gamuts[i].matrix,
		matrix: new Float64Array(this.gamuts[i].inMatrix.buffer.slice(0)),
		cat: this.gamuts[i].cat
	};
	i = this.inSelect.selectedIndex;
	out.input = {
		wx: this.gamuts[i].wx, wy: this.gamuts[i].wy,
		rx: this.gamuts[i].rx, ry: this.gamuts[i].ry,
		gx: this.gamuts[i].gx, gy: this.gamuts[i].gy,
		bx: this.gamuts[i].bx, by: this.gamuts[i].by,
		wcs: this.getWCS(this.gamuts[i].wcs),
		isMatrix: this.gamuts[i].matrix,
		matrix: new Float64Array(this.gamuts[i].inMatrix.buffer.slice(0)),
		cat: this.gamuts[i].cat
	};
	i = this.outSelect.selectedIndex;
	out.output = {
		wx: this.gamuts[i].wx, wy: this.gamuts[i].wy,
		rx: this.gamuts[i].rx, ry: this.gamuts[i].ry,
		gx: this.gamuts[i].gx, gy: this.gamuts[i].gy,
		bx: this.gamuts[i].bx, by: this.gamuts[i].by,
		wcs: this.getWCS(this.gamuts[i].wcs),
		isMatrix: this.gamuts[i].matrix,
		matrix: new Float64Array(this.gamuts[i].outMatrix.buffer.slice(0)),
		cat: this.gamuts[i].cat
	};
	params.twkCS = out;
};
TWKCS.prototype.setParams = function(params) {
	if (typeof params.twkCS !== 'undefined') {
		var p = params.twkCS;
		if (typeof p.editMatrix !== 'undefined') {
			this.gamuts[p.editIdx].inMatrix = new Float64Array(p.editMatrix.buffer.slice(0));
			this.gamuts[p.editIdx].outMatrix = this.mInverse(p.editMatrix);
			this.gamuts[p.editIdx].wcs = this.wrkspcSelect.options[p.wcs].lastChild.nodeValue;
			if (this.gamList.selectedIndex === p.editIdx) {
				this.wrkspcSelect.options[p.wcs].selected = true;
				for (var j=0; j<9; j++) {
					this.matIn[j].value = parseFloat(this.gamuts[p.editIdx].inMatrix[j].toFixed(8)).toString();
					this.matOut[j].value = parseFloat(this.gamuts[p.editIdx].outMatrix[j].toFixed(8)).toString();
				}
			}
		}
		this.xyButton.disabled = true;
		if (typeof p.xyVals !== 'undefined') {
			var xy = p.xyVals;
			if (!isNaN(xy[0])&&!isNaN(xy[1])&&!isNaN(xy[2])&&!isNaN(xy[3])&&!isNaN(xy[4])&&!isNaN(xy[5])) {
				this.xyVals = p.xyVals;
				if (
					xy[0] !== this.gamuts[p.editIdx].rx ||
					xy[1] !== this.gamuts[p.editIdx].ry ||
					xy[2] !== this.gamuts[p.editIdx].gx ||
					xy[3] !== this.gamuts[p.editIdx].gy ||
					xy[4] !== this.gamuts[p.editIdx].bx ||
					xy[5] !== this.gamuts[p.editIdx].by
				) {
					this.xyButton.disabled = false;
				}
			}
		}
	}
//	this.toggleTweak();
};
TWKCS.prototype.getSettings = function(data) {
	var m = this.gamuts.length;
	var list = [];
	for (var j=0; j<m; j++) {
		list.push({
			title: this.gamList.options[j].lastChild.nodeValue,
			matrix: this.gamuts[j].matrix,
			lock: this.gamuts[j].lock,
			std: this.gamuts[j].std,
			wx: this.gamuts[j].wx, wy: this.gamuts[j].wy,
			rx: this.gamuts[j].rx, ry: this.gamuts[j].ry,
			gx: this.gamuts[j].gx, gy: this.gamuts[j].gy,
			bx: this.gamuts[j].bx, by: this.gamuts[j].by,
			wcs: this.gamuts[j].wcs,
			inMatrix: this.taToString(this.gamuts[j].inMatrix),
			outMatrix: this.taToString(this.gamuts[j].outMatrix),
			cat: this.CATSelect.options[this.gamuts[j].cat].lastChild.nodeValue
		});
	}
	data.customCS = {
		edit: this.gamList.options[this.gamList.selectedIndex].lastChild.nodeValue,
		input: this.inSelect.options[this.inSelect.selectedIndex].lastChild.nodeValue,
		output: this.outSelect.options[this.outSelect.selectedIndex].lastChild.nodeValue,
		list: list
	};
};
TWKCS.prototype.setSettings = function(settings) {
	if (typeof settings.customCS !== 'undefined') {
		var data = settings.customCS;
		if (data.list !== 'undefined') {
			this.gamuts.length = 0;
			this.gamList.length = 0;
			this.inSelect.length = 0;
			this.outSelect.length = 0;
			var m = data.list.length;
			this.title.value = data.edit;
			for (var j=0; j<m; j++) {
				this.gamuts.push({
					matrix: data.list[j].matrix,
					lock: data.list[j].lock,
					std: data.list[j].std,
					wx: data.list[j].wx, wy: data.list[j].wy,
					rx: data.list[j].rx, ry: data.list[j].ry,
					gx: data.list[j].gx, gy: data.list[j].gy,
					bx: data.list[j].bx, by: data.list[j].by,
					wcs: data.list[j].wcs,
					inMatrix: new Float64Array(data.list[j].inMatrix.split(',').map(Number)),
					outMatrix: new Float64Array(data.list[j].outMatrix.split(',').map(Number)),
					cat: this.getCAT(data.list[j].cat)
				});
				var option1 = document.createElement('option');
				option1.appendChild(document.createTextNode(data.list[j].title));
				this.gamList.appendChild(option1);
				if (data.list[j].title === data.edit) {
					this.xWP.value = data.list[j].wx.toString();
					this.yWP.value = data.list[j].wy.toString();
					this.xR.value = data.list[j].rx.toString();
					this.yR.value = data.list[j].ry.toString();
					this.xG.value = data.list[j].gx.toString();
					this.yG.value = data.list[j].gy.toString();
					this.xB.value = data.list[j].bx.toString();
					this.yB.value = data.list[j].by.toString();
					option1.selected = true;
					if (data.list[j].std) {
						this.stdIll.className = 'side-item';
						this.stdWP.checked = true;
						this.cstWP.checked = false;
						this.xWP.disabled = true;
						this.yWP.disabled = true;
						var m2 = this.stdIll.options.length;
						for (var k=0; k<m2; k++) {
							if (this.stdIll.options[k].lastChild.nodeValue.toUpperCase() === data.list[j].std.toUpperCase()) {
								this.stdIll.options[k].selected = true;
//								break;
							}
						}
					} else {
						this.stdIll.className = 'side-item-hide';
						this.stdWP.checked = false;
						this.cstWP.checked = true;
						this.xWP.disabled = false;
						this.yWP.disabled = false;
					}
				}
				var option2 = document.createElement('option');
				option2.appendChild(document.createTextNode(data.list[j].title));
				if (data.list[j].title === data.input) {
					option2.selected = true;
				}
				this.inSelect.appendChild(option2);
				var option3 = document.createElement('option');
				option3.appendChild(document.createTextNode(data.list[j].title));
				if (data.list[j].title === data.output) {
					option3.selected = true;
				}
				this.outSelect.appendChild(option3);
			}
		}
		this.changeInput();
		this.changeOutput();
		this.toggleTweak();
	}
};
TWKCS.prototype.getInfo = function(info) {
};
TWKCS.prototype.isCustomGamma = function() {
	return false;
};
TWKCS.prototype.isCustomGamut = function() {
	return false;
};
TWKCS.prototype.events = function() {
	this.gamList.onchange = function(here){ return function(){
		here.changeCS();
		here.messages.gtSetParams();
	};}(this);
	this.newButton.onclick = function(here){ return function(){
		here.newCS();
		here.messages.gtSetParams();
	};}(this);
	this.removeButton.onclick = function(here){ return function(){
		here.removeCS();
		here.messages.gtSetParams();
	};}(this);
	this.clspOpt.onclick = function(here){ return function(){
		here.clspMatx();
		here.messages.gtSetParams();
	};}(this);
	this.matxOpt.onclick = function(here){ return function(){
		here.clspMatx();
		here.messages.gtSetParams();
	};}(this);
	this.wrkspcSelect.onchange = function(here){ return function(){
		here.changeWCS();
		if (!here.matCalcCheck.checked) {
			here.messages.gtSetParams();
		}
	};}(this);
	this.title.oninput = function(here){ return function(){
		here.changeTitle();
	};}(this);
	this.stdWP.onchange = function(here){ return function(){
		here.illOrWP();
		here.messages.gtSetParams();
	};}(this);
	this.stdIll.onchange = function(here){ return function(){
		here.changeIll();
		here.messages.gtSetParams();
	};}(this);
	this.cstWP.onchange = function(here){ return function(){
		here.illOrWP();
		here.messages.gtSetParams();
	};}(this);
	this.xWP.onchange = function(here){ return function(){
		here.testWx();
		here.messages.gtSetParams();
	};}(this);
	this.yWP.onchange = function(here){ return function(){
		here.testWy();
		here.messages.gtSetParams();
	};}(this);
	this.xR.onchange = function(here){ return function(){
		here.testRx();
		here.messages.gtSetParams();
	};}(this);
	this.yR.onchange = function(here){ return function(){
		here.testRy();
		here.messages.gtSetParams();
	};}(this);
	this.xG.onchange = function(here){ return function(){
		here.testGx();
		here.messages.gtSetParams();
	};}(this);
	this.yG.onchange = function(here){ return function(){
		here.testGy();
		here.messages.gtSetParams();
	};}(this);
	this.xB.onchange = function(here){ return function(){
		here.testBx();
		here.messages.gtSetParams();
	};}(this);
	this.yB.onchange = function(here){ return function(){
		here.testBy();
		here.messages.gtSetParams();
	};}(this);
	this.inSelect.onchange = function(here){ return function(){
		here.changeInput();
		here.messages.gtSetParams();
	};}(this);
	this.outSelect.onchange = function(here){ return function(){
		here.changeOutput();
		here.messages.gtSetParams();
	};}(this);
	this.matInOpt.onclick = function(here){ return function(){
		here.toggleMatIO();
		here.messages.gtSetParams();
	};}(this);
	this.matOutOpt.onclick = function(here){ return function(){
		here.toggleMatIO();
		here.messages.gtSetParams();
	};}(this);
	for (var j=0; j<9; j++) {
		this.matIn[j].onchange = function(here){ return function(){
			here.updateInMatrix();
			here.messages.gtSetParams();
		};}(this);
		this.matOut[j].onchange = function(here){ return function(){
			here.updateOutMatrix();
			here.messages.gtSetParams();
		};}(this);
	}
	this.xyButton.onclick = function(here){ return function(){
		here.setPrimaries();
	};}(this);
	this.CATSelect.onchange = function(here){ return function(){
		here.changeCAT();
		here.messages.gtSetParams();
	};}(this);
};
// Tweak-Specific Code
TWKCS.prototype.setIlluminants = function() {
	this.illuminants = []
	this.illuminants.push({name:'a',	x:0.44757, y:0.40745});
	this.illuminants.push({name:'b',	x:0.34842, y:0.35161});
	this.illuminants.push({name:'c',	x:0.31006, y:0.31616});
	this.illuminants.push({name:'d40',	x:0.38230, y:0.38380});
	this.illuminants.push({name:'d45',	x:0.36210, y:0.37090});
	this.illuminants.push({name:'d50',	x:0.34567, y:0.35850});
	this.illuminants.push({name:'d55',	x:0.33242, y:0.34743});
	this.illuminants.push({name:'d60',	x:0.32168, y:0.33767});
	this.illuminants.push({name:'d65',	x:0.31270, y:0.32900});
	this.illuminants.push({name:'d70',	x:0.30540, y:0.32160});
	this.illuminants.push({name:'d75',	x:0.29902, y:0.31485});
	this.illuminants.push({name:'e',	x:1/3    , y:1/3	});
	this.illuminants.push({name:'f1',	x:0.31310, y:0.33727});
	this.illuminants.push({name:'f2',	x:0.37208, y:0.37529});
	this.illuminants.push({name:'f3',	x:0.40910, y:0.39430});
	this.illuminants.push({name:'f4',	x:0.44018, y:0.40329});
	this.illuminants.push({name:'f5',	x:0.31379, y:0.34531});
	this.illuminants.push({name:'f6',	x:0.37790, y:0.38835});
	this.illuminants.push({name:'f7',	x:0.31292, y:0.32933});
	this.illuminants.push({name:'f8',	x:0.34588, y:0.35875});
	this.illuminants.push({name:'f9',	x:0.37417, y:0.37281});
	this.illuminants.push({name:'f10',	x:0.34609, y:0.35986});
	this.illuminants.push({name:'f11',	x:0.38052, y:0.37713});
	this.illuminants.push({name:'f12',	x:0.43695, y:0.40441});
	var m = this.illuminants.length;
	for (var j=0; j<m; j++) {
		var option = document.createElement('option');
		option.value = j;
		if (this.illuminants[j].name === 'd65') {
			option.selected = true;
		}
		option.appendChild(document.createTextNode(this.illuminants[j].name.toUpperCase()));
		this.stdIll.appendChild(option);
	}
};
TWKCS.prototype.changeIll = function() {
	var i = this.stdIll.selectedIndex;
	this.xWP.value = this.illuminants[i].x.toString();
	this.yWP.value = this.illuminants[i].y.toString();
	this.gamuts[this.gamList.selectedIndex].std = this.illuminants[i].name.toUpperCase();
	this.gamuts[this.gamList.selectedIndex].wx = this.illuminants[i].x;
	this.gamuts[this.gamList.selectedIndex].wy = this.illuminants[i].y;
	this.gamuts[this.gamList.selectedIndex].lock = true;
};
TWKCS.prototype.illOrWP = function() {
	if (this.stdWP.checked) {
		this.stdIll.className = 'side-item';
		this.xWP.disabled = true;
		this.yWP.disabled = true;
		this.gamuts[this.gamList.selectedIndex].std = this.stdIll.options[this.stdIll.selectedIndex].lastChild.nodeValue;
		this.changeIll();
	} else {
		this.stdIll.className = 'side-item-hide';
		this.xWP.disabled = false;
		this.yWP.disabled = false;
		this.gamuts[this.gamList.selectedIndex].std = false;
	}
	this.gamuts[this.gamList.selectedIndex].lock = true;
};
TWKCS.prototype.newCS = function() {
	this.title.value = 'Gamut ' + this.count.toString();
	this.count++;
	var i = this.gamuts.length;
	this.gamuts.push({
		cat: this.CATSelect.selectedIndex,
		matrix: false, lock: false,
		std: 'D65',
		wx: 0.31270,wy: 0.32900,
		rx: 0.64,	ry: 0.33,
		gx: 0.30,	gy: 0.60,
		bx: 0.15,	by: 0.06,
		wcs: 'Rec709',
		inMatrix: new Float64Array([1,0,0, 0,1,0, 0,0,1]),
		outMatrix: new Float64Array([1,0,0, 0,1,0, 0,0,1])
	});
	var m = this.stdIll.options.length;
	for (var j=0; j<m; j++) {
		if (this.stdIll.options[j].lastChild.nodeValue === 'D65') {
			this.stdIll.options[j].selected = true;
			break;
		}
	}
	m = this.wrkspcSelect.options.length;
	for (var j=0; j<m; j++) {
		if (this.wrkspcSelect.options[j].lastChild.nodeValue === 'Rec709') {
			this.wrkspcSelect.options[j].selected = true;
			break;
		}
	}
	this.setXY(i);
	this.stdWP.checked = true;
	this.illOrWP();
	var option1 = document.createElement('option');
	option1.appendChild(document.createTextNode(this.title.value));
	i = this.gamList.options.length;
	this.gamList.appendChild(option1);
	this.gamList.options[i].selected = true;
	var option2 = document.createElement('option');
	option2.appendChild(document.createTextNode(this.title.value));
	i = this.inSelect.options.length;
	this.inSelect.appendChild(option2);
	var option3 = document.createElement('option');
	option3.appendChild(document.createTextNode(this.title.value));
	i = this.outSelect.options.length;
	this.outSelect.appendChild(option3);
	this.outSelect.options[i].selected = true;
	this.changeInput();
	this.changeOutput();
};
TWKCS.prototype.changeCAT = function() {
	this.gamuts[this.gamList.selectedIndex].cat = this.CATSelect.selectedIndex;
};
TWKCS.prototype.getWCS = function(wcs) {
	var m = this.wrkspcSelect.options.length;
	for (var j=0; j<m; j++) {
		if (this.wrkspcSelect.options[j].lastChild.nodeValue === wcs) {
			return j;
		}
	}
};
TWKCS.prototype.changeWCS = function(wcs) {
	var edIdx = this.gamList.selectedIndex;
	if (this.matCalcCheck.checked) {
		this.messages.gtTx(this.p,3,{
			idx: edIdx,
			oldWCS: this.getWCS(this.gamuts[edIdx].wcs),
			newWCS: this.getWCS(this.wrkspcSelect.options[this.wrkspcSelect.selectedIndex].lastChild.nodeValue),
			matrix: this.gamuts[edIdx].inMatrix.buffer.slice(0),
			cat: this.gamuts[edIdx].cat
		});
	}
	this.gamuts[edIdx].wcs = this.wrkspcSelect.options[this.wrkspcSelect.selectedIndex].lastChild.nodeValue;
};
TWKCS.prototype.recalcMatrix = function(idx,wcs,buff) {
	this.wrkspcSelect.selectedIndex = wcs;
	this.gamuts[idx].wcs = this.wrkspcSelect.options[wcs].lastChild.nodeValue;
	var matrix = new Float64Array(buff);
	var inv = this.mInverse(matrix);
	var matStore = this.gamuts[idx].outMatrix;
	var r;
	if (inv) {
		for (var j=0; j<9; j++) {
			if (Math.abs(inv[j]-Math.round(inv[j])) > 0.000001) {
				matStore[j] = Math.round(inv[j]*10000000)/10000000;
			} else {
				matStore[j] = Math.round(inv[j]);
			}
		}
	} else {
		for (var j=0; j<9; j++) {
			if (j === 0 || j === 4 || j === 8) {
				matStore[j] = 1;
			} else {
				matStore[j] = 0;
			}
		}
	}
	for (var j=0; j<9; j++) {
		if (Math.abs(matrix[j]-Math.round(matrix[j])) > 0.000001) {
			this.gamuts[idx].inMatrix[j] = Math.round(matrix[j]*10000000)/10000000;
		} else {
			this.gamuts[idx].inMatrix[j] = Math.round(matrix[j]);
		}
	}
	if (idx === this.gamList.selectedIndex) {
		for (var j=0; j<9; j++) {
			this.matIn[j].value = this.gamuts[idx].inMatrix[j].toString();
			this.matOut[j].value = this.gamuts[idx].outMatrix[j].toString();
		}
	}
	this.messages.gtSetParams();
};
TWKCS.prototype.getCAT = function(cat) {
	var m = this.CATSelect.options.length;
	for (var j=0; j<m; j++) {
		if (this.CATSelect.options[j].lastChild.nodeValue === cat) {
			return j;
		}
	}
};
TWKCS.prototype.removeCS = function() {
	var i = this.gamList.selectedIndex;
	var m = this.gamList.options.length;
	if (m>1) {
		this.gamList.remove(i);
		this.inSelect.remove(i);
		this.outSelect.remove(i);
		this.gamuts.splice(i,1);
	}
	this.changeCS();
};
TWKCS.prototype.clspMatx = function() {
	if (this.clspOpt.checked) {
		this.wppBox.className = 'twk-tab';
		this.matxBox.className = 'twk-tab-hide';
		this.gamuts[this.gamList.selectedIndex].matrix = false;
	} else {
		this.wppBox.className = 'twk-tab-hide';
		this.matxBox.className = 'twk-tab-box';
		this.gamuts[this.gamList.selectedIndex].matrix = true;
	}
};
TWKCS.prototype.toggleMatIO = function() {
	if (this.matInOpt.checked) {
		for (var j=0; j<9; j++) {
			this.matIn[j].disabled = false;
			this.matOut[j].disabled = true;
		}
	} else {
		for (var j=0; j<9; j++) {
			this.matIn[j].disabled = true;
			this.matOut[j].disabled = false;
		}
	}
};
TWKCS.prototype.updateInMatrix = function() {
	var mat = new Float64Array(9);
	var i;
	for (var j=0; j<9; j++) {
		i = parseFloat(this.matIn[j].value);
		if (isNaN(i)) {
			i = this.gamuts[this.gamList.selectedIndex].inMatrix[j];
			this.matIn[j].value = i.toString();
			mat[j] = i;
		} else {
			this.gamuts[this.gamList.selectedIndex].inMatrix[j] = i;
			mat[j] = i;
		}
	}
	var inv = this.mInverse(mat);
	var matStore = this.gamuts[this.gamList.selectedIndex].outMatrix;
	if (inv) {
		for (var j=0; j<9; j++) {
			inv[j] = parseFloat(inv[j].toFixed(8));
			this.matOut[j].value = inv[j].toString();
			matStore[j] = inv[j];
		}
	} else {
		for (var j=0; j<9; j++) {
			if (j === 0 || j === 4 || j === 8) {
				this.matOut[j].value = '1';
				matStore[j] = 1;
			} else {
				this.matOut[j].value = '0';
				matStore[j] = 0;
			}
		}
	}
};
TWKCS.prototype.updateOutMatrix = function() {
	var mat = new Float64Array(9);
	var i;
	for (var j=0; j<9; j++) {
		i = parseFloat(this.matOut[j].value);
		if (isNaN(i)) {
			i = this.gamuts[this.gamList.selectedIndex].outMatrix[j];
			this.matOut[j].value = i.toString();
			mat[j] = i;
		} else {
			this.gamuts[this.gamList.selectedIndex].outMatrix[j] = i;
			mat[j] = i;
		}
	}
	var inv = this.mInverse(mat);
	var matStore = this.gamuts[this.gamList.selectedIndex].inMatrix;
	if (inv) {
		for (var j=0; j<9; j++) {
			inv[j] = parseFloat(inv[j].toFixed(8));
			this.matIn[j].value = inv[j].toString();
			matStore[j] = inv[j];
		}
	} else {
		for (var j=0; j<9; j++) {
			if (j === 0 || j === 4 || j === 8) {
				this.matIn[j].value = '1';
				matStore[j] = 1;
			} else {
				this.matIn[j].value = '0';
				matStore[j] = 0;
			}
		}
	}
};
TWKCS.prototype.mInverse = function(M) {
	var det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
				(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
				(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	if (det === 0) {
		return false;
	}
	return new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
TWKCS.prototype.changeCS = function() {
	var i = this.gamList.selectedIndex;
	this.outSelect.options[i].selected = true;
	this.setXY(i);
	this.title.value = this.gamList.options[i].lastChild.nodeValue;
	if (this.gamuts[i].std) {
		this.stdWP.checked = true;
		this.cstWP.checked = false;
		var m = this.stdIll.options.length;
		for (var j=0; j<m; j++) {
			if (this.stdIll.options[j].lastChild.nodeValue.toUpperCase() === this.gamuts[i].std) {
				this.stdIll.options[j].selected = true;
				break;
			}
		}
	} else {
		this.stdWP.checked = false;
		this.cstWP.checked = true;
	}
	this.illOrWP();
	for (var j=0; j<9; j++) {
		this.matIn[j].value = this.gamuts[i].inMatrix[j].toString();
		this.matOut[j].value = this.gamuts[i].outMatrix[j].toString();
	}
	if (typeof this.gamuts[i].wcs !== 'undefined') {
		var m = this.wrkspcSelect.options.length;
		for (var j=0; j<m; j++) {
			if (this.wrkspcSelect.options[j].lastChild.nodeValue === this.gamuts[i].wcs) {
				this.wrkspcSelect.options[j].selected = true;
				break;
			}
		}
	}
	if (typeof this.gamuts[i].matrix === 'boolean' && this.gamuts[i].matrix) {
		this.matxOpt.checked = true;
		this.clspOpt.checked = false;
	} else {
		this.matxOpt.checked = false;
		this.clspOpt.checked = true;
	}
	this.CATSelect.options[this.gamuts[i].cat].selected = true;
	this.clspMatx();
	this.changeOutput();
};
TWKCS.prototype.setXY = function(i) {
	this.xWP.value = this.gamuts[i].wx.toString();
	this.yWP.value = this.gamuts[i].wy.toString();
	this.xR.value = this.gamuts[i].rx.toString();
	this.yR.value = this.gamuts[i].ry.toString();
	this.xG.value = this.gamuts[i].gx.toString();
	this.yG.value = this.gamuts[i].gy.toString();
	this.xB.value = this.gamuts[i].bx.toString();
	this.yB.value = this.gamuts[i].by.toString();
};
TWKCS.prototype.testWx = function() {
	var i = this.gamList.options.selectedIndex;
	var x = parseFloat(this.xWP.value);
	if (isNaN(x)) {
		this.xWP.value = this.gamuts[i].wx.toString();
	} else {
		this.gamuts[i].wx = x;
	}
	this.gamuts[i].lock = true;
};
TWKCS.prototype.testWy = function() {
	var i = this.gamList.options.selectedIndex;
	var y = parseFloat(this.yWP.value);
	if (isNaN(y)) {
		this.yWP.value = this.gamuts[i].wy.toString();
	} else {
		this.gamuts[i].wy = y;
	}
	this.gamuts[i].lock = true;
};
TWKCS.prototype.testRx = function() {
	var i = this.gamList.options.selectedIndex;
	var x = parseFloat(this.xR.value);
	if (isNaN(x)) {
		this.xR.value = this.gamuts[i].rx.toString();
	} else {
		this.gamuts[i].rx = x;
	}
	this.gamuts[i].lock = true;
};
TWKCS.prototype.testRy = function() {
	var i = this.gamList.options.selectedIndex;
	var y = parseFloat(this.yR.value);
	if (isNaN(y)) {
		this.yR.value = this.gamuts[i].ry.toString();
	} else {
		this.gamuts[i].ry = y;
	}
	this.gamuts[i].lock = true;
};
TWKCS.prototype.testGx = function() {
	var i = this.gamList.options.selectedIndex;
	var x = parseFloat(this.xG.value);
	if (isNaN(x)) {
		this.xG.value = this.gamuts[i].gx.toString();
	} else {
		this.gamuts[i].gx = x;
	}
	this.gamuts[i].lock = true;
};
TWKCS.prototype.testGy = function() {
	var i = this.gamList.options.selectedIndex;
	var y = parseFloat(this.yG.value);
	if (isNaN(y)) {
		this.yG.value = this.gamuts[i].gy.toString();
	} else {
		this.gamuts[i].gy = y;
	}
	this.gamuts[i].lock = true;
};
TWKCS.prototype.testBx = function() {
	var i = this.gamList.options.selectedIndex;
	var x = parseFloat(this.xB.value);
	if (isNaN(x)) {
		this.xB.value = this.gamuts[i].bx.toString();
	} else {
		this.gamuts[i].bx = x;
	}
	this.gamuts[i].lock = true;
};
TWKCS.prototype.testBy = function() {
	var i = this.gamList.options.selectedIndex;
	var y = parseFloat(this.yB.value);
	if (isNaN(y)) {
		this.yB.value = this.gamuts[i].by.toString();
	} else {
		this.gamuts[i].by = y;
	}
	this.gamuts[i].lock = true;
};
TWKCS.prototype.setPrimaries = function() {
	var xy = this.xyVals;
	if (!isNaN(xy[0])&&!isNaN(xy[1])&&!isNaN(xy[2])&&!isNaN(xy[3])&&!isNaN(xy[4])&&!isNaN(xy[5])) {
		var i = this.gamList.selectedIndex;
		this.gamuts[i].rx = xy[0];
		this.gamuts[i].ry = xy[1];
		this.gamuts[i].gx = xy[2];
		this.gamuts[i].gy = xy[3];
		this.gamuts[i].bx = xy[4];
		this.gamuts[i].by = xy[5];
		this.xR.value = xy[0];
		this.yR.value = xy[1];
		this.xG.value = xy[2];
		this.yG.value = xy[3];
		this.xB.value = xy[4];
		this.yB.value = xy[5];
		this.clspOpt.checked = true;
		this.clspMatx();
	}
};
TWKCS.prototype.changeInput = function() {
	var i = this.inSelect.options[this.inSelect.selectedIndex].lastChild.nodeValue;
	this.inputs.inGamut.options[this.inputs.custGamInIdx].removeChild(this.inputs.inGamut.options[this.inputs.custGamInIdx].firstChild);
	this.inputs.inGamut.options[this.inputs.custGamInIdx].appendChild(document.createTextNode('Custom - '+i));
};
TWKCS.prototype.changeOutput = function() {
	var o = this.outSelect.options[this.outSelect.selectedIndex].lastChild.nodeValue;
	this.inputs.outGamut.options[this.inputs.custGamOutIdx].removeChild(this.inputs.outGamut.options[this.inputs.custGamOutIdx].firstChild);
	this.inputs.outGamut.options[this.inputs.custGamOutIdx].appendChild(document.createTextNode('Custom - '+o));
};
TWKCS.prototype.changeTitle = function() {
	this.title.value = this.title.value.replace(/[/"/']/gi, '');
	if (this.title.value.length > 0) {
		var i = this.gamList.selectedIndex;
		this.gamList.options[i].removeChild(this.gamList.options[i].firstChild);
		this.gamList.options[i].appendChild(document.createTextNode(this.title.value));
		this.inSelect.options[i].removeChild(this.inSelect.options[i].firstChild);
		this.inSelect.options[i].appendChild(document.createTextNode(this.title.value));
		this.changeInput();
		this.outSelect.options[i].removeChild(this.outSelect.options[i].firstChild);
		this.outSelect.options[i].appendChild(document.createTextNode(this.title.value));
		this.changeOutput();
	}
};
TWKCS.prototype.taToString = function(data) {
	var out = [];
	var m = data.length;
	for (var j=0; j<m; j++) {
		out[j] = data[j];
	}
	return out.toString();
};
TWKCS.prototype.createRadioElement = function(name, checked) {
    var radioInput;
    try {
        var radioHtml = '<input type="radio" name="' + name + '"';
        if ( checked ) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += '/>';
        radioInput = document.createElement(radioHtml);
    } catch( err ) {
        radioInput = document.createElement('input');
        radioInput.setAttribute('type', 'radio');
        radioInput.setAttribute('name', name);
        if ( checked ) {
            radioInput.setAttribute('checked', 'checked');
        }
    }
    return radioInput;
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-white.js
* White balance 'dropper' object for the LUTCalc Web App.
* 13th August 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKWHITE(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.p = 12;
	this.messages.addUI(this.p,this);
	this.io();
	this.ui();
	this.events();
}
TWKWHITE.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;
	// Tweak - Specific Inputs

	// Base Data
	this.sysCCT = 6504;
	this.sysDuv = 0.00549;
	this.newCCT = this.sysCCT;
	this.newDuv = this.sysDuv;
	this.newDpl = 0;
	// Reference Temperature (Recording)
	this.refInput = document.createElement('input');
	this.refInput.setAttribute('type','number');
	this.refInput.className = 'kelvin-input';
	this.refInput.value = '5500';
	// Desired Colour Temperature
	this.ctInput = document.createElement('input');
	this.ctInput.setAttribute('type','number');
	this.ctInput.className = 'kelvin-input';
	this.ctInput.value = this.refInput.value;
	// Lamp Colour Temperature Input
	this.lampInput = document.createElement('input');
	this.lampInput.setAttribute('type','number');
	this.lampInput.className = 'kelvin-input';
	this.lampInput.value = this.refInput.value;
	this.lampButton = document.createElement('input');
	this.lampButton.setAttribute('type','button');
	this.lampButton.value = 'Unlock Lightsource From New White';
	this.lampFree = false;
	// CTO / CTB Slider
	this.ctS = new lutSlider({
		min: -1.25,
		max: 1.25,
		value: 0,
		step: 0.05,
		title: false,
		minLabel: 'CTO',
		maxLabel: 'CTB',
		input: 'label',
		reset: true,
		dataFormat: {
			neg: '[[VALUE]] CTO',
			zero: 'Clear',
			pos: '[[VALUE]] CTB',
		}
	});
	// Duv (Green / Magenta) Slider
	this.duvS = new lutSlider({
		min: -1.5,
		max: 1.5,
		value: 0,
		step: 0.05,
		title: false,
		minLabel: 'Minus Green',
		maxLabel: 'Plus Green',
		input: 'label',
		reset: true,
		dataFormat: {
			neg: '[[VALUE]] Minus Green',
			zero: 'Clear',
			pos: '[[VALUE]] Plus Green',
		}
	});
	// Dpl (Yellow / Blue) Slider
	this.dplS = new lutSlider({
		min: -1.5,
		max: 1.5,
		value: 0,
		step: 0.05,
		title: false,
		minLabel: 'Minus Green',
		maxLabel: 'Plus Green',
		input: 'label',
		reset: true,
		dataFormat: {
			neg: '[[VALUE]] Minus Green',
			zero: 'Clear',
			pos: '[[VALUE]] Plus Green',
		}
	});
	// Preview Window White Sampling Button
	this.sample = false;
	this.sampleButton = document.createElement('input');
	this.sampleButton.setAttribute('type','button');
	this.sampleButton.value = 'Preview Click For White';
	// Advanced Options Checkbox
	this.advancedCheck = document.createElement('input');
	this.advancedCheck.setAttribute('type','checkbox');
	this.advancedCheck.className = 'twk-checkbox';
	this.advancedCheck.checked = false;
	// Lamp Nominal Temperature selected
	this.lampTempSelect = document.createElement('select');
	this.lampTempSelect.className = 'twk-select';
	// Chromatic Adaptation Transform Model Selector
	this.catSelect = document.createElement('select');
	this.catSelect.className = 'twk-select';
};
TWKWHITE.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('White Balance')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak';
	// Tweak - Specific UI Elements
	// Advanced Box - Holds Advanced Or Experimental Inputs
	this.advancedBox = document.createElement('div');
	this.advancedBox.className = 'twk-advanced-hide';
	// Reference White Temperature
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Reference White')));
	this.box.appendChild(this.refInput);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('K')));
	this.box.appendChild(document.createElement('br'));
	// New White Temperature
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('New White Balance')));
	this.box.appendChild(this.ctInput);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('K')));
	this.box.appendChild(document.createElement('br'));
	// Light Source Temperature
	this.lampBox = document.createElement('div');
	this.lampBox.className = 'tweak-hide';
	this.lampBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Lamp Nominal Temperature')));
	this.lampBox.appendChild(this.lampInput);
	this.lampBox.appendChild(document.createElement('label').appendChild(document.createTextNode('K')));
	this.box.appendChild(this.lampBox);
	this.box.appendChild(this.lampButton);	
	this.box.appendChild(document.createElement('br'));
	// Colour Temperature Correction
	this.ctBox = document.createElement('div');
	this.ctBox.className = 'slider-holder';
	this.ctBox.appendChild(this.ctS.element);
	this.box.appendChild(this.ctBox);
	// Plus / Minus Green
	this.duvBox = document.createElement('div');
	this.duvBox.className = 'slider-holder';
	this.duvBox.appendChild(this.duvS.element);
	this.box.appendChild(this.duvBox);
	// White Sample Button
	this.preBox = document.createElement('div');
	this.preBox.className = 'tweak-hide';
	this.preBox.appendChild(this.sampleButton);
	this.box.appendChild(this.preBox);
	// Advanced settings Checkbox
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Advanced Settings')));
	this.box.appendChild(this.advancedCheck);
	// Lamp Nominal Colour Temperature Selector
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Lamp Nominal Colour')));
	this.lampList();
	this.advancedBox.appendChild(this.lampTempSelect);
	this.advancedBox.appendChild(document.createElement('br'));
	// Chromatic Adaptation Transform Selection
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Chromatic Adaptation Model')));
	this.advancedBox.appendChild(this.catSelect);

	// Build Box Hierarchy
	this.box.appendChild(this.advancedBox);
	this.holder.appendChild(this.box);
};
TWKWHITE.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked && this.inputs.d[1].checked) { // This checks for 'Customisations' to be checked and LUT type set to '3D' (the d[1] item)
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKWHITE.prototype.toggleTweak = function() {
	if (this.inputs.showPreview) {
		this.preBox.className = 'tweak';
	} else {
		this.preBox.className = 'tweak-hide';
	}
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKWHITE.prototype.getTFParams = function(params) {
	// No parameters are relevent
};
TWKWHITE.prototype.getCSParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doWB = true;
		out.ref = parseFloat(this.refInput.value);
		var refMired = 1000000/out.ref;
		out.ctShift = (1000000/parseFloat(this.ctInput.value))-refMired;
		out.lampShift = (1000000/parseFloat(this.lampInput.value))-refMired;
		out.duv = parseFloat(this.duvS.getValue());
		out.dpl = parseFloat(this.dplS.getValue());
		out.CAT = this.catSelect.selectedIndex;
	} else {
		out.doWB = false;
	}
	params.twkWB = out;
};
TWKWHITE.prototype.setParams = function(params) {
	if (typeof params.twkWHITE !== 'undefined') {
		var p = params.twkWHITE;
		this.toggleTweaks();
	}
	// Any changes to UI inputs coming from the gamma and gamut workers should go here
};
TWKWHITE.prototype.getSettings = function(data) {
	data.whiteBalance = {
		doWB: this.tweakCheck.checked,
		ref: parseFloat(this.refInput.value),
		lampFree: this.lampFree,
		newTemp: parseFloat(this.ctInput.value),
		lampTemp: parseFloat(this.lampInput.value),
		Duv: parseFloat(this.duvS.getValue()),
//		Dpl: parseFloat(this.dplS.getValue()),
		advanced: this.advancedCheck.checked,
		CAT: this.catSelect.options[this.catSelect.selectedIndex].lastChild.nodeValue
	};
};
TWKWHITE.prototype.setSettings = function(settings) {
	if (typeof settings.whiteBalance !== 'undefined') {
		var data = settings.whiteBalance;
		if (typeof data.doWB === 'boolean') {
			this.tweakCheck.checked = data.doWB;
			this.toggleTweak();
		}
		if (typeof data.ref === 'number') {
			this.refInput.value = data.ref.toString();
			this.testRefInput();
		}
		if (typeof data.lampFree === 'boolean') {
			this.lampFree = data.lampFree;
		}
		if (typeof data.newTemp === 'number') {
			this.ctInput.value = data.newTemp.toString();
			this.testCTInput();
		}
		if (typeof data.lampTemp === 'number') {
			this.lampInput.value = data.lampTemp.toString();
			this.testLampInput();
		}
		if (typeof data.Duv === 'number') {
			this.duvS.setValue(parseFloat(data.Duv));
		}
//		if (typeof data.Dpl === 'number') {
//			this.dplS.setValue(parseFloat(data.Dpl));
//			this.testDplSlider();
//		}
		if (typeof data.advanced === 'boolean') {
			this.advancedCheck.checked = data.advanced;
			this.toggleAdvanced();
		}
		if (typeof data.CAT !== 'undefined') {
			var m = this.catSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.catSelect.options[j].lastChild.nodeValue === data.CAT) {
					this.catSelect.options[j].selected = true;
					break;
				}
			}
		}
	}
};
TWKWHITE.prototype.getInfo = function(info) {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doWB = true;
	} else {
		info.doWB = false;
	}
};
TWKWHITE.prototype.isCustomGamma = function() {
	return false;
};
TWKWHITE.prototype.isCustomGamut = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKWHITE.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gtSetParams();
	};}(this);
	this.refInput.onchange = function(here){ return function(){
		here.testRefInput();
		here.messages.gtSetParams();
	};}(this);
	this.ctS.action = function(here){ return function(){
		here.testCTSlider();
		here.messages.gtSetParams();
	};}(this);
	this.duvS.action = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.dplS.action = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.ctInput.onchange = function(here){ return function(){
		here.testCTInput();
		here.messages.gtSetParams();
	};}(this);
	this.lampInput.onchange = function(here){ return function(){
		here.testLampInput();
		here.messages.gtSetParams();
	};}(this);
	this.sampleButton.onclick = function(here){ return function(){
		here.toggleSample();
	};}(this);
	this.lampButton.onclick = function(here){ return function(){
		here.toggleLamp();
	};}(this);
//	this.inputs.previewCanvas.onclick = function(here){ return function(e){
//		here.previewSample(e.clientX, e.clientY);
//	};}(this);
	this.advancedCheck.onclick = function(here){ return function(){
		here.toggleAdvanced();
	};}(this);
	this.lampTempSelect.onchange = function(here){ return function(){
		here.testLampTempSelect();
		here.messages.gtSetParams();
	};}(this);
	this.catSelect.onchange = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
};
// Tweak-Specific Code
TWKWHITE.prototype.testRefInput = function() {
	var refTemp = Math.round(parseFloat(this.refInput.value));
	if (refTemp < 100) {
		refTemp = 100;
	} else if (isNaN(refTemp)) {
		refTemp = 5500;
	}
	this.refInput.value = refTemp.toString();
	var refMired = 1000000 / Math.round(parseFloat(this.refInput.value));
	var temp = Math.round(parseFloat(this.ctInput.value));
	var ctMiredShift = (1000000/temp) - refMired;
	var miredScale = (1000000/3200)-(1000000/5500); // scale mireds so that 3200 -> 5500 shift = 1 on slider
	var sliderVal = (ctMiredShift / miredScale).toFixed(2);
	this.ctS.setValue(sliderVal);
};
TWKWHITE.prototype.testCTInput = function() {
	var refMired = 1000000 / Math.round(parseFloat(this.refInput.value));
	var temp = Math.round(parseFloat(this.ctInput.value));
	if (temp <= 100) {
		temp = 100;
		this.ctInput.value = temp.toString();
	} else if (isNaN(temp)) {
		this.ctInput.value = this.refInput.value;
		temp = Math.round(parseFloat(this.ctInput.value));
	}
	var ctMiredShift = (1000000/temp) - refMired;
	var miredScale = (1000000/3200)-(1000000/5500); // scale mireds so that 3200 -> 5500 shift = 1 on slider
	if (!this.lampFree) {
		this.lampInput.value = this.ctInput.value;
		var m = this.lampTempL.length;
		for (var j=0; j<m; j++) {
			if (temp >= this.lampTempL[j] && temp <= this.lampTempH[j]) {
				this.lampTempSelect.options[j].selected = true;
				break;
			}
		}
	}
	this.ctS.setValue((ctMiredShift / miredScale).toFixed(2));
};
TWKWHITE.prototype.lampList = function() {
	var colours = [	'Warm Comfort Light',
					'Warm White',
					'Tungsten',
					'White',
					'Cool White',
					'Daylight',
					'Cool Daylight'
	];
	var temps = [	2500,
					2800,
					3200,
					3500,
					4300,
					5500,
					6500
	];
	this.lampTempL = [];
	this.lampTempH = [];
	var max = colours.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = temps[j].toString();
		option.appendChild(document.createTextNode(colours[j]));
		if (temps[j] === parseInt(this.lampInput.value)) {
			option.selected = true;
		}
		if (j === 0) {
			this.lampTempL[j] = 0;
			this.lampTempH[j] = (temps[j] + temps[j+1])/2;
		} else if (j === max-1) {
			this.lampTempL[j] = this.lampTempH[j-1]+1;
			this.lampTempH[j] = 99999;
		} else {
			this.lampTempL[j] = this.lampTempH[j-1]+1;
			this.lampTempH[j] = (temps[j] + temps[j+1])/2;
		}
		this.lampTempSelect.appendChild(option);
	}
};
TWKWHITE.prototype.testLampInput = function() {
	var temp = Math.round(parseFloat(this.lampInput.value));
	if (isNaN(temp)) {
		this.lampInput.value = this.ctInput.value;
	} else if (temp < 500) {
		this.lampInput.value = '500';
	} else {
		this.lampInput.value = temp.toString();
	}
	var m = this.lampTempL.length;
	for (var j=0; j<m; j++) {
		if (temp >= this.lampTempL[j] && temp <= this.lampTempH[j]) {
			this.lampTempSelect.options[j].selected = true;
			break;
		}
	}
};
TWKWHITE.prototype.testLampTempSelect = function() {
	this.lampInput.value = this.lampTempSelect.options[this.lampTempSelect.selectedIndex].value;
	if (!this.lampFree) {
		this.ctInput.value = this.lampInput.value;
		this.testCTInput();
	}
};
TWKWHITE.prototype.testCTSlider = function() {
	var val = this.ctS.getValue();
	var miredScale = (1000000/3200)-(1000000/5500); // scale mireds so that 3200 -> 5500 shift = 1 on slider
	var refMired = 1000000 / Math.round(parseFloat(this.refInput.value));
	var ctMiredShift = val * miredScale;
	if (-ctMiredShift > refMired * 0.9) {
		this.refInput.value = Math.round(1000000 / (-ctMiredShift / 0.9)).toString();
		refMired = 1000000 / parseFloat(this.refInput.value);
	}
	var temp = 1000000 / (refMired + ctMiredShift);
	this.ctInput.value = Math.round(temp).toString();
	if (!this.lampFree) {
		this.lampInput.value = this.ctInput.value;
	}
};
TWKWHITE.prototype.gotCATs = function(CATs) {
	var max = CATs.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = j.toString();
		option.appendChild(document.createTextNode(CATs[j]));
		if (j === 0) {
			option.selected = true;
		}
		this.catSelect.appendChild(option);
	}
};
TWKWHITE.prototype.toggleSample = function() {
	if (this.sample) {
		this.sampleButton.value = 'Preview Click For White';
		this.sample = false;
	} else {
		this.sampleButton.value = 'Stop Preview Click For White';
		this.sample = true;
		this.messages.takePreviewClick(0);
	}
};
TWKWHITE.prototype.toggleLamp = function() {
	if (this.lampFree) {
		this.lampButton.value = 'Unlock Lightsource From New White';
		this.lampBox.className = 'tweak-hide';
		this.lampInput.value = this.ctInput.value;
		this.lampFree = false;
	} else {
		this.lampButton.value = 'Lock Lightsource To New White';
		this.lampBox.className = 'tweak';
		this.lampFree = true;
	}
};
TWKWHITE.prototype.previewSample = function(x,y) {
	if (this.tweakCheck.checked) {
		if (this.sample) {
			var rect = this.inputs.previewCanvas.getBoundingClientRect();
			x = (x - rect.left)/rect.width;
			y = (y - rect.top)/rect.height;
			this.messages.getPreCCTDuv(x,y);
		}
	}
};
TWKWHITE.prototype.gotPreCCTDuv = function(p) {
	var refMired = 1000000 / parseFloat(this.refInput.value);
	var sysMired = 1000000 / p.sys;
	var ctMiredRef = (1000000 / p.ct) - sysMired + refMired;
	var lampMiredRef = (1000000 / p.lamp) - sysMired + refMired;
	this.ctInput.value = Math.round(1000000 / ctMiredRef);
	this.testCTInput();
	this.lampInput.value = Math.round(1000000 / lampMiredRef);
	this.duvS.setValue(p.duv);
	this.dplS.setValue(p.dpl);
	this.messages.gtSetParams();
};
TWKWHITE.prototype.toggleAdvanced = function() {
	if (this.advancedCheck.checked) {
		this.advancedBox.className = 'twk-advanced';
	} else {
		this.advancedBox.className = 'twk-advanced-hide';
	}
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-asccdl.js
* ASC-CDL object for the LUTCalc Web App.
* 10th April 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKASCCDL(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.io();
	this.ui();
}
TWKASCCDL.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;

	// Saturation Slider
	this.satS = new lutSlider({
		min: 0,
		max: 2,
		value: 1,
		step: 0.05,
		title: false,
		lhs: 'Saturation',
		minLabel: false,
		maxLabel: false,
		input: 'number',
		inputLim: false,
		reset: true
	});
	// Colour Channel Selector
	this.channelSelect = document.createElement('select');
	this.channelSelect.className = 'twk-select';
	this.channelList();
	// SOP Arrays
	this.sS = [];
	this.oS = [];
	this.pS = [];
	for (var j=0; j<4; j++) {
		this.sS[j] = new lutSlider({
			min: 0,
			mid: 1,
			max: 10,
			value: 1,
			step: 0.0001,
			title: false,
			lhs: 'Slope',
			minLabel: false,
			maxLabel: false,
			input: 'number',
			inputLim: false,
			reset: true,
			resetAll: true
		});
		this.oS[j] = new lutSlider({
			min: -0.5,
			max: 0.5,
			value: 0,
			step: 0.01,
			title: false,
			lhs: 'Offset',
			minLabel: false,
			maxLabel: false,
			input: 'number',
			inputLim: false,
			reset: true,
			resetAll: true
		});
		this.pS[j] = new lutSlider({
			min: 0,
			mid: 1,
			max: 10,
			value: 1,
			step: 0.01,
			title: false,
			lhs: 'Power',
			minLabel: false,
			maxLabel: false,
			input: 'number',
			inputLim: false,
			reset: true,
			resetAll: true
		});
	}
};
TWKASCCDL.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('ASC-CDL')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
// Tweak - Specific UI Elements
	// Saturation
	this.box.appendChild(this.satS.element);
	// Channel Selector
	this.box.appendChild(this.channelSelect);
	this.box.appendChild(document.createElement('br'));
	// SOP Boxes
	this.sop = [];
	for (var j=0; j<4; j++) {
		this.sop[j] = document.createElement('div');
		if (j === 0) {
			this.sop[j].className = 'twk-tab';
		} else {
			this.sop[j].className = 'twk-tab-hide';
		}
		this.sop[j].appendChild(this.sS[j].element);
		this.sop[j].appendChild(this.oS[j].element);
		this.sop[j].appendChild(this.pS[j].element);
		this.box.appendChild(this.sop[j]);
	}
	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKASCCDL.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked) {
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
		if (this.inputs.d[1].checked) {
			this.satS.show();
		} else {
			this.satS.hide();
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKASCCDL.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKASCCDL.prototype.getTFParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doASCCDL = true;
		var cdl = new Float64Array(10);
		for (var j=0; j<3; j++) {
			cdl[ j ] = this.sS[j+1].getValue();
			cdl[j+3] = this.oS[j+1].getValue();
			cdl[j+6] = this.pS[j+1].getValue();
		}
		cdl[9] = this.satS.getValue();
		out.cdl = cdl.buffer;
	} else {
		out.doASCCDL = false;
	}
	params.twkASCCDL = out;
};
TWKASCCDL.prototype.getCSParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doASCCDL = true;
		var cdl = new Float64Array(10);
		for (var j=0; j<3; j++) {
			cdl[ j ] = this.sS[j+1].getValue();
			cdl[j+3] = this.oS[j+1].getValue();
			cdl[j+6] = this.pS[j+1].getValue();
		}
		cdl[9] = this.satS.getValue();
		out.cdl = cdl.buffer;
	} else {
		out.doASCCDL = false;
	}
	params.twkASCCDL = out;
};
TWKASCCDL.prototype.setParams = function(params) {
	if (typeof params.twkASCCDL !== 'undefined') {
		var p = params.twkASCCDL;
		this.toggleTweaks();
	}
};
TWKASCCDL.prototype.getSettings = function(data) {
	var cdl = [];
	for (var j=0; j<3; j++) {
		cdl[ j ] = this.sS[j+1].getValue();
		cdl[j+3] = this.oS[j+1].getValue();
		cdl[j+6] = this.pS[j+1].getValue();
	}
	cdl[9] = this.satS.getValue();
	data.ascCDL = {
		doASCCDL: this.tweakCheck.checked,
		cdl: cdl.toString(),
		channel: this.channelSelect.options[this.channelSelect.selectedIndex].lastChild.nodeValue
	};
};
TWKASCCDL.prototype.setSettings = function(settings) {
	if (typeof settings.ascCDL !== 'undefined') {
		var data = settings.ascCDL;
		if (typeof data.doASCCDL === 'boolean') {
			this.tweakCheck.checked = data.doASCCDL;
			this.toggleTweak();
		}
		if (typeof data.cdl !== 'undefined') {
			var cdl = data.cdl.split(',').map(Number);
			this.sS[0].setValue((parseFloat(cdl[0])+parseFloat(cdl[1])+parseFloat(cdl[2]))/3);
			this.oS[0].setValue((parseFloat(cdl[3])+parseFloat(cdl[4])+parseFloat(cdl[5]))/3);
			this.pS[0].setValue((parseFloat(cdl[6])+parseFloat(cdl[7])+parseFloat(cdl[8]))/3);
			for (var j=0; j<3; j++) {
				this.sS[j+1].setValue(parseFloat(cdl[ j ]));
				this.oS[j+1].setValue(parseFloat(cdl[j+3]));
				this.pS[j+1].setValue(parseFloat(cdl[j+6]));
			}
			this.satS.setValue(parseFloat(cdl[9]));
		}
		if (typeof data.channel !== 'undefined') {
			var m = this.channelSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.channelSelect.options[j].lastChild.nodeValue === data.channel) {
					this.channelSelect.options[j].selected = true;
					break;
				}
			}
			this.changeChannel();
		}
	}
};
TWKASCCDL.prototype.getInfo = function(info) {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doASCCDL = true;
		info.ASCSat = this.satS.getValue().toString();
	} else {
		info.doASCCDL = false;
	}
};
TWKASCCDL.prototype.isCustomGamma = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKASCCDL.prototype.isCustomGamut = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKASCCDL.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
	this.channelSelect.onchange = function(here){ return function(){
		here.changeChannel();
	};}(this);
	this.satS.action = function(here){ return function(){
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
	this.sS[0].action = function(here){ return function(){
		var off = 0;
		for (var l=1; l<4; l++) {
			off += here.sS[l].getValue();
		}
		off = this.getValue() - (off/3);
		for (var l=1; l<4; l++) {
			here.sS[l].setValue(Math.max(0,here.sS[l].getValue()+off));
		}
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
	this.oS[0].action = function(here){ return function(){
		var off = 0;
		for (var l=1; l<4; l++) {
			off += here.oS[l].getValue();
		}
		off = this.getValue() - (off/3);
		for (var l=1; l<4; l++) {
			here.oS[l].setValue(here.oS[l].getValue()+off);
		}
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
	this.pS[0].action = function(here){ return function(){
		var off = 0;
		for (var l=1; l<4; l++) {
			off += here.pS[l].getValue();
		}
		off = this.getValue() - (off/3);
		for (var l=1; l<4; l++) {
			here.pS[l].setValue(Math.max(0,here.pS[l].getValue()+off));
		}
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
	this.sS[0].resetAll = function(here){ return function(){
		for (var l=0; l<4; l++) {
			here.sS[l].reset();
		}
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
	this.oS[0].resetAll = function(here){ return function(){
		for (var l=0; l<4; l++) {
			here.oS[l].reset();
		}
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
	this.pS[0].resetAll = function(here){ return function(){
		for (var l=0; l<4; l++) {
			here.pS[l].reset();
		}
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
	for (var j=1; j<4; j++) {
		this.sS[j].action = function(here){ return function(){
			var o = 0;
			for (var l=1; l<4; l++) {
				o += here.sS[l].getValue();
			}
			here.sS[0].setValue(o/3);
			here.messages.gaSetParams();
			here.messages.gtSetParams();
		};}(this);
		this.sS[j].resetAll = function(here){ return function(){
			for (var l=0; l<4; l++) {
				here.sS[l].reset();
			}
			here.messages.gaSetParams();
			here.messages.gtSetParams();
		};}(this);
		this.oS[j].action = function(here){ return function(){
			var o = 0;
			for (var l=1; l<4; l++) {
				o += here.oS[l].getValue();
			}
			here.oS[0].setValue(o/3);
			here.messages.gaSetParams();
			here.messages.gtSetParams();
		};}(this);
		this.oS[j].resetAll = function(here){ return function(){
			for (var l=0; l<4; l++) {
				here.oS[l].reset();
			}
			here.messages.gaSetParams();
			here.messages.gtSetParams();
		};}(this);
		this.pS[j].action = function(here){ return function(){
			var o = 0;
			for (var l=1; l<4; l++) {
				o += here.pS[l].getValue();
			}
			here.pS[0].setValue(o/3);
			here.messages.gaSetParams();
			here.messages.gtSetParams();
		};}(this);
		this.pS[j].resetAll = function(here){ return function(){
			for (var l=0; l<4; l++) {
				here.pS[l].reset();
			}
			here.messages.gaSetParams();
			here.messages.gtSetParams();
		};}(this);
	}
};
// Tweak-Specific Code
TWKASCCDL.prototype.channelList = function() {
	var channels = [
		'Gray',
		'Red',
		'Green',
		'Blue'
	];
	var max = channels.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = j.toString();
		option.appendChild(document.createTextNode(channels[j]));
		if (j === 0) {
			option.selected = true;
		}
		this.channelSelect.appendChild(option);
	}
};
TWKASCCDL.prototype.changeChannel = function() {
	var chan = this.channelSelect.selectedIndex;
	for (var j=0; j<4; j++) {
		if (j === chan) {
			this.sop[j].className = 'twk-tab';
		} else {
			this.sop[j].className = 'twk-tab-hide';
		}
	}
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-psstcdl.js
* Primary / Secondary / Skin Tone CDL object for the LUTCalc Web App.
* 10th April 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKPSSTCDL(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.io();
	this.ui();
}
TWKPSSTCDL.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;

	// Base Controls / Refinement Radio Boxes
	this.basRef = [];
	this.basRef[0] = this.createRadioElement('basRefOpt',true);
	this.basRef[1] = this.createRadioElement('basRefOpt',false);
	// Colour Channel Selector
	this.channelSelect = document.createElement('select');
	this.channelSelect.className = 'twk-select';
	this.channelList();
	// SOP Arrays
	this.bS = [];
	var cS = [];
	var satS = [];
	var sS = [];
	var oS = [];
	var pS = [];
	for (var j=0; j<7; j++) {
		cS[j] = new lutSlider({
			min: -3.5,
			max: 3.5,
			value: 0,
			step: 0.01,
			title: false,
			lhs: 'Colour',
			minLabel: false,
			maxLabel: false,
			input: 'number',
			reset: true,
			resetAll: true
		});
		satS[j] = new lutSlider({
			min: 0,
			max: 2,
			value: 1,
			step: 0.01,
			title: false,
			lhs: 'Saturation',
			minLabel: false,
			maxLabel: false,
			input: 'number',
			inputLim: false,
			reset: true,
			resetAll: true
		});
		sS[j] = new lutSlider({
			min: 0,
			mid: 1,
			max: 10,
			value: 1,
			step: 0.01,
			title: false,
			lhs: 'Slope',
			minLabel: false,
			maxLabel: false,
			input: 'number',
			inputLim: false,
			reset: true,
			resetAll: true
		});
		oS[j] = new lutSlider({
			min: -0.5,
			max: 0.5,
			value: 0,
			step: 0.01,
			title: false,
			lhs: 'Offset',
			minLabel: false,
			maxLabel: false,
			input: 'number',
			inputLim: false,
			reset: true,
			resetAll: true
		});
		pS[j] = new lutSlider({
			min: 0,
			mid: 1,
			max: 10,
			value: 1,
			step: 0.01,
			title: false,
			lhs: 'Power',
			minLabel: false,
			maxLabel: false,
			input: 'number',
			inputLim: false,
			reset: true,
			resetAll: true
		});
	}
	this.bS[0] = cS;
	this.bS[1] = satS;
	this.bS[2] = sS;
	this.bS[3] = oS;
	this.bS[4] = pS;
	// Refined Data
	this.initVals();
	// Refining Sliders
	this.rSelect = document.createElement('select');
	this.rSelect.className = 'twk-select';
	this.refineList();

	var cSs = [];
	var satSs = [];
	var sSs = [];
	var oSs = [];
	var pSs = [];
	var cLs = [];
	var satLs = [];
	var sLs = [];
	var oLs = [];
	var pLs = [];
	for (var j=0; j<28; j++) {
		cLs[j] = document.createElement('input');
		cLs[j].setAttribute('type','checkbox');
		cLs[j].className = 'twk-tinycheck';
		satLs[j] = document.createElement('input');
		satLs[j].setAttribute('type','checkbox');
		satLs[j].className = 'twk-tinycheck';
		sLs[j] = document.createElement('input');
		sLs[j].setAttribute('type','checkbox');
		sLs[j].className = 'twk-tinycheck';
		oLs[j] = document.createElement('input');
		oLs[j].setAttribute('type','checkbox');
		oLs[j].className = 'twk-tinycheck';
		pLs[j] = document.createElement('input');
		pLs[j].setAttribute('type','checkbox');
		pLs[j].className = 'twk-tinycheck';
		if (j%4 === 0) {
			cSs[j] = new lutSlider({
			min: -3.5,
			max: 3.5,
			value: 0,
			step: 0.01,
			style: 'slider-bare-red',
			v: true
		});
			satSs[j] = new lutSlider({
			min: 0,
			max: 2,
			value: 1,
			step: 0.01,
			style: 'slider-bare-red',
			v: true
		});
			sSs[j] = new lutSlider({
			min: 0,
			mid: 1,
			max: 10,
			value: 1,
			step: 0.01,
			style: 'slider-bare-red',
			v: true
		});
			oSs[j] = new lutSlider({
			min: -0.5,
			max: 0.5,
			value: 0,
			step: 0.01,
			style: 'slider-bare-red',
			v: true
		});
			pSs[j] = new lutSlider({
			min: 0,
			mid: 1,
			max: 10,
			value: 1,
			step: 0.01,
			style: 'slider-bare-red',
			v: true
		});
			cLs[j].checked = true;
			cLs[j].disabled = true;
			satLs[j].checked = true;
			satLs[j].disabled = true;
			sLs[j].checked = true;
			sLs[j].disabled = true;
			oLs[j].checked = true;
			oLs[j].disabled = true;
			pLs[j].checked = true;
			pLs[j].disabled = true;
		} else {
			cSs[j] = new lutSlider({
			min: -3.5,
			max: 3.5,
			value: 0,
			step: 0.01,
			style: 'slider-bare',
			v: true
		});
			satSs[j] = new lutSlider({
			min: 0,
			max: 2,
			value: 1,
			step: 0.01,
			style: 'slider-bare',
			v: true
		});
			sSs[j] = new lutSlider({
			min: 0,
			mid: 1,
			max: 10,
			value: 1,
			step: 0.01,
			style: 'slider-bare',
			v: true
		});
			oSs[j] = new lutSlider({
			min: -0.5,
			max: 0.5,
			value: 0,
			step: 0.01,
			style: 'slider-bare',
			v: true
		});
			pSs[j] = new lutSlider({
			min: 0,
			mid: 1,
			max: 10,
			value: 1,
			step: 0.01,
			style: 'slider-bare',
			v: true
		});
			cLs[j].checked = false;
			satLs[j].checked = false;
			sLs[j].checked = false;
			oLs[j].checked = false;
			pLs[j].checked = false;
		}
	}
	this.rSs = [];
	this.rSs[0] = cSs;
	this.rSs[1] = satSs;
	this.rSs[2] = sSs;
	this.rSs[3] = oSs;
	this.rSs[4] = pSs;
	this.rLs = [];
	this.rLs[0] = cLs;
	this.rLs[1] = satLs;
	this.rLs[2] = sLs;
	this.rLs[3] = oLs;
	this.rLs[4] = pLs;
	this.rR =[];
	for (var j=0; j<5; j++) {
		this.rR[j] = document.createElement('input');
		this.rR[j].setAttribute('type','button');
		this.rR[j].setAttribute('value','Reset');
	}


	this.rLock = [];
	for (var j=0; j<28; j++) {
		this.rLock[j] = document.createElement('input');
		this.rLock[j].setAttribute('type','checkbox');
		this.rLock[j].className = 'twk-tinycheck';
		if (j%4 === 0) {
			this.rLock[j].checked = true;
			this.rLock[j].disabled = true;
		} else {
			this.rLock[j].checked = false;
		}
	}
	// Advanced Options Checkbox
	this.advancedCheck = document.createElement('input');
	this.advancedCheck.setAttribute('type','checkbox');
	this.advancedCheck.className = 'twk-checkbox';
	this.advancedCheck.checked = false;
	// Chroma Scale Checkbox
	this.chromaScaleCheck = document.createElement('input');
	this.chromaScaleCheck.setAttribute('type','checkbox');
	this.chromaScaleCheck.className = 'twk-checkbox';
	this.chromaScaleCheck.checked = true;
	// Luma Scale Checkbox
	this.lumaScaleCheck = document.createElement('input');
	this.lumaScaleCheck.setAttribute('type','checkbox');
	this.lumaScaleCheck.className = 'twk-checkbox';
	this.lumaScaleCheck.checked = false;
};
TWKPSSTCDL.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('PSST-CDL')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	// Advanced Box - Holds Advanced Or Experimental Inputs
	this.advancedBox = document.createElement('div');
	this.advancedBox.className = 'twk-advanced-hide';

// Tweak - Specific UI Elements
	// Base Controls / Refinement Radio Boxes
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Base Adjustments')));
	this.box.appendChild(this.basRef[0]);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Refinements')));
	this.box.appendChild(this.basRef[1]);
	// Base Controls Box
	this.baseBox = document.createElement('div');
	this.baseBox.className = 'twk-tab';
	// Channel Selector
	this.baseBox.appendChild(this.channelSelect);
	this.baseBox.appendChild(document.createElement('br'));
	// SOP Boxes
	this.cssop = [];
	this.beforeBar1 = [];
	this.afterBar = [];
	this.beforeBar2 = [];
	for (var j=0; j<7; j++) {
		this.cssop[j] = document.createElement('div');
		if (j === this.channelSelect.options.selectedIndex) {
			this.cssop[j].className = 'twk-tab';
		} else {
			this.cssop[j].className = 'twk-tab-hide';
		}
		this.beforeBar1[j] = document.createElement('div');
		this.beforeBar1[j].className = 'twk-psst-colour-bars-s-h';
		this.cssop[j].appendChild(this.beforeBar1[j]);
		this.afterBar[j] = document.createElement('div');
		this.afterBar[j].className = 'twk-psst-colour-bars-l-h';
		this.cssop[j].appendChild(this.afterBar[j]);
		this.beforeBar2[j] = document.createElement('div');
		this.beforeBar2[j].className = 'twk-psst-colour-bars-s-h';
		this.cssop[j].appendChild(this.beforeBar2[j]);
		this.cssop[j].appendChild(document.createElement('br'));

		this.cssop[j].appendChild(this.bS[0][j].element);
		this.cssop[j].appendChild(this.bS[1][j].element);
		this.cssop[j].appendChild(this.bS[2][j].element);
		this.cssop[j].appendChild(this.bS[3][j].element);
		this.cssop[j].appendChild(this.bS[4][j].element);
		this.baseBox.appendChild(this.cssop[j]);
	}
	// Refinement Controls
	this.refineBox = document.createElement('div');
	this.refineBox.className = 'twk-tab-hide';
	this.refineBox.appendChild(this.rSelect);
	this.refineBox.appendChild(document.createElement('br'));
	// Coloured Background
	this.coloursBox = document.createElement('div');
	this.coloursBox.id = 'twk-psst-coloursbox';
	this.beforeBars1 = [];
	this.beforeBars2 = [];
	this.afterBars = [];
	for (var j=0; j<28; j++) {
		this.beforeBars1[j] = document.createElement('div');
		this.beforeBars1[j].className = 'twk-psst-colour-bars-s';
		this.coloursBox.appendChild(this.beforeBars1[j]);
	}
    this.coloursBox.appendChild(document.createElement('br'));
	for (var j=0; j<28; j++) {
		this.afterBars[j] = document.createElement('div');
		this.afterBars[j].className = 'twk-psst-colour-bars-l';
		this.coloursBox.appendChild(this.afterBars[j]);
	}
    this.coloursBox.appendChild(document.createElement('br'));
	for (var j=0; j<28; j++) {
		this.beforeBars2[j] = document.createElement('div');
		this.beforeBars2[j].className = 'twk-psst-colour-bars-s';
		this.coloursBox.appendChild(this.beforeBars2[j]);
	}
	this.refineBox.appendChild(this.coloursBox);
	// Array Of Sliders
	this.rSop = [];
	this.rLsBox = [];
	for (var j=0; j<5; j++) {
		this.rSop[j] = document.createElement('div');
		this.rLsBox[j] = document.createElement('div');
		for (var k=0; k<28; k++) {
			this.rSop[j].appendChild(this.rSs[j][k].element);
			this.rLsBox[j].appendChild(this.rLs[j][k]);
		}
		if (j === this.rSelect.selectedIndex) {
			this.rSop[j].className = 'twk-psst-spectrum';
			this.rLsBox[j].className = 'twk-tab';
			this.rR[j].className = 'small-button';
		} else {
			this.rSop[j].className = 'twk-psst-spectrum-hide';
			this.rLsBox[j].className = 'twk-tab-hide';
			this.rR[j].className = 'small-button-hide';
		}
		this.refineBox.appendChild(this.rSop[j]);
		this.refineBox.appendChild(this.rLsBox[j]);
		this.refineBox.appendChild(this.rR[j]);
	}
	// Scale Chroma / Luma options
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Scale Chroma')));
	this.advancedBox.appendChild(this.chromaScaleCheck);
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Scale Luma')));
	this.advancedBox.appendChild(this.lumaScaleCheck);
	// Build Box Hierarchy
	this.box.appendChild(this.baseBox);
	this.box.appendChild(this.refineBox);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Advanced Settings')));
	this.box.appendChild(this.advancedCheck);
	this.box.appendChild(this.advancedBox);
	this.holder.appendChild(this.box);
};
TWKPSSTCDL.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked && this.inputs.d[1].checked) {
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKPSSTCDL.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKPSSTCDL.prototype.getTFParams = function(params) {
	// No Relevant Parameters For This Tweak
};
TWKPSSTCDL.prototype.getCSParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doPSSTCDL = true;
		var c = new Float64Array(29);
		for (var j=0; j<29; j++) {
			c[j] = (this.vals[0][j]/7)%1;
		}
		out.c = c.buffer;
		out.sat = this.vals[1].buffer.slice(0);
		out.s = this.vals[2].buffer.slice(0);
		out.o = this.vals[3].buffer.slice(0);
		out.p = this.vals[4].buffer.slice(0);
		out.chromaScale = this.chromaScaleCheck.checked;
		out.lumaScale = this.lumaScaleCheck.checked;
	} else {
		out.doPSSTCDL = false;
	}
	params.twkPSSTCDL = out;
};
TWKPSSTCDL.prototype.setParams = function(params) {
	if (typeof params.twkPSSTCDL !== 'undefined') {
		this.toggleTweaks();
	}
};
TWKPSSTCDL.prototype.getSettings = function(data) {
	data.psstCDL = {
		doPSSTCDL: this.tweakCheck.checked,
		basic: this.basRef[0].checked,
		channel: this.channelSelect.options[this.channelSelect.selectedIndex].lastChild.nodeValue,
		control: this.rSelect.options[this.rSelect.selectedIndex].lastChild.nodeValue,
		colour: this.taToString(this.vals[0],7),
		colourLock: this.checksToString(this.rLs[0]),
		saturation: this.taToString(this.vals[1]),
		saturationLock: this.checksToString(this.rLs[1]),
		slope: this.taToString(this.vals[2]),
		slopeLock: this.checksToString(this.rLs[2]),
		offset: this.taToString(this.vals[3]),
		offsetLock: this.checksToString(this.rLs[3]),
		power: this.taToString(this.vals[4]),
		powerLock: this.checksToString(this.rLs[4]),
		scaleChroma: this.chromaScaleCheck.checked,
		scaleLuma: this.lumaScaleCheck.checked
	};
};
TWKPSSTCDL.prototype.setSettings = function(settings) {
	if (typeof settings.psstCDL !== 'undefined') {
		var data = settings.psstCDL;
		if (typeof data.doPSSTCDL === 'boolean') {
			this.tweakCheck.checked = data.doPSSTCDL;
			this.toggleTweak();
		}
		if (typeof data.basic === 'boolean') {
			this.basRef[0].checked = data.basic;
			this.basRef[1].checked = !data.basic;
			this.toggleBasRef();
		}
		if (typeof data.channel !== 'undefined') {
			var m = this.channelSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.channelSelect.options[j].lastChild.nodeValue === data.channel) {
					this.channelSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.control !== 'undefined') {
			var m = this.rSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.rSelect.options[j].lastChild.nodeValue === data.control) {
					this.rSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.colour !== 'undefined') {
			var m = this.vals[0].length;
			var colour = data.colour.split(',').map(Number);
			for (var j=0; j<m; j++) {
				this.vals[0][j] = colour[j]*7;
				if (j%4 === 0) {
					this.baseVals[0][parseInt(j/4)] = colour[j];
				}
				if (j === 0) {
					this.baseVals[0][7] = this.baseVals[0][0];
				}
			}
			for (var j=0; j<7; j++) {
				this.bS[0][j].setValue(this.baseVals[0][j]*7);
			}
		}
		if (typeof data.colourLock !== 'undefined') {
			var colourLock = data.colourLock.split(',').map(Number);
			for (var j=0; j<28; j++) {
				if (colourLock[j] === 1) {
					this.rLs[0][j] = true;
				} else {
					this.rLs[0][j] = false;
				}
			}
		}
		if (typeof data.saturation !== 'undefined') {
			var m = this.vals[1].length;
			var sat = data.saturation.split(',').map(Number);
			for (var j=0; j<m; j++) {
				this.vals[1][j] = sat[j];
				if (j%4 === 0) {
					var baseSat = parseInt(j/4);
					this.baseVals[1][baseSat] = sat[j];
				}
				if (j === 0) {
					this.baseVals[1][7] = sat[j];
				}
			}
			for (var j=0; j<7; j++) {
				this.bS[1][j].setValue(this.baseVals[1][j]);
			}
		}
		if (typeof data.saturationLock !== 'undefined') {
			var saturationLock = data.saturationLock.split(',').map(Number);
			for (var j=0; j<28; j++) {
				if (saturationLock[j] === 1) {
					this.rLs[1][j] = true;
				} else {
					this.rLs[1][j] = false;
				}
			}
		}
		if (typeof data.slope !== 'undefined') {
			var m = this.vals[2].length;
			var slope = data.slope.split(',').map(Number);
			for (var j=0; j<m; j++) {
				this.vals[2][j] = slope[j];
				if (j%4 === 0) {
					var baseSlope = parseInt(j/4);
					this.baseVals[2][baseSlope] = slope[j];
				}
				if (j === 0) {
					this.baseVals[2][7] = slope[j];
				}
			}
			for (var j=0; j<7; j++) {
				this.bS[2][j].setValue(this.baseVals[2][j]);
			}
		}
		if (typeof data.slopeLock !== 'undefined') {
			var slopeLock = data.slopeLock.split(',').map(Number);
			for (var j=0; j<28; j++) {
				if (slopeLock[j] === 1) {
					this.rLs[2][j] = true;
				} else {
					this.rLs[2][j] = false;
				}
			}
		}
		if (typeof data.offset !== 'undefined') {
			var m = this.vals[3].length;
			var offset = data.offset.split(',').map(Number);
			for (var j=0; j<m; j++) {
				this.vals[3][j] = offset[j];
				if (j%4 === 0) {
					var baseOffset = parseInt(j/4);
					this.baseVals[3][baseOffset] = offset[j];
				}
				if (j === 0) {
					this.baseVals[3][7] = offset[j];
				}
			}
			for (var j=0; j<7; j++) {
				this.bS[3][j].setValue(this.baseVals[3][j]);
			}
		}
		if (typeof data.offsetLock !== 'undefined') {
			var offsetLock = data.offsetLock.split(',').map(Number);
			for (var j=0; j<28; j++) {
				if (offsetLock[j] === 1) {
					this.rLs[3][j] = true;
				} else {
					this.rLs[3][j] = false;
				}
			}
		}
		if (typeof data.power !== 'undefined') {
			var m = this.vals[4].length;
			var power = data.power.split(',').map(Number);
			for (var j=0; j<m; j++) {
				this.vals[4][j] = power[j];
				if (j%4 === 0) {
					var basePower = parseInt(j/4);
					this.baseVals[4][basePower] = power[j];
				}
				if (j === 0) {
					this.baseVals[4][7] = power[j];
				}
			}
			for (var j=0; j<7; j++) {
				this.bS[4][j].setValue(this.baseVals[4][j]);
			}
		}
		if (typeof data.powerLock !== 'undefined') {
			var powerLock = data.powerLock.split(',').map(Number);
			for (var j=0; j<28; j++) {
				if (powerLock[j] === 1) {
					this.rLs[4][j] = true;
				} else {
					this.rLs[4][j] = false;
				}
			}
		}
		this.updateRef();
		if (typeof data.scaleChroma === 'boolean') {
			this.chromaScaleCheck.checked = data.scaleChroma;
		}
		if (typeof data.scaleLuma === 'boolean') {
			this.lumaScaleCheck.checked = data.scaleLuma;
		}
	}
};
TWKPSSTCDL.prototype.getInfo = function(info) {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doPSSTCDL = true;
	} else {
		info.doPSSTCDL = false;
	}
};
TWKPSSTCDL.prototype.isCustomGamma = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKPSSTCDL.prototype.isCustomGamut = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKPSSTCDL.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gtSetParams();
	};}(this);
	this.channelSelect.onchange = function(here){ return function(){
		here.changeChannel();
	};}(this);
	this.basRef[0].onchange = function(here){ return function(){
		here.toggleBasRef();
	};}(this);
	this.basRef[1].onchange = function(here){ return function(){
		here.toggleBasRef();
	};}(this);
	this.rSelect.onchange = function(here){ return function(){
		here.updateRef();
	};}(this);
	for (var k=0; k<5; k++) {
		for (var j=0; j<7; j++) {
			this.bS[k][j].action = function(i){ return function(){
				if (i[1] === 0) {
					i[0].baseVals[i[1]][i[2]] = i[0].bS[i[1]][i[2]].getValue()/7;
				} else {
					i[0].baseVals[i[1]][i[2]] = i[0].bS[i[1]][i[2]].getValue();
				}
				if (i[2] === 0) {
					i[0].baseVals[i[1]][7] = i[0].baseVals[i[1]][0];
				}
				i[0].updateR(i[1]);
				i[0].messages.gtSetParams();
			};}([this,k,j]);
			this.bS[k][j].resetAll = function(i){ return function(){
				for (var l=0; l<7; l++) {
					i[0].bS[i[1]][l].reset();
					if (i[1] === 0) {
						i[0].baseVals[i[1]][l] = i[0].bS[i[1]][l].getValue()/7;
					} else {
						i[0].baseVals[i[1]][l] = i[0].bS[i[1]][l].getValue();
					}
					if (l === 0) {
						i[0].baseVals[i[1]][7] = i[0].baseVals[i[1]][0];
					}
				}
				i[0].updateR(i[1]);
				i[0].messages.gtSetParams();
			};}([this,k]);
		}
		for (var j=0; j<28; j++) {
			this.rSs[k][j].action = function(i){ return function(){
				i[0].vals[i[1]][i[2]] = i[0].rSs[i[1]][i[2]].getValue();
				if (i[2]%4 === 0) {
					var l = Math.round(i[2]/4);
					i[0].bS[i[1]][l].setValue(i[0].vals[i[1]][i[2]]);
					if (i[1] === 0) {
						i[0].baseVals[i[1]][l] = i[0].vals[i[1]][i[2]]/7;
					} else {
						i[0].baseVals[i[1]][l] = i[0].vals[i[1]][i[2]];
					}
				} else {
					i[0].rLs[i[1]][i[2]].checked = true;
				}
				if (i[2] === 0) {
					i[0].vals[i[1]][28] = i[0].vals[i[1]][0];
					i[0].baseVals[i[1]][7] = i[0].baseVals[i[1]][0];
				}
				if (i[2]%4 === 0) {
					i[0].updateR(i[1]);
				}
				i[0].messages.gtSetParams();
			};}([this,k,j]);
			this.rLs[k][j].onclick = function(i){ return function(){
				if (!i[0].rLs[i[1]][i[2]].checked) {
					i[0].updateR(i[1]);
					i[0].messages.gtSetParams();
				}
			};}([this,k,j]);
		}
		this.rR[k].onclick = function(i){ return function(){
			for (var l=0; l<28; l++) {
				i[0].rSs[i[1]][l].reset();
				i[0].vals[i[1]][l] = i[0].rSs[i[1]][l].getValue();
				if (l%4 !== 0) {
					i[0].rLs[i[1]][l].checked = false;
				}
			}
			i[0].vals[i[1]][28] = i[0].vals[i[1]][0];
			for (var l=0; l<7; l++) {
				i[0].bS[i[1]][l].reset();
				if (i[1] === 0) {
					i[0].baseVals[i[1]][l] = i[0].bS[i[1]][l].getValue()/7;
				} else {
					i[0].baseVals[i[1]][l] = i[0].bS[i[1]][l].getValue();
				}
			}
			i[0].baseVals[i[1]][7] = i[0].baseVals[i[1]][0];
			i[0].messages.gtSetParams();
		};}([this,k]);
	}
	this.advancedCheck.onclick = function(here){ return function(){
		here.toggleAdvanced();
	};}(this);
	this.chromaScaleCheck.onclick = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.lumaScaleCheck.onclick = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
};
// Tweak-Specific Code
TWKPSSTCDL.prototype.psstColours = function(p) {
	var before = new Uint8Array(p.b);
	var after = new Uint8Array(p.a);
	for (var j=0; j<28; j++) {
		this.beforeBars1[j].style.backgroundColor = 'rgb(' + before[j*3] + ',' + before[(j*3)+1] + ',' + before[(j*3)+2]+')';
		this.afterBars[j].style.backgroundColor = 'rgb(' + after[j*3] + ',' + after[(j*3)+1] + ',' + after[(j*3)+2]+')';
		this.beforeBars2[j].style.backgroundColor = 'rgb(' + before[j*3] + ',' + before[(j*3)+1] + ',' + before[(j*3)+2]+')';
		if (j%4 === 0) {
			var k = parseInt(j/4);
			this.beforeBar1[k].style.backgroundColor = 'rgb(' + before[j*3] + ',' + before[(j*3)+1] + ',' + before[(j*3)+2]+')';
			this.afterBar[k].style.backgroundColor = 'rgb(' + after[j*3] + ',' + after[(j*3)+1] + ',' + after[(j*3)+2]+')';
			this.beforeBar2[k].style.backgroundColor = 'rgb(' + before[j*3] + ',' + before[(j*3)+1] + ',' + before[(j*3)+2]+')';
		}
	}
	this.toggleTweaks();
};
TWKPSSTCDL.prototype.createRadioElement = function(name, checked) {
    var radioInput;
    try {
        var radioHtml = '<input type="radio" name="' + name + '"';
        if ( checked ) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += '/>';
        radioInput = document.createElement(radioHtml);
    } catch( err ) {
        radioInput = document.createElement('input');
        radioInput.setAttribute('type', 'radio');
        radioInput.setAttribute('name', name);
        if ( checked ) {
            radioInput.setAttribute('checked', 'checked');
        }
    }
    return radioInput;
};
TWKPSSTCDL.prototype.initVals = function() {
	this.vals = [];
	this.baseRings = [];
	this.baseVals = [];
	for (var j=0; j<5; j++) {
		var valRow = new Float64Array(29);
		for (var k=0; k<29; k++) {
			if (j === 0 || j === 3) {
				valRow[k] = 0;
			} else {
				valRow[k] = 1;
			}
		}
		var baseRow = new Float64Array(8);
		for (var k=0; k<8; k++) {
			if (j === 0 || j === 3) {
				baseRow[k] = 0;
			} else {
				baseRow[k] = 1;
			}
		}
		this.vals[j] = valRow;
		this.baseVals[j] = baseRow;
		var ring = new Ring();
	  	ring.setDetails({
			title: '',
			L: baseRow.buffer,
			p: false
		});
		this.baseRings[j] = ring;
	}
};
TWKPSSTCDL.prototype.channelList = function() {
	var channels = [
		'Blue',
		'Magenta',
		'Red',
		'Skin',
		'Yellow',
		'Green',
		'Cyan'
	];
	var max = channels.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = j.toString();
		option.appendChild(document.createTextNode(channels[j]));
		if (channels[j] === 'Skin') {
			option.selected = true;
		}
		this.channelSelect.appendChild(option);
	}
};
TWKPSSTCDL.prototype.changeChannel = function() {
	var chan = this.channelSelect.selectedIndex;
	for (var j=0; j<7; j++) {
		if (j === chan) {
			this.cssop[j].className = 'twk-tab';
		} else {
			this.cssop[j].className = 'twk-tab-hide';
		}
	}
};
TWKPSSTCDL.prototype.refineList = function() {
	var controls = [
		'Colour Shift',
		'Saturation',
		'Slope',
		'Offset',
		'Power'
	];
	var max = controls.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = j.toString();
		option.appendChild(document.createTextNode(controls[j]));
		if (controls[j] === 'Saturation') {
			option.selected = true;
		}
		this.rSelect.appendChild(option);
	}
};
TWKPSSTCDL.prototype.toggleBasRef = function() {
	if (this.basRef[0].checked) {
		this.baseBox.className = 'twk-tab';
		this.refineBox.className = 'twk-tab-hide';
	} else {
		this.baseBox.className = 'twk-tab-hide';
		this.refineBox.className = 'twk-tab';
	}
	this.updateRef();
};
TWKPSSTCDL.prototype.updateR = function(control) {
	var vals = this.vals[control];
	var locks = this.rLs[control];
	var ring = this.baseRings[control];
	var rSs = this.rSs[control];
	for (var j=0; j<28; j++) {
		if (j%4 === 0 || !locks[j].checked) {
			vals[j] = ring.fCub(j/28);
			if ((control === 1 || control === 4) && vals[j] < 0) {
				vals[j] = 0;
			} else if (control === 0) {
				vals[j] *= 7;
			}
		}
		rSs[j].setValue(vals[j]);
	}
	vals[28] = ring.fCub(1);
	if ((control === 1 || control === 4) && vals[28] < 0) {
		vals[28] = 0;
	}
};
TWKPSSTCDL.prototype.updateRef = function() {
	var control = this.rSelect.selectedIndex;
	for (var j=0; j<5; j++) {
		if (j === control) {
			this.rSop[j].className = 'twk-psst-spectrum';
			this.rLsBox[j].className = 'twk-tab';
			this.rR[j].className = 'small-button';
		} else {
			this.rSop[j].className = 'twk-psst-spectrum-hide';
			this.rLsBox[j].className = 'twk-tab-hide';
			this.rR[j].className = 'small-button-hide';
		}
	}
	this.updateR(control);
};
TWKPSSTCDL.prototype.toggleAdvanced = function() {
	if (this.advancedCheck.checked) {
		this.advancedBox.className = 'twk-advanced';
	} else {
		this.advancedBox.className = 'twk-advanced-hide';
	}
};
TWKPSSTCDL.prototype.taToString = function(data,mul) {
	var out = [];
	var m = data.length;
	if (typeof mul === 'number') {
		for (var j=0; j<m; j++) {
			out[j] = data[j]/mul;
		}
	} else {
		for (var j=0; j<m; j++) {
			out[j] = data[j];
		}
	}
	return out.toString();
};
TWKPSSTCDL.prototype.checksToString = function(data) {
	var out = [];
	var m = data.length;
	for (var j=0; j<m; j++) {
		if (data[j].checked) {
			out[j] = 1;
		} else {
			out[j] = 0;
		}
	}
	return out.toString();
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-hg.js
* Highlight Gamut object for the LUTCalc Web App.
* 10th April 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKHG(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.p = 9;
	this.messages.addUI(this.p,this);
	this.io();
	this.ui();
	lutcalcReady(this.p);
}
TWKHG.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;

// Tweak - Specific Inputs
	// Highlight gamut selector
	this.gamutSelect = document.createElement('select');
	var max = this.inputs.gamutOutList.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = this.inputs.gamutOutList[j].idx;
		option.appendChild(document.createTextNode(this.inputs.gamutOutList[j].name));
		this.gamutSelect.appendChild(option);
	}
	this.inputs.addInput('twkHGSelect',this.gamutSelect);
	// Choice between linear (IRE) or log (stop) transition from base gamut to highlight gamut
	this.linOpt = this.createRadioElement('linLog',true);
	this.linOpt.value = '0';
	this.logOpt = this.createRadioElement('linLog',false);
	this.logOpt.value = '1';
	// Linear (IRE) inputs for the start and end of the transition
	this.linLow = document.createElement('input');
	this.linLow.setAttribute('type','number');
	this.linLow.setAttribute('step','any');
	this.linLow.className = 'ire-input';
	this.linLow.value = '18';
	this.linHigh = document.createElement('input');
	this.linHigh.setAttribute('type','number');
	this.linHigh.setAttribute('step','any');
	this.linHigh.className = 'ire-input';
	this.linHigh.value = '90';
	// Log (stop) inputs for the start and end of the transition
	this.logLow = document.createElement('input');
	this.logLow.setAttribute('type','number');
	this.logLow.setAttribute('step','any');
	this.logLow.className = 'stop-input';
	this.logLow.value = '0';
	this.logHigh = document.createElement('input');
	this.logHigh.setAttribute('type','number');
	this.logHigh.setAttribute('step','any');
	this.logHigh.className = 'stop-input';
	this.logHigh.value = (Math.log(5*parseFloat(this.linHigh.value)/90)/Math.LN2).toFixed(4).toString();
};
TWKHG.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('Highlight Gamut')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	// Tweak - Specific UI Elements

	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Gamut')));
	this.box.appendChild(this.gamutSelect);
	this.box.appendChild(document.createElement('br'));
	this.box.appendChild(this.linOpt);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Linear (% IRE)')));
	this.box.appendChild(this.logOpt);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Log (Stops)')));

	this.linBox = document.createElement('div');
	this.linBox.className = 'twk-tab';
	this.linBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Crossover Low % Reflected')));
	this.linBox.appendChild(document.createElement('br'));
	this.linBox.appendChild(this.linLow);
	this.linBox.appendChild(document.createElement('label').appendChild(document.createTextNode('%')));
	this.linBox.appendChild(document.createElement('br'));
	this.linBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Crossover High % Reflected')));
	this.linBox.appendChild(document.createElement('br'));
	this.linBox.appendChild(this.linHigh);
	this.linBox.appendChild(document.createElement('label').appendChild(document.createTextNode('%')));
	this.box.appendChild(this.linBox);

	this.logBox = document.createElement('div');
	this.logBox.className = 'twk-tab-hide';
	this.logBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Crossover Low Stops From 18% Grey')));
	this.logBox.appendChild(document.createElement('br'));
	this.logBox.appendChild(this.logLow);
	this.logBox.appendChild(document.createElement('br'));
	this.logBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Crossover High Stops From 18% Grey')));
	this.logBox.appendChild(document.createElement('br'));
	this.logBox.appendChild(this.logHigh);
	this.box.appendChild(this.logBox);

	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKHG.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked && this.inputs.d[1].checked) { // This checks for 'Customisations' to be checked and LUT type set to '3D' (the d[1] item)
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKHG.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKHG.prototype.getTFParams = function(params) {
	// No Relevant Parameters For This Tweak
};
TWKHG.prototype.getCSParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doHG = true;
		out.lin = this.linOpt.checked;
		out.gamut = parseInt(this.gamutSelect.options[this.gamutSelect.selectedIndex].value);
		out.low = parseFloat(this.logLow.value);
		out.high = parseFloat(this.logHigh.value);
	} else {
		out.doHG = false;
	}
	params.twkHG = out;
};
TWKHG.prototype.setParams = function(params) {
	if (typeof params.twkHG !== 'undefined') {
		var p = params.twkHG;
		this.toggleTweaks();
	}
	// Any changes to UI inputs coming from the gamma and gamut workers should go here
};
TWKHG.prototype.getSettings = function(data) {
	data.highlightGamut = {
		doHG: this.tweakCheck.checked,
		gamut: this.gamutSelect.options[this.gamutSelect.selectedIndex].lastChild.nodeValue,
		linear: this.linOpt.checked,
		low: parseFloat(this.logLow.value),
		high: parseFloat(this.logHigh.value)
	};
};
TWKHG.prototype.setSettings = function(settings) {
	if (typeof settings.highlightGamut !== 'undefined') {
		var data = settings.highlightGamut;
		if (typeof data.doHG === 'boolean') {
			this.tweakCheck.checked = data.doHG;
			this.toggleTweak();
		}
		if (typeof data.gamut !== 'undefined') {
			var m = this.gamutSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.gamutSelect.options[j].lastChild.nodeValue === data.gamut) {
					this.gamutSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.linear === 'boolean') {
			this.linOpt.checked = data.linear;
			this.logOpt.checked = !data.linear;
			this.toggleLinLog();
		}
		if (typeof data.low === 'number' && typeof data.high === 'number') {
			this.logLow.value = data.low.toString();
			this.logHigh.value = data.high.toString();
			this.testLogLow();
			this.testLogHigh();
		}
	}
};
TWKHG.prototype.getInfo = function(info) {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doHG = true;
	} else {
		info.doHG = false;
	}
	info.twkHGGamutName = this.gamutSelect.options[this.gamutSelect.selectedIndex].lastChild.nodeValue;
};
TWKHG.prototype.isCustomGamma = function() {
	return false;
};
TWKHG.prototype.isCustomGamut = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKHG.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gtSetParams();
	};}(this);
	this.gamutSelect.onchange = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.linOpt.onchange = function(here){ return function(){
		here.toggleLinLog();
		here.messages.gtSetParams();
	};}(this);
	this.logOpt.onchange = function(here){ return function(){
		here.toggleLinLog();
		here.messages.gtSetParams();
	};}(this);
	this.linLow.onchange = function(here){ return function(){
		here.testLinLow();
		here.messages.gtSetParams();
	};}(this);
	this.linHigh.onchange = function(here){ return function(){
		here.testLinHigh();
		here.messages.gtSetParams();
	};}(this);
	this.logLow.onchange = function(here){ return function(){
		here.testLogLow();
		here.messages.gtSetParams();
	};}(this);
	this.logHigh.onchange = function(here){ return function(){
		here.testLogHigh();
		here.messages.gtSetParams();
	};}(this);
};
// Tweak-Specific Code
TWKHG.prototype.createRadioElement = function(name, checked) {
    var radioInput;
    try {
        var radioHtml = '<input type="radio" name="' + name + '"';
        if ( checked ) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += '/>';
        radioInput = document.createElement(radioHtml);
    } catch( err ) {
        radioInput = document.createElement('input');
        radioInput.setAttribute('type', 'radio');
        radioInput.setAttribute('name', name);
        if ( checked ) {
            radioInput.setAttribute('checked', 'checked');
        }
    }
    return radioInput;
};
TWKHG.prototype.gamutList = function(gamuts) {
	max = gamuts.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = gamuts[j].idx;
		option.appendChild(document.createTextNode(gamuts[j].name));
		this.gamutSelect.appendChild(option);
	}
};
TWKHG.prototype.toggleLinLog = function() {
	if (this.linOpt.checked) {
		this.linBox.className = 'twk-tab';
		this.logBox.className = 'twk-tab-hide';
	} else {
		this.linBox.className = 'twk-tab-hide';
		this.logBox.className = 'twk-tab';
	}
};
TWKHG.prototype.testLinLow = function() {
	if (/^([1-9]\d*)$/.test(this.linLow.value)) {
		if (parseInt(this.linLow.value) >= parseInt(this.linHigh.value)) {
			this.linLow.value = (parseInt(this.linHigh.value) - 1).toString();
		}
		this.logLow.value = (Math.log(parseFloat(this.linLow.value)/18)/Math.LN2).toFixed(4).toString();
	} else {
		this.linLow.value = '18';
		this.logLow.value = '0';
		this.testLinLow();
	}
};
TWKHG.prototype.testLinHigh = function() {
	if (/^([1-9]\d*)$/.test(this.linHigh.value)) {
		if (parseInt(this.linHigh.value) <= parseInt(this.linLow.value)) {
			this.linHigh.value = (parseInt(this.linLow.value) + 1).toString();
		} else if (parseInt(this.linHigh.value) < 2){
			this.linHigh.value = '2';
		}
		this.logHigh.value = (Math.log(parseFloat(this.linHigh.value)/18)/Math.LN2).toFixed(4).toString();
	} else {
		this.linHigh.value = '90';
		this.logHigh.value = (Math.log(5)/Math.LN2).toFixed(4).toString();
		this.testLinHigh();
	}
};
TWKHG.prototype.testLogLow = function() {
	if (!isNaN(parseFloat(this.logLow.value)) && isFinite(this.logLow.value)) {
		if (parseFloat(this.logLow.value) >= parseFloat(this.logHigh.value)) {
			this.logLow.value = (parseFloat(this.logHigh.value) - 0.1).toFixed(4).toString();
		}
		this.linLow.value = (Math.round(Math.pow(2,parseFloat(this.logLow.value))*18)).toString();
	} else {
		this.linLow.value = '18';
		this.logLow.value = '0';
		this.testLogLow();
	}
};
TWKHG.prototype.testLogHigh = function() {
	if (!isNaN(parseFloat(this.logHigh.value)) && isFinite(this.logHigh.value)) {
		if (parseFloat(this.logHigh.value) <= parseFloat(this.logLow.value)) {
			this.logHigh.value = (parseFloat(this.logLow.value) + 0.1).toFixed(4).toString();
		}
		this.linHigh.value = (Math.round(Math.pow(2,parseFloat(this.logHigh.value))*18)).toString();
	} else {
		this.linHigh.value = '90';
		this.logHigh.value = (Math.log(5)/Math.LN2).toFixed(4).toString();
		this.testLogHigh();
	}
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-sat.js
* Variable Saturation (By Luminance) object for the LUTCalc Web App.
* 2nd October 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKMulti(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.p = 14;
	this.messages.addUI(this.p,this);
	this.io();
	this.ui();
	this.events();
}
TWKMulti.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;
	// Tweak - Specific Inputs
	// Stop-By-Stop Saturation Sliders
	this.sat = new Float64Array([
		1,1,1,1,1,1,1,1,
		1,
		1,1,1,1,1,1,1,1
	]);
	this.satS = [];
	for (var j=0; j<17; j++) {
		this.satS[j] = new lutSlider({
			min: 0,
			max: 2,
			value: 1,
			step: 0.01,
			style: 'slider-bare',
			v: true
		});
	}
	this.stopInput = document.createElement('input');
	this.stopInput.setAttribute('type','number');
	this.stopInput.setAttribute('step',1);
	this.stopInput.className = 'small-input';
	this.stopInput.value = 0;
	this.satInput = document.createElement('input');
	this.satInput.setAttribute('type','number');
	this.satInput.setAttribute('step','any');
	this.satInput.className = 'small-input';
	this.satInput.value = 1;
	this.monochrome = document.createElement('input');
	this.monochrome.setAttribute('type','button');
	this.monochrome.className = 'small-button';
	this.monochrome.setAttribute('value','Monochrome');
	this.satReset = document.createElement('input');
	this.satReset.setAttribute('type','button');
	this.satReset.className = 'small-button';
	this.satReset.setAttribute('value','Reset Saturation');
	// Colour Picker
	this.pRLabel = document.createElement('label');
	this.pRLabel.appendChild(document.createTextNode('128'));
	this.pGLabel = document.createElement('label');
	this.pGLabel.appendChild(document.createTextNode('128'));
	this.pBLabel = document.createElement('label');
	this.pBLabel.appendChild(document.createTextNode('128'));
	this.pCurIdxHS = new Uint8Array([0,127,0]);
	this.pIdx = 0;
	this.pHue = 127;
	this.pSat = 0;
	this.pColBox = document.createElement('div');
	this.pColBox.className = 'picker-colour';
	this.pOKButton = document.createElement('input');
	this.pOKButton.setAttribute('type','button');
	this.pOKButton.value = 'OK';
	this.pCancelButton = document.createElement('input');
	this.pCancelButton.setAttribute('type','button');
	this.pCancelButton.value = 'Cancel';
	this.tones = [];
	this.tIdx = 0;
};
TWKMulti.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('Multitone')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	// Tweak - Specific UI Elements
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Stop:')));
	this.box.appendChild(this.stopInput);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Saturation:')));
	this.box.appendChild(this.satInput);
	// Box for stop-by-stop slider background
	this.coloursBox = document.createElement('div');
	this.coloursBox.id = 'twk-multi-coloursbox';
	this.redBars = [];
	this.greenBars = [];
	this.blueBars = [];
	for (var j=0; j<17; j++) {
		this.redBars[j] = document.createElement('div');
		this.redBars[j].className = 'twk-multi-colour-bars-r';
		this.coloursBox.appendChild(this.redBars[j]);
	}
	for (var j=0; j<17; j++) {
		this.greenBars[j] = document.createElement('div');
		this.greenBars[j].className = 'twk-multi-colour-bars-g';
		this.coloursBox.appendChild(this.greenBars[j]);
	}
	for (var j=0; j<17; j++) {
		this.blueBars[j] = document.createElement('div');
		this.blueBars[j].className = 'twk-multi-colour-bars-b';
		this.coloursBox.appendChild(this.blueBars[j]);
	}
	this.box.appendChild(this.coloursBox);
	// Array Of Sliders
	this.satSs = document.createElement('div');
	this.satSs.className = 'twk-multi-sliders';
	for (var j=0; j<17; j++) {
		var sliderBox = document.createElement('div');
		sliderBox.className = 'twk-multi-sliderbox';
		sliderBox.appendChild(this.satS[j].element);
		this.satSs.appendChild(sliderBox);
	}
	this.box.appendChild(this.satSs);
	for (var j=0; j<17; j++) {
		var stopLabel = document.createElement('label');
		stopLabel.appendChild(document.createTextNode(j-8));
		stopLabel.className = 'twk-multi-stop';
		this.box.appendChild(stopLabel);
	}
	this.box.appendChild(document.createElement('br'));
	this.box.appendChild(this.monochrome);
	this.box.appendChild(this.satReset);
	// Build Box Hierarchy
	this.holder.appendChild(this.box);

	this.buildPicker();
	this.addTone(0);
};
TWKMulti.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked && this.inputs.d[1].checked) { // This checks for 'Customisations' to be checked and LUT type set to '3D' (the d[1] item)
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKMulti.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKMulti.prototype.getTFParams = function(params) {
	// No parameters are relevent
};
TWKMulti.prototype.getCSParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doMulti = true;
		out.sat = this.sat.buffer.slice(0);
		var m = this.tones.length;
		var pStop = new Float64Array(m);
		for (var j=0; j<m; j++) {
			pStop[j] = this.tones[j].stop.getValue();
		}
		var hs = this.getHueSats();
		out.pHue = hs.hues.buffer;
		out.pSat = hs.sats.buffer;
		out.pStop = pStop.buffer;
	} else {
		out.doMulti = false;
	}
	params.twkMulti = out;
};
TWKMulti.prototype.setParams = function(params) {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		this.messages.gtTx(this.p,9,this.getHueSats());
	}
	if (typeof params.twkMulti !== 'undefined') {
		var p = params.twkMulti;
		this.toggleTweaks();
	}
	// Any changes to UI inputs coming from the gamma and gamut workers should go here
};
TWKMulti.prototype.getSettings = function(data) {
	var hs = this.getHueSats();
	var m = this.tones.length;
	var stops = new Float64Array(m);
	for (var j=0; j<m; j++) {
		stops[j] = this.tones[j].stop.getValue();
	}
	data.multiTone = {
		doMulti: this.tweakCheck.checked,
		minStop: -8,
		maxStop: 8,
		saturation: this.taToString(this.sat),
		monoHue: this.taToString(hs.hues),
		monoSat: this.taToString(hs.sats),
		monoStop: this.taToString(stops)		
	};
};
TWKMulti.prototype.setSettings = function(settings) {
	if (typeof settings.multiTone !== 'undefined') {
		var data = settings.multiTone;
		if (typeof data.doMulti === 'boolean') {
			this.tweakCheck.checked = data.doMulti;
			this.toggleTweak();
		}
		if (typeof data.saturation !== 'undefined') {
			this.sat = new Float64Array(data.saturation.split(',').map(Number));
		}
		if (typeof data.monoHue !== 'undefined' && typeof data.monoSat !== 'undefined' && typeof data.monoStop !== 'undefined') {
			var monoHue = new Uint8Array(data.monoHue.split(',').map(Number));
			var monoSat = new Uint8Array(data.monoSat.split(',').map(Number));
			var monoStop = new Float64Array(data.monoHue.split(',').map(Number));
			var m = this.tones.length;
			if (m > 1) {
				for (var j=1; j<m; j++) {
					this.tones[1].box.parentNode.removeChild(this.tones[1].box);
					this.tones.splice(1,1);
				}
			}
			m = monoStop.length;
			for (var j=0; j<m; j++) {
				if (j>0) {
					this.addTone(j);
				} else {
					this.pHue = monoHue[j];
				}
				this.tones[j].hue.setValue(parseInt(monoHue[j]));
				this.tones[j].sat.setValue(parseFloat((parseFloat(monoSat[j])/255).toFixed(3)));
				this.tones[j].stop.setValue(parseFloat(monoStop[j]));
			}
		}
	}
};
TWKMulti.prototype.getInfo = function(info) {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doMulti = true;
	} else {
		info.doMulti = false;
	}
};
TWKMulti.prototype.isCustomGamma = function() {
	return false;
};
TWKMulti.prototype.isCustomGamut = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKMulti.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gtSetParams();
	};}(this);
	this.stopInput.onchange = function(here){ return function(){
		var val = parseInt(this.stopInput.value);
		if (isNaN(val)) {
			here.stopInput.value = 0;
			here.satInput.value = here.satS[8].getValue();
		} else {
			val = Math.max(-8,Math.min(8,val));
			here.stopInput.value = val.toString();
			here.satInput.value = here.satS[val+8].getValue();
		}
		here.messages.gtSetParams();
	};}(this);
	this.satInput.onchange = function(here){ return function(){
		var val = parseFloat(here.satInput.value);
		if (isNaN(val)) {
			here.satInput.value = parseFloat(this.satS[parseInt(here.stopInput.value)+8].getValue());
		} else {
			var i = parseInt(here.stopInput.value)+8;
			val = Math.max(0,Math.min(2,val));
			here.satInput.value = val.toString();
			here.satS[i].setValue(val);
			here.sat[i] = val;
		}
		here.messages.gtSetParams();
	};}(this);
	for (var j=0; j<17; j++) {
		this.satS[j].action = function(i){ return function(){
			var val = i[0].satS[i[1]].getValue();
			if (i[0].sat[i[1]] !== val) {
				i[0].sat[i[1]] = val;
				i[0].stopInput.value = i[1]-8;
				i[0].satInput.value = val;		
				i[0].messages.gtSetParams();
			}
		};}([this,j]);
	}
	this.monochrome.onclick = function(here){ return function(){
		for (var j=0; j<17; j++) {
			here.satS[j].setValue(0);
			here.sat[j] = 0;
		}
		here.stopInput.value = 0;
		here.satInput.value = 0;
		here.messages.gtSetParams();
	};}(this);
	this.satReset.onclick = function(here){ return function(){
		for (var j=0; j<17; j++) {
			here.satS[j].setValue(1);
			here.sat[j] = 1;
		}
		here.stopInput.value = 0;
		here.satInput.value = 1;
		here.messages.gtSetParams();
	};}(this);
	this.pCan.onclick = function(here){ return function(e){
		here.updatePicker(e.clientX, e.clientY);
	};}(this);
	this.pOKButton.onclick = function(here){ return function(e){
		here.updateTone();
		modalBox.className = 'modalbox-hide';
		here.pickerHolder.className = 'colourpicker-hide';
	};}(this);
	this.pCancelButton.onclick = function(here){ return function(e){
		modalBox.className = 'modalbox-hide';
		here.pickerHolder.className = 'colourpicker-hide';
	};}(this);
};
// Tweak-Specific Code
TWKMulti.prototype.addTone = function(idx) {
	var toneBox = document.createElement('div');
	toneBox.className = 'twk-multi-tone';
	var pmBox = document.createElement('div');
	pmBox.className = 'twk-multi-pmbox';
	var plus = document.createElement('input');
	plus.setAttribute('type','button');
	plus.className= 'twk-multi-plus';
	plus.value = '+';
	pmBox.appendChild(plus);
	var minus = document.createElement('input');
	minus.setAttribute('type','button');
	minus.className= 'twk-multi-minus';
	minus.value='-';
	pmBox.appendChild(minus);
	toneBox.appendChild(pmBox);
	var toneColour = document.createElement('div');
	toneColour.className = 'picker-colour-small';
	toneBox.appendChild(toneColour);
	var toneRight = document.createElement('div');
	toneRight.className = 'twk-multi-tab';
	var hueS = new lutSlider({
		min: 0,
		max: 255,
		value: 127,
		step: 1,
		title: 'Hue',
		style: 'slider-slim',
		minLabel: false,
		maxLabel: false,
		input: 'label',
		inputLim: false,
		reset: false
	});
	var satS = new lutSlider({
		min: 0,
		max: 1,
		value: 0,
		step: 0.001,
		title: 'Saturation',
		style: 'slider-slim',
		minLabel: false,
		maxLabel: false,
		input: 'label',
		inputLim: false,
		reset: false
	});
	var stopS = new lutSlider({
		min: -8,
		max: 8,
		value: 0,
		step: 0.01,
		title: 'Stop',
		style: 'slider-slim',
		minLabel: false,
		maxLabel: false,
		input: 'label',
		inputLim: false,
		reset: false
	});
	if (this.tones.length === 1 || (this.tones.length > 1 && idx >= this.tones.length)) {
		var m1 = this.tones[idx-1].stop.getValue();
		if (m1 >= 8) {
			if (idx - 1 === 0) {
				this.tones[idx-1].stop.setValue(0);
			} else {
				var m2 = this.tones[idx-2].stop.getValue();
				this.tones[idx-1].stop.setValue(parseFloat(((m2+8)/2).toFixed(3)));
			}
			stopS.setValue(8);
		} else {
			stopS.setValue(((m1+8)/2).toFixed(3));
		}
	} else if (this.tones.length > 1) {
		var m1 = this.tones[idx-1].stop.getValue();
		var p1 = this.tones[idx].stop.getValue();
		stopS.setValue(parseFloat(((m1+p1)/2).toFixed(3)));
	} else {
		stopS.setValue(0);
	}
	toneRight.appendChild(hueS.element);
	toneRight.appendChild(satS.element);
	toneRight.appendChild(stopS.element);
	toneBox.appendChild(toneRight);
	toneBox.appendChild(toneRight);
	if (this.tones.length === 0 || idx >= this.tones.length) {
		this.box.appendChild(toneBox);
	} else {
		this.tones[idx].box.parentNode.insertBefore(toneBox,this.tones[idx].box);
	}
	var object = {
		idx: this.tIdx,
		colBox: toneColour,
		hue: hueS,
		sat: satS,
		stop: stopS,
		box: toneBox
	};
	if (idx === 0) {
		this.tones[0] = object;
	} else if (idx >= this.tones.length) {
		this.tones.push(object);
	} else {
		this.tones.splice(idx,0,object);
	}
	// Events
	plus.onclick = function(i){ return function(){
		var idx = i[0].getIdx(i[1]);
		i[0].addTone(idx+1);
		i[0].messages.gtSetParams();
	};}([this,this.tIdx]);
	minus.onclick = function(i){ return function(){
		if (i[0].tones.length > 1) {
			var idx = i[0].getIdx(i[1]);
			i[0].tones[idx].box.parentNode.removeChild(i[0].tones[idx].box);
			i[0].tones.splice(idx,1);
			i[0].messages.gtSetParams();
		}
	};}([this,this.tIdx]);
	toneColour.onclick = function(i){ return function(){
		i[0].messages.gtTx(i[0].p,8,{tIdx: i[1]});
	};}([this,this.tIdx]);
	hueS.action = function(here){ return function(){
		here.pHue = this.getValue();
		here.messages.gtSetParams();
	};}(this);
	satS.action = function(here){ return function(){
		here.pSat = this.getValue();
		here.messages.gtSetParams();
	};}(this);
	stopS.action = function(i){ return function(){
		i[0].pStop = this.getValue();
		var idx = i[0].getIdx(i[1]);
		if (idx > 0) {
			i[0].shuffleDown(idx-1, i[0].pStop);
		}
		if (idx < i[0].tones.length-1) {
			i[0].shuffleUp(idx+1, i[0].pStop);
		}
		i[0].messages.gtSetParams();
	};}([this,this.tIdx]);
	this.tIdx++;
};
TWKMulti.prototype.shuffleDown = function(idx, val) {
	var tone = this.tones[idx];
	var old = tone.stop.getValue();
	if (old >= val) {
		val = parseFloat((val - 0.001).toFixed(3));
		tone.stop.setValue(val);
//		tone.stopValue.removeChild(tone.stopValue.firstChild);
//		tone.stopValue.appendChild(document.createTextNode(val.toString()));
		if (idx > 0) {
			this.shuffleDown(idx-1, val);
		}
	}
};
TWKMulti.prototype.shuffleUp = function(idx, val) {
	var tone = this.tones[idx];
	var old = tone.stop.getValue();
	if (old <= val) {
		val = parseFloat((val + 0.001).toFixed(3));
		tone.stop.setValue(val);
//		tone.stopValue.removeChild(tone.stopValue.firstChild);
//		tone.stopValue.appendChild(document.createTextNode((val).toString()));
		if (idx < this.tones.length-1) {
			this.shuffleUp(idx+1, val);
		}
	}
};
TWKMulti.prototype.updateTone = function() {
	var tone = this.tones[this.pIdx];
	var d = this.pCtx.getImageData(this.pHue,Math.round((1-this.pSat)*255),1,1);
	tone.colBox.style.backgroundColor = 'rgb('+d.data[0]+','+d.data[1]+','+d.data[2]+')';
	tone.hue.setValue(this.pHue);
	tone.sat.setValue(this.pSat);
	this.messages.gtSetParams();
};
TWKMulti.prototype.getIdx = function(tIdx) {
	var m = this.tones.length;
	for (var j=0; j<m; j++) {
		if (this.tones[j].idx === tIdx) {
			return j;
		}
	}
};
TWKMulti.prototype.gotColSqr = function(colSqr,tIdx) {
	this.pIdx = this.getIdx(tIdx);
	this.pHue = Math.round((this.tones[this.pIdx].hue.getValue()));
	this.pSat = this.tones[this.pIdx].sat.getValue();
	var c = new Uint8Array(colSqr);
	this.pData.data.set(c);
	this.pCtx.putImageData(this.pData,0,0);
	modalBox.className = 'modalbox';
	this.pickerHolder.className = 'colourpicker';
	var d = this.pCtx.getImageData(this.pHue,255-Math.round(this.pSat*255),1,1);
	this.pRLabel.removeChild(this.pRLabel.firstChild);
	this.pRLabel.appendChild(document.createTextNode(d.data[0]));
	this.pGLabel.removeChild(this.pGLabel.firstChild);
	this.pGLabel.appendChild(document.createTextNode(d.data[1]));
	this.pBLabel.removeChild(this.pBLabel.firstChild);
	this.pBLabel.appendChild(document.createTextNode(d.data[2]));
	this.pColBox.style.backgroundColor = 'rgb('+d.data[0]+','+d.data[1]+','+d.data[2]+')';
}
TWKMulti.prototype.getHueSats = function() {
	var m = this.tones.length;
	var h = new Uint8Array(m);
	var s = new Uint8Array(m);
	for (var j=0; j<m; j++) {
		h[j] = Math.round(this.tones[j].hue.getValue());
		s[j] = Math.round(this.tones[j].sat.getValue() * 255);
	}
	return { hues: h, sats: s };
};
TWKMulti.prototype.updatePicker = function(cx,cy) {
	var rect = this.pCan.getBoundingClientRect();
	var x =Math.round(255*(cx - rect.left)/rect.width);
	var y = Math.round(255*(cy - rect.top)/rect.height);
	this.pHue=x;
	this.pSat=parseFloat((1-((cy - rect.top)/rect.height)).toFixed(3));
	var d = this.pCtx.getImageData(x,y,1,1);
	this.pRLabel.removeChild(this.pRLabel.firstChild);
	this.pRLabel.appendChild(document.createTextNode(d.data[0]));
	this.pGLabel.removeChild(this.pGLabel.firstChild);
	this.pGLabel.appendChild(document.createTextNode(d.data[1]));
	this.pBLabel.removeChild(this.pBLabel.firstChild);
	this.pBLabel.appendChild(document.createTextNode(d.data[2]));
	this.pColBox.style.backgroundColor = 'rgb('+d.data[0]+','+d.data[1]+','+d.data[2]+')';
};
TWKMulti.prototype.buildPicker = function() {
	this.pickerHolder = document.createElement('div');
	this.pickerHolder.className = 'colourpicker-hide';
	this.pickerBox = document.createElement('div');
	this.pickerBox.className = 'popup';
	this.pCan = document.createElement('canvas');
	this.pCan.className = 'picker-can';
	this.pCan.width = '256';
	this.pCan.height = '256';
	this.pCtx = this.pCan.getContext('2d');
	this.pData = this.pCtx.createImageData(256,256);
	this.pickerBox.appendChild(this.pCan);
	var infoBox = document.createElement('div');
	infoBox.className = 'picker-info';
	infoBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Red:')));
	infoBox.appendChild(document.createElement('br'));
	infoBox.appendChild(this.pRLabel);
	infoBox.appendChild(document.createElement('br'));
	infoBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Green:')));
	infoBox.appendChild(document.createElement('br'));
	infoBox.appendChild(this.pGLabel);
	infoBox.appendChild(document.createElement('br'));
	infoBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Blue:')));
	infoBox.appendChild(document.createElement('br'));
	infoBox.appendChild(this.pBLabel);
	infoBox.appendChild(document.createElement('br'));
	infoBox.appendChild(this.pColBox);
	this.pickerBox.appendChild(infoBox);
	this.pickerBox.appendChild(document.createElement('br'));
	this.pickerBox.appendChild(this.pOKButton);
	this.pickerBox.appendChild(this.pCancelButton);
	this.pickerHolder.appendChild(this.pickerBox);
//	document.getElementById('body').appendChild(this.pickerHolder);
	modalBox.appendChild(this.pickerHolder);
};
TWKMulti.prototype.multiColours = function(p) {
	var o = new Uint8Array(p.o);
	var hs = new Uint8Array(p.hs);
	for (var j=0; j<17; j++) {
		this.redBars[j].style.backgroundColor = 'rgb(' + o[j*3] + ',' + o[(j*3)+1] + ',' + o[(j*3)+2]+')';
		this.greenBars[j].style.backgroundColor = 'rgb(' + o[((j+17)*3)] + ',' + o[((j+17)*3)+1] + ',' + o[((j+17)*3)+2]+')';
		this.blueBars[j].style.backgroundColor = 'rgb(' + o[((j+34)*3)] + ',' + o[((j+34)*3)+1] + ',' + o[((j+34)*3)+2]+')';
	}
	var m = this.tones.length;
	for (var j=0; j<m; j++) {
		this.tones[j].colBox.style.backgroundColor = 'rgb(' + hs[j*3] + ',' + hs[(j*3)+1] + ',' + hs[(j*3)+2]+')';
	}
	this.toggleTweaks();
};
TWKMulti.prototype.taToString = function(data) {
	var out = [];
	var m = data.length;
	for (var j=0; j<m; j++) {
		out[j] = data[j];
	}
	return out.toString();
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-knee.js
* User definable knee generating object for LUTCalc
* 20th September 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKKnee(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.io();
	this.ui();
	this.events();
}
TWKKnee.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;
	// Clip to Legal or Extended
	this.legOpt = this.createRadioElement('legExt',true);
	this.legOpt.value = '0';
	this.extOpt = this.createRadioElement('legExt',false);
	this.extOpt.value = '1';
	// Max Start value
	this.max = 8;
	// Sliders
	this.startS = new lutSlider({
		min: -5,
		max: this.max,
		value: 0.05,
		step: 0.05,
		title: 'Knee Start Level',
		minLabel: false,
		maxLabel: false,
		input: 'number',
		lhs: '18% Gray +',
		rhs: 'Stops',
		reset: true
	});
	this.clipS = new lutSlider({
		min: 0.05,
		max: 8,
		value: 6,
		step: 0.05,
		title: 'Clip Level',
		minLabel: false,
		maxLabel: false,
		input: 'number',
		lhs: '18% Gray +',
		rhs: 'Stops',
		reset: true
	});
	this.slopeS = new lutSlider({
		min: 0,
		max: 2.5,
		value: 0.25,
		step: 0.01,
		title: 'Slope At Clip',
		minLabel: false,
		maxLabel: false,
		input: 'number',
		reset: true
	});
	this.smoothS = new lutSlider({
		min: 0,
		max: 1,
		value: 1,
		step: 0.01,
		title: 'Smoothness',
		minLabel: false,
		maxLabel: false,
		input: 'number',
		reset: true
	});
};
TWKKnee.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('Knee')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	// Tweak - Specific UI Elements
	// Legal Range / Extended Range
	this.box.appendChild(this.legOpt);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Legal Range')));
	this.box.appendChild(this.extOpt);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Extended Range')));
	// Sliders
	this.box.appendChild(this.startS.element);
	this.box.appendChild(this.clipS.element);
	this.box.appendChild(this.slopeS.element);
	this.box.appendChild(this.smoothS.element);
	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKKnee.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked) {
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKKnee.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKKnee.prototype.getTFParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doKnee = true;
	} else {
		out.doKnee = false;
	}
	if (this.legOpt.checked) {
		out.legal = true;
	} else {
		out.legal = false;
	}
	out.kneeStart = this.startS.getValue();
	out.kneeClip = this.clipS.getValue();
	out.clipSlope = this.slopeS.getValue();
	out.smoothness = this.smoothS.getValue();
	params.twkKnee = out;
};
TWKKnee.prototype.getCSParams = function(params) {
	// Leave function content blank if not parameters are relevent
};
TWKKnee.prototype.setParams = function(params) {
	if (typeof params.twkKnee !== 'undefined') {
		var p = params.twkKnee;
		if (typeof p.max === 'number') {
			this.startS.setMax(p.max.toFixed(2));
		}
		if (typeof p.kneeStart === 'number') {
			this.startS.setValue(p.kneeStart);
		}
		this.toggleTweaks();
	}
	// Any changes to UI inputs coming from the gamma and gamut workers should go here
};
TWKKnee.prototype.getSettings = function(data) {
	data.knee = {
		doKnee: this.tweakCheck.checked,
		legal: this.legOpt.checked,
		kneeStart: this.startS.getValue(),
		kneeClip: this.clipS.getValue(),
		clipSlope: this.slopeS.getValue(),
		smoothness: this.smoothS.getValue(),
		max: this.max
	};
};
TWKKnee.prototype.setSettings = function(settings) {
	if (typeof settings.knee !== 'undefined') {
		var data = settings.knee;
        if (typeof data.doKnee === 'boolean') {
            this.tweakCheck.checked = data.doKnee;
            this.toggleTweak();
        }
		if (typeof data.legal === 'boolean') {
			this.legOpt.checked = data.legal;
			this.extOpt.checked = !data.legal;
		}
		if (typeof data.kneeStart === 'number') {
			this.startS.setValue(data.kneeStart);
		}
		if (typeof data.kneeClip === 'number') {
			this.clipS.setValue(data.kneeClip);
		}
		if (typeof data.clipSlope === 'number') {
			this.slopeS.setValue(data.clipSlope);
		}
		if (typeof data.smoothness === 'number') {
			this.smoothS.setValue(data.smoothness);
		}
		if (typeof data.max === 'number') {
			this.startS.setMax(data.max.toFixed(2));
		}
	}
};
TWKKnee.prototype.getInfo = function(info) {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doKnee = true;
	} else {
		info.doKnee = false;
	}
};
TWKKnee.prototype.isCustomGamma = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKKnee.prototype.isCustomGamut = function() {
	return false;
};
TWKKnee.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gaSetParams();
	};}(this);
	this.legOpt.onchange = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.extOpt.onchange = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.startS.action = function(here){ return function(){
		var clip = here.clipS.getValue();
		var start = this.getValue();
		if (start >= clip) {
			here.clipS.setValue(start + 0.05);
		}
		here.messages.gaSetParams();
	};}(this);
	this.clipS.action = function(here){ return function(){
		var clip = this.getValue();
		var start = here.startS.getValue();
		if (start >= clip) {
			here.startS.setValue(start - 0.05);
		}
		here.messages.gaSetParams();
	};}(this);
	this.slopeS.action = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.smoothS.action = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
};
// Tweak-Specific Code
TWKKnee.prototype.createRadioElement = function(name, checked) {
    var radioInput;
    try {
        var radioHtml = '<input type="radio" name="' + name + '"';
        if ( checked ) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += '/>';
        radioInput = document.createElement(radioHtml);
    } catch( err ) {
        radioInput = document.createElement('input');
        radioInput.setAttribute('type', 'radio');
        radioInput.setAttribute('name', name);
        if ( checked ) {
            radioInput.setAttribute('checked', 'checked');
        }
    }
    return radioInput;
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-blkhi.js
* Black level and highlight level adjustment object for the LUTCalc Web App.
* 6th September 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKBlkHi(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.io();
	this.ui();
}
TWKBlkHi.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;

	// Black Level Adjustment Checkbox
	this.blackLevelCheck = document.createElement('input');
	this.blackLevelCheck.setAttribute('type','checkbox');
	this.blackLevelCheck.className = 'twk-checkbox';
	this.blackLevelCheck.checked = false;
	// Black Level In % IRE
	this.blackLevelInput = document.createElement('input');
	this.blackLevelInput.setAttribute('type','number');
	this.blackLevelInput.setAttribute('step','any');
	this.blackLevelInput.className = 'ire-input';
	// Black Level Value Lock
	this.blackLevelLock = document.createElement('input');
	this.blackLevelLock.setAttribute('type','checkbox');
	this.blackLevelLock.className = 'twk-checkbox';
	this.blackLevelLock.checked = false;

	// Highlight Level Adjustment Checkbox
	this.highLevelCheck = document.createElement('input');
	this.highLevelCheck.setAttribute('type','checkbox');
	this.highLevelCheck.className = 'twk-checkbox';
	this.highLevelCheck.checked = false;
	// Highlight Reflectance Level In % Reflectance
	this.highLevelRef = document.createElement('input');
	this.highLevelRef.setAttribute('type','number');
	this.highLevelRef.setAttribute('step','any');
	this.highLevelRef.className = 'ire-input';
	this.highLevelRef.value='90';
	// Highlight Reflectance Maps To In Rec709 % IRE - Info Only
	this.highLevelRec = document.createElement('span');
	// Highlight Reflectance Maps To In % IRE
	this.highLevelMap = document.createElement('input');
	this.highLevelMap.setAttribute('type','number');
	this.highLevelMap.setAttribute('step','any');
	this.highLevelMap.className = 'ire-input';
	// Highlight Level Lock
	this.highLevelLock = document.createElement('input');
	this.highLevelLock.setAttribute('type','checkbox');
	this.highLevelLock.className = 'twk-checkbox';
	this.highLevelLock.checked = false;
};
TWKBlkHi.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('Black Level / Highlight Level')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	this.holder.appendChild(this.box);

// Tweak - Specific UI Elements
	// Black Level
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Black Level')));
	this.box.appendChild(this.blackLevelCheck);
	this.blackLevelBox = document.createElement('div');
	this.blackLevelBox.className = 'twk-tab-hide';
	this.blackLevelBox.appendChild(this.blackLevelInput);
	this.blackLevelBox.appendChild(document.createElement('label').appendChild(document.createTextNode('% IRE')));
	this.blackLevelBox.appendChild(document.createElement('br'));
	this.blackLevelBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Lock Value')));
	this.blackLevelBox.appendChild(this.blackLevelLock);
	this.box.appendChild(this.blackLevelBox);
	this.separator = document.createElement('div');
	this.separator.className = 'twk-tab';
	this.box.appendChild(this.separator);
	// Highlight Level
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Highlight Level')));
	this.box.appendChild(this.highLevelCheck);
	this.highLevelBox = document.createElement('div');
	this.highLevelBox.className = 'twk-tab-hide';
	this.highLevelBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Reflected')));
	this.highLevelBox.appendChild(this.highLevelRef);
	this.highLevelBox.appendChild(document.createElement('label').appendChild(document.createTextNode('%')));
	this.highLevelBox.appendChild(document.createElement('br'));
	this.highLevelBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Maps To (')));
	this.highLevelBox.appendChild(this.highLevelRec);
	this.highLevelBox.appendChild(document.createElement('label').appendChild(document.createTextNode('% IRE In Rec709)')));
	this.highLevelBox.appendChild(document.createElement('br'));
	this.highLevelBox.appendChild(this.highLevelMap);
	this.highLevelBox.appendChild(document.createElement('label').appendChild(document.createTextNode('% IRE')));
	this.highLevelBox.appendChild(document.createElement('br'));
	this.highLevelBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Lock Value')));
	this.highLevelBox.appendChild(this.highLevelLock);
	this.box.appendChild(this.highLevelBox);
};
TWKBlkHi.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked) {
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKBlkHi.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKBlkHi.prototype.getTFParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doBlkHi = true;
	} else {
		out.doBlkHi = false;
	}
	if (tweaks && tweak && this.blackLevelCheck.checked) {
		out.doBlack = true;
	} else {
		out.doBlack = false;
	}
	if (tweaks && tweak && this.highLevelCheck.checked) {
		out.doHigh = true;
	} else {
		out.doHigh = false;
	}
	var blackLevel = parseFloat(this.blackLevelInput.value);
	if (!isNaN(blackLevel)) {
		out.blackLevel = blackLevel/100;
	}
	var highRef = parseFloat(this.highLevelRef.value);
	if (!isNaN(highRef)) {
		out.highRef = highRef/100;
	}
	var highMap = parseFloat(this.highLevelMap.value);
	if (!isNaN(highMap)) {
		out.highMap = highMap/100;
	}
	out.blackLock = this.blackLevelLock.checked;
	out.highLock = this.highLevelLock.checked;
	params.twkBlkHi = out;
};
TWKBlkHi.prototype.getCSParams = function(params) {
	// No Relevant Parameters For This Tweak
};
TWKBlkHi.prototype.setParams = function(params) {
	if (typeof params.twkBlkHi !== 'undefined') {
		var p = params.twkBlkHi;
		this.blackDefault = (p.blackDef*100).toFixed(2).toString();
		this.highDefault = (p.highDef*100).toFixed(2).toString();
		if (typeof params.changedGamma === 'boolean' && params.changedGamma) {
			if (this.blackLevelLock.checked) {
				this.blackLevelInput.value = (p.blackLevel*100).toFixed(2).toString();
			} else {
				this.blackLevelInput.value = (p.blackDef*100).toFixed(2).toString();
			}
			if (this.highLevelLock.checked) {
				this.highLevelRef.value = (p.highRef*100).toFixed(2).toString();
				this.highLevelMap.value = (p.highMap*100).toFixed(2).toString();
				this.highLevelRec.innerHTML = (p.high709*100).toFixed(2).toString();
			} else {
				this.highLevelRef.value = (p.highRef*100).toFixed(2).toString();
				this.highLevelMap.value = (p.highDef*100).toFixed(2).toString();
				this.highLevelRec.innerHTML = (p.high709*100).toFixed(2).toString();
			}
		} else {
			this.blackLevelInput.value = (p.blackLevel*100).toFixed(2).toString();
			this.highLevelRef.value = (p.highRef*100).toFixed(2).toString();
			this.highLevelMap.value = (p.highMap*100).toFixed(2).toString();
			this.highLevelRec.innerHTML = (p.high709*100).toFixed(2).toString();
		}
		this.toggleTweaks();
	}
};
TWKBlkHi.prototype.getSettings = function(data) {
	data.blackHighlight = {
		doBH: this.tweakCheck.checked,
		doBlack: this.blackLevelCheck.checked,
		doHigh: this.highLevelCheck.checked,
		blackLevel: parseFloat(this.blackLevelInput.value),
		blackLock: this.blackLevelLock.checked,
		highRef: parseFloat(this.highLevelRef.value),
		highMap: parseFloat(this.highLevelMap.value),
		highLock: this.highLevelLock.checked
	};
	if (this.blackLevelInput.value !== this.blackDefault) {
		data.blackHighlight.blackLock = true;
	}
	if (this.highLevelMap.value !== this.highDefault) {
		data.blackHighlight.highLock = true;
	}
};
TWKBlkHi.prototype.setSettings = function(settings) {
	if (typeof settings.blackHighlight !== 'undefined') {
		var data = settings.blackHighlight;
		if (typeof data.doBH === 'boolean') {
			this.tweakCheck.checked = data.doBH;
			this.toggleTweak();
		}
		if (typeof data.doBlack === 'boolean') {
			this.blackLevelCheck.checked = data.doBlack;
			this.toggleBlack();
		}
		if (typeof data.doHigh === 'boolean') {
			this.highLevelCheck.checked = data.doHigh;
			this.toggleHigh();
		}
		if (typeof data.blackLock === 'boolean') {
			this.blackLevelLock.checked = data.blackLock;
		}
		if (typeof data.highLock === 'boolean') {
			this.highLevelLock.checked = data.highLock;
		}
		if (typeof data.blackLevel === 'number') {
			this.blackLevelInput.value = data.blackLevel.toString();
		}
		if (typeof data.highRef === 'number' && typeof data.highMap === 'number') {
			this.highLevelRef.value = data.highRef.toString();
			this.highLevelMap.value = data.highMap.toString();
		}
	}
};
TWKBlkHi.prototype.getInfo = function(info) {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak && this.blackLevelCheck.checked) {
		info.doBlk = true;
		info.blackLevel = this.blackLevelInput.value;
	} else {
		info.doBlk = false;
		info.blackLevel = this.blackDefault;
	}
};
TWKBlkHi.prototype.isCustomGamma = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKBlkHi.prototype.isCustomGamut = function() {
	return false;
};
TWKBlkHi.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gaSetParams();
	};}(this);
	this.blackLevelCheck.onclick = function(here){ return function(){
		here.toggleBlack();
		here.messages.gaSetParams();
	};}(this);
	this.blackLevelInput.onchange = function(here){ return function(){
		here.testBlack();
		here.messages.gaSetParams();
	};}(this);
	this.highLevelCheck.onclick = function(here){ return function(){
		here.toggleHigh();
		here.messages.gaSetParams();
	};}(this);
	this.highLevelRef.onchange = function(here){ return function(){
		here.testHighRef();
		here.messages.gaSetParams();
	};}(this);
	this.highLevelMap.onchange = function(here){ return function(){
		here.testHighMap();
		here.messages.gaSetParams();
	};}(this);
};
// Tweak-Specific Code
TWKBlkHi.prototype.toggleBlack = function() {
	if (this.blackLevelCheck.checked) {
		this.blackLevelBox.className = 'twk-sub-box';
		this.separator.className = 'twk-tab-hide';
	} else {
		this.blackLevelBox.className = 'twk-sub-box-hide';
		this.separator.className = 'twk-tab';
	}
};
TWKBlkHi.prototype.testBlack = function() {
	if (!isNaN(parseFloat(this.blackLevelInput.value)) && isFinite(this.blackLevelInput.value) && (parseFloat(this.blackLevelInput.value)>-7.3)) {
	} else {
			this.blackLevelInput.value = null;
	}
};
TWKBlkHi.prototype.toggleHigh = function() {
	if (this.highLevelCheck.checked) {
		this.highLevelBox.className = 'twk-sub-box';
	} else {
		this.highLevelBox.className = 'twk-sub-box-hide';
	}
};
TWKBlkHi.prototype.testHighRef = function() {
	if (!isNaN(parseFloat(this.highLevelRef.value)) && isFinite(this.highLevelRef.value) && (parseFloat(this.highLevelRef.value)>0)) {
	} else {
		this.highLevelRef.value = '90';
		this.highLevelMap.value = null;
	}
};
TWKBlkHi.prototype.testHighMap = function() {
	if (!isNaN(parseFloat(this.highLevelMap.value)) && isFinite(this.highLevelMap.value) && (parseFloat(this.highLevelMap.value)>-7.3)) {
	} else {
		this.highLevelMap.value = null;
	}
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-blkgam.js
* Black gamma adjustment object for the LUTCalc Web App.
* 19th July 2016
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKBlkGam(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.io();
	this.ui();
}
TWKBlkGam.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;
	// Tweak - Specific Inputs
	// Power
	this.gamS = new lutSlider({
		min: 0.01,
		mid: 1,
		max: 10,
		value: 1,
		step: 0.01,
		title: false,
		lhs: 'Power',
		minLabel: false,
		maxLabel: false,
		input: 'number',
		reset: true
	});
	// Limit
	this.limS = new lutSlider({
		min: -9,
		max: 2,
		value: -1.5,
		step: 0.1,
		title: false,
		lhs: 'Stop Limit',
		minLabel: false,
		maxLabel: false,
		input: 'number',
		reset: true
	});
	// Feather
	this.feaS = new lutSlider({
		min: 0,
		max: 9,
		value: 2,
		step: 0.1,
		title: false,
		lhs: 'Feather',
		minLabel: false,
		maxLabel: false,
		rhs: 'Stops',
		input: 'number',
		reset: true
	});
};
TWKBlkGam.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('Black Gamma')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	// Tweak - Specific UI Elements
	this.box.appendChild(this.gamS.element);
	this.box.appendChild(this.limS.element);
	this.box.appendChild(this.feaS.element);
	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKBlkGam.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked) { // This checks for 'Customisations' to be checked and LUT type set to '3D' (the d[1] item)
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKBlkGam.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKBlkGam.prototype.getTFParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doBlkGam = true;
	} else {
		out.doBlkGam = false;
	}
	out.upperLim = this.limS.getValue();
	out.feather = this.feaS.getValue();
	out.power = this.gamS.getValue();
	params.twkBlkGam = out;
};
TWKBlkGam.prototype.getCSParams = function(params) {
	// No Relevant Parameters For This Tweak
};
TWKBlkGam.prototype.setParams = function(params) {
	if (typeof params.twkBlkGam !== 'undefined') {
		var p = params.twkBlkGam;
		this.toggleTweaks();
	}
};
TWKBlkGam.prototype.getSettings = function(data) {
	data.blackGamma = {
		doBlkGamma: this.tweakCheck.checked,
		stopLimit: this.limS.getValue(),
		feather: this.feaS.getValue(),
		power: this.gamS.getValue()
	};
};
TWKBlkGam.prototype.setSettings = function(settings) {
	if (typeof settings.blackGamma !== 'undefined') {
		var data = settings.blackGamma;
		if (typeof data.doBlkGamma === 'boolean') {
			this.tweakCheck.checked = data.doBlkGamma;
			this.toggleTweak();
		}
		if (typeof data.stopLimit === 'number') {
			this.limS.setValue(data.stopLimit);
		}
		if (typeof data.feather === 'number') {
			this.feaS.setValue(data.feather);
		}
		if (typeof data.power === 'number') {
			this.gamS.setValue(data.power);
		}
	}
};
TWKBlkGam.prototype.getInfo = function(info) {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doBlkGam = true;
	} else {
		info.doBlkGam = false;
	}
};
TWKBlkGam.prototype.isCustomGamma = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKBlkGam.prototype.isCustomGamut = function() {
	return false;
};
TWKBlkGam.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gaSetParams();
	};}(this);
	this.limS.action = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.feaS.action = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.gamS.action = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
};
// Tweak-Specific Code
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-sdrsat.js
* Adjustment using gamma correction to up the saturation of HLG signals in SDR viewing
* 4th April 2019
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKSDRSat(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.io();
	this.ui();
	this.events();
}
TWKSDRSat.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;
	// Tweak - Specific Inputs
	this.gamma = new lutSlider({
		min: 1,
		max: 2,
		value: 1.2,
		step: 0.05,
		title: false,
		lhs: 'Saturation',
		minLabel: false,
		maxLabel: false,
		input: 'number',
		reset: true
	});
	this.hdrs = [
//		'Rec2100 PQ (PQ OOTF)',
//		'Rec2100 PQ (HLG OOTF)',
		'Rec2100 HLG',
//		'PQ (EOTF Only)',
		'ITU Proposal (400%)',
		'ITU Proposal (800%)',
		'BBC WHP283 (400%)',
		'BBC WHP283 (800%)'
	];
	this.wgts = [
		'Rec2020',
		'Rec2100'
	];
};
TWKSDRSat.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('SDR Saturation')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	// Tweak - Specific UI Elements
	this.box.appendChild(this.gamma.element);
	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKSDRSat.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked && this.inputs.d[1].checked) { // This checks for 'Customisations' to be checked and LUT type set to '3D' (the d[1] item)
		var oG = this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue;
		var oGt = this.inputs.outGamut.options[this.inputs.outGamut.selectedIndex].lastChild.nodeValue;
		if (this.hdrs.indexOf(oG) > -1 && this.wgts.indexOf(oGt) > -1) {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKSDRSat.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKSDRSat.prototype.getTFParams = function(params) {
	// No parameters are relevent
};
TWKSDRSat.prototype.getCSParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doSDRSat = true;
		out.gamma = this.gamma.getValue();
	} else {
		out.doSDRSat = false;
	}
	params.twkSDRSat = out;
};
TWKSDRSat.prototype.setParams = function(params) {
	if (typeof params.twkSDRSat !== 'undefined') {
		var p = params.twkSDRSat;
		this.toggleTweaks();
	}
};
TWKSDRSat.prototype.getSettings = function(data) {
	data.sdrsat = {
		doSDRSat: this.tweakCheck.checked,
		gamma: this.gamma.getValue()
	};
};
TWKSDRSat.prototype.setSettings = function(settings) {
	if (typeof settings.SDRSAT !== 'undefined') {
		var data = settings.SDRSAT;
		if (typeof data.doSDRSat === 'boolean') {
			this.tweakCheck.checked = data.doSDRSat;
			this.gamma.setValue(parseFloat(data.gamma));
			this.toggleTweak();
		}
	}
};
TWKSDRSat.prototype.getInfo = function(info) {
	// Provides metadata to LUT formats
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doSDRSat = true;
	} else {
		info.doSDRSat = false;
	}
};
TWKSDRSat.prototype.isCustomGamma = function() {
	return false;
};
TWKSDRSat.prototype.isCustomGamut = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKSDRSat.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gtSetParams();
	};}(this);
	this.gamma.action = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
};
// Tweak-Specific Code
	// Methods called by event responses should go here
	// Requirements:
	//		style.display should be avoided, use className = 'value';
	//		for showing and hiding, it should be of the form className = 'twk-itemclass' and className = 'twk-itemclass-hide'
/* twk-gamlim.js
* A gamut limiter to avoid ugly clipping for the LUTCalc Web App.
* 10th April 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKGamutLim(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.io();
	this.ui();
	this.events();
}
TWKGamutLim.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;
	// Tweak - Specific Inputs
	// Max Start Value
	// Pre / Post option radios
	this.linear = false;
	this.prePost = [];
	this.prePost[0] = this.createRadioElement('prePostRadio',false);
	this.prePost[1] = this.createRadioElement('prePostRadio',true);
	// Sliders
	this.preInputBox = document.createElement('span');
	this.preIG = document.createElement('input');
	this.preIG.setAttribute('type','number');
	this.preIG.setAttribute('step',0.1);
	this.preIG.value = 2.3;
	this.preIG.className = '_input';
	this.preS = new lutSlider({
		min: -6,
		max: 6,
		value: 0,
		step: 0.1,
		title: 'Level',
		minLabel: false,
		maxLabel: false,
		input: 'number',
		lhs: this.preInputBox,
		rhs: 'Stops',
		reset: false
	});
	this.pstS = new lutSlider({
		min: 1,
		max: 109,
		value: 100,
		step: 1,
		title: 'Level',
		minLabel: false,
		maxLabel: false,
		input: 'number',
		rhs: '%IRE',
		reset: false
	});
	// Gamut List
	this.gtSelect = document.createElement('select');
	this.gamutList = this.inputs.gamutMatrixList;
	m = this.gamutList.length;
	var opt = document.createElement('option');
	opt.value = 9999;
	opt.appendChild(document.createTextNode('Match Output Gamut'));
	this.gtSelect.appendChild(opt);
	for (var j=0; j<m; j++) {
		var option = document.createElement('option');
		option.value = this.gamutList[j].idx;
		option.appendChild(document.createTextNode(this.gamutList[j].name));
		this.gtSelect.appendChild(option);
	}
	this.diffGam = false;
	this.bothCheck = document.createElement('input');
	this.bothCheck.setAttribute('type','checkbox');
	this.bothCheck.className = 'twk-checkbox';
	this.bothCheck.checked = true;
};
TWKGamutLim.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('Gamut Limiter')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	// Tweak - Specific UI Elements
	// Pre / Post radio choice
	this.box.appendChild(this.prePost[0]);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Linear Space')));
	this.box.appendChild(this.prePost[1]);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Post Gamma')));
	// Linear Space Level Value
	this.preBox = document.createElement('div');
	this.preBox.className = 'twk-tab-hide';
	var preLabL = document.createElement('span');
	preLabL.innerHTML = '18% Gray +';
	var preLabR = document.createElement('span');
	preLabR.innerHTML = 'Stops /';
	var pstLabL = document.createElement('span');
	pstLabL.innerHTML = 'Ref White +';
	this.preInputBox.appendChild(preLabL);
	this.preInputBox.appendChild(this.preIG);
	this.preInputBox.appendChild(preLabR);
	this.preInputBox.appendChild(pstLabL);
	this.preBox.appendChild(this.preS.element);
	this.box.appendChild(this.preBox);
	// Post Tonemap Level Value
	this.pstBox = document.createElement('div');
	this.pstBox.className = 'twk-tab';
	this.pstBox.appendChild(this.pstS.element);
	this.box.appendChild(this.pstBox);
	// Limit to other colourspaces
	this.gtBox = document.createElement('div');
	this.gtBox.className = 'twk-tab';
	this.gtBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Gamut To Limit To')));
	this.gtBox.appendChild(this.gtSelect);
	this.bothBox = document.createElement('div');
	this.bothBox.className = 'twk-tab-hide';
	this.bothBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Protect Both')));
	this.bothBox.appendChild(this.bothCheck);
	this.gtBox.appendChild(this.bothBox);
	this.box.appendChild(this.gtBox);
	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKGamutLim.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked && this.inputs.d[1].checked) {
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKGamutLim.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKGamutLim.prototype.getTFParams = function(params) {
	// No Relevant Parameters For This Tweak
};
TWKGamutLim.prototype.getCSParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doGamutLim = true;
	} else {
		out.doGamutLim = false;
	}
	if (this.linear) {
		out.lin = true;
		out.level = Math.pow(2,this.preS.getValue()); // Effect start level in stops around 18% gray
	} else {
		out.lin = false;
		out.level = this.pstS.getValue()/100; // Effect start level in % IRE
	}
	if (this.diffGam) {
		out.gamut = this.gtSelect.options[this.gtSelect.selectedIndex].lastChild.nodeValue;
		out.both = this.bothCheck.checked;
	}
	params.twkGamutLim = out;
};
TWKGamutLim.prototype.setParams = function(params) {
	if (typeof params.twkGamutLim !== 'undefined') {
		var p = params.twkGamutLim;
		this.toggleTweaks();
	}
};
TWKGamutLim.prototype.getSettings = function(data) {
	data.gamutLim = {
		doGamutLim: this.tweakCheck.checked,
		preLevel: Math.pow(2,this.preS.getValue()),
		postLevel: this.pstS.getValue()/100,
		otherGamut: this.diffGam,
		otherWhich: this.gtSelect.options[this.gtSelect.selectedIndex].lastChild.nodeValue,
		both: this.bothCheck.checked
	};
	if (this.linear) {
		data.gamutLim.when = 'pre';
	} else {
		data.gamutLim.when = 'post';
	}
};
TWKGamutLim.prototype.setSettings = function(settings) {
	if (typeof settings.gamutLim !== 'undefined') {
		var data = settings.gamutLim;
		if (typeof data.doGamutLim === 'boolean') {
			this.tweakCheck.checked = data.doGamutLim;
			this.toggleTweak();
		}
		if (typeof data.preLevel === 'number') {
			this.preS.setValue(Math.log(data.preLevel)/Math.log(2));
			this.preIG.value = Math.round((this.preS.getValue()*10) + 23)/10;
		}
		if (typeof data.postLevel === 'number') {
			this.pstS.setValue(data.postLevel*100);
		}
		if (typeof data.otherGamut === 'boolean') {
			this.diffGam = data.otherGamut;
		}
		if (typeof data.otherWhich !== 'undefined') {
			var m = this.gtSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.gtSelect.options[j].lastChild.nodeValue === data.otherWhich) {
					this.gtSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.both === 'boolean') {
			this.bothCheck.checked = data.both
		}
		if (typeof data.when !== 'undefined') {
			if (data.when === 'pre') {
				this.prePost[0].checked = true;
				this.prePost[1].checked = false;
			} else {
				this.prePost[0].checked = false;
				this.prePost[1].checked = true;
			}
			this.togglePrePost();
		}		
	}
};
TWKGamutLim.prototype.getInfo = function(info) {
	// Provides metadata to LUT formats
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doGamutLim = true;
	} else {
		info.doGamutLim = false;
	}
};
TWKGamutLim.prototype.isCustomGamma = function() {
	return false;
};
TWKGamutLim.prototype.isCustomGamut = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
	return false;
};
TWKGamutLim.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gtSetParams();
	};}(this);
	this.prePost[0].onchange = function(here){ return function(){
		here.togglePrePost();
	};}(this);
	this.prePost[1].onchange = function(here){ return function(){
		here.togglePrePost();
	};}(this);
	this.preS.action = function(here){ return function(){
		here.preIG.value = Math.round((this.getValue()*10) + 23)/10;
		here.messages.gtSetParams();
	};}(this);
	this.preIG.onchange = function(here){ return function(){
		here.testPreG();
		here.messages.gtSetParams();
	};}(this);
	this.pstS.action = function(here){ return function(){
		here.preIG.value = Math.round((this.getValue()*10) + 23)/10;
		here.messages.gtSetParams();
	};}(this);
	this.gtSelect.onchange = function(here){ return function(){
		here.diffGamut();
		here.messages.gtSetParams();
	};}(this);
	this.bothCheck.onclick = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
};
// Tweak-Specific Code
TWKGamutLim.prototype.togglePrePost = function() {
	if (this.prePost[0].checked) {
		this.linear = true;
		this.preBox.className = 'twk-tab';
		this.pstBox.className = 'twk-tab-hide';
	} else {
		this.linear = false;
		this.preBox.className = 'twk-tab-hide';
		this.pstBox.className = 'twk-tab';
	}
	this.messages.gtSetParams();
};
TWKGamutLim.prototype.testPreG = function() {
	var val = Math.round(parseFloat(this.preIG.value)*10);
	if (val > 83) {
		val = 83;
	} else if (val < -37) {
		val = -37;
	}
	this.preS.setValue((val - 23)/10);
	this.preIG.value = val/10;
};
TWKGamutLim.prototype.diffGamut = function() {
	if (this.gtSelect.selectedIndex > 0 && this.gtSelect.options[this.gtSelect.selectedIndex].lastChild.nodeValue !== this.inputs.outGamut.options[this.inputs.outGamut.selectedIndex].lastChild.nodeValue) {
		this.bothBox.className = 'twk-tab';
		this.diffGam = true;
	} else {
		this.bothBox.className = 'twk-tab-hide';
		this.diffGam = false;
	}
};
TWKGamutLim.prototype.changeGamut = function() {
	var gtList = this.inputs.outGamut;
	var m = this.gtSelect.length;
	var matrix = false;
	for (var j=1; j<m; j++) {
		if (gtList.options[gtList.selectedIndex].lastChild.nodeValue === this.gtSelect.options[j].lastChild.nodeValue) {
			matrix = true;
			break;
		}
	}
	if (matrix) {
		this.gtBox.className = 'twk-tab';
		this.diffGamut();
	} else {
		this.gtBox.className = 'twk-tab-hide';
		this.diffGam = false;
	}
}
TWKGamutLim.prototype.createRadioElement = function(name, checked) {
    var radioInput;
    try {
        var radioHtml = '<input type="radio" name="' + name + '"';
        if ( checked ) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += '/>';
        radioInput = document.createElement(radioHtml);
    } catch( err ) {
        radioInput = document.createElement('input');
        radioInput.setAttribute('type', 'radio');
        radioInput.setAttribute('name', name);
        if ( checked ) {
            radioInput.setAttribute('checked', 'checked');
        }
    }
    return radioInput;
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-display.js
* Final conversion from base colourspace to a different colourspace (ie maintaining look).
* 12th May 2017
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKDisplay(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.p = 17;
	this.messages.addUI(this.p,this);
	this.io();
	this.ui();
	this.events();
}
TWKDisplay.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;
	// Tweak - Specific Inputs
	this.inSpaceSelect = document.createElement('select');
	this.outSpaceSelect = document.createElement('select');
	this.spaceNames = [];
	var list = this.inputs.gammaDisList;
	var m = list.length;
	for (var j=0; j<m; j++) {
		this.spaceNames.push(list[j].name);
		var optIn = document.createElement('option');
		optIn.innerHTML = list[j].name;
		optIn.value = list[j].idx;
		this.inSpaceSelect.appendChild(optIn);
		var optOut = document.createElement('option');
		optOut.innerHTML = list[j].name;
		optOut.value = list[j].idx;
		this.outSpaceSelect.appendChild(optOut);
		if (list[j].name === 'Rec709') {
			optIn.selected = true;
			optOut.selected = true;
		}
	}
	this.inGamutSelect = document.createElement('select');
	this.outGamutSelect = document.createElement('select');
	list = [
		'Rec709',
		'Rec2020',
		'sRGB',
		'DCI-P3',
		'DCI-D60',
		'DCI-D65',
		'ProPhoto RGB'
	];
	m = list.length;
	for (var j=0; j<m; j++) {
		var optIn = document.createElement('option');
		optIn.innerHTML = list[j];
		optIn.value = j;
		this.inGamutSelect.appendChild(optIn);
		var optOut = document.createElement('option');
		optOut.innerHTML = list[j];
		optOut.value = j;
		this.outGamutSelect.appendChild(optOut);
	}
	this.gtIdx = [];
	list = this.inputs.gammaDisBaseGamuts;
	m = list.length;
	for (var j=0; j<m; j++) {
		switch (list[j]) {
			case 'Rec709':
				this.gtIdx.push(0);
				break;
			case 'Rec2020':
				this.gtIdx.push(1);
				break;
			case 'sRGB':
				this.gtIdx.push(2);
				break;
			case 'P3 - DCI':
				this.gtIdx.push(3);
				break;
			case 'P3 - D60':
				this.gtIdx.push(4);
				break;
			case 'P3 - D65':
				this.gtIdx.push(5);
				break;
			case 'ProPhoto RGB':
				this.gtIdx.push(6);
				break;
			default:
				this.gtIdx.push(9999);
		}
	}
	this.csIdx = [];
	list = this.inputs.gammaOutList;
	m = list.length;
	for (var j=0; j<m; j++) {
		if (list[j].name.indexOf('Rec2100') !== -1 || list[j].name.indexOf('PQ') !== -1) {
			this.csIdx.push(this.spaceNames.indexOf(list[j].name));
		} else if (list[j].name === 'Linear / γ') {
			// Ignore
		} else {
			switch(this.inputs.gammaBaseGamuts[list[j].idx]) {
				case 'Rec709':
					this.csIdx.push(0);
					break;
				case 'Rec2020':
					this.csIdx.push(1);
					break;
				case 'sRGB':
					this.csIdx.push(2);
					break;
				default:
					this.csIdx.push(9999);
					break;
			}
		}
	}
	this.csLIdx = [];
	list = this.inputs.gammaLinList;
	m = list.length - 2;
	for (var j=0; j<m; j++) {
		this.csLIdx.push(j);
		if (list[j].name === 'DCI - γ2.60') {
			j += 2;
		}
	}
};
TWKDisplay.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('Display Colourspace Converter')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	// Tweak - Specific UI Elements
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Output Base Colourspace')));
	this.box.appendChild(this.inSpaceSelect);
	this.box.appendChild(document.createElement('br'));
	this.inGamutBox = document.createElement('div');
	this.inGamutBox.className = 'twk-tab-hide';
	this.inGamutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Using Gamut')));
	this.inGamutBox.appendChild(this.inGamutSelect);
	this.box.appendChild(this.inGamutBox);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Convert To')));
	this.box.appendChild(this.outSpaceSelect);
	this.outGamutBox = document.createElement('div');
	this.outGamutBox.className = 'twk-tab-hide';
	this.outGamutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Using Gamut')));
	this.outGamutBox.appendChild(this.outGamutSelect);
	this.box.appendChild(this.outGamutBox);
	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKDisplay.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked) { // This checks for 'Customisations' to be checked and LUT type set to '3D' (the d[1] item)
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKDisplay.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKDisplay.prototype.getTFParams = function(params) {
	// Parameters to be sent to the 'Gamma' (Transfer Function) web worker go here
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doDisplay = true;
	} else {
		out.doDisplay = false;
	}
	out.inIdx = parseInt(this.inSpaceSelect.options[this.inSpaceSelect.options.selectedIndex].value);
	out.inGt = this.gtIdx[this.inSpaceSelect.options.selectedIndex];
	if (out.inGt === 9999) {
		out.inGt = this.inGamutSelect.selectedIndex;
	}
	out.outIdx = parseInt(this.outSpaceSelect.options[this.outSpaceSelect.options.selectedIndex].value);
	out.outGt = this.gtIdx[this.outSpaceSelect.options.selectedIndex];
	if (out.outGt === 9999) {
		out.outGt = this.outGamutSelect.selectedIndex;
	}
	params.twkDisplay = out;
};
TWKDisplay.prototype.getCSParams = function(params) {
	// Parameters to be sent to the 'Gamut' (Colour Space) web worker go here
};
TWKDisplay.prototype.setParams = function(params) {
	if (typeof params.twkDisplay !== 'undefined') {
		var p = params.twkDisplay;
		this.toggleTweaks();
	}
};
TWKDisplay.prototype.getSettings = function(data) {
	data.display = {
		doDisplay: this.tweakCheck.checked,
		baseCS: this.inSpaceSelect.options[this.inSpaceSelect.selectedIndex].lastChild.nodeValue,
		outputCS: this.outSpaceSelect.options[this.outSpaceSelect.selectedIndex].lastChild.nodeValue,
	};
	if (this.gtIdx[this.inSpaceSelect.options.selectedIndex] === 9999) {
		data.display.baseGamut = this.inGamutSelect.options[this.inGamutSelect.selectedIndex].lastChild.nodeValue;
	} else {
		data.display.baseGamut = data.display.baseCS;
	}
	if (this.gtIdx[this.outSpaceSelect.options.selectedIndex] === 9999) {
		data.display.outputGamut = this.outGamutSelect.options[this.outGamutSelect.selectedIndex].lastChild.nodeValue;
	} else {
		data.display.outputGamut = data.display.outputCS;
	}
};
TWKDisplay.prototype.setSettings = function(settings) {
	if (typeof settings.display !== 'undefined') {
		var data = settings.display;
		if (typeof data.doDisplay === 'boolean') {
			this.tweakCheck.checked = data.doDisplay;
			this.toggleTweak();
		}
		if (typeof data.baseCS !== 'undefined') {
			var m = this.inSpaceSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.inSpaceSelect.options[j].lastChild.nodeValue === data.baseCS) {
					this.inSpaceSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.outputCS !== 'undefined') {
			var m = this.outSpaceSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.outSpaceSelect.options[j].lastChild.nodeValue === data.outputCS) {
					this.outSpaceSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.baseGamut !== 'undefined') {
			var m = this.inGamutSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.inGamutSelect.options[j].lastChild.nodeValue === data.baseGamut) {
					this.inGamutSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.outputGamut !== 'undefined') {
			var m = this.outGamutSelect.options.length;
			for (var j=0; j<m; j++) {
				if (this.outGamutSelect.options[j].lastChild.nodeValue === data.outputGamut) {
					this.outGamutSelect.options[j].selected = true;
					break;
				}
			}
		}
	}
};
TWKDisplay.prototype.getInfo = function(info) {
	// Provides metadata to LUT formats
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doDisplay = true;
	} else {
		info.doDisplay = false;
	}
};
TWKDisplay.prototype.isCustomGamma = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKDisplay.prototype.isCustomGamut = function() {
	return false;
};
TWKDisplay.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gaSetParams();
	};}(this);
	this.inSpaceSelect.onchange = function(here){ return function(){
		here.testSpace(true);
		here.messages.gaSetParams();
	};}(this);
	this.outSpaceSelect.onchange = function(here){ return function(){
		here.testSpace(false);
		here.messages.gaSetParams();
	};}(this);
};
// Tweak-Specific Code
TWKDisplay.prototype.testSpace = function(isIn) {
	var idx, box;
	if (isIn) {
		idx = this.inSpaceSelect.selectedIndex;
		box = this.inGamutBox;
	} else {
		idx = this.outSpaceSelect.selectedIndex;
		box = this.outGamutBox;
	}
	if (this.gtIdx[idx] === 9999) {
		box.className = 'twk-tab';
	} else {
		box.className = 'twk-tab-hide';
	}	
};
TWKDisplay.prototype.updateGammaOut = function() {
	var m = this.inSpaceSelect.length;
	if (parseInt(this.inputs.outGamma.options[this.inputs.outGamma.options.selectedIndex].value) === 9999) {
		var idx = this.csLIdx[parseInt(this.inputs.outLinGamma.selectedIndex)];
		if (idx < m) {
			this.inSpaceSelect.options[idx].selected = true;
		}
	} else {
		var idx = this.csIdx[parseInt(this.inputs.outGamma.selectedIndex)];
		if (idx !== 9999 && idx < m) {
			this.inSpaceSelect.options[idx].selected = true;
		}
	}
};/* twk-fc.js
* False Colour customisation object for the LUTCalc Web App.
* 10th April 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKFC(tweaksBox, inputs, messages) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.io();
	this.ui();
}
TWKFC.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;
	// Tweak - Specific Inputs
	// Purple - Black Clip
	this.purpleCheck = document.createElement('input');
	this.purpleCheck.setAttribute('type','checkbox');
	this.purpleCheck.className = 'twk-checkbox';
	this.purpleCheck.checked = true;
	// Blue - Just Above Black Clip
	this.blueCheck = document.createElement('input');
	this.blueCheck.setAttribute('type','checkbox');
	this.blueCheck.className = 'twk-checkbox';
	this.blueCheck.checked = true;
	this.blueInput = document.createElement('input');
	this.blueInput.setAttribute('type','number');
	this.blueInput.setAttribute('step','any');
	this.blueInput.className = 'stop-input';
	this.blueInput.value = '6.1';
	// Green - 18% Gray
	this.greenCheck = document.createElement('input');
	this.greenCheck.setAttribute('type','checkbox');
	this.greenCheck.className = 'twk-checkbox';
	this.greenCheck.checked = true;
	// Pink - One Stop Over 18% Gray
	this.pinkCheck = document.createElement('input');
	this.pinkCheck.setAttribute('type','checkbox');
	this.pinkCheck.className = 'twk-checkbox';
	this.pinkCheck.checked = true;
	// Orange - 90% White
	this.orangeCheck = document.createElement('input');
	this.orangeCheck.setAttribute('type','checkbox');
	this.orangeCheck.className = 'twk-checkbox';
	this.orangeCheck.checked = false;
	// Yellow - Just Below White Clip
	this.yellowCheck = document.createElement('input');
	this.yellowCheck.setAttribute('type','checkbox');
	this.yellowCheck.className = 'twk-checkbox';
	this.yellowCheck.checked = true;
	this.yellowInput = document.createElement('input');
	this.yellowInput.setAttribute('type','number');
	this.yellowInput.setAttribute('step','any');
	this.yellowInput.className = 'stop-input';
	this.yellowInput.value = '0.5';
	// Red - White Clip
	this.redCheck = document.createElement('input');
	this.redCheck.setAttribute('type','checkbox');
	this.redCheck.className = 'twk-checkbox';
	this.redCheck.checked = true;
	this.redInput = document.createElement('input');
	this.redInput.setAttribute('type','number');
	this.redInput.setAttribute('step','any');
	this.redInput.className = 'stop-input';
	this.redInput.value = '6';
};
TWKFC.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('False Colour')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	// Tweak - Specific UI Elements
	var purpleBox = document.createElement('div');
	purpleBox.className = 'twk-sub-box';
	purpleBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Purple - Black Clip')));
	purpleBox.appendChild(this.purpleCheck);
	this.box.appendChild(purpleBox);
	var blueBox = document.createElement('div');
	blueBox.className = 'twk-sub-box';
	blueBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Blue - Just Above Black Clip')));
	blueBox.appendChild(this.blueCheck);
	blueBox.appendChild(document.createElement('br'));
	blueBox.appendChild(this.blueInput);
	blueBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Stops Below 18% Gray')));
	this.box.appendChild(blueBox);
	var greenBox = document.createElement('div');
	greenBox.className = 'twk-sub-box';
	greenBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Green - 18% Mid Gray')));
	greenBox.appendChild(this.greenCheck);
	this.box.appendChild(greenBox);
	var pinkBox = document.createElement('div');
	pinkBox.className = 'twk-sub-box';
	pinkBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Pink - One Stop Over 18% Mid Gray')));
	pinkBox.appendChild(this.pinkCheck);
	this.box.appendChild(pinkBox);
	var orangeBox = document.createElement('div');
	orangeBox.className = 'twk-sub-box';
	orangeBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Orange - 90% White')));
	orangeBox.appendChild(this.orangeCheck);
	this.box.appendChild(orangeBox);
	var yellowBox = document.createElement('div');
	yellowBox.className = 'twk-sub-box';
	yellowBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Yellow - Just Below White Clip')));
	yellowBox.appendChild(this.yellowCheck);
	yellowBox.appendChild(document.createElement('br'));
	yellowBox.appendChild(this.yellowInput);
	yellowBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Stops Below White Clip')));
	this.box.appendChild(yellowBox);
	var redBox = document.createElement('div');
	redBox.className = 'twk-sub-box';
	redBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Red - White Clip')));
	redBox.appendChild(this.redCheck);
	redBox.appendChild(document.createElement('br'));
	redBox.appendChild(this.redInput);
	redBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Stops Above 18% Mid Gray')));
	this.box.appendChild(redBox);
	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKFC.prototype.toggleTweaks = function() {
	// If The Overall Checkbox Is Ticked
	if (this.inputs.tweaks.checked && this.inputs.d[1].checked) { // This checks for 'Customisations' to be checked and LUT type set to '3D' (the d[1] item)
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKFC.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKFC.prototype.getTFParams = function(params) {
	// No Relevant Parameters For This Tweak
};
TWKFC.prototype.getCSParams = function(params) {
	var out = {};
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		out.doFC = true;
		out.fcs = [
			this.purpleCheck.checked,
			this.blueCheck.checked,
			this.greenCheck.checked,
			this.pinkCheck.checked,
			this.orangeCheck.checked,
			this.yellowCheck.checked,
			this.redCheck.checked
		];
	} else {
		out.doFC = false;
	}
	out.blue = parseFloat(this.blueInput.value);
	out.yellow = parseFloat(this.yellowInput.value);
	out.red = parseFloat(this.redInput.value);
	params.twkFC = out;
};
TWKFC.prototype.setParams = function(params) {
	if (typeof params.twkFC !== 'undefined') {
		var p = params.twkFC;
		this.toggleTweaks();
	}
};
TWKFC.prototype.getSettings = function(data) {
	data.falseColour = {
		doFC: this.tweakCheck.checked,
		doPurple: this.purpleCheck.checked,
		doBlue: this.blueCheck.checked,
		doGreen: this.greenCheck.checked,
		doPink: this.pinkCheck.checked,
		doOrange: this.orangeCheck.checked,
		doYellow: this.yellowCheck.checked,
		doRed: this.redCheck.checked,
		blue: parseFloat(this.blueInput.value),
		yellow: parseFloat(this.yellowInput.value),
		red: parseFloat(this.redInput.value)
	};
};
TWKFC.prototype.setSettings = function(settings) {
	if (typeof settings.falseColour !== 'undefined') {
		var data = settings.falseColour;
		if (typeof data.doFC === 'boolean') {
			this.tweakCheck.checked = data.doFC;
			this.toggleTweak();
		}
		if (typeof data.doPurple === 'boolean') {
			this.purpleCheck.checked = data.doPurple;
		}
		if (typeof data.doBlue === 'boolean') {
			this.blueCheck.checked = data.doBlue;
		}
		if (typeof data.doGreen === 'boolean') {
			this.greenCheck.checked = data.doGreen;
		}
		if (typeof data.doPink === 'boolean') {
			this.pinkCheck.checked = data.doPink;
		}
		if (typeof data.doOrange === 'boolean') {
			this.orangeCheck.checked = data.doOrange;
		}
		if (typeof data.doYellow === 'boolean') {
			this.yellowCheck.checked = data.doYellow;
		}
		if (typeof data.doRed === 'boolean') {
			this.redCheck.checked = data.doRed;
		}
		if (typeof data.blue === 'number') {
			this.blueInput.value = data.blue.toString();
		}
		if (typeof data.yellow === 'number') {
			this.yellowInput.value = data.yellow.toString();
		}
		if (typeof data.red === 'number') {
			this.redInput.value = data.red.toString();
		}
	}
};
TWKFC.prototype.getInfo = function(info) {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		info.doFC = true;
	} else {
		info.doFC = false;
	}
};
TWKFC.prototype.isCustomGamma = function() {
	return false;
};
TWKFC.prototype.isCustomGamut = function() {
	var tweaks = this.inputs.tweaks.checked;
	var tweak = this.tweakCheck.checked;
	if (tweaks && tweak) {
		return true;
	} else {
		return false;
	}
};
TWKFC.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gtSetParams();
	};}(this);

	// Event responses for input changes or click should go here
	this.purpleCheck.onclick = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.blueCheck.onclick = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.greenCheck.onclick = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.pinkCheck.onclick = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.orangeCheck.onclick = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.yellowCheck.onclick = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.redCheck.onclick = function(here){ return function(){
		here.messages.gtSetParams();
	};}(this);
	this.blueInput.onchange = function(here){ return function(){
		here.testBlue();
		here.messages.gtSetParams();
	};}(this);
	this.yellowInput.onchange = function(here){ return function(){
		here.testYellow();
		here.messages.gtSetParams();
	};}(this);
	this.redInput.onchange = function(here){ return function(){
		here.testRed();
		here.messages.gtSetParams();
	};}(this);
};
// Tweak-Specific Code
TWKFC.prototype.testBlue = function() {
	if (!isNaN(parseFloat(this.blueInput.value)) && isFinite(this.blueInput.value)) {
		if (parseFloat(this.blueInput.value)<1) {
			this.blueInput.value = '1';
		}
	} else {
		this.blueInput.value = '6.1';
	}
};
TWKFC.prototype.testYellow = function() {
	if (!isNaN(parseFloat(this.yellowInput.value)) && isFinite(this.yellowInput.value)) {
		 if (parseFloat(this.yellowInput.value)<0.0001) {
			this.yellowInput.value = '0.0001';
		 } else if (parseFloat(this.yellowInput.value)>3) {
			this.yellowInput.value = '3';
		 }
	} else {
		this.yellowInput.value = '0.5';
	}
};
TWKFC.prototype.testRed = function() {
	if (!isNaN(parseFloat(this.redInput.value)) && isFinite(this.redInput.value)) {
		 if (parseFloat(this.redInput.value)<3.5) {
			this.redInput.value = '3.5';
		 }
	} else {
		this.redInput.value = '6';
	}
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-sampler.js
* pixel RGB values sampler tool from the preview window.
* 9th October 2016
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKSampler(tweaksBox, inputs, messages, files) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.files = files;
	this.p = 15;
	this.messages.addUI(this.p,this);
	this.titles = [];
	this.gridsX = [];
	this.gridsY = [];
	this.sampleData = [];
	this.gridX = [];
	this.gridY = [];
	this.sampleSet = 1;
	this.io();
	this.ui();
	this.events();
}
TWKSampler.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox';
	this.tweakCheck.checked = false;
	// Tweak - Specific Inputs
	// Set Grid Button
	this.setGrid = false;
	this.setGridButton = document.createElement('input');
	this.setGridButton.setAttribute('type','button');
	this.setGridButton.value = 'Set Sample Grid';
	// Set Sample Button
	this.setSample = false;
	this.setSampleButton = document.createElement('input');
	this.setSampleButton.setAttribute('type','button');
	this.setSampleButton.value = 'Start Click To Add Sample Point';
	// Reset Grid Button
	this.resetGridButton = document.createElement('input');
	this.resetGridButton.setAttribute('type','button');
	this.resetGridButton.value = 'Reset Grid';
	this.resetGridButton.disabled = true;
	// Separator options
	this.compSep = document.createElement('select');
	this.sampSep = document.createElement('select');
	var seps = [ ',',' ',"\t","\n" ];
	var sepNames = [ 'Comma','Space','Tab','New Line' ];
	var m = seps.length;
	for (var j=0; j<m; j++) {
		var opt1 = document.createElement('option');
		opt1.value = seps[j];
		opt1.innerHTML = sepNames[j];
		if (seps[j] === "\t") {
			opt1.selected = true;
		}
		this.compSep.appendChild(opt1);
		var opt2 = document.createElement('option');
		opt2.value = seps[j];
		opt2.innerHTML = sepNames[j];
		if (seps[j] === "\n") {
			opt2.selected = true;
		}
		this.sampSep.appendChild(opt2);
	}
	// Include info
	this.gridInfoCheck = document.createElement('input');
	this.gridInfoCheck.setAttribute('type','checkbox');
	this.gridInfoCheck.className = 'twk-checkbox';
	this.gridInfoCheck.checked = false;
	// Sample Depth
	this.sampDepth = document.createElement('select');
	var depths = [8,10,12,0];
	var depthNames = ['8-bit','10-bit','12-bit','Floating Point'];
	var m = depths.length;
	for (var j=0; j<m; j++) {
		var opt3 = document.createElement('option');
		opt3.value = depths[j];
		opt3.innerHTML = depthNames[j];
		if (depths[j] === 8) {
			opt3.selected = true;
		}
		this.sampDepth.appendChild(opt3);
	}
	// Take Samples Button
	this.sampleButton = document.createElement('input');
	this.sampleButton.setAttribute('type','button');
	this.sampleButton.id = 'twk-sampler-button';
	this.sampleButton.value = 'Take Sample Set';
	this.sampleButton.disabled = true;
	// Samples Filename
	this.fileName = document.createElement('input');
	this.fileName.setAttribute('type','text');
	this.fileName.className = 'text-input';
	this.fileName.value = 'Samples';
	// Save Samples Button
	this.saveSamplesButton = document.createElement('input');
	this.saveSamplesButton.setAttribute('type','button');
	this.saveSamplesButton.value = 'Save Samples';
	this.saveSamplesButton.disabled = true;
	// Clear Data Button
	this.clearDataButton = document.createElement('input');
	this.clearDataButton.setAttribute('type','button');
	this.clearDataButton.value = 'Clear Sample Data';
	this.clearDataButton.disabled = true;
};
TWKSampler.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder-hide';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('RGB Sampler')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak-hide';
	// Tweak - Specific UI Elements
	this.box.appendChild(this.setGridButton);
	this.box.appendChild(document.createElement('br'));
	this.gridBox = document.createElement('div');
	this.gridBox.className = 'twk-tab-hide';
	this.gridBox.appendChild(this.setSampleButton);
	this.gridBox.appendChild(this.resetGridButton);
	this.box.appendChild(this.gridBox);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('File Name')));
	this.box.appendChild(this.fileName);
	this.box.appendChild(document.createElement('br'));
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Component Separator')));
	this.box.appendChild(this.compSep);
	this.box.appendChild(document.createElement('br'));
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Sample Separator')));
	this.box.appendChild(this.sampSep);
	this.box.appendChild(document.createElement('br'));
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Sample Precision')));
	this.box.appendChild(this.sampDepth);
	this.box.appendChild(document.createElement('br'));
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Include Grid Coordinates')));
	this.box.appendChild(this.gridInfoCheck);
	this.box.appendChild(document.createElement('br'));
	this.box.appendChild(this.sampleButton);
	this.box.appendChild(document.createElement('br'));
	this.box.appendChild(this.saveSamplesButton);
	this.box.appendChild(this.clearDataButton);
	this.box.appendChild(document.createElement('br'));
	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKSampler.prototype.toggleTweaks = function() {
	if (this.inputs.tweaks.checked && this.inputs.showPreview) {
		if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue !== 'Null') {
			this.holder.className = 'tweakholder';
		} else {
			this.holder.className = 'tweakholder-hide';
			this.tweakCheck.checked = false;
		}
	} else {
		this.holder.className = 'tweakholder-hide';
		this.tweakCheck.checked = false;
	}
	this.toggleTweak();
};
TWKSampler.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		this.box.className = 'tweak';
	} else {
		this.box.className = 'tweak-hide';
	}
};
TWKSampler.prototype.getTFParams = function(params) {
	// No Relevant Parameters For This Tweak
};
TWKSampler.prototype.getCSParams = function(params) {
	// No Relevant Parameters For This Tweak
};
TWKSampler.prototype.setParams = function(params) {
	if (typeof params.twkSampler !== 'undefined') {
		var p = params.twkSampler;
		this.toggleTweaks();
	}
};
TWKSampler.prototype.getSettings = function(data) {
	// Nothing to see for now...
};
TWKSampler.prototype.setSettings = function(settings) {
	// Nothing to see for now...
};
TWKSampler.prototype.getInfo = function(info) {
	// Nothing to see for now...
};
TWKSampler.prototype.isCustomGamma = function() {
	return false;
};
TWKSampler.prototype.isCustomGamut = function() {
	return false;
};
TWKSampler.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gtSetParams();
	};}(this);
	this.setGridButton.onclick = function(here){ return function(){
		here.toggleGrid();
	};}(this);
	this.resetGridButton.onclick = function(here){ return function(){
		here.resetGrid();
	};}(this);
	this.setSampleButton.onclick = function(here){ return function(){
		here.toggleSample();
	};}(this);
	this.sampleButton.onclick = function(here){ return function(){
		here.getSamples();
	};}(this);
	this.fileName.onchange = function(here){ return function(){
		here.fileName.value = here.files.filename(here.fileName.value);
	};}(this);
	this.saveSamplesButton.onclick = function(here){ return function(){
		here.saveSamples();
	};}(this);
	this.clearDataButton.onclick = function(here){ return function(){
		here.clearData();
	};}(this);
};
// Tweak-Specific Code
TWKSampler.prototype.toggleGrid = function() {
	if (this.setGrid) {
		this.setGridButton.value = 'Set Sample Grid';
		this.gridBox.className = 'twk-tab-hide';
		this.inputs.samplerCanvas.className = 'can-hide';
		this.setGrid = false;
	} else {
		this.setGridButton.value = 'Hide Sample Grid';
		this.gridBox.className = 'twk-tab';
		if (this.inputs.small) {
			this.inputs.samplerCanvas.className = 'can-2-small';
		} else {
			this.inputs.samplerCanvas.className = 'can-2-large';
		}
		this.setGrid = true;
	}
};
TWKSampler.prototype.toggleSample = function() {
	if (this.setSample) {
		this.setSampleButton.value = 'Start Click To Add Sample Point';
		this.setSample = false;
	} else {
		this.setSampleButton.value = 'Stop Click To Add Sample Point';
		this.setSample = true;
		this.messages.takePreviewClick(1);
	}
};
TWKSampler.prototype.resetGrid = function() {
	this.gridX = [];
	this.gridY = [];
	this.inputs.samplerCtx.clearRect(0, 0, this.inputs.samplerCanvas.width, this.inputs.samplerCanvas.height);
	this.resetGridButton.disabled = true;
	this.sampleButton.disabled = true;
};
TWKSampler.prototype.getSamples = function() {
	var data = this.messages.getSamples(this.gridX,this.gridY);
	this.titles.push(data.title);
	this.gridsX.push(new Float64Array(this.gridX));
	this.gridsY.push(new Float64Array(this.gridY));
	this.sampleData.push(data.samples);
	this.sampleSet++;
	this.sampleButton.value = 'Take Sample Set ' + this.sampleSet.toString();
	if (this.clearDataButton.disabled) {
		this.clearDataButton.disabled = false;
		this.saveSamplesButton.disabled = false;
	}
};
TWKSampler.prototype.clearData = function() {
	this.titles = [];
	this.grids = [];
	this.sampleData = [];
	this.sampleSet = 1;
	this.sampleButton.value = 'Take Sample Set';
	this.saveSamplesButton.disabled = true;
	this.clearDataButton.disabled = true;
};
TWKSampler.prototype.previewSample = function(x,y) {
	if (this.tweakCheck.checked && this.setSample) {
		var rect = this.inputs.previewCanvas.getBoundingClientRect();
		x = (x - rect.left)/rect.width;
		y = (y - rect.top)/rect.height;
		this.gridX.push(x);
		this.gridY.push(y);
		x *= parseInt(this.inputs.samplerCanvas.width);
		y *= parseInt(this.inputs.samplerCanvas.height);
		this.inputs.samplerCtx.beginPath();
		this.inputs.samplerCtx.strokeStyle = '#00ffff';
		this.inputs.samplerCtx.lineWidth = 2;
		this.inputs.samplerCtx.arc(x,y,14,0,2*Math.PI,false);
		this.inputs.samplerCtx.stroke();
		this.inputs.samplerCtx.fillStyle = '#00ffff';
		this.inputs.samplerCtx.font = '20px  "Avant Garde", Avantgarde, "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
		this.inputs.samplerCtx.lineWidth = 1;
		this.inputs.samplerCtx.textBaseline = "middle";
		this.inputs.samplerCtx.textAlign = "center";
		this.inputs.samplerCtx.fillText(this.gridX.length,x,y);
		this.inputs.samplerCtx.stroke();		
		if (this.sampleButton.disabled) {
			this.resetGridButton.disabled = false;
			this.sampleButton.disabled = false;
		}
	}
};
TWKSampler.prototype.saveSamples = function() {
	var out = '';
	var d = parseInt(this.sampDepth.options[this.sampDepth.selectedIndex].value);
	if (d !== 0) {
		d = Math.pow(2,d)-1;
	}
	var cs = this.compSep.options[this.compSep.selectedIndex].value;
	var ss = this.sampSep.options[this.sampSep.selectedIndex].value;
	var gridInfo = this.gridInfoCheck.checked;
	var m = this.titles.length;
	var m2,k,data;
	for (var j=0; j<m; j++) {
		out += this.titles[j] + "\n";
		if (gridInfo) {
			out += 'GridX' + cs + 'GridY' + cs;
		}
		out += 'Red' + cs + 'Green' + cs + 'Blue' + ss
		data = this.sampleData[j];
		m2 = data.length/3;
		for (var i=0; i<m2; i++) {
			k = i*3;
			if (gridInfo) {
				out += this.gridsX[j][i].toFixed(4).toString() + cs + this.gridsY[j][i].toFixed(4).toString() + cs;
			}
			if (d === 0) {
				out += data[ k ].toFixed(8).toString() + cs;
				out += data[k+1].toFixed(8).toString() + cs;
				out += data[k+2].toFixed(8).toString() + ss;
			} else {
				out += Math.round(d*((data[ k ]*876)+64)/1023).toString() + cs;
				out += Math.round(d*((data[k+1]*876)+64)/1023).toString() + cs;
				out += Math.round(d*((data[k+2]*876)+64)/1023).toString() + ss;
			}
		}
		out += "\n";
	}
	this.files.save( out, this.fileName.value, 'txt', 2 );
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* twk-la.js
* LUTAnalyst object for the LUTCalc Web App.
* 10th April 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function TWKLA(tweaksBox, inputs, messages, files, formats) {
	this.tweaksBox = tweaksBox;
	this.inputs = inputs;
	this.messages = messages;
	this.files = files;
	this.formats = formats;
	this.validExts = this.formats.validExts();
	this.isTxt = this.formats.isTxt();
	this.p = 10;
	this.messages.addUI(this.p,this);
	this.io();
	this.ui();
	lutcalcReady(this.p);
}
TWKLA.prototype.io = function() {
	// Tweak Checkbox
	this.tweakCheck = document.createElement('input');
	this.tweakCheck.setAttribute('type','checkbox');
	this.tweakCheck.className = 'twk-checkbox-hide';
	this.tweakCheck.checked = false;
	// Tweak - Specific Inputs
	this.analysed = document.createElement('input');
	this.analysed.setAttribute('type','hidden');
	this.analysed.value = '0';

	this.newOpt = this.createRadioElement('newOrLoad',true);
	this.oldOpt = this.createRadioElement('newOrLoad',false);
	this.inputs.addInput('laNewOld',[this.newOpt,this.oldOpt]);

	this.fileInput = document.createElement('input');
	if (this.inputs.isApp) {
		this.fileInput.setAttribute('type','text');
	} else {
		this.fileInput.setAttribute('type','file');
	}
	this.inputs.addInput('laFileData',{});

	this.title = document.createElement('input');
	this.inputs.addInput('laTitle',this.title);

	this.gammaSelect = document.createElement('select');
	var max = this.inputs.gammaInList.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = this.inputs.gammaInList[j].idx;
		option.appendChild(document.createTextNode(this.inputs.gammaInList[j].name));
		this.gammaSelect.appendChild(option);
	}
	this.inputs.addInput('laGammaSelect',this.gammaSelect);
	this.linGammaSelect = document.createElement('select');
	max = this.inputs.gammaLinList.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = this.inputs.gammaLinList[j].idx;
		option.appendChild(document.createTextNode(this.inputs.gammaLinList[j].name));
		this.linGammaSelect.appendChild(option);
	}
	this.inputs.addInput('laLinGammaSelect',this.linGammaSelect);

	this.gamutSelect = document.createElement('select');
	max = this.inputs.gamutLAList.length;
	for (var j=0; j<max; j++) {
		var option = document.createElement('option');
		option.value = this.inputs.gamutLAList[j].idx;
		option.appendChild(document.createTextNode(this.inputs.gamutLAList[j].name));
		this.gamutSelect.appendChild(option);
	}
	this.inputs.addInput('laGamutSelect',this.gamutSelect);

	this.pqOOTFLw = document.createElement('input');
	this.pqOOTFLw.setAttribute('type','number');
	this.pqOOTFLw.setAttribute('step',1);
	this.pqOOTFLw.className = 'base-input';
	this.pqOOTFLw.value = 10000;
	this.pqEOTFLw = document.createElement('input');
	this.pqEOTFLw.setAttribute('type','number');
	this.pqEOTFLw.setAttribute('step',1);
	this.pqEOTFLw.className = 'base-input';
	this.pqEOTFLw.value = 10000;
	this.hlgOOTFLw = document.createElement('input');
	this.hlgOOTFLw.setAttribute('type','number');
	this.hlgOOTFLw.setAttribute('step',1);
	this.hlgOOTFLw.className = 'base-input';
	this.hlgOOTFLw.value = 1000;
	this.hlgOOTFLb = document.createElement('input');
	this.hlgOOTFLb.setAttribute('type','number');
	this.hlgOOTFLb.setAttribute('step',1);
	this.hlgOOTFLb.className = 'base-input';
	this.hlgOOTFLb.value = 0;
	this.hlgScale = [];
	this.hlgScale[0] = lutRadioElement('hlgScale', true); // NHK / Base Spec (90% maps to 50% IRE)
	this.hlgScale[1] = lutRadioElement('hlgScale', false); // BBC (90% maps to 75% IRE)
	this.arriLegal = [];
	this.arriLegal[0] = lutRadioElement('arriLegal', true); // arri recording range
	this.arriLegal[1] = lutRadioElement('arriLegal', false);

	this.dim33 = this.createRadioElement('lutAnalystDim',false);
	this.dim65 = this.createRadioElement('lutAnalystDim',true);
	this.inputs.addInput('laDim',[this.dim33,this.dim65]);
	
	this.oldMethod = 1;
	this.intCub = this.createRadioElement('intMethod',false);
	this.intTet = this.createRadioElement('intMethod',false);
	this.intLin = this.createRadioElement('intMethod',false);
	this.inputs.addInput('laIntMethod',[this.intCub,this.intTet,this.intLin]);
	this.inputs.laIntMethod[this.oldMethod].checked = true;

	this.dlOpt = this.createRadioElement('range',true);
	this.ddOpt = this.createRadioElement('range',false);
	this.llOpt = this.createRadioElement('range',false);
	this.ldOpt = this.createRadioElement('range',false);
	this.inputs.addInput('laRange',[this.dlOpt,this.ddOpt,this.llOpt,this.ldOpt]);

	this.advancedCheck = document.createElement('input');
	this.advancedCheck.setAttribute('type','checkbox');
	this.advancedCheck.className = 'twk-checkbox';
	this.advancedCheck.checked = false;

	this.intGenCub = this.createRadioElement('intGenMethod',false);
	this.intGenTet = this.createRadioElement('intGenMethod',false);
	this.intGenLin = this.createRadioElement('intGenMethod',false);
	this.inputs.addInput('laIntGenMethod',[this.intGenCub,this.intGenTet,this.intGenLin]);
	this.inputs.laIntGenMethod[this.oldMethod].checked = true;

	this.oldPreMethod = this.oldMethod;
	this.intPreCub = this.createRadioElement('intPreMethod',false);
	this.intPreTet = this.createRadioElement('intPreMethod',false);
	this.intPreLin = this.createRadioElement('intPreMethod',false);
	this.inputs.addInput('laIntPreMethod',[this.intPreCub,this.intPreTet,this.intPreLin]);
	this.inputs.laIntPreMethod[this.oldMethod].checked = true;

	this.doButton = document.createElement('input');
	this.doButton.setAttribute('type','button');
	this.doButton.className = 'twk-button-hide';
	this.doButton.value = 'Analyse';

	this.declampButton = document.createElement('input');
	this.declampButton.setAttribute('type','button');
	this.declampButton.className = 'twk-button-hide';
	this.declampButton.value = 'Declip';

	this.storeButton = document.createElement('input');
	this.storeButton.setAttribute('type','button');
	this.storeButton.className = 'twk-button-hide';
	this.storeButton.value = 'Save Cube';

	this.storeBinButton = document.createElement('input');
	this.storeBinButton.setAttribute('type','button');
	this.storeBinButton.className = 'twk-button-hide';
	this.storeBinButton.value = 'Save Binary';

	this.backButton = document.createElement('input');
	this.backButton.setAttribute('type','button');
	this.backButton.className = 'twk-button-hide';
	this.backButton.value = 'New LUT';
	
	this.showGt = true;
	// LUTAnalyst Object
	lutInputs.addInput('lutAnalyst',new LUTAnalyst(this.inputs, this.messages));
};
TWKLA.prototype.ui = function() {
	// General Tweak Holder (Including Checkbox)
	this.holder = document.createElement('div');
	this.holder.className = 'tweakholder';
	this.tweaksBox.appendChild(this.holder);
	this.holder.appendChild(document.createElement('label').appendChild(document.createTextNode('LUTAnalyst')));
	this.holder.appendChild(this.tweakCheck);
	// Tweak Box - Inputs Which Appear When the Tweak Checkbox Is Ticked
	this.box = document.createElement('div');
	this.box.className = 'tweak';
// Tweak - Specific UI Elements
	// Initial box - choose between loading a LUT or previously analysed LUTAnalyst file.
	this.startBox = document.createElement('div');
	this.startBox.appendChild(this.newOpt);
	this.startBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Import New LUT')));
	this.startBox.appendChild(this.oldOpt);
	this.startBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Load Existing Analysed LA LUT')));
	this.startBox.appendChild(document.createElement('br'));
	this.startBox.appendChild(this.fileInput);
	this.startBox.className = 'twk-tab';
	this.box.appendChild(this.startBox);
	// LUT being analysed parameters
	this.analysisBox = document.createElement('div');
	this.analysisBox.appendChild(document.createElement('label').appendChild(document.createTextNode('LUT Title')));
	this.analysisBox.appendChild(this.title);
	this.analysisBox.appendChild(document.createElement('br'));
	this.analysisBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Input Gamma')));
	this.analysisBox.appendChild(this.gammaSelect);
	this.analysisBox.appendChild(document.createElement('br'));
	this.linGammaBox = document.createElement('div');
	this.linGammaBox.appendChild(document.createElement('label').appendChild(document.createTextNode('γ Correction')));
	this.linGammaBox.appendChild(this.linGammaSelect);
	this.linGammaBox.className = 'twk-tab-hide';
	this.analysisBox.appendChild(this.linGammaBox);

	this.pqOOTFBox = document.createElement('div');
	this.pqOOTFBox.className = 'twk-tab-hide';
	this.pqOOTFBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Display: Peak Mastering Level (Lw)')));
	this.pqOOTFBox.appendChild(this.pqOOTFLw);
	this.pqOOTFBox.appendChild(document.createElement('label').appendChild(document.createTextNode('nits')));
	this.analysisBox.appendChild(this.pqOOTFBox);
	this.pqEOTFBox = document.createElement('div');
	this.pqEOTFBox.className = 'twk-tab-hide';
	this.pqEOTFBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Display: Peak Mastering Level (Lw)')));
	this.pqEOTFBox.appendChild(this.pqEOTFLw);
	this.pqEOTFBox.appendChild(document.createElement('label').appendChild(document.createTextNode('nits')));
	this.analysisBox.appendChild(this.pqEOTFBox);
	this.hlgOOTFBox = document.createElement('div');
	this.hlgOOTFBox.className = 'twk-tab-hide';
	this.hlgOOTFBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Display: Peak Mastering Level (Lw)')));
	this.hlgOOTFBox.appendChild(this.hlgOOTFLw);
	this.hlgOOTFBox.appendChild(document.createElement('label').appendChild(document.createTextNode('nits')));
//	this.hlgOOTFInBox.appendChild(this.hlgOOTFLbIn);
	this.analysisBox.appendChild(this.hlgOOTFBox);
	this.hlgOETFBox = document.createElement('div');
	this.hlgOETFBox.className = 'twk-tab-hide';
	this.hlgOETFBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Reference White Scaling')));
	this.hlgOETFBox.appendChild(this.hlgScale[0]);
	this.hlgOETFBox.appendChild(document.createElement('label').appendChild(document.createTextNode('NHK / Spec. Base')));
	this.hlgOETFBox.appendChild(this.hlgScale[1]);
	this.hlgOETFBox.appendChild(document.createElement('label').appendChild(document.createTextNode('BBC')));
	this.analysisBox.appendChild(this.hlgOETFBox);

	this.arriLegalBox = document.createElement('div');
	this.arriLegalBox.className = 'twk-tab-hide';
	this.arriLegalBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Codec Range')));
	this.arriLegalBox.appendChild(this.arriLegal[0]);
	this.arriLegalBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Legal')));
	this.arriLegalBox.appendChild(this.arriLegal[1]);
	this.arriLegalBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Full Range')));
	this.analysisBox.appendChild(this.arriLegalBox);

	this.gamutBox = document.createElement('div');
	this.gamutBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Input Gamut')));
	this.gamutBox.appendChild(this.gamutSelect);
	this.gamutBox.appendChild(document.createElement('br'));
	this.gamutBox.className = 'twk-tab-hide';
	this.analysisBox.appendChild(this.gamutBox);
	this.analysisBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Analysis Dimension:')));
	this.analysisBox.appendChild(this.dim33);
	this.analysisBox.appendChild(document.createElement('label').appendChild(document.createTextNode('33x33x33')));
	this.analysisBox.appendChild(this.dim65);
	this.analysisBox.appendChild(document.createElement('label').appendChild(document.createTextNode('65x65x65')));
	this.analysisBox.appendChild(document.createElement('br'));
	this.analysisBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Analysis Method:')));
	this.analysisBox.appendChild(this.intCub);
	this.analysisBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Tricubic')));
	this.analysisBox.appendChild(this.intTet);
	this.analysisBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Tetrahedral')));
	this.analysisBox.appendChild(this.intLin);
	this.analysisBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Trilinear')));
	this.analysisBox.appendChild(document.createElement('br'));
	var rangeBox = document.createElement('div');
	rangeBox.className = 'twk-narrow-sub-box';
	rangeBox.appendChild(document.createElement('label').appendChild(document.createTextNode('LUT Range  ')));
	rangeBox.appendChild(document.createElement('br'));
	rangeBox.appendChild(this.dlOpt);
	rangeBox.appendChild(document.createElement('label').appendChild(document.createTextNode('109%→100%')));
	rangeBox.appendChild(this.ddOpt);
	rangeBox.appendChild(document.createElement('label').appendChild(document.createTextNode('109%→109%')));
	rangeBox.appendChild(document.createElement('br'));
	rangeBox.appendChild(this.llOpt);
	rangeBox.appendChild(document.createElement('label').appendChild(document.createTextNode('100%→100%')));
	rangeBox.appendChild(this.ldOpt);
	rangeBox.appendChild(document.createElement('label').appendChild(document.createTextNode('100%→109%')));
	this.analysisBox.appendChild(rangeBox);
	// Add the analysis box to the main box
	this.analysisBox.className = 'twk-tab-hide';
	this.box.appendChild(this.analysisBox);
	// Advanced settings Checkbox
	this.advancedCheckBox = document.createElement('div');
	this.advancedCheckBox.className = 'twk-tab-hide';
	this.advancedCheckBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Advanced Settings')));
	this.advancedCheckBox.appendChild(this.advancedCheck);
	// Advanced Box - Holds Advanced Or Experimental Inputs
	this.advancedBox = document.createElement('div');
	this.advancedBox.className = 'twk-advanced-hide';
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Generation Method:')));
	this.advancedBox.appendChild(this.intGenCub);
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Tricubic')));
	this.advancedBox.appendChild(this.intGenTet);
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Tetrahedral')));
	this.advancedBox.appendChild(this.intGenLin);
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Trilinear')));
	this.advancedBox.appendChild(document.createElement('br'));
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Preview Method:')));
	this.advancedBox.appendChild(this.intPreCub);
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Tricubic')));
	this.advancedBox.appendChild(this.intPreTet);
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Tetrahedral')));
	this.advancedBox.appendChild(this.intPreLin);
	this.advancedBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Trilinear')));
	this.advancedBox.appendChild(document.createElement('br'));
	this.advancedBox.appendChild(this.declampButton);
	this.advancedCheckBox.appendChild(this.advancedBox);
	// Buttons
	this.box.appendChild(this.doButton);
	this.box.appendChild(this.storeButton);
	this.box.appendChild(this.storeBinButton);
	this.box.appendChild(this.backButton);
	this.box.appendChild(this.advancedCheckBox);

	// Build Box Hierarchy
	this.holder.appendChild(this.box);
};
TWKLA.prototype.toggleTweaks = function() {
	// LUTAnalyst will always be visible
};
TWKLA.prototype.toggleTweak = function() {
	if (this.tweakCheck.checked) {
		if (parseInt(this.inputs.inGamma.options[this.inputs.inGamma.options.length - 1].value) !== this.inputs.gammaLA) {
			var laOption = document.createElement('option');
				laOption.value = this.inputs.gammaLA;
				laOption.innerHTML = 'LA - ' + this.title.value;
			this.inputs.inGamma.appendChild(laOption);
		} else {
			this.inputs.inGamma.options[this.inputs.inGamma.options.length - 1].innerHTML = 'LA - ' + this.title.value;
		}
		if (parseInt(this.inputs.outGamma.options[this.inputs.outGamma.options.length - 1].value) !== this.inputs.gammaLA) {
			var laOption = document.createElement('option');
				laOption.value = this.inputs.gammaLA;
				laOption.innerHTML = 'LA - ' + this.title.value;
			this.inputs.outGamma.appendChild(laOption);
		} else {
			this.inputs.outGamma.options[this.inputs.outGamma.options.length - 1].innerHTML = 'LA - ' + this.title.value;
		}
		if (parseInt(this.inputs.outGamut.options[this.inputs.outGamut.options.length - 1].value) !== this.inputs.gamutLA) {
			var laOption = document.createElement('option');
				laOption.value = this.inputs.gamutLA;
				laOption.innerHTML = 'LA - ' + this.title.value;
			this.inputs.outGamut.appendChild(laOption);
		} else {
			this.inputs.outGamut.options[this.inputs.outGamut.options.length - 1].innerHTML = 'LA - ' + this.title.value;
		}
		if (parseInt(this.inputs.twkHGSelect.options[this.inputs.twkHGSelect.options.length - 1].value) !== this.inputs.gamutLA) {
			var laOption = document.createElement('option');
				laOption.value = this.inputs.gamutLA;
				laOption.innerHTML = 'LA - ' + this.title.value;
			this.inputs.twkHGSelect.appendChild(laOption);
		} else {
			this.inputs.twkHGSelect.options[this.inputs.twkHGSelect.options.length - 1].innerHTML = 'LA - ' + this.title.value;
		}
		if (this.showGt) {
			this.inputs.outGamut.options[this.inputs.outGamut.options.length - 1].className = 'select-item';
			this.inputs.twkHGSelect.options[this.inputs.twkHGSelect.options.length - 1].className = 'select-item';
		} else {
			this.inputs.outGamut.options[this.inputs.outGamut.options.length - 1].className = 'select-item-hide';
			this.inputs.twkHGSelect.options[this.inputs.twkHGSelect.options.length - 1].className = 'select-item-hide';
		}
	} else {
		if (parseInt(this.inputs.inGamma.options[this.inputs.inGamma.options.selectedIndex].value) === this.inputs.gammaLA) {
			this.inputs.inGamma.options[0].selected = true;
		}
		if (parseInt(this.inputs.inGamma.options[this.inputs.inGamma.options.length - 1].value) === this.inputs.gammaLA) {
			this.inputs.inGamma.remove(this.inputs.inGamma.options.length - 1);
		}
		if (parseInt(this.inputs.outGamma.options[this.inputs.outGamma.options.selectedIndex].value) === this.inputs.gammaLA) {
			this.inputs.outGamma.options[0].selected = true;
		}
		if (parseInt(this.inputs.outGamma.options[this.inputs.outGamma.options.length - 1].value) === this.inputs.gammaLA) {
			this.inputs.outGamma.remove(this.inputs.outGamma.options.length - 1);
		}
		if (parseInt(this.inputs.outGamut.options[this.inputs.outGamut.options.selectedIndex].value) === this.inputs.gamutLA) {
			this.inputs.outGamut.options[0].selected = true;
		}
		if (parseInt(this.inputs.outGamut.options[this.inputs.outGamut.options.length - 1].value) === this.inputs.gamutLA) {
			this.inputs.outGamut.remove(this.inputs.outGamut.options.length - 1);
		}
		if (parseInt(this.inputs.twkHGSelect.options[this.inputs.twkHGSelect.options.selectedIndex].value) === this.inputs.gamutLA) {
			this.inputs.twkHGSelect.options[0].selected = true;
		}
		if (parseInt(this.inputs.twkHGSelect.options[this.inputs.twkHGSelect.options.length - 1].value) !== this.inputs.gamutLA) {
			this.inputs.twkHGSelect.remove(this.inputs.twkHGSelect.options.length - 1);
		}
	}
};
TWKLA.prototype.getTFParams = function(params) {
	// No Relevant Parameters For This Tweak
};
TWKLA.prototype.getCSParams = function(params) {
	var out = {};
	if (this.intGenCub.checked) {
		out.genInt = 0;
	} else if (this.intGenTet.checked) {
		out.genInt = 1;
	} else {
		out.genInt = 2;
	}
	if (this.intPreCub.checked) {
		out.preInt = 0;
	} else if (this.intPreTet.checked) {
		out.preInt = 1;
	} else {
		out.preInt = 2;
	}
	params.twkLA = out;
};
TWKLA.prototype.setParams = function(params) {
	if (typeof params.twkLA !== 'undefined') {
		var p = params.twkLA;
	}
	this.syncHDRVals();
	// Any changes to UI inputs coming from the gamma and gamut workers should go here
};
TWKLA.prototype.getSettings = function(data) {
};
TWKLA.prototype.setSettings = function(settings) {
};
TWKLA.prototype.getInfo = function(info) {
};
TWKLA.prototype.isCustomGamma = function() {
	return false;
};
TWKLA.prototype.isCustomGamut = function() {
	return false;
};
TWKLA.prototype.events = function() {
	this.tweakCheck.onclick = function(here){ return function(){
		here.toggleTweak();
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
	// Event responses for input changes or click should go here
	if (this.inputs.isApp) {
		this.fileInput.onclick = function(here){ return function(){
			here.getFile();
		};}(this);
	} else {
		this.fileInput.onchange = function(here){ return function(){
			here.getFile();
		};}(this);
	}
	this.gammaSelect.onchange = function(here){ return function(){
		here.testGamma();
	};}(this);
	this.title.onchange = function(here){ return function(){
		here.cleanTitle();
	};}(this);
	this.advancedCheck.onclick = function(here){ return function(){
		here.toggleAdvanced();
	};}(this);
	this.intCub.onclick = function(here){ return function(){
		here.updateLAMethod(0);
	};}(this);
	this.intTet.onclick = function(here){ return function(){
		here.updateLAMethod(1);
	};}(this);
	this.intLin.onclick = function(here){ return function(){
		here.updateLAMethod(2);
	};}(this);
	this.intPreCub.onclick = function(here){ return function(){
		here.updatePreMethod(0);
	};}(this);
	this.intPreTet.onclick = function(here){ return function(){
		here.updatePreMethod(1);
	};}(this);
	this.intPreLin.onclick = function(here){ return function(){
		here.updatePreMethod(2);
	};}(this);
	this.doButton.onclick = function(here){ return function(){
		here.doStuff();
	};}(this);
	this.declampButton.onclick = function(here){ return function(){
		here.deClamp();
	};}(this);
	this.backButton.onclick = function(here){ return function(){
		here.reset();
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
	this.storeButton.onclick = function(here){ return function(){
		here.store(true);
	};}(this);
	this.storeBinButton.onclick = function(here){ return function(){
		here.store(false);
	};}(this);

	this.pqOOTFLw.onchange = function(here){ return function(){
		here.testPQLw();
		here.messages.gaSetParams();
	};}(this);
	this.hlgOOTFLw.onchange = function(here){ return function(){
		here.testHLGLw();
		here.messages.gaSetParams();
	};}(this);
	this.pqEOTFLw.onchange = function(here){ return function(){
		here.testPQEOTFLw();
		here.messages.gaSetParams();
	};}(this);
	this.hlgScale[0].onchange = function(here){ return function(){
		here.testNHKBBC();
		here.messages.gaSetParams();
	};}(this);
	this.hlgScale[1].onchange = function(here){ return function(){
		here.testNHKBBC();
		here.messages.gaSetParams();
	};}(this);
	this.arriLegal[0].onchange = function(here){ return function(){
		here.testARRILegal();
		here.messages.gaSetParams();
	};}(this);
	this.arriLegal[1].onchange = function(here){ return function(){
		here.testARRILegal();
		here.messages.gaSetParams();
	};}(this);
};
// Tweak-Specific Code
TWKLA.prototype.testPQLw = function() {
	var Lw = parseFloat(this.pqOOTFLw.value);
	if (isNaN(Lw)) {
		Lw = 10000;
	} else {
		Lw = Math.round(Math.max(100,Math.min(10000,Lw)));
	}
	this.pqOOTFLw.value = Lw;
	this.inputs.inPQLw.value = this.pqOOTFLw.value;
//	this.inputs.outPQLw.value = this.pqOOTFLw.value;
};
TWKLA.prototype.testPQEOTFLw = function() {
	var Lw = parseFloat(this.pqEOTFLw.value);
	if (isNaN(Lw)) {
		Lw = 10000;
	} else {
		Lw = Math.round(Math.max(100,Math.min(10000,Lw)));
	}
	this.pqEOTFLw.value = Lw;
	this.inputs.inPQEOTFLw.value = this.pqEOTFLw.value;
//	this.inputs.outPQEOTFLw.value = this.pqEOTFLw.value;
};
TWKLA.prototype.testHLGLw = function() {
	var Lw = parseFloat(this.hlgOOTFLw.value);
	if (isNaN(Lw)) {
		Lw = 1000;
	} else {
		Lw = Math.round(Lw);
	}
	this.hlgOOTFLw.value = Lw;
	this.inputs.inHLGLw.value = this.hlgOOTFLw.value;
//	this.inputs.outHLGLw.value = this.hlgOOTFLw.value;
};
TWKLA.prototype.testNHKBBC = function() {
	this.inputs.hlgBBCScaleIn[0].checked = this.hlgScale[0].checked;
	this.inputs.hlgBBCScaleIn[1].checked = this.hlgScale[1].checked;
//	this.inputs.hlgBBCScaleOut[0].checked = this.hlgScale[0].checked;
//	this.inputs.hlgBBCScaleOut[1].checked = this.hlgScale[1].checked;
};
TWKLA.prototype.testARRILegal = function() {
	this.inputs.arriLegalIn[0].checked = this.arriLegal[0].checked;
	this.inputs.arriLegalIn[1].checked = this.arriLegal[1].checked;
	this.messages.updateARRIRangeIn();
};
TWKLA.prototype.createRadioElement = function(name, checked) {
    var radioInput;
    try {
        var radioHtml = '<input type="radio" name="' + name + '"';
        if ( checked ) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += '/>';
        radioInput = document.createElement(radioHtml);
    } catch( err ) {
        radioInput = document.createElement('input');
        radioInput.setAttribute('type', 'radio');
        radioInput.setAttribute('name', name);
        if ( checked ) {
            radioInput.setAttribute('checked', 'checked');
        }
    }
    return radioInput;
};
TWKLA.prototype.getFile = function() {
	var validExts = [];
	var isTxt = [];
	if (this.newOpt.checked) {
		validExts = this.validExts.slice(0);
		isTxt = this.isTxt.slice(0);
	} else {
		validExts = ['lacube','labin'];
		isTxt = [true, false];
	}
	if (this.inputs.isApp || this.fileInput.value !== '') {
		this.files.loadLUTFromInput(this.fileInput, validExts, isTxt, 'laFileData', this, 0);
	}
};
TWKLA.prototype.followUp = function(input) {
	switch (input) {
		case 0:	this.gotFile();
				break;
		default:break;
	}
};
TWKLA.prototype.gotFile = function() {
	this.startBox.className = 'twk-tab-hide';
	this.backButton.className = 'twk-button';
	if (this.newOpt.checked) {
		this.analysisBox.className = 'twk-tab';
		this.testGamma();
		this.inputs.lutAnalyst.reset();
		var parsed = false;
 		if (this.inputs.laFileData.isTxt) {
			parsed = this.formats.parse(this.inputs.laFileData.format,this.inputs.laFileData.title, this.inputs.laFileData.text, this.inputs.lutAnalyst, 'inLUT');
		} else {
			parsed = this.formats.parse(this.inputs.laFileData.format,this.inputs.laFileData.title, this.inputs.laFileData.buff, this.inputs.lutAnalyst, 'inLUT');
		}
		if (parsed) {
			this.title.value = this.inputs.lutAnalyst.getTitle('in');
			this.doButton.className = 'twk-button';
			this.advancedCheckBox.className = 'twk-tab';
			if (this.inputs.lutAnalyst.is3D()) {
				this.showGt = true;
				this.gamutBox.className = 'twk-tab';
			} else {
				this.showGt = false;
				this.gamutBox.className = 'twk-tab-hide';
			}
			if (this.inputs.lutAnalyst.inLUT.isClamped()) {
				this.declampButton.value = 'Declip';
				this.declampButton.disabled = false;
			} else {
				this.declampButton.value = 'Unclipped';
				this.declampButton.disabled = true;
			}
			this.declampButton.className = 'twk-button';
			
		} else {
			this.reset();
		}
	} else {
		this.doButton.className = 'twk-button-hide';
		this.declampButton.className = 'twk-button-hide';
		this.inputs.lutAnalyst.reset();
		var parsed = false;
		switch (this.inputs.laFileData.format) {
			case 'lacube': parsed = this.inputs.laCube.parse(this.inputs.laFileData.title, this.inputs.laFileData.text, this.inputs.lutAnalyst, 'tf', 'cs');
						   break;
			case 'labin': parsed = this.inputs.laBin.parse(this.inputs.laFileData.title, this.inputs.laFileData.buff, this.inputs.lutAnalyst, 'tf', 'cs');
						  break;
		}
		if (parsed) {
			if (this.inputs.lutAnalyst.cs) {
				this.showGt = true;
			} else {
				this.showGt = false;
			}
			this.title.value = this.inputs.lutAnalyst.getTitle('tf');
			this.advancedCheckBox.className = 'twk-tab';
			this.inputs.lutAnalyst.updateLATF(true);
			if (this.showGt) {
				this.inputs.lutAnalyst.updateLACS();
			}
			this.tweakCheck.checked = true;
			this.tweakCheck.className = 'twk-checkbox';
			this.toggleTweak();
		} else {
			this.reset();
		}
	}
};
TWKLA.prototype.testGamma = function() {
	// Hide Everything
	this.linGammaBox.className = 'twk-tab-hide';
	this.pqOOTFBox.className = 'twk-tab-hide';
	this.pqEOTFBox.className = 'twk-tab-hide';
	this.hlgOOTFBox.className = 'twk-tab-hide';
	this.hlgOETFBox.className = 'twk-tab-hide';
	this.arriLegalBox.className = 'twk-tab-hide';
	// Show As Required
	var idx = parseInt(this.gammaSelect.options[this.gammaSelect.options.selectedIndex].value);
	if (idx === 9999) {
		this.linGammaBox.className = 'twk-tab';
		idx = parseInt(this.linGammaSelect.options[this.linGammaSelect.options.selectedIndex].value);
		if (idx === this.inputs.gammaPQOOTF || idx === this.inputs.gammaPQOOTF + 1) {
			this.pqOOTFBox.className = 'twk-tab';
		} else if (idx === this.inputs.gammaHLGOOTF || idx === this.inputs.gammaHLGOOTF + 1) {
			this.hlgOOTFBox.className = 'twk-tab';
			this.hlgOETFBox.className = 'twk-tab';
		}
	} else if (idx === this.inputs.gammaPQ || idx === this.inputs.gammaPQOOTF || idx === this.inputs.gammaPQOOTF + 1) {
		this.pqOOTFBox.className = 'twk-tab';
	} else if (idx === this.inputs.gammaPQ + 1 || idx === this.inputs.gammaHLGOOTF || idx === this.inputs.gammaHLGOOTF + 1) {
		this.hlgOOTFBox.className = 'twk-tab';
		this.hlgOETFBox.className = 'twk-tab';
	} else if (idx === this.inputs.gammaPQEOTF) {
		this.pqEOTFBox.className = 'twk-tab';
	} else if (idx === this.inputs.gammaHLG) {
		this.hlgOETFBox.className = 'twk-tab';
	} else if (this.inputs.gammaArriList.indexOf(idx) > -1) {
		this.arriLegalBox.className = 'twk-tab';
	}
};
TWKLA.prototype.doStuff = function() {
	this.cleanTitle();
	this.inputs.lutAnalyst.getTF();
};
TWKLA.prototype.doneStuff = function() {
	this.tweakCheck.checked = true;
	this.tweakCheck.className = 'twk-checkbox';
	this.doButton.value = 'Re-Analyse';
	this.storeButton.className = 'twk-button';
	this.storeBinButton.className = 'twk-button';
	this.toggleTweak();
	this.inputs.outGamma.options[this.inputs.outGamma.options.length - 1].selected = true;
	this.messages.hideGammaSubsOut();
	if (this.showGt) {
		this.inputs.outGamut.options[this.inputs.outGamut.options.length - 1].selected = true;
	}
	this.messages.changeGamma();
	if (this.showGt) {
		this.messages.changeGamut();
	}
	maxHeights();
};
TWKLA.prototype.reset = function() {
	this.tweakCheck.checked = false;
	this.tweakCheck.className = 'twk-checkbox-hide';
	if (this.inputs.outGamma.options.length > 0 && this.inputs.outGamut.options.length > 0 && this.inputs.twkHGSelect.options.length > 0) {
		if (parseInt(this.inputs.outGamma.options[this.inputs.outGamma.options.length - 1].value) === this.inputs.gammaLA) {
			this.inputs.outGamma.options[0].selected = true;
		}
		if (parseInt(this.inputs.outGamut.options[this.inputs.outGamut.options.length - 1].value) === this.inputs.gamutLA) {
			this.inputs.outGamut.options[0].selected = true;
		}
		if (parseInt(this.inputs.twkHGSelect.options[this.inputs.twkHGSelect.options.length - 1].value) === this.inputs.gamutLA) {
			this.inputs.twkHGSelect.options[0].selected = true;
		}
		this.toggleTweak();
	}
	this.inputs.lutAnalyst.reset();
	this.inputs.laFileData = {};
	this.fileInput.value = '';
	this.dlOpt.checked = true;

	this.doButton.value = 'Analyse';

	this.startBox.className = 'twk-tab';
	this.analysisBox.className = 'twk-tab-hide';
	this.linGammaBox.className = 'twk-tab-hide';
	this.advancedCheckBox.className = 'twk-tab-hide';

	this.backButton.className = 'twk-button-hide';
	this.storeButton.className = 'twk-button-hide';
	this.storeBinButton.className = 'twk-button-hide';
	this.declampButton.className = 'twk-button-hide';
	this.doButton.className = 'twk-button-hide';
	maxHeights();
};
TWKLA.prototype.store = function(cube) {
	if (this.inputs.lutAnalyst.cs) { // 3D LUT
		var meta = this.inputs.lutAnalyst.cs.getMetadata();
		var params = {
			in1DTF: 'S-Log3',
			in1DEX: true,
			in3DTF: 'S-Log3',
			in3DCS: meta.inputCS,
			sysCS: meta.sysCS,
			in3DEX: meta.inputEX,
			interpolation: meta.interpolation,
			baseISO: meta.baseISO,
			inputMatrix: meta.inputMatrix
		}
		if (meta.nativeTF !== 0) {
			params.in3DTF = meta.inputTF;
		}
		if (cube) {
			this.files.save(
				this.inputs.laCube.build(
					this.title.value,
					this.inputs.lutAnalyst.getL(),
					this.inputs.lutAnalyst.getRGB(),
					params
				),
				this.title.value,
				'lacube',
				0
			);
		} else {
			this.files.saveBinary(
				this.inputs.laBin.build(
					this.title.value,
					this.inputs.lutAnalyst.getL(),
					this.inputs.lutAnalyst.getRGB(),
					params
				),
				this.title.value,
				'labin',
				0
			);
		}
	} else {
		var params = {
			in1DTF: 'S-Log3',
			in1DEX: true,
		}
		if (cube) {
			this.files.save(
				this.inputs.laCube.build(
					this.title.value,
					this.inputs.lutAnalyst.getL(),
					false,
					params
				),
				this.title.value,
				'lacube',
				0
			);
		} else {
			this.files.saveBinary(
				this.inputs.laBin.build(
					this.title.value,
					this.inputs.lutAnalyst.getL(),
					false,
					params
				),
				this.title.value,
				'labin',
				0
			);
		}
	}
/*
	this.files.buildLA1DMethod(
		this.title.value,
		this.inputs.lutAnalyst.getL()
	);
*/
};
TWKLA.prototype.deClamp = function() {
	this.inputs.lutAnalyst.inLUT.deClamp();
	this.declampButton.value = 'Declipped';
	this.declampButton.disabled = true;
	if (this.doButton.value === 'Re-Analyse') {
		this.doStuff();
	}
/*
		this.files.save(
			this.inputs.laCube.build(
				this.title.value,
				new Float64Array(3).buffer,
				this.inputs.lutAnalyst.inLUT.getRGB()
			),
			'test',
			'cube',
			0
		);
*/
};
TWKLA.prototype.toggleAdvanced = function() {
	if (this.advancedCheck.checked) {
		this.advancedBox.className = 'twk-advanced';
	} else {
		this.advancedBox.className = 'twk-advanced-hide';
	}
};
TWKLA.prototype.updatePreMethod = function(newPreMethod) {
	if (newPreMethod !== this.oldPreMethod) {
		this.oldPreMethod = newPreMethod;
		this.messages.gtSetParams();
	}
};
TWKLA.prototype.updateLAMethod = function(newMethod) {
	if (newMethod !== this.oldMethod) {
		switch (newMethod) {
			case 0:  this.intGenCub.checked = true;
					 this.intPreCub.checked = true;
					 break;
			case 1:  this.intGenTet.checked = true;
					 this.intPreTet.checked = true;
					 break;
			case 2:
			default: this.intGenLin.checked = true;
					 this.intPreLin.checked = true;
					 break;
		}
		this.oldMethod = newMethod;
	}
};
TWKLA.prototype.syncHDRVals = function(here) {
	if (here) { // send from here to the gamma box
		this.inputs.inPQLw.value = this.pqOOTFLw.value;
//		this.inputs.outPQLw.value = this.pqOOTFLw.value;
		this.inputs.inPQEOTFLw.value = this.pqEOTFLw.value;
//		this.inputs.outPQEOTFLw.value = this.pqEOTFLw.value;
		this.inputs.inHLGLw.value = this.hlgOOTFLw.value;
//		this.inputs.outHLGLw.value = this.hlgOOTFLw.value;
		this.inputs.inHLGLb.value = this.hlgOOTFLb.value;
//		this.inputs.outHLGLb.value = this.hlgOOTFLb.value;
		this.inputs.hlgBBCScaleIn[0].checked = this.hlgScale[0].checked;
		this.inputs.hlgBBCScaleIn[1].checked = this.hlgScale[1].checked;
//		this.inputs.hlgBBCScaleOut[0].checked = this.hlgScale[0].checked;
//		this.inputs.hlgBBCScaleOut[1].checked = this.hlgScale[1].checked;
		this.inputs.arriLegalIn[0].checked = this.arriLegal[0].checked;
		this.inputs.arriLegalIn[1].checked = this.arriLegal[1].checked;
	} else { // collect from gamma box
		this.pqOOTFLw.value = this.inputs.inPQLw.value;
		this.pqEOTFLw.value = this.inputs.inPQEOTFLw.value;
		this.hlgOOTFLw.value = this.inputs.inHLGLw.value;
		this.hlgOOTFLb.value = this.inputs.inHLGLb.value;
		this.hlgScale[0].checked = this.inputs.hlgBBCScaleIn[0].checked;
		this.hlgScale[1].checked = this.inputs.hlgBBCScaleIn[1].checked;
		this.arriLegal[0].checked = this.inputs.arriLegalIn[0].checked;
		this.arriLegal[1].checked = this.inputs.arriLegalIn[1].checked;
	}
};
TWKLA.prototype.cleanTitle = function() {
	this.title.value = this.title.value.replace(/[/"/']/gi, '');
	if (parseInt(this.inputs.inGamma.options[this.inputs.inGamma.options.length - 1].value) === this.inputs.gammaLA) {
		this.inputs.inGamma.options[this.inputs.inGamma.options.length - 1].innerHTML = 'LA - ' + this.title.value;
	}
	if (parseInt(this.inputs.outGamma.options[this.inputs.outGamma.options.length - 1].value) === this.inputs.gammaLA) {
		this.inputs.outGamma.options[this.inputs.outGamma.options.length - 1].innerHTML = 'LA - ' + this.title.value;
	}
	if (parseInt(this.inputs.outGamut.options[this.inputs.outGamut.options.length - 1].value) === this.inputs.gamutLA) {
		this.inputs.outGamut.options[this.inputs.outGamut.options.length - 1].innerHTML = 'LA - ' + this.title.value;
	}
	if (parseInt(this.inputs.twkHGSelect.options[this.inputs.twkHGSelect.options.length - 1].value) === this.inputs.gamutLA) {
		this.inputs.twkHGSelect.options[this.inputs.twkHGSelect.options.length - 1].innerHTML = 'LA - ' + this.title.value;
	}
	maxHeights();
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* luttweaksbox.js
* Customisation of transfer curves and colour space (gamma and gamut) options UI object for the LUTCalc Web App.
* 7th October 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTTweaksBox(fieldset, inputs, messages, files, formats) {
	this.box = document.createElement('fieldset');
	this.inputs = inputs;
	this.messages = messages;
	this.p = 3;
	this.messages.addUI(this.p,this);
	this.files = files;
	this.formats = formats;
	this.tweaksList = [];
	this.gaLists = false;
	this.gtLists = false;
	this.built = false;
	fieldset.appendChild(this.box);
}
LUTTweaksBox.prototype.build = function() {
	this.io();
	this.ui();
	this.toggleTweaks();
	this.messages.gaSetParams();
	this.messages.gtSetParams();
	lutcalcReady(this.p);
};
LUTTweaksBox.prototype.io = function() {
	// Tweaks Checkbox
	this.tweaks = document.createElement('input');
	this.tweaks.setAttribute('type','checkbox');
	this.tweaks.checked = true;
	this.inputs.addInput('tweaks',this.tweaks);
	this.inputs.addInput('tweakTitles', []);
};
LUTTweaksBox.prototype.ui = function() {
	var topBox = document.createElement('div');
	topBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Customisation')));
	topBox.appendChild(this.tweaks);
	topBox.id = 'tweak-top';
	this.box.appendChild(topBox);
	this.holder = document.createElement('div');
	this.holder.id = 'tweaksholder';
	this.box.appendChild(this.holder);

	this.inputs.tweakTitles.push('Custom Colour Space');
	this.cs = this.tweaksList.length;
	this.tweaksList.push(new TWKCS(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('White Balance');
	this.wb = this.tweaksList.length;
	this.tweaksList.push(new TWKWHITE(this.holder, this.inputs, this.messages));
	this.messages.gtTx(3,17,{});
	this.inputs.tweakTitles.push('PSST-CDL');
	this.PSST = this.tweaksList.length;
	this.tweaksList.push(new TWKPSSTCDL(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('ASC-CDL');
	this.tweaksList.push(new TWKASCCDL(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('Multitone');
	this.multi = this.tweaksList.length;
	this.tweaksList.push(new TWKMulti(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('Highlight Gamut');
	this.tweaksList.push(new TWKHG(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('Knee');
	this.tweaksList.push(new TWKKnee(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('Black Level / Highlight Level');
	this.tweaksList.push(new TWKBlkHi(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('Black Gamma');
	this.tweaksList.push(new TWKBlkGam(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('SDR Saturation');
	this.sdr = this.tweaksList.length;
	this.tweaksList.push(new TWKSDRSat(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('Display Colourspace Converter');
	this.tweaksList.push(new TWKDisplay(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('Gamut Limiter');
	this.gl = this.tweaksList.length;
	this.tweaksList.push(new TWKGamutLim(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('False Colour');
	this.tweaksList.push(new TWKFC(this.holder, this.inputs, this.messages));
	this.inputs.tweakTitles.push('RGB Sampler');
	this.tweaksList.push(new TWKSampler(this.holder, this.inputs, this.messages, this.files));
	this.inputs.tweakTitles.push('LUTAnalyst');
	this.LA = this.tweaksList.length;
	this.tweaksList.push(new TWKLA(this.holder, this.inputs, this.messages, this.files, this.formats));

};
LUTTweaksBox.prototype.events = function() {
	var max = this.tweaksList.length;
	for (var j=0; j<max; j++) {
		this.tweaksList[j].events();
	}
	this.tweaks.onclick = function(here){ return function(){
		here.toggleTweaks();
		here.messages.gaSetParams();
		here.messages.gtSetParams();
	};}(this);
};
//	Event Responses
LUTTweaksBox.prototype.toggleTweaks = function() {
	var max = this.tweaksList.length;
	for (var j=0; j<max; j++) {
		this.tweaksList[j].toggleTweaks();
	}
};
LUTTweaksBox.prototype.gotGammaLists = function() {
	this.gaLists = true;
	if (this.gtLists && !this.built) {
		this.build();
		this.built = true;
	}
};
LUTTweaksBox.prototype.gotGamutLists = function() {
	this.gtLists = true;
	if (this.gaLists && !this.built) {
		this.build();
		this.built = true;
	}
};
LUTTweaksBox.prototype.changeGamut = function() {
	this.tweaksList[this.cs].toggleTweak();
	this.tweaksList[this.gl].changeGamut();
};
LUTTweaksBox.prototype.updateGammaOut = function() {
	this.tweaksList[this.sdr].toggleTweaks();
};
LUTTweaksBox.prototype.gotCATs = function(CATs) {
	this.tweaksList[this.wb].gotCATs(CATs);
};
LUTTweaksBox.prototype.getTFParams = function(params) {
	if (typeof this.tweaks !== 'undefined' && this.tweaks.checked) {
		params.tweaks = true;
	} else {
		params.tweaks = false;
	}
	var max = this.tweaksList.length;
	for (var j=0; j<max; j++) {
		this.tweaksList[j].getTFParams(params);
	}
};
LUTTweaksBox.prototype.getCSParams = function(params) {
	if (typeof this.tweaks !== 'undefined' && this.tweaks.checked) {
		params.tweaks = true;
	} else {
		params.tweaks = false;
	}
	var max = this.tweaksList.length;
	for (var j=0; j<max; j++) {
		this.tweaksList[j].getCSParams(params);
	}
};
LUTTweaksBox.prototype.setParams = function(params) {
	var max = this.tweaksList.length;
	for (var j=0; j<max; j++) {
		this.tweaksList[j].setParams(params);
	}
};
LUTTweaksBox.prototype.psstColours = function(params) {
	this.tweaksList[this.PSST].psstColours(params);
};
/*
LUTTweaksBox.prototype.gotColSqr = function(params) {
	this.tweaksList[this.multi].gotColSqr(params);
};
*/
LUTTweaksBox.prototype.multiColours = function(params) {
	this.tweaksList[this.multi].multiColours(params);
};
LUTTweaksBox.prototype.getInfo = function(info) {
	if (this.tweaks.checked) {
		info.tweaks = true;
	} else {
		info.tweaks = false;
	}
	var max = this.tweaksList.length;
	for (var j=0; j<max; j++) {
		this.tweaksList[j].getInfo(info);
	}	
};
LUTTweaksBox.prototype.followUp = function(tweak, input) {
	switch (tweak) {
		case 10:	this.tweaksList[this.LA].followUp(input);
				break;
		default:break;
	}
};
LUTTweaksBox.prototype.getSettings = function(data) {
	data.tweaksBox = {
		tweaks: this.tweaks.checked
	};
	var m = this.tweaksList.length;
	for (var j=0; j<m; j++) {
		this.tweaksList[j].getSettings(data.tweaksBox);
	}	
};
LUTTweaksBox.prototype.setSettings = function(settings) {
	if (typeof settings.tweaksBox !== 'undefined') {
		var data = settings.tweaksBox;
		if (typeof data.tweaks === 'boolean') {
			this.tweaks.checked = data.tweaks;
			this.toggleTweaks();
		}
		var m = this.tweaksList.length;
		for (var j=0; j<m; j++) {
			this.tweaksList[j].setSettings(data);
		}	
	}
};
LUTTweaksBox.prototype.getHeight = function() {
	return this.box.clientHeight;
};
LUTTweaksBox.prototype.setMaxHeight = function(height) {
	height -= 96;
	if (height < 150) {
		height = 150;
	}
	this.holder.style.maxHeight = height.toString() + 'px';
};
LUTTweaksBox.prototype.isCustomGamma = function() {
	var custom = false;
	var m = this.tweaksList.length;
	for (var j=0; j<m; j++) {
		if (this.tweaksList[j].isCustomGamma()) {
			custom = true;
		}
	}
	return custom;
};
LUTTweaksBox.prototype.isCustomGamut = function() {
	var custom = false;
	var m = this.tweaksList.length;
	for (var j=0; j<m; j++) {
		if (this.tweaksList[j].isCustomGamut()) {
			custom = true;
		}
	}
	return custom;
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* lutlutbox.js
* LUT format and title options UI object for the LUTCalc Web App.
* 7th October 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTLutBox(fieldset, inputs, messages, formats) {
	this.box = document.createElement('fieldset');
	this.inputs = inputs;
	this.catList = [];
	this.messages = messages;
	this.p = 4;
	this.messages.addUI(this.p,this);
	this.formats = formats;
	this.fieldset = fieldset;
	this.io();
	this.ui();
	fieldset.appendChild(this.box);
	lutcalcReady(this.p);
}
LUTLutBox.prototype.getFieldSet = function() {
	return this.fieldset;
};
LUTLutBox.prototype.io = function() {
	this.lutName = document.createElement('input');
	this.inputs.addInput('name',this.lutName);
	this.titleButton = document.createElement('input');
	this.titleButton.setAttribute('type','button');
	this.titleButton.value = 'Auto Title';
	this.lutOneD = this.createRadioElement('dims', false);
	this.lutThreeD = this.createRadioElement('dims', true);
	this.inputs.addInput('d',[this.lutOneD,this.lutThreeD]);
	this.oneD = document.createElement('span');
	this.inputs.addInput('oneDBox',this.oneD);
	this.threeD = document.createElement('span');
	this.inputs.addInput('threeDBox',this.threeD);
	this.lutOne = [];
	this.lutOneLabel = [];
	this.lutOne[0] = this.createRadioElement('dimension', true);
	this.lutOne[0].value = '1024';
	this.lutOneLabel[0] = document.createElement('label');
	this.lutOneLabel[0].appendChild(document.createTextNode('1024'));
	this.lutOne[1] = this.createRadioElement('dimension', false);
	this.lutOne[1].value = '4096';
	this.lutOneLabel[1] = document.createElement('label');
	this.lutOneLabel[1].appendChild(document.createTextNode('4096'));
	this.lutOne[2] = this.createRadioElement('dimension', false);
	this.lutOne[2].value = '16384';
	this.lutOneLabel[2] = document.createElement('label');
	this.lutOneLabel[2].appendChild(document.createTextNode('16384'));
	this.lutThree = [];
	this.lutThreeLabel = [];
	this.lutThree[0] = this.createRadioElement('dimension', false);
	this.lutThree[0].value = '17';
	this.lutThreeLabel[0] = document.createElement('label');
	this.lutThreeLabel[0].appendChild(document.createTextNode('17x17x17'));
	this.lutThree[1] = this.createRadioElement('dimension', false);
	this.lutThree[1].value = '33';
	this.lutThree[1].checked = true;
	this.lutThreeLabel[1] = document.createElement('label');
	this.lutThreeLabel[1].appendChild(document.createTextNode('33x33x33'));
	this.lutThree[2] = this.createRadioElement('dimension', false);
	this.lutThree[2].value = '65';
	this.lutThreeLabel[2] = document.createElement('label');
	this.lutThreeLabel[2].appendChild(document.createTextNode('65x65x65'));
	this.inputs.addInput('dimension',[this.lutOne[0],this.lutOne[1],this.lutOne[2],this.lutThree[0],this.lutThree[1],this.lutThree[2]]);	
	this.inputs.addInput('dimensionLabel',[this.lutOneLabel[0],this.lutOneLabel[1],this.lutOneLabel[2],this.lutThreeLabel[0],this.lutThreeLabel[1],this.lutThreeLabel[2]]);	
	this.lutInLegal = this.createRadioElement('inrange', false);
	this.lutInData = this.createRadioElement('inrange', true);
	this.inputs.addInput('inRange',[this.lutInLegal,this.lutInData]);	
	this.lutOutLegal = this.createRadioElement('outrange', false);
	this.lutOutData = this.createRadioElement('outrange', true);
	this.inputs.addInput('outRange',[this.lutOutLegal,this.lutOutData]);	
	this.gradeOpt = this.createRadioElement('lutusage', true);
	this.mlutOpt = this.createRadioElement('lutusage', false);
	this.inputs.addInput('lutUsage',[this.gradeOpt,this.mlutOpt]);
	this.scaleBox = document.createElement('div');
	this.inputs.addInput('scaleBox',this.scaleBox);
	this.scaleInputs = document.createElement('div');
	this.inputs.addInput('scaleInputs',this.scaleInputs);
	this.scaleCheck = document.createElement('input');
	this.inputs.addInput('scaleCheck',this.scaleCheck);
	this.scaleMin = document.createElement('input');
	this.inputs.addInput('scaleMin',this.scaleMin);
	this.scaleMax = document.createElement('input');
	this.inputs.addInput('scaleMax',this.scaleMax);
	this.bitsBox = document.createElement('div');
	this.inputs.addInput('bitsBox',this.bitsBox);
	this.inBitsSelect = document.createElement('select');
	this.inputs.addInput('inBitsSelect',this.inBitsSelect);
	this.outBitsSelect = document.createElement('select');
	this.inputs.addInput('outBitsSelect',this.outBitsSelect);
	this.nikonBox = document.createElement('div');
	this.inputs.addInput('nikonBox',this.nikonBox);
	this.nikonBank = document.createElement('select');
	this.inputs.addInput('nikonBank',this.nikonBank);
	this.nikonShr = document.createElement('input');
	this.nikonShr.setAttribute('type','range');
	this.nikonShr.setAttribute('min',0);
	this.nikonShr.setAttribute('max',9);
	this.nikonShr.setAttribute('step',1);
	this.nikonShr.setAttribute('value',0);
	this.inputs.addInput('nikonShr',this.nikonShr);
	this.nikonShrLabel = document.createElement('label');
	this.nikonSat = document.createElement('input');
	this.nikonSat.setAttribute('type','range');
	this.nikonSat.setAttribute('min',-3);
	this.nikonSat.setAttribute('max',3);
	this.nikonSat.setAttribute('step',1);
	this.nikonSat.setAttribute('value',0);
	this.inputs.addInput('nikonSat',this.nikonSat);
	this.nikonSatLabel = document.createElement('label');
	this.nikonHue = document.createElement('input');
	this.nikonHue.setAttribute('type','range');
	this.nikonHue.setAttribute('min',-3);
	this.nikonHue.setAttribute('max',3);
	this.nikonHue.setAttribute('step',1);
	this.nikonHue.setAttribute('value',0);
	this.inputs.addInput('nikonHue',this.nikonHue);
	this.nikonHueLabel = document.createElement('label');
//	this.lutClipCheck = document.createElement('input');
//	this.inputs.addInput('clipCheck',this.lutClipCheck);
	this.lutClipSelect = document.createElement('select');
	this.inputs.addInput('clipSelect',this.lutClipSelect);
	this.clipLegalBox = document.createElement('div');
	this.lutClipLegalCheck = document.createElement('input');
	this.inputs.addInput('clipLegalCheck',this.lutClipLegalCheck);
	this.buildClipSelect();
};
LUTLutBox.prototype.ui = function() {
	// LUT title / filename
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('LUT Title / Filename')));
	this.lutName.setAttribute('type','text');
	this.lutName.className = 'text-input';
	this.lutName.value = 'Custom LUT';
	this.box.appendChild(this.lutName);
	this.box.appendChild(this.titleButton);
	this.box.appendChild(document.createElement('br'));
	// 1D or 3D
	this.dims = document.createElement('span');
	this.dims.className = 'graybox';
	this.dims.appendChild(this.lutOneD);
	this.dims.appendChild(document.createElement('label').appendChild(document.createTextNode('1D')));
	this.dims.appendChild(this.lutThreeD);
	this.dims.appendChild(document.createElement('label').appendChild(document.createTextNode('3D')));
	this.box.appendChild(this.dims);
	// 1D size options
	this.oneD.className = 'graybox-hide';
	this.oneD.appendChild(this.lutOne[0]);
	this.oneD.appendChild(this.lutOneLabel[0]);
	this.oneD.appendChild(this.lutOne[1]);
	this.oneD.appendChild(this.lutOneLabel[1]);
	this.oneD.appendChild(this.lutOne[2]);
	this.oneD.appendChild(this.lutOneLabel[2]);
	this.box.appendChild(this.oneD);
	// 3D size options
	this.threeD.className = 'graybox';
	this.threeD.appendChild(this.lutThree[0]);
	this.threeD.appendChild(this.lutThreeLabel[0]);
	this.threeD.appendChild(this.lutThree[1]);
	this.threeD.appendChild(this.lutThreeLabel[1]);
	this.threeD.appendChild(this.lutThree[2]);
	this.threeD.appendChild(this.lutThreeLabel[2]);
	this.box.appendChild(this.threeD);
	this.box.appendChild(document.createElement('br'));
	// Input / output ranges
	this.lutRange = document.createElement('div');
	this.lutRange.className = 'graybox';
	this.lutRange.appendChild(document.createElement('label').appendChild(document.createTextNode('Input Range:')));
	this.lutRange.appendChild(this.lutInLegal);
	this.lutRange.appendChild(document.createElement('label').appendChild(document.createTextNode('100%')));
	this.lutRange.appendChild(this.lutInData);
	this.lutRange.appendChild(document.createElement('label').appendChild(document.createTextNode('109%')));
	this.lutRange.appendChild(document.createElement('br'));
	this.lutRange.appendChild(document.createElement('label').appendChild(document.createTextNode('Output Range:')));
	this.lutRange.appendChild(this.lutOutLegal);
	this.lutRange.appendChild(document.createElement('label').appendChild(document.createTextNode('100%')));
	this.lutRange.appendChild(this.lutOutData);
	this.lutRange.appendChild(document.createElement('label').appendChild(document.createTextNode('109%')));
	this.box.appendChild(this.lutRange);
	this.box.appendChild(document.createElement('br'));
	// Grading LUT / MLUT radio boxes
	this.lutUsage = document.createElement('div');
	this.lutUsage.className = 'graybox';
	this.lutUsage.appendChild(this.gradeOpt);
	this.lutUsage.appendChild(document.createElement('label').appendChild(document.createTextNode('Grading LUT')));
	this.lutUsage.appendChild(this.mlutOpt);
	this.lutUsage.appendChild(document.createElement('label').appendChild(document.createTextNode('Camera / Monitor LUT (MLUT)')));
	this.lutUsage.appendChild(document.createElement('br'));
	this.box.appendChild(this.lutUsage);
	// LUT type selections
	this.lutType = document.createElement('div');
	this.lutType.className = 'emptybox';
	this.lutType.appendChild(document.createElement('label').appendChild(document.createTextNode('LUT Type')));
	this.lutType.appendChild(this.inputs.gradeSelect);
	this.lutType.appendChild(this.inputs.mlutSelect);
	this.lutUsage.appendChild(this.lutType);
	// LUT input scaling (useful for narrow range gammas such as Rec709 or linear)
	this.scaleBox.className = 'emptybox-hide';
	this.scaleBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Input Scaling:')));
	this.scaleCheck.setAttribute('type','checkbox');
	this.scaleCheck.checked = false;
	this.scaleBox.appendChild(this.scaleCheck);
	this.scaleInputs.className = 'emptybox-hide';
	this.scaleInputs.appendChild(document.createElement('label').appendChild(document.createTextNode(' Min')));
	this.scaleMin.setAttribute('type','number');
	this.scaleMin.setAttribute('step','any');
	this.scaleMin.className = 'ire-input';
	this.scaleMin.value = '0';
	this.scaleInputs.appendChild(this.scaleMin);
	this.scaleInputs.appendChild(document.createElement('label').appendChild(document.createTextNode(' Max')));
	this.scaleMax.setAttribute('type','number');
	this.scaleMax.setAttribute('step','any');
	this.scaleMax.className = 'ire-input';
	this.scaleMax.value = '1';
	this.scaleInputs.appendChild(this.scaleMax);
	this.scaleBox.appendChild(this.scaleInputs);
	this.lutUsage.appendChild(this.scaleBox);
	// LUT integer bit depths for files which require it (eg 3dl)
	this.bitsBox.className = 'emptybox-hide';
	this.bitsBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Input Bits')));
	for (var j=10; j<18; j += 2) {
		var option1 = document.createElement('option');
		option1.value = j;
		option1.appendChild(document.createTextNode(j.toString() + ' (0-' + (Math.pow(2,j)-1).toString() + ')'));
		if (j === 10) {
			option1.selected = true;
		}
		var option2 = document.createElement('option');
		option2.value = j;
		option2.appendChild(document.createTextNode(j.toString() + ' (0-' + (Math.pow(2,j)-1).toString() + ')'));
		if (j === 12) {
			option2.selected = true;
		}
		this.inBitsSelect.appendChild(option1);
		this.outBitsSelect.appendChild(option2);
	}
	this.inBitsSelect.className = 'lut-opt';
	this.outBitsSelect.className = 'lut-opt';
	this.bitsBox.appendChild(this.inBitsSelect);
	this.bitsBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Output Bits')));
	this.bitsBox.appendChild(this.outBitsSelect);
	this.lutUsage.appendChild(this.bitsBox);
	// Nikon specific settings
	this.nikonBox.className = 'emptybox-hide';
	this.nikonBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Bank Number:')));
	for (var j=1; j<100; j++) {
		var option = document.createElement('option');
		option.value = j;
		option.appendChild(document.createTextNode(j.toString()));
		this.nikonBank.appendChild(option);
	}
	this.nikonBank.className = 'lut-opt';
	this.nikonBox.appendChild(this.nikonBank);
	this.nikonBox.appendChild(document.createElement('br'));
	this.nikonBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Sharpening:')));
	this.nikonBox.appendChild(this.nikonShr);
	this.nikonShrLabel.innerHTML = '0';
	this.nikonBox.appendChild(this.nikonShrLabel);
	this.nikonBox.appendChild(document.createElement('br'));
	this.nikonBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Saturation:')));
	this.nikonBox.appendChild(this.nikonSat);
	this.nikonSatLabel.innerHTML = '0';
	this.nikonBox.appendChild(this.nikonSatLabel);
	this.nikonBox.appendChild(document.createElement('br'));
	this.nikonBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Hue:')));
	this.nikonBox.appendChild(this.nikonHue);
	this.nikonHueLabel.innerHTML = '0';
	this.nikonBox.appendChild(this.nikonHueLabel);
	this.lutUsage.appendChild(this.nikonBox);
	// 0-1.0 hard clip checkbox
	this.lutClip = document.createElement('div');
	this.lutClip.className = 'emptybox';
	this.lutClip.appendChild(document.createElement('label').appendChild(document.createTextNode('Hard Clip')));
	this.lutClip.appendChild(this.lutClipSelect);
	this.clipLegalBox.appendChild(document.createElement('label').appendChild(document.createTextNode('0%-100%')));
	this.lutClipLegalCheck.setAttribute('type','checkbox');
	this.lutClipLegalCheck.checked = true;
	this.clipLegalBox.appendChild(this.lutClipLegalCheck);
	this.clipLegalBox.className = 'input-set';
	this.lutClip.appendChild(this.clipLegalBox);
//	this.lutClipCheck.setAttribute('type','checkbox');
//	this.lutClipCheck.checked = false;
//	this.lutClip.appendChild(this.lutClipCheck);
	this.lutUsage.appendChild(document.createElement('br'));
	this.lutUsage.appendChild(this.lutClip);
};
LUTLutBox.prototype.events = function() {
	this.lutName.onchange = function(here){ return function(){
		here.cleanName();
//		lutFile.filename();
	};}(this);
	this.titleButton.onclick = function(here){ return function(){
		here.autoTitle();
//		lutFile.filename();
	};}(this);
	this.lutClipSelect.onchange = function(here){ return function(){
		here.displayCLC();
		here.messages.gaSetParams();
	};}(this);
	this.lutClipLegalCheck.onchange = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
//	this.lutClipCheck.onchange = function(here){ return function(){
//		here.messages.gaSetParams();
//	};}(this);
	this.scaleCheck.onchange = function(here){ return function(){
		here.toggleInScale();
		here.messages.gaSetParams();
	};}(this);
	this.lutOneD.onchange = function(here){ return function(){
		here.messages.oneOrThree();
	};}(this);
	this.lutThreeD.onchange = function(here){ return function(){
		here.messages.oneOrThree();
	};}(this);
	this.lutInLegal.onchange = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.lutInData.onchange = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.lutOutLegal.onchange = function(here){ return function(){
		here.displayCLC();
		here.messages.gaSetParams();
	};}(this);
	this.lutOutData.onchange = function(here){ return function(){
		here.displayCLC();
		here.messages.gaSetParams();
	};}(this);
	this.scaleMin.oninput = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.scaleMax.oninput = function(here){ return function(){
		here.messages.gaSetParams();
	};}(this);
	this.nikonShr.oninput = function(here){ return function(){
		here.nikonShrLabel.innerHTML = here.nikonShr.value;
	};}(this);
	this.nikonSat.oninput = function(here){ return function(){
		here.nikonSatLabel.innerHTML = here.nikonSat.value;
	};}(this);
	this.nikonHue.oninput = function(here){ return function(){
		here.nikonHueLabel.innerHTML = here.nikonHue.value;
	};}(this);
};
// Set Up Data
LUTLutBox.prototype.buildClipSelect = function() {
	var optNone = document.createElement('option');
	optNone.value = 0;
	optNone.innerHTML = 'Unclipped';
	this.lutClipSelect.appendChild(optNone);
	var optBoth = document.createElement('option');
	optBoth.value = 1;
	optBoth.innerHTML = 'Both B&W';
	this.lutClipSelect.appendChild(optBoth);
	var optBlack = document.createElement('option');
	optBlack.value = 2;
	optBlack.innerHTML = 'Black Only';
	this.lutClipSelect.appendChild(optBlack);
	var optWhite = document.createElement('option');
	optWhite.value = 3;
	optWhite.innerHTML = 'White Only';
	this.lutClipSelect.appendChild(optWhite);
	this.lutClipSelect.options[2].selected = true;	
};
LUTLutBox.prototype.createRadioElement = function(name, checked) {
    var radioInput;
    try {
        var radioHtml = '<input type="radio" name="' + name + '"';
        if ( checked ) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += '/>';
        radioInput = document.createElement(radioHtml);
    } catch( err ) {
        radioInput = document.createElement('input');
        radioInput.setAttribute('type', 'radio');
        radioInput.setAttribute('name', name);
        if ( checked ) {
            radioInput.setAttribute('checked', 'checked');
        }
    }
    return radioInput;
};
// Event Responses
LUTLutBox.prototype.changeGamma = function() {
	this.formats.updateOptions();
};
LUTLutBox.prototype.gotGammaLists = function() {
	this.catList = this.inputs.gammaCatList;
};
LUTLutBox.prototype.getSettings = function(data) {
	var m = this.inputs.dimension.length;
	var meshSize;
	for (var j=0; j<m; j++) {
		if (this.inputs.dimension[j].checked) {
			meshSize = parseInt(this.inputs.dimension[j].value);
			break;
		}
	}
	data.lutBox = {
		oneD: this.lutOneD.checked,
		meshSize: meshSize,
		legalIn: this.lutInLegal.checked,
		legalOut: this.lutOutLegal.checked,
//		hardClip: this.lutClipCheck.checked,
		clipOption: parseInt(this.lutClipSelect.options[this.lutClipSelect.selectedIndex].value),
		clipLegal: this.lutClipLegalCheck.checked,
		grading: this.gradeOpt.checked,
		gradeOption: this.inputs.gradeSelect.options[this.inputs.gradeSelect.selectedIndex].lastChild.nodeValue.replace(/ *\([^)]*\) */g, ""),
		mlutOption: this.inputs.mlutSelect.options[this.inputs.mlutSelect.selectedIndex].lastChild.nodeValue.replace(/ *\([^)]*\) */g, ""),
		scaleCheck: this.scaleCheck.checked,
		scaleMin: parseFloat(this.scaleMin.value),
		scaleMax: parseFloat(this.scaleMax.value),
		inBits: parseFloat(this.inBitsSelect.options[this.inBitsSelect.selectedIndex].value),
		outBits: parseFloat(this.outBitsSelect.options[this.outBitsSelect.selectedIndex].value),
		nikonBank: parseInt(this.nikonBank.options[this.nikonBank.selectedIndex].value),
		nikonSharp: parseInt(this.nikonShr.value),
		nikonSat: parseInt(this.nikonSat.value),
		nikonHue: parseInt(this.nikonHue.value)
	};
};
LUTLutBox.prototype.setSettings = function(settings) {
	if (typeof settings.lutBox !== 'undefined') {
		var data = settings.lutBox;
		if (typeof data.oneD === 'boolean') {
			this.lutOneD.checked = data.oneD;
			this.lutThreeD.checked = !data.oneD;
            this.messages.oneOrThree();
		}
		if (typeof data.meshSize === 'number') {
			var m = this.inputs.dimension.length;
			for (var j=0; j<m; j++) {
				if (parseInt(this.inputs.dimension[j].value) === data.meshSize) {
 					this.inputs.dimension[j].checked = true;
					break;
				}
			}
		}
		if (typeof data.legalIn === 'boolean') {
			this.lutInLegal.checked = data.legalIn;
			this.lutInData.checked = !data.legalIn;
		}
		if (typeof data.legalOut === 'boolean') {
			this.lutOutLegal.checked = data.legalOut;
			this.lutOutData.checked = !data.legalOut;
			this.displayCLC();
		}
		if (typeof data.hardClip === 'boolean') {
//			this.lutClipCheck.checked = data.hardClip;
			if (data.hardClip) {
				this.lutClipSelect.options[1].selected = true;
			} else {
				this.lutClipSelect.options[0].selected = true;
			}
		}
		if (typeof data.clipOption === 'number') {
			for (var j=0; j<4; j++) {
				if (parseFloat(this.lutClipSelect.options[j].value) === data.clipOption) {
					this.lutClipSelect.options[j].selected = true;
					break;
				}
			}
		}
		if (typeof data.clipLegal === 'boolean') {
			this.lutClipLegalCheck.checked = data.clipLegal;
		}
		if (typeof data.scaleCheck === 'boolean') {
			this.scaleCheck.checked = data.scaleCheck;
		}
		if (typeof data.scaleMin === 'number') {
			this.scaleMin.value = data.scaleMin;
		}
		if (typeof data.scaleMax === 'number') {
			this.scaleMax.value = data.scaleMax;
		}
		if (typeof data.inBits === 'number') {
			var m = this.inBitsSelect.options.length;
			for (var j=0; j<m; j++) {
				if (parseInt(this.inBitsSelect.options[j].value) === data.inBits) {
					this.inBitsSelect.options[j].selected = true;
				}
			}
		}
		if (typeof data.outBits === 'number') {
			var m = this.outBitsSelect.options.length;
			for (var j=0; j<m; j++) {
				if (parseInt(this.outBitsSelect.options[j].value) === data.outBits) {
					this.outBitsSelect.options[j].selected = true;
				}
			}
		}
		if (typeof data.nikonBank === 'number') {
			var m = this.nikonBank.options.length;
			for (var j=0; j<m; j++) {
				if (parseInt(this.nikonBank.options[j].value) === data.nikonBank) {
					this.nikonBank.options[j].selected = true;
				}
			}
		}
		if (typeof data.nikonSharp === 'number') {
			this.nikonShr.value = data.nikonSharp;
		}
		if (typeof data.nikonSat === 'number') {
			this.nikonSat.value = data.nikonSat;
		}
		if (typeof data.nikonSharp === 'number') {
			this.nikonHue.value = data.nikonHue;
		}
	}
};
LUTLutBox.prototype.getInfo = function(info) {
	info.name = this.lutName.value;
	if (this.lutOneD.checked) {
		info.oneD = true;
	} else {
		info.oneD = false;
	}
	var max = this.inputs.dimension.length;
	for (var j =0; j < max; j++) {
		if (this.inputs.dimension[j].checked) {
			info.dimension = parseInt(this.inputs.dimension[j].value);
			break;
		}
	}
	if (this.mlutOpt.checked) {
		info.mlut = true;
	} else {
		info.mlut = false;
	}
	if (this.lutClipSelect.selectedIndex > 0) {
		info.hardClip = true;
	} else {
		info.hardClip = false;
	}
//	if (this.lutClipCheck.checked) {
//		info.hardClip = true;
//	} else {
//		info.hardClip = false;
//	}
	if (this.lutInLegal.checked) {
		info.legalIn = true;
	} else {
		info.legalIn = false;
	}
	if (this.lutOutLegal.checked) {
		info.legalOut = true;
	} else {
		info.legalOut = false;
	}
	if (this.scaleCheck.checked) {
		info.scaleCheck = true;
	} else {
		info.scaleCheck = false;
	}
	info.scaleMin = parseFloat(this.scaleMin.value);
	info.scaleMax = parseFloat(this.scaleMax.value);
	info.inBits = parseInt(this.inBitsSelect.options[this.inBitsSelect.options.selectedIndex].value);
	info.outBits = parseInt(this.outBitsSelect.options[this.outBitsSelect.options.selectedIndex].value);
	info.nikonBank = parseInt(this.nikonBank.options[this.nikonBank.options.selectedIndex].value);
	info.nikonSharp = parseInt(this.nikonShr.value);
	info.nikonSat = parseInt(this.nikonSat.value);
	info.nikonHue = parseInt(this.nikonHue.value);
};
LUTLutBox.prototype.toggleInScale = function() {
	if (this.scaleCheck.checked === true) {
		this.scaleInputs.className = 'emptybox';
	} else {
		this.scaleInputs.className = 'emptybox-hide';
	}
};
LUTLutBox.prototype.displayCLC = function() {
	if (this.lutClipSelect.selectedIndex > 0 && this.lutOutData.checked) {
		this.clipLegalBox.className = 'input-set';
	} else {
		this.clipLegalBox.className = 'input-set-hide';
	}
};
LUTLutBox.prototype.autoTitle = function() {
	var info = {};
	this.messages.getInfo(info);
	var title = '';
	if (info.nul) {
		title = 'Null LUT';
	} else {
		switch (info.inGammaName) {
			case 'LogC (Sup 3.x & 4.x)':
			case 'LogC (Sup 2.x)': title += 'LogC'; break;
			case 'Canon C-Log2' : title += 'CLog2'; break;
			case 'Canon C-Log3' : title += 'CLog3'; break;
			case 'Apple Log': title += 'AppleLog'; break;
			case 'Panasonic V-Log' : title += 'VLog'; break;
			case 'Fujifilm F-Log' : title += 'FLog'; break;
			case 'Varicam V709' : title += 'V709'; break;
			case 'Rec709 (800%)' : title += 'Rec709800'; break;
			case 'EOS Standard (Legal)' :
			case 'EOS Standard' : title += 'EOSStd'; break;
			case 'Hybrid-Log Gamma' : title += 'HLG'; break;
			case 'Dolby PQ' : title += 'PQ'; break;
			case 'Canon WideDR' : title += 'WideDR'; break;
			case 'Rec2020 12-bit' : title += 'Rec2020'; break;
			case 'Scene Linear IRE - γ1.0 (18% Gray = 0.2)' : title += 'LinIRE'; break;
			case 'Scene Linear Reflectance - γ1.0 (18% Gray = 0.18)' : title += 'LinRef'; break;
			default:
				if (info.inGammaName.indexOf('- γ') > 0) {
					title += info.inGammaName.substring(0, info.inGammaName.indexOf('- γ') - 1).replace(/\s/g,'');
				} else {
					title += info.inGammaName.replace(/[\s/-]/gi, '');
				}
		}
		if (this.lutThreeD.checked) {
			title += '_';
			switch (info.inGamutName) {
				case 'Sony S-Gamut3.cine': title += 'SG3c'; break;
				case 'Sony S-Gamut3': title += 'SG3'; break;
				case 'Sony S-Gamut': title += 'SG'; break;
				case 'Sony S-Gamut3.cine (Venice)': title += 'SG3cVenice'; break;
				case 'Sony S-Gamut3 (Venice)': title += 'SG3Venice'; break;
				case 'Alexa Wide Gamut': title += 'AlexaWG'; break;
				case 'ARRI Wide Gamut 4': title +='ARRIWG4'; break;
				case 'Canon Cinema Gamut': title += 'CanonCG'; break;
				case 'Panasonic V-Gamut': title += 'VGamut'; break;
				case 'Fujifilm F-Log Gamut': title += 'FLogGamut'; break;
				case 'Canon CP IDT (Daylight)': title += 'C300Day'; break;
				case 'Canon CP IDT (Tungsten)': title += 'C300Tung'; break;
				case 'Canon DCI-P3+': title += 'CanonDCIP3p'; break;
				case 'DJI X3 DLog':
				case 'DJI X5/X7/X9 DLog': title += 'DJIDLog'; break;
				case 'DJI DLog-M': title += 'DJIDLogM'; break;
				case 'Adobe Wide Gamut RGB': title += 'AdobeWGRGB'; break;
				case 'Varicam V709': title += 'V709'; break;
				default:
					title += info.inGamutName.replace(/[\s/-]/gi, '');
			}
		}
		title += '-';
		switch (info.outGammaName) {
			case 'LogC (Sup 3.x & 4.x)':
			case 'LogC (Sup 2.x)': title += 'LogC'; break;
			case 'Canon C-Log2' : title += 'CLog2'; break;
			case 'Canon C-Log3' : title += 'CLog3'; break;
			case 'Apple Log': title += 'AppleLog'; break;
			case 'Panasonic V-Log' : title += 'VLog'; break;
			case 'Fujifilm F-Log' : title += 'FLog'; break;
			case 'Varicam V709' : title += 'V709'; break;
			case 'Rec709 (800%)' : title += 'Rec709800'; break;
			case 'EOS Standard (Legal)' :
			case 'EOS Standard' : title += 'EOSStd'; break;
			case 'Hybrid-Log Gamma' : title += 'HLG'; break;
			case 'Dolby PQ' : title += 'PQ'; break;
			case 'Canon WideDR' : title += 'WideDR'; break;
			case 'Rec2020 12-bit' : title += 'Rec2020'; break;
			case 'Scene Linear IRE - γ1.0 (18% Gray = 0.2)' : title += 'LinIRE'; break;
			case 'Scene Linear Reflectance - γ1.0 (18% Gray = 0.18)' : title += 'LinRef'; break;
			default:
				if (info.outGammaName.indexOf('- γ') > 0) {
					title += info.outGammaName.substring(0, info.outGammaName.indexOf('- γ') - 1).replace(/\s/g,'');
				} else {
					title += info.outGammaName.replace(/[\s/-]/gi, '');
				}
		}
		if (this.lutThreeD.checked) {
			title += '_';
			switch (info.outGamutName) {
				case 'Sony S-Gamut3.cine': title += 'SG3c'; break;
				case 'Sony S-Gamut3': title += 'SG3'; break;
				case 'Sony S-Gamut': title += 'SG'; break;
				case 'Sony S-Gamut3.cine (Venice)': title += 'SG3cVenice'; break;
				case 'Sony S-Gamut3 (Venice)': title += 'SG3Venice'; break;
				case 'Alexa Wide Gamut': title += 'AlexaWG'; break;
				case 'ARRI Wide Gamut 4': title +='ARRIWG4'; break;
				case 'Canon Cinema Gamut': title += 'CanonCG'; break;
				case 'Panasonic V-Gamut': title += 'VGamut'; break;
				case 'Fujifilm F-Log Gamut': title += 'FLogGamut'; break;
				case 'Canon CP IDT (Daylight)': title += 'C300Day'; break;
				case 'Canon CP IDT (Tungsten)': title += 'C300Tung'; break;
				case 'Canon DCI-P3+': title += 'CanonDCIP3p'; break;
				case 'DJI X3 DLog':
				case 'DJI X5/X7/X9 DLog': title += 'DJIDLog'; break;
				case 'DJI DLog-M': title += 'DJIDLogM'; break;
				case 'Adobe Wide Gamut RGB': title += 'AdobeWGRGB'; break;
				case 'Varicam V709': title += 'V709'; break;
				default:
					title += info.outGamutName.replace(/[\s/-]/gi, '');;
			}
		}
		if (info.doBlk) {
			title += '_B' + info.blackLevel.replace('.','p');
		}
		if (info.doASCCDL && info.ASCSat !== '1') {
			title += '_S' + info.ASCSat.replace('.','p');
		}
	}
	this.lutName.value = title;
	this.cleanName();
};
LUTLutBox.prototype.cleanName = function() {
	this.lutName.value = this.lutName.value.replace(/[/"/']/gi, '');
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* lutgeneratebox.js
* 'Generate' button UI object and LUT construction code for the LUTCalc Web App.
* 7th October 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTGenerateBox(fieldset, inputs, messages, file, formats) {
	this.box = document.createElement('fieldset');
	this.fieldset = fieldset;
	this.inputs = inputs;
	this.messages = messages;
	this.p = 5;
	this.messages.addUI(this.p,this);
	this.lT = 0;
	this.dimension = 0;
	this.file = file;
	this.formats = formats;
	this.gamutInName = '';
	this.gamutOutName = '';
	this.gamutHGName = '';
	this.baseIRE = 0;
	this.setMin = -2;
	this.setMax = 2;
	this.setStep = 3;
	this.setPass = 1;
	this.setTotal = ((this.setMax - this.setMin)*this.setStep)+1;
	this.doSet = false;
	this.setVal = 0;
	this.currentName = '';
	this.currentStop = 0;
	this.io();
	this.ui();
	lutcalcReady(this.p);
}
LUTGenerateBox.prototype.io = function() {
	this.genButton = document.createElement('input');
	this.genButton.setAttribute('type','button');
	this.genButton.value = 'Generate LUT';
	this.genSetButton = document.createElement('input');
	this.genSetButton.setAttribute('type','button');
	this.genSetButton.value = 'Generate Set';
	this.goSetButton = document.createElement('input');
	this.goSetButton.setAttribute('type','button');
	this.goSetButton.value = 'Go';
	this.genSetMin = document.createElement('select');
	this.genSetMax = document.createElement('select');
	this.genSetStep = document.createElement('select');
	this.cancelSetButton = document.createElement('input');
	this.cancelSetButton.setAttribute('type','button');
	this.cancelSetButton.value = 'Cancel';
	this.cancelProgButton = document.createElement('input');
	this.cancelProgButton.setAttribute('type','button');
	this.cancelProgButton.value = 'Cancel';
	this.precisionSetting = document.createElement('input');
	this.precisionSetting.setAttribute('type', 'number');
	this.precisionSetting.setAttribute('min', 3);
	this.precisionSetting.setAttribute('max', 128);
	this.precisionSetting.setAttribute('step', 1);
	this.precisionSetting.value = this.messages.getPrecision();
	this.settingsButton = document.createElement('input');
	this.settingsButton.setAttribute('type','button');
	this.settingsButton.value = 'Settings';
	this.saveButton = document.createElement('input');
	this.saveButton.setAttribute('type','button');
	this.saveButton.value = 'Save Settings';
	this.loadButton = document.createElement('input');
	this.loadButton.setAttribute('type','button');
	this.loadButton.value = 'Load Settings';
	this.defButton = document.createElement('input');
	this.defButton.setAttribute('type','button');
	this.defButton.value = 'Set Default Options';
	this.defResetButton = document.createElement('input');
	this.defResetButton.setAttribute('type','button');
	this.defResetButton.value = 'Reset Defaults';
	this.doneButton = document.createElement('input');
	this.doneButton.setAttribute('type','button');
	this.doneButton.value = 'Done';
	this.inputs.addInput('settingsData',{});
	this.fileInput = document.createElement('input');
	this.fileInput.setAttribute('type','file');
};
LUTGenerateBox.prototype.ui = function() {
	this.box.appendChild(this.genButton);
	this.box.appendChild(this.genSetButton);
	this.fileInput.style.display = 'none';
	this.box.appendChild(this.settingsButton);
	this.box.appendChild(this.fileInput);
	this.fieldset.id = 'genbutton';
	this.fieldset.appendChild(this.box);
	this.buildSettingsPopup();
	this.buildGenSetPopup();
	this.buildSetProgressPopup();
};
LUTGenerateBox.prototype.events = function() {
	this.genButton.onclick = function(here){ return function(){
		here.generate();
	};}(this);
	this.genSetButton.onclick = function(here){ return function(){
		modalBox.className = 'modalbox';
		here.genSetHolder.className = 'lutset-popup';
	};}(this);
	this.goSetButton.onclick = function(here){ return function(e){
		here.genSetHolder.className = 'lutset-popup-hide';
		here.setProgHolder.className = 'setprog-popup';
		here.generateSet();
	};}(this);
	this.cancelSetButton.onclick = function(here){ return function(e){
		modalBox.className = 'modalbox-hide';
		here.genSetHolder.className = 'lutset-popup-hide';
		here.setProgHolder.className = 'setprog-popup-hide';
	};}(this);
	this.cancelProgButton.onclick = function(here){ return function(e){
		here.doSet = false;
		here.inputs.name.value = here.currentName;
		here.inputs.stopShift.value = here.currentStop;
		modalBox.className = 'modalbox-hide';
		here.setProgHolder.className = 'setprog-popup-hide';
	};}(this);
	this.settingsButton.onclick = function(here){ return function(){
		modalBox.className = 'modalbox';
		here.settingsHolder.className = 'settings-popup';
	};}(this);
	this.precisionSetting.onchange = function(here){ return function(){
		var precision = Math.max(3, Math.min(128, parseInt(here.precisionSetting.value)));
		here.precisionSetting.value = precision;
		here.messages.setPrecision(precision);
	};}(this);
	this.saveButton.onclick = function(here){ return function(){
		here.file.save(here.messages.getSettings(),new Date().toJSON().slice(0,10),'lutcalc',3);
	};}(this);
	this.loadButton.onclick = function(here){ return function(){
		if (here.inputs.isApp) {
			here.loadSettings();
		} else {
			var e = new MouseEvent('click');
			here.fileInput.dispatchEvent(e);
		}
	};}(this);
	if (this.inputs.isApp) {
		this.fileInput.onclick = function(here){ return function(){
			here.loadSettings();
		};}(this);
	} else {
		this.fileInput.onchange = function(here){ return function(){
			here.loadSettings();
		};}(this);
	}
	this.doneButton.onclick = function(here){ return function(e){
		modalBox.className = 'modalbox-hide';
		here.settingsHolder.className = 'settings-popup-hide';
	};}(this);
};
LUTGenerateBox.prototype.triggerSettingsPopup = function() {
    modalBox.className = 'modalbox';
    this.settingsHolder.className = 'settings-popup';
};
LUTGenerateBox.prototype.triggerSetReset = function() {
    window.webkit.messageHandlers.setReset.postMessage(this.messages.getSettings());
};
LUTGenerateBox.prototype.triggerSetDefault = function() {
    window.webkit.messageHandlers.setDefault.postMessage(this.messages.getSettings());
};
LUTGenerateBox.prototype.triggerSetCurrent = function() {
    window.webkit.messageHandlers.setCurrent.postMessage(this.messages.getSettings());
};
LUTGenerateBox.prototype.triggerGenerateSet = function() {
    modalBox.className = 'modalbox';
    this.genSetHolder.className = 'lutset-popup';
};
LUTGenerateBox.prototype.getSettings = function(data) {
	data.generateBox = {
		precision: parseInt(this.precisionSetting.value)
	};
};
LUTGenerateBox.prototype.setSettings = function(settings) {
	if (typeof settings.generateBox !== 'undefined') {
		var data = settings.generateBox;
		if (typeof data.precision === 'number') {
			this.precisionSetting.value = data.precision;
			this.messages.setPrecision(data.precision);
		}
	}
};
LUTGenerateBox.prototype.getBox = function() {
	return { box: this.box, button: this.genButton };
};
LUTGenerateBox.prototype.gotBaseIRE = function(baseIRE) {
	this.baseIRE = baseIRE;
};
LUTGenerateBox.prototype.generate = function() {
    this.doSet = false;
	this.inputs.doSaveDialog = 1;
	if (this.inputs.d[0].checked) {
		this.oneDLUT();
	} else {
		this.threeDLUT();
	}
};
LUTGenerateBox.prototype.generateSet = function() {
	this.doSet = true;
	this.inputs.doSaveDialog = 2;
	this.currentName = this.inputs.name.value;
	this.currentStop = this.inputs.stopShift.value;
	this.setMin = parseFloat(this.genSetMin.options[this.genSetMin.selectedIndex].value);
	this.setMax = parseFloat(this.genSetMax.options[this.genSetMax.selectedIndex].value);
	this.setStep = parseFloat(this.genSetStep.options[this.genSetStep.selectedIndex].value);
	this.setVal = this.setMin;
	this.setPass = 1;
	this.setTotal = ((this.setMax - this.setMin)*this.setStep)+1;
	this.inputs.stopShift.value = Math.round(this.setVal*100)/100;
	if (this.setVal < -0.000001 || setVal > 0.000001) {
		this.inputs.name.value = this.currentName + '_' + this.setVal.toFixed(2).toString().replace('.','p');
	} else {
		this.inputs.name.value = this.currentName + '_' +'0-Native';
	}
	this.setProgText.innerHTML = 'Generating Set - File ' + this.setPass.toString() + ' Of ' + this.setTotal.toString();
	if (this.inputs.d[0].checked) {
		this.oneDLUT();
	} else {
		this.threeDLUT();
	}
};
LUTGenerateBox.prototype.oneDLUT = function() {
	this.dimension = 1024;
	var max = this.inputs.dimension.length;
	for (var i=0; i<max; i++) {
		if (this.inputs.dimension[i].checked) {
			this.dimension = parseInt(this.inputs.dimension[i].value);
			break;
		}
	}
	this.lut = new Float64Array(((this.dimension)*3));
	var chunks = 2;
	var chunk = parseInt(this.dimension / chunks);
	for (var j=0; j<chunks; j++) {
		var start = chunk*j;
		if ((start + chunk) > this.dimension) {
			if (this.doSet) {
				this.messages.gaTx(this.p,1,{start: start,vals: (this.dimension - start),dim: this.dimension, eiMult: Math.pow(2,this.setVal)});
			} else {
				this.messages.gaTx(this.p,1,{start: start,vals: (this.dimension - start),dim: this.dimension});
			}
		} else {
			if (this.doSet) {
				this.messages.gaTx(this.p,1,{start: start,vals: chunk,dim: this.dimension, eiMult: Math.pow(2,this.setVal)});
			} else {
				this.messages.gaTx(this.p,1,{start: start,vals: chunk,dim: this.dimension});
			}
		}
	}
};
LUTGenerateBox.prototype.threeDLUT = function() {
	this.dimension = 33;
	var max = this.inputs.dimension.length;
	for (var i=0; i<max; i++) {
		if (this.inputs.dimension[i].checked) {
			this.dimension = parseInt(this.inputs.dimension[i].value);
			break;
		}
	}
	var chunks = this.dimension;
	var chunk = this.dimension * this.dimension;
	this.lut = new Float64Array(chunk*chunks*3);
	for (var j=0; j<chunks; j++) {
		var R = 0;
		var G = 0;
		var B = j;
		if (this.doSet) {
			this.messages.gaTx(this.p,3,{R:R, G:G, B:B, vals:chunk, dim:this.dimension, eiMult: Math.pow(2,this.setVal)});
		} else {
			this.messages.gaTx(this.p,3,{R:R, G:G, B:B, vals:chunk, dim:this.dimension});
		}
	}
};
LUTGenerateBox.prototype.got1D = function(d) {
	var o = new Float64Array(d.o);
	this.lut.set(o, d.start*3);
	this.lT += d.vals;
	if (this.lT === this.dimension) {
		this.lT = 0;
		this.formats.output(this.lut.buffer);
		if (!this.inputs.isApp && !this.inputs.isChromeApp) {
			if (this.doSet && this.setPass < this.setTotal) {
				this.setVal += 1/this.setStep;
				this.setPass++;
				this.inputs.stopShift.value = Math.round(this.setVal*100)/100;
				if (this.setVal < -0.000001 || this.setVal > 0.000001) {
					this.inputs.name.value = this.currentName + '_' + this.setVal.toFixed(2).toString().replace('.','p');
				} else {
					this.inputs.name.value = this.currentName + '_' +'0-Native';
				}
				this.setProgText.innerHTML = 'Generating Set - File ' + this.setPass.toString() + ' Of ' + this.setTotal.toString();
				this.oneDLUT();
			} else {
				if (this.doSet) {
					this.inputs.name.value = this.currentName;
					this.inputs.stopShift.value = this.currentStop;
				}
				this.doSet = false;
				this.setVal = this.setMin;
				this.setPass = 1;
				modalBox.className = 'modalbox-hide';
				this.setProgHolder.className = 'setprog-popup-hide';
			}
		}
	}
};
LUTGenerateBox.prototype.got3D = function(d) {
	var o = new Float64Array(d.o);
	this.lut.set(o, d.vals*d.B*3);
	this.lT++;
	if (this.lT === this.dimension) {
		this.lT = 0;
		this.formats.output(this.lut.buffer);
		if (!this.inputs.isApp && !this.inputs.isChromeApp) {
			if (this.doSet && this.setPass < this.setTotal) {
				this.setVal += 1/this.setStep;
				this.setPass++;
				this.inputs.stopShift.value = Math.round(this.setVal*100)/100;
				if (this.setVal < -0.000001 || this.setVal > 0.000001) {
					this.inputs.name.value = this.currentName + '_' + this.setVal.toFixed(2).toString().replace('.','p');
				} else {
					this.inputs.name.value = this.currentName + '_' +'0-Native';
				}
				this.setProgText.innerHTML = 'Generating Set - File ' + this.setPass.toString() + ' Of ' + this.setTotal.toString();
				this.threeDLUT();
			} else {
				if (this.doSet) {
					this.inputs.name.value = this.currentName;
					this.inputs.stopShift.value = this.currentStop;
				}
				this.doSet = false;
				this.setVal = this.setMin;
				this.setPass = 1;
				modalBox.className = 'modalbox-hide';
				this.setProgHolder.className = 'setprog-popup-hide';
			}
		}
	}
};
LUTGenerateBox.prototype.saved = function(success) {
	if (this.inputs.isApp || this.inputs.isChromeApp) {
		if (success && this.doSet && this.setPass < this.setTotal) {
			this.inputs.doSaveDialog = 0;
			this.setVal += 1/this.setStep;
			this.setPass++;
			this.inputs.stopShift.value = Math.round(this.setVal*100)/100;
			if (this.setVal < -0.000001 || this.setVal > 0.000001) {
				this.inputs.name.value = this.currentName + '_' + this.setVal.toFixed(2).toString().replace('.','p');
			} else {
				this.inputs.name.value = this.currentName + '_' +'0-Native';
			}
			this.setProgText.innerHTML = 'Generating Set - File ' + this.setPass.toString() + ' Of ' + this.setTotal.toString();
			if (this.inputs.d[0].checked) {
				this.oneDLUT();
			} else {
				this.threeDLUT();
			}
		} else {
			if (this.doSet) {
				this.inputs.name.value = this.currentName;
				this.inputs.stopShift.value = this.currentStop;
			}
			this.doSet = false;
			this.inputs.doSaveDialog = 1;
			this.setVal = this.setMin;
			this.setPass = 1;
			modalBox.className = 'modalbox-hide';
			this.setProgHolder.className = 'setprog-popup-hide';
		}
	}
};
LUTGenerateBox.prototype.loadSettings = function() {
	if (this.inputs.isApp || this.fileInput.value !== '') {
		this.file.loadLUTFromInput(this.fileInput, ['lutcalc'], [true], 'settingsData', this, 0);
	}
};
LUTGenerateBox.prototype.followUp = function(d) {
	switch (d) {
        case 0: this.messages.setSettings();
			break;
	}
};
LUTGenerateBox.prototype.buildSettingsPopup = function() {
	this.settingsHolder = document.createElement('div');
	this.settingsHolder.className = 'settings-popup-hide';
	this.settingsBox = document.createElement('div');
	this.settingsBox.className = 'popup';
	this.settingsBox.appendChild(this.saveButton);
	this.settingsBox.appendChild(this.loadButton);
	this.settingsBox.appendChild(document.createElement('br'));
	var precisionBox = document.createElement('div');
	var prePrecision = document.createElement('label');
	prePrecision.innerHTML = "Decimal LUT Precision";
	var postPrecision = document.createElement('label');
	postPrecision.innerHTML = "Places";
	precisionBox.appendChild(prePrecision);
	precisionBox.appendChild(this.precisionSetting);
	precisionBox.appendChild(postPrecision);
	precisionBox.appendChild(document.createElement('br'));
	this.settingsBox.appendChild(precisionBox);
	this.settingsBox.appendChild(this.doneButton);
	this.settingsHolder.appendChild(this.settingsBox);
	modalBox.appendChild(this.settingsHolder);
};
LUTGenerateBox.prototype.buildGenSetPopup = function() {
	for (var j=0; j<4; j++) {
		var minOpt = document.createElement('option');
		minOpt.value = j-4;
		minOpt.innerHTML = (j-4).toString();
		if ((j-4) === this.setMin) {
			minOpt.selected = true;
		}
		this.genSetMin.appendChild(minOpt);
		var maxOpt = document.createElement('option');
		maxOpt.value = j+1;
		maxOpt.innerHTML = (j+1).toString();
		if ((j+1) === this.setMax) {
			maxOpt.selected = true;
		}
		this.genSetMax.appendChild(maxOpt);
		var stepOpt = document.createElement('option');
		stepOpt.value = j+1;
		if (j === 0 ) {
			stepOpt.innerHTML = '1';
		} else {
			stepOpt.innerHTML = '1/' + (j+1).toString();
		}
		if ((j+1) === this.setStep) {
			stepOpt.selected = true;
		}
		this.genSetStep.appendChild(stepOpt);
	}
	this.genSetHolder = document.createElement('div');
	this.genSetHolder.className = 'lutset-popup-hide';
	this.genSetBox = document.createElement('div');
	this.genSetBox.className = 'popup';
	this.genSetBox.appendChild(document.createTextNode('Stop Shift Minimum'));
	this.genSetBox.appendChild(this.genSetMin);
	this.genSetBox.appendChild(document.createElement('br'));
	this.genSetBox.appendChild(document.createTextNode('Stop Shift Maximum'));
	this.genSetBox.appendChild(this.genSetMax);
	this.genSetBox.appendChild(document.createElement('br'));
	this.genSetBox.appendChild(document.createTextNode('Step Size'));
	this.genSetBox.appendChild(this.genSetStep);
	this.genSetBox.appendChild(document.createTextNode('Stop'));
	this.genSetBox.appendChild(document.createElement('br'));
	this.genSetBox.appendChild(this.goSetButton);
	this.genSetBox.appendChild(this.cancelSetButton);
	this.genSetHolder.appendChild(this.genSetBox);
	modalBox.appendChild(this.genSetHolder);
};
LUTGenerateBox.prototype.buildSetProgressPopup = function() {
	this.setProgHolder = document.createElement('div');
	this.setProgHolder.className = 'setprog-popup-hide';
	this.setProgBox = document.createElement('div');
	this.setProgBox.className = 'popup';
	this.setProgText = document.createElement('p');
	this.setProgBox.appendChild(this.setProgText);
	this.setProgBox.appendChild(this.cancelProgButton);
	this.setProgHolder.appendChild(this.setProgBox);
	modalBox.appendChild(this.setProgHolder);
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* lutpreview.js
* Realtime preview object for the LUTCalc Web App.
* 29th June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTPreview(fieldset,inputs,messages,file) {
	this.box = document.createElement('fieldset');
	this.box.id = 'preview-holder';
	this.fieldset = fieldset;
	this.inputs = inputs;
	this.messages = messages;
	this.file = file;
	this.p = 8;
	this.messages.addUI(this.p,this);
	this.main = document.getElementById('main');
	this.left = document.getElementById('left');
	this.right = document.getElementById('right');
	this.io();
	this.ui();
}
LUTPreview.prototype.io = function() {
	this.upd = 0;
	// Preview window io
	this.preButton = document.createElement('input');
	this.preButton.setAttribute('type','button');
	this.preButton.value = 'Preview';
	this.sizeButton = document.createElement('input');
	this.sizeButton.setAttribute('type','button');
	this.sizeButton.value = 'Large Image';
	this.sizeButton.className = 'base-button-hide';
	this.sizeButton.id = 'preview-size-button';
	//
	this.defSelect = document.createElement('select');
	var defs = [
		'High Contrast',
		'Low Contrast',
		'Rec709 Gamut',
		'xy / uv Chromacity',
		'Grayscale'
	];
	this.chromOpt = 3;
	for (var j=0; j<5; j++) {
		var option = document.createElement('option');
		option.value = j;
		option.appendChild(document.createTextNode(defs[j]));
		this.defSelect.appendChild(option);
	}
	var defFiles = [
		'HDRPreview',
		'LDRPreview',
		'CW',
		'xyuv',
		'Gray'
	];
	var defExts = [
		'png',
		'png',
		'png',
		'png',
		'png'
	];
	var m = defFiles.length;
	var shed = document.getElementById('shed');
	for (var j=0; j<m; j++) {
//		var MSB = this.inputs['defmsb'+j];
		var MSB = document.createElement('img');
		MSB.alt = 'defmsb' + j;
		MSB.id = 'defmsb' + j;
		MSB.src = defFiles[j] + 'MSB.' + defExts[j];
		shed.appendChild(MSB);
//		var LSB = this.inputs['deflsb'+j];
		var LSB = document.createElement('img');
		LSB.alt = 'deflsb' + j;
		LSB.id = 'deflsb' + j;
		LSB.src = defFiles[j] + 'LSB.' + defExts[j];
		shed.appendChild(LSB);
	}
	//
	this.buttonHolder = document.createElement('fieldset');
	this.buttonHolder.className = 'button-holder';
	this.preLeg = this.createRadioElement('prelegdat',true);
	this.preDat = this.createRadioElement('prelegdat',false);
	this.wavCheck = document.createElement('input');
	this.wavCheck.setAttribute('type','checkbox');
	this.wavCheck.checked = false;
	this.vecCheck = document.createElement('input');
	this.vecCheck.setAttribute('type','checkbox');
	this.vecCheck.checked = false;
	this.rgbCheck = document.createElement('input');
	this.rgbCheck.setAttribute('type','checkbox');
	this.rgbCheck.checked = false;
	this.fileButton = document.createElement('input');
	this.fileButton.setAttribute('type','button');
	this.fileButton.value = 'Load Preview...';
	this.fileButton.className = 'base-button-hide';
	this.fileInput = document.createElement('input');
	this.fileInput.setAttribute('type','file');
	this.inputs.addInput('preFileData',{});
	this.show = false;
	this.inputs.addInput('showPreview',this.show);
	// File popup io
	this.preCSBoxHolder = document.createElement('div');
	this.preGammaSelect = document.createElement('select');
	this.preGamutSelect = document.createElement('select');
	this.preLegalRange = this.createRadioElement('prerange', false);
	this.preDataRange = this.createRadioElement('prerange', true);
	this.preOKButton = document.createElement('input');
	this.preOKButton.setAttribute('type','button');
	this.preOKButton.value = 'OK';
	this.preCancelButton = document.createElement('input');
	this.preCancelButton.setAttribute('type','button');
	this.preCancelButton.value = 'Cancel';
	// Windowless buttons
	this.sizeButton.className = 'base-button-hide';
	this.fileButton.className = 'base-button-hide';
};
LUTPreview.prototype.ui = function() {

	this.buttonHolder.appendChild(this.sizeButton);
	this.buttonHolder.appendChild(this.defSelect);
	this.buttonHolder.appendChild(this.fileButton);
	this.box.appendChild(this.buttonHolder);

	this.fileInput.style.display = 'none';
	this.box.appendChild(this.fileInput);
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('100%')));
	this.box.appendChild(this.preLeg);	
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('109%')));
	this.box.appendChild(this.preDat);	
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('WFM')));
	this.box.appendChild(this.wavCheck);	
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('Vector')));
	this.box.appendChild(this.vecCheck);	
	this.box.appendChild(document.createElement('label').appendChild(document.createTextNode('RGB')));
	this.box.appendChild(this.rgbCheck);	
	this.box.appendChild(document.createElement('br'));

	// RGB Values box
	this.rgbBox = document.createElement('div');
	this.rgbBox.appendChild(document.createTextNode('10-Bit Values - R:'));
	this.rgbR = document.createElement('div');
	this.rgbR.className = 'fixed-width-no';
	this.rgbR.innerHTML = '0';
	this.rgbBox.appendChild(this.rgbR);
	this.rgbBox.appendChild(document.createTextNode('G:'));
	this.rgbG = document.createElement('div');
	this.rgbG.className = 'fixed-width-no';
	this.rgbG.innerHTML = '0';
	this.rgbBox.appendChild(this.rgbG);
	this.rgbBox.appendChild(document.createTextNode('B:'));
	this.rgbB = document.createElement('div');
	this.rgbB.className = 'fixed-width-no';
	this.rgbB.innerHTML = '0';
	this.rgbBox.appendChild(this.rgbB);
	this.box.appendChild(this.rgbBox);

	this.uiCanvases();

	this.fieldset.className = 'shadowbox-hide';
	this.fieldset.appendChild(this.box);

	this.uiPopup();
};
LUTPreview.prototype.uiCanvases = function() {
	this.width = 960;
	this.height = 540;
	this.rastSize = this.width*8*3;
	this.wform = false;
	this.vscope = false;
	this.parade = false;
	this.vscale = 410;
	this.changed = false;
	this.eiMult = 1;
	this.line = 0;
	this.small = true;
	this.inputs.addInput('small',this.small);
	this.leg = true;
	this.initPrimaries();
	// Preview image canvases
	this.pBox = document.createElement('div');
	this.pBox.id = 'preview-box';
	this.pBox.className = 'preview-box-small';
	this.pCan = document.createElement('canvas');
	this.pCan.id = 'can-preview';
	this.pCan.className = 'can-1-small';
	this.inputs.addInput('previewCanvas',this.pCan);
	this.pCan.width = this.width.toString();
	this.pCan.height = this.height.toString();
	this.pCtx = this.pCan.getContext('2d', { willReadFrequently: true });
	this.pData = this.pCtx.createImageData(this.width,this.height);
	this.pRaw = new Float64Array(this.width * this.height * 3);
	this.inputs.addInput('preRaw',this.pRaw);
	this.pBox.appendChild(this.pCan);
	this.sCan = document.createElement('canvas');
	this.sCan.id = 'can-sampler';
	this.sCan.className = 'can-2-small';
	this.inputs.addInput('samplerCanvas',this.sCan);
	this.sCan.width = this.width.toString();
	this.sCan.height = this.height.toString();
	this.sCtx = this.sCan.getContext('2d');
	this.inputs.addInput('samplerCtx',this.sCtx);
	this.pBox.appendChild(this.sCan);
	this.oCan = document.createElement('canvas');
	this.oCan.id = 'can-overlay';
	this.oCan.className = 'can-hide';
	this.oCan.width = this.width.toString();
	this.oCan.height = this.height.toString();
	this.oCtx = this.oCan.getContext('2d');
	this.pBox.appendChild(this.oCan);
	this.box.appendChild(this.pBox);
	this.lCan = document.createElement('canvas');
	this.lCan.className = 'can-hide';
	this.lCan.width = this.width.toString();
	this.lCan.height = this.height.toString();
	this.lCtx = this.lCan.getContext('2d', { willReadFrequently: true });
	this.box.appendChild(this.lCan);
	// Waveform
	this.wCan = document.createElement('canvas');
	this.wCan.id = 'can-waveform';
	this.wCan.className = 'can-hide';
	this.wCan.width = this.width.toString();
	this.wCan.height = this.height.toString();
	this.wCtx = this.wCan.getContext('2d');
	this.wData = this.wCtx.createImageData(this.width,this.height);
	this.box.appendChild(this.wCan);
	// Vectorscope
	this.vCan = document.createElement('canvas');
	this.vCan.id = 'can-vector';
	this.vCan.className = 'can-hide';
	this.vCan.width = this.width.toString();
	this.vCan.height = this.height.toString();
	this.vCtx = this.vCan.getContext('2d');
	this.vData = this.vCtx.createImageData(this.width,this.height);
	this.box.appendChild(this.vCan);
	// RGB parade
	this.rgbCan = document.createElement('canvas');
	this.rgbCan.id = 'can-parade';
	this.rgbCan.className = 'can-hide';
	this.rgbCan.width = this.width.toString();
	this.rgbCan.height = this.height.toString();
	this.rgbCtx = this.rgbCan.getContext('2d');
	this.rgbData = this.rgbCtx.createImageData(this.width,this.height);
	this.box.appendChild(this.rgbCan);
	this.def = [];
	this.defNext = 4;
	this.defOpt = 0;
//	this.loadDefault(this.defNext);
	this.defaultImgs(this.defNext);
};
LUTPreview.prototype.uiPopup = function() {
	modalBox.className = 'modalbox-hide';
	this.preCSBoxHolder.className = 'popupholder-hide';
	this.preCSBox = document.createElement('div');
	this.preCSBox.className = 'popup';
	this.preCSBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Loading Preview Image')));
	this.preCSBox.appendChild(document.createElement('br'));
	this.preCSBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Image Gamma')));
	this.preCSBox.appendChild(this.preGammaSelect);
	this.preCSBox.appendChild(document.createElement('br'));
	this.preCSBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Image Colour Space')));
	this.preCSBox.appendChild(this.preGamutSelect);
	this.preCSBox.appendChild(document.createElement('br'));
	this.preCSBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Legal Range')));
	this.preCSBox.appendChild(this.preLegalRange);
	this.preCSBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Data Range')));
	this.preCSBox.appendChild(this.preDataRange);
	this.preCSBox.appendChild(document.createElement('br'));
	this.preCSBox.appendChild(this.preOKButton);
	this.preCSBox.appendChild(this.preCancelButton);
	this.preCSBoxHolder.appendChild(this.preCSBox);
//	document.getElementById('body').appendChild(this.preCSBoxHolder);
	modalBox.appendChild(this.preCSBoxHolder);
};
LUTPreview.prototype.uiExternal = function(genBox) {
	this.generateButton = genBox.button;
	genBox.box.insertBefore(this.preButton, genBox.button);
	this.defSelect.className = 'base-select-hide';
};
LUTPreview.prototype.events = function() {
	this.fileButton.onclick = function(here){ return function(){
		if (here.inputs.isApp) {
			here.preGetImg();
		} else {
			var e = new MouseEvent('click');
			here.fileInput.dispatchEvent(e);
		}
	};}(this);
	if (this.inputs.isApp) {
		this.fileInput.onclick = function(here){ return function(){
			here.preGetImg();
		};}(this);
	} else {
		this.fileInput.onchange = function(here){ return function(){
			here.preGetImg();
		};}(this);
	}
	this.preOKButton.onclick = function(here){ return function(){
		here.preCSBoxHolder.className = 'popupholder-hide';
		modalBox.className = 'modalbox-hide';
		here.prepPreview();
	};}(this);
	this.preCancelButton.onclick = function(here){ return function(){
		here.preCSBoxHolder.className = 'popupholder-hide';
		modalBox.className = 'modalbox-hide';
	};}(this);
	this.preButton.onclick = function(here){ return function(){
		here.toggle();
	};}(this);
	this.sizeButton.onclick = function(here){ return function(){
		here.toggleSize();
	};}(this);
	this.defSelect.onchange = function(here){ return function(){
		here.toggleDefault();
	};}(this);
	this.preLeg.onclick = function(here){ return function(){
		here.toggleRange();
	};}(this);
	this.preDat.onclick = function(here){ return function(){
		here.toggleRange();
	};}(this);
	this.wavCheck.onclick = function(here){ return function(){
		here.toggleWaveform();
	};}(this);
	this.vecCheck.onclick = function(here){ return function(){
		here.toggleVectorscope();
	};}(this);
	this.rgbCheck.onclick = function(here){ return function(){
		here.toggleParade();
	};}(this);
	this.pCan.onmousemove = function(here){ return function(e){
		here.rgbVals(e.clientX, e.clientY);
	};}(this);
	this.pCan.onclick = function(here){ return function(e){
		here.messages.previewSample(e.clientX, e.clientY);
	};}(this);
	this.oCan.onmousemove = function(here){ return function(e){
		here.rgbVals(e.clientX, e.clientY);
	};}(this);
	this.oCan.onclick = function(here){ return function(e){
		here.messages.previewSample(e.clientX, e.clientY);
	};}(this);
	this.sCan.onmousemove = function(here){ return function(e){
		here.rgbVals(e.clientX, e.clientY);
	};}(this);
	this.sCan.onclick = function(here){ return function(e){
		here.messages.previewSample(e.clientX, e.clientY);
	};}(this);
};
// Base data
LUTPreview.prototype.initPrimaries = function() {
	this.pName = ['Yl','Cy','G','Mg','R','B'];
	this.p75x = [-0.375,0.0859375,-0.2890625,0.2890625,-0.0859375,0.375];
	this.p75y = [0.034598214,-0.375,-0.340401786,0.340401786,0.375,-0.034598214];
	this.p100x = [-0.5,0.114955357,-0.385416667,0.385416667,-0.114955357,0.5];
	this.p100y = [0.045758929,-0.5,-0.453869048,0.453869048,0.5,-0.045758929];
	this.pCurx = [-0.375,0.0859375,-0.2890625,0.2890625,-0.0859375,0.375];
	this.pCury = [0.034598214,-0.375,-0.340401786,0.340401786,0.375,-0.034598214];
	this.pTextx = [];
	this.pTexty = [];
	for (var j=0; j<6; j++) {
		this.p75x[j] = Math.round((this.p75x[j]*this.vscale)+480);
		this.p100x[j] = Math.round((this.p100x[j]*this.vscale)+480);
		this.pCurx[j] = Math.round((this.pCurx[j]*this.vscale)+480);
		this.p75y[j] = Math.round(270-(this.p75y[j]*this.vscale));
		this.p100y[j] = Math.round(270-(this.p100y[j]*this.vscale));
		this.pCury[j] = Math.round(270-(this.pCury[j]*this.vscale));
		this.pTextx.push(0.5*(this.p100x[j]+this.p75x[j]));
		this.pTexty.push(0.5*(this.p100y[j]+this.p75y[j]));
	}
};
LUTPreview.prototype.updatePrimaries = function(data) {
	var d = new Float64Array(data);
	var Y,Pr,Pb;
	for (var j=0; j<18; j += 3) {
		Y = (0.2126*d[j]) + ((1-0.2126-0.0722)*d[j+1]) + (0.0722*d[j+2]);
		Pb = 0.5*(d[j+2]-Y)/(1-0.0722);
		Pr = 0.5*(d[ j ]-Y)/(1-0.2126);
		this.pCurx[j/3] = Math.round((Pb*this.vscale)+480);
		this.pCury[j/3] = Math.round(270-(Pr*this.vscale));
	}
};
// Image loading
LUTPreview.prototype.defaultImgs = function(opt) {
	this.gotMSB = false;
	this.gotLSB = false;
	var MSB = document.getElementById('defmsb' + opt);
	var LSB = document.getElementById('deflsb' + opt);
	if (MSB.complete) {
		this.loadedMSB(opt)
	} else {
		MSB.addEventListener('load',(function(i){
                return function(){
                    i.here.loadedMSB(i.opt);
                }
            })({here:this,opt:opt}),
            false
        );
	}
	if (LSB.complete) {
		this.loadedLSB(opt)
	} else {
		LSB.addEventListener('load',(function(i){
                return function(){
                    i.here.loadedLSB(i.opt);
                }
            })({here:this,opt:opt}),
            false
        );
	}
};
LUTPreview.prototype.loadedMSB = function(opt) {
	this.pCtx.drawImage(document.getElementById('defmsb' + opt),0,0);
	this.gotMSB = true;
	this.loadedDefault();
}
LUTPreview.prototype.loadedLSB = function(opt) {
	this.lCtx.drawImage(document.getElementById('deflsb' + opt),0,0);
	this.gotLSB = true;
	this.loadedDefault();
}
LUTPreview.prototype.loadDefault = function(opt) {
	this.gotMSB = false;
	this.gotLSB = false;
	var msb = new Image();
	var lsb = new Image();
	msb.onload = (function(input) {
		var box = input.box;
		var MSB = input.msb;
		return function(e) {
			box.pCtx.drawImage(MSB,0,0);
			box.gotMSB = true;
			box.loadedDefault();
		};
	})({
		box: this,
		msb: msb
	});
	lsb.onload = (function(input) {
		var box = input.box;
		var LSB = input.lsb;
		return function(e) {
			box.lCtx.drawImage(LSB,0,0);
			box.gotLSB = true;
			box.loadedDefault();
		};
	})({
		box: this,
		lsb: lsb
	});
	switch(opt) {
		case 0:
			msb.src = "HDRPreviewMSB.jpg";
			lsb.src = "HDRPreviewLSB.jpg";
			break;
		case 1:
			msb.src = "LDRPreviewMSB.jpg";
			lsb.src = "LDRPreviewLSB.jpg";
			break;
		case 2:
			msb.src = "CWMSB.jpg";
			lsb.src = "CWLSB.jpg";
			break;
		case 3:
			msb.src = "xyuvMSB.jpg";
			lsb.src = "xyuvLSB.jpg";
			break;
		case 4:
			msb.src = "GrayMSB.png";
			lsb.src = "GrayLSB.png";
			break;
	}
};
LUTPreview.prototype.loadedDefault = function() {
	if (this.gotLSB && this.gotMSB) {
		// Convert 8-bit Most Significant Bits (MSB) and Least Significant Bits (LSB) S-Log3 pngs into a Float64 Array
		// of linear RGB values
		var lsb = this.lCtx.getImageData(0,0,960,540);
		var msb = this.pCtx.getImageData(0,0,960,540);
		var max = Math.round(msb.data.length/4);
		var def = new Float64Array(max*3);
		if (this.defNext === 3) {
			var x,y,z;
			for (var j=0; j<max; j++) {
				x = parseFloat((msb.data[(j*4)+0]*256)+lsb.data[(j*4)+0])/65535;
				y = parseFloat((msb.data[(j*4)+1]*256)+lsb.data[(j*4)+1])/65535;
				z = parseFloat((msb.data[(j*4)+2]*256)+lsb.data[(j*4)+2])/65535;
// Change this if I move from S-Gamut3.cine
				def[(j*3)+0] = (1.8467789693*x) + (-0.5259861230*y) + (-0.2105452114*z);
				def[(j*3)+1] = (-0.4441532629*x) + (1.2594429028*y) + (0.1493999729*z);
				def[(j*3)+2] = (0.0408554212*x) + (0.0156408893*y) + (0.8682072487*z);
			}
		} else {
			for (var j=0; j<max; j++) {
				def[(j*3)+0] = this.sl3ToLin(parseFloat((msb.data[(j*4)+0]*256)+lsb.data[(j*4)+0])/65535);
				def[(j*3)+1] = this.sl3ToLin(parseFloat((msb.data[(j*4)+1]*256)+lsb.data[(j*4)+1])/65535);
				def[(j*3)+2] = this.sl3ToLin(parseFloat((msb.data[(j*4)+2]*256)+lsb.data[(j*4)+2])/65535);
			}
		}
		this.def[this.defNext] = def;
		this.defNext--;
		if (this.defNext >= 0) {
//			this.loadDefault(this.defNext);
			this.defaultImgs(this.defNext);
		} else {
			this.pre = this.def[0];
			var shed = document.getElementById('shed');
			var imgs = [];
			[].push.apply(imgs,shed.getElementsByTagName('img'));
			max = imgs.length-1;
			for (var j=max; j>=0; j--) {
				shed.removeChild(imgs[j]);
				imgs[j] = null;
			}
			this.refresh();
			lutcalcReady(this.p);
		}
	}
};
LUTPreview.prototype.updatePopup = function() {
	this.preGammaSelect.length = 0;
	this.preGamutSelect.length = 0;
	var max1 = this.inputs.inGammaOpts.length;
	var max2 = this.inputs.inLinGammaOpts.length;
	for (var j=0; j<max1; j++) {
		if (this.inputs.inGammaOpts[j].value === '9999') {
			for (var k=0; k<max2; k++) {
				var option = document.createElement('option');
				option.value = this.inputs.inLinGammaOpts[k].value;
				option.appendChild(this.inputs.inLinGammaOpts[k].lastChild.cloneNode(false));
				this.preGammaSelect.appendChild(option);
			}
		} else {
			var option = document.createElement('option');
			option.value = this.inputs.inGammaOpts[j].value;
			option.appendChild(this.inputs.inGammaOpts[j].lastChild.cloneNode(false));
			this.preGammaSelect.appendChild(option);
		}
	}
	var max1 = this.inputs.inGamutOpts.length;
	for (var j=0; j<max1; j++) {
		if (this.inputs.inGamutOpts[j].lastChild.nodeValue !== 'Passthrough') {
			var option = document.createElement('option');
			option.value = this.inputs.inGamutOpts[j].value;
			option.appendChild(this.inputs.inGamutOpts[j].lastChild.cloneNode(false));
			this.preGamutSelect.appendChild(option);
		}
	}
	this.preCSBoxHolder.className = 'popupholder';
	modalBox.className = 'modalbox';
};
LUTPreview.prototype.preGetImg = function() {
    var validExts;
    if (this.inputs.isApp) {
        validExts = ['jpg','jpeg','png','bmp','tiff','tif'];
    } else {
        validExts = ['jpg','jpeg','png','bmp'];
    }
	if (this.inputs.isApp || this.fileInput.value !== '') {
		this.file.loadImgFromInput(this.fileInput, validExts, 'preFileData', this, 0);
	}
};
LUTPreview.prototype.followUp = function(d) {
	switch (d) {
        case 0: this.preGotImg();
			break;
	}
};
LUTPreview.prototype.preGotImg = function() {
	if (this.inputs.isApp) {
		this.preIn = this.inputs.preFileData.imageData;
	} else {
	    var w = this.inputs.preFileData.w;
		var h = this.inputs.preFileData.h;
		var wS = 960;
		var hS = h * wS / w;
		var fCan = document.createElement('canvas');
		fCan.width = '960';
		fCan.height = '540';
		var fCtx = fCan.getContext('2d');
		fCtx.drawImage(this.inputs.preFileData.pic,0,0,wS,hS);
		var f = fCtx.getImageData(0,0,960,540);
		var max = Math.round(f.data.length/4);
		this.preIn = new Float64Array(max*3);
		var r,g,b;
		var k=0;
		for (var j=0; j<max; j++) {
			this.preIn[(j*3)+0] = parseFloat(f.data[(j*4)+0])/255;
			this.preIn[(j*3)+1] = parseFloat(f.data[(j*4)+1])/255;
			this.preIn[(j*3)+2] = parseFloat(f.data[(j*4)+2])/255;
		}
	}
	this.updatePopup();
};
LUTPreview.prototype.prepPreview = function() {
	this.messages.gaTx(8,14,{
		gamma: parseInt(this.preGammaSelect.options[this.preGammaSelect.options.selectedIndex].value),
		gamut: parseInt(this.preGamutSelect.options[this.preGamutSelect.options.selectedIndex].value),
		legal: this.preLegalRange.checked,
		i: this.preIn.buffer
	});
};
LUTPreview.prototype.preppedPreview = function(buff) {
	this.def[5] = new Float64Array(buff);
	this.pre = this.def[5];
	if (this.defSelect.options.length === 5) {
		var option = document.createElement('option');
		option.value = 5;
		this.defSelect.appendChild(option);
		this.defSelect.options[5].appendChild(document.createTextNode(this.inputs.preFileData.title));
	}
	this.defSelect.options[5].removeChild(this.defSelect.options[5].firstChild);
	this.defSelect.options[5].appendChild(document.createTextNode(this.inputs.preFileData.title));
	this.defSelect.options[5].selected = true;
//	this.refresh();
	this.toggleDefault();
};
// Scope drawing
LUTPreview.prototype.clearWaveform = function() {
	var max = 960*540*4;
	for (var j=0; j<max; j += 4) {
		this.wData.data[ j ] = 0;
		this.wData.data[j+1] = 0;
		this.wData.data[j+2] = 0;
		this.wData.data[j+3] = 255;
	}
};
LUTPreview.prototype.clearVectorScope = function() {
	var max = 960*540*4;
	for (var j=0; j<max; j += 4) {
		this.vData.data[ j ] = 0;
		this.vData.data[j+1] = 0;
		this.vData.data[j+2] = 0;
		this.vData.data[j+3] = 255;
	}
};
LUTPreview.prototype.clearParade = function() {
	var max = 960*540*4;
	for (var j=0; j<max; j += 4) {
		this.rgbData.data[ j ] = 0;
		this.rgbData.data[j+1] = 0;
		this.rgbData.data[j+2] = 0;
		this.rgbData.data[j+3] = 255;
	}
};
LUTPreview.prototype.drawWaveform = function() {
	this.wCtx.beginPath();
	this.wCtx.strokeStyle = '#307030';
	this.wCtx.lineWidth = 1;
	this.wCtx.font='10px "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	this.wCtx.textAlign = 'center';
	this.wCtx.textBaseline = 'bottom';
	for (var j=0; j<11; j++) {
		y = 555-(((parseFloat(j/10)*876)+64)*550/1023);
		this.wCtx.moveTo(0,y);
		this.wCtx.lineTo(960,y);
		this.wCtx.strokeText((j * 10).toString() + '%',20,y);
		this.wCtx.strokeText((j * 10).toString() + '%',940,y);
	}
	this.wCtx.stroke();
};
LUTPreview.prototype.drawVectorScope = function() {
	var s = this.vscale;
	this.vCtx.beginPath();
	this.vCtx.strokeStyle = '#307030';
	this.vCtx.lineWidth = 3;
	this.vCtx.font='20px "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	this.vCtx.textAlign = 'center';
	this.vCtx.textBaseline = 'middle';
	this.vCtx.arc(480,270,(s/2)+60,0,2*Math.PI);
	this.vCtx.stroke();
	this.vCtx.beginPath();
	this.vCtx.lineWidth = 1.5;
	this.vCtx.moveTo(460,270);
	this.vCtx.lineTo(500,270);
	this.vCtx.moveTo(480,250);
	this.vCtx.lineTo(480,290);
	for (var j=0; j<6; j++) {
		this.vCtx.moveTo(this.p75x[j]+10,this.p75y[j]);
		this.vCtx.arc(this.p75x[j],this.p75y[j],10,0,2*Math.PI);
		this.vCtx.moveTo(this.p100x[j]+10,this.p100y[j]);
		this.vCtx.arc(this.p100x[j],this.p100y[j],10,0,2*Math.PI);
		this.vCtx.strokeText(this.pName[j],this.pTextx[j],this.pTexty[j]);
	}
	this.vCtx.stroke();
	var colour = ['#c0c000','#00c0c0','#00c000','#c000c0','#c00000','#0000c0'];
	for (var j=0; j<6; j++) {
		this.vCtx.beginPath();
		this.vCtx.lineWidth = 2;
		this.vCtx.strokeStyle = colour[j];
		this.vCtx.moveTo(this.pCurx[j]+10,this.pCury[j]);
		this.vCtx.arc(this.pCurx[j],this.pCury[j],10,0,2*Math.PI);
		this.vCtx.stroke();
	}
};
LUTPreview.prototype.drawParade = function() {
	this.rgbCtx.beginPath();
	this.rgbCtx.strokeStyle = '#707070';
	this.rgbCtx.lineWidth = 1;
	this.rgbCtx.font='10px "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	this.rgbCtx.textAlign = 'center';
	this.rgbCtx.textBaseline = 'bottom';
	for (var j=0; j<11; j++) {
		y = 555-(((parseFloat(j/10)*876)+64)*550/1023);
		this.rgbCtx.moveTo(0,y);
		this.rgbCtx.lineTo(960,y);
		this.rgbCtx.strokeText((j * 10).toString() + '%',20,y);
		this.rgbCtx.strokeText((j * 10).toString() + '%',940,y);
	}
	this.rgbCtx.stroke();
};
// Preview drawing
LUTPreview.prototype.isChanged = function(eiMult) {
	this.changed = true;
	if (typeof eiMult === 'number') {
		this.eiMult = eiMult;
	}
	if (this.show) {
		this.refresh();
	}
};
LUTPreview.prototype.gotLine = function(data) {
	if (data.upd === this.upd) {
		var raster8 = new Uint8Array(data.o);
		this.pData.data.set(raster8,data.line*this.width*4);
		var raster = new Float64Array(data.f);
		var l = raster.length;
		if (this.vscope) {
			var Kb = 0.0722;
			var Kr = 0.2126;
			var Y,Pb, Pr;
			var s = this.vscale;
			var k=0;
			for (var j=0; j<l; j += 3) {
				r = Math.max(0,(raster[ j ]));
				g = Math.max(0,(raster[j+1]));
				b = Math.max(0,(raster[j+2]));
				Y = (Kr*r) + ((1-Kr-Kb)*g) + (Kb*b);
				Pb = 0.5*(b-Y)/(1-Kb);
				Pr = 0.5*(r-Y)/(1-Kr);
	        	p = (
	        			((480 + Math.round(s * Pb))) +
	        			((270 - Math.round(s * Pr))*960)
	        		) * 4;
	
				this.vData.data[ p ] = Math.max(64,raster8[ k ]);
				this.vData.data[p+1] = Math.max(64,raster8[k+1]);
				this.vData.data[p+2] = Math.max(64,raster8[k+2]);
				this.vData.data[p+3] = 255;
	
				this.vData.data[p+4] = Math.max(64,raster8[ k ]);
				this.vData.data[p+5] = Math.max(64,raster8[k+1]);
				this.vData.data[p+6] = Math.max(64,raster8[k+2]);
				this.vData.data[p+7] = 255;
	
				this.vData.data[p+3840] = Math.max(64,raster8[ k ]);
				this.vData.data[p+3841] = Math.max(64,raster8[k+1]);
				this.vData.data[p+3842] = Math.max(64,raster8[k+2]);
				this.vData.data[p+3843] = 255;
	
				this.vData.data[p+3844] = Math.max(64,raster8[ k ]);
				this.vData.data[p+3845] = Math.max(64,raster8[k+1]);
				this.vData.data[p+3846] = Math.max(64,raster8[k+2]);
				this.vData.data[p+3847] = 255;
	
				k += 4;
			}
		}
		if (this.wform) {
			var x,y,p;
			var k = 0;
			for (var j=0; j<l; j += 3) {
				x = (j%2880)/3;
				y = 555-Math.round(((((0.2126*raster[ j ])+(0.7152*raster[j+1])+(0.0722*raster[j+2]))*876)+64)*550/1023);
				p = (3840*y) + (4*x);
	
				this.wData.data[ p ] = Math.max(80,raster8[ k ]);
				this.wData.data[p+1] = Math.max(80,raster8[k+1]);
				this.wData.data[p+2] = Math.max(80,raster8[k+2]);
				this.wData.data[p+3] = 255;
				
				k += 4;
			}
		}
		if (this.parade) {
			var x,r,g,b;
			var k = 0;
			for (var j=0; j<l; j += 3) {
				x = 4*Math.round((j%2880)/9);
				r = (3840*(555 - Math.round(((raster[ j ]*876)+64)*550/1023))) + x;
				g = (3840*(555 - Math.round(((raster[j+1]*876)+64)*550/1023))) + x + 1280;
				b = (3840*(555 - Math.round(((raster[j+2]*876)+64)*550/1023))) + x + 2560;
	
				this.rgbData.data[ r ] = 200;
				this.rgbData.data[r+1] = 0;
				this.rgbData.data[r+2] = 0;
				this.rgbData.data[r+3] = 255;
	
				this.rgbData.data[ g ] = 0;
				this.rgbData.data[g+1] = 200;
				this.rgbData.data[g+2] = 0;
				this.rgbData.data[g+3] = 255;
				
				this.rgbData.data[ b ] = 0;
				this.rgbData.data[b+1] = 0;
				this.rgbData.data[b+2] = 200;
				this.rgbData.data[b+3] = 255;
	
				k += 4;
			}
		}
		this.pRaw.set(raster,data.line*this.width*3);
		if (this.line === this.height-1) {
			this.pCtx.putImageData(this.pData,0,0);
			if (this.wform) {
				this.wCtx.putImageData(this.wData,0,0);
				this.drawWaveform();
			}
			if (this.vscope) {
				this.vCtx.putImageData(this.vData,0,0);
				this.drawVectorScope();
			}
			if (this.parade) {
				this.rgbCtx.putImageData(this.rgbData,0,0);
				this.drawParade();
			}
			this.line = 0;
			if (this.show && this.changed) {
				this.refresh();
			}
		} else if (this.show) {
			this.line++;
			var input = {
				line: this.line,
				upd: data.upd,
				o: this.pre.buffer.slice(this.line*this.rastSize,(this.line+1)*this.rastSize),
				leg: this.leg,
				eiMult: this.eiMult,
				to: ['o']
			};
			if (this.inputs.d[0].checked) {
				this.messages.gaTx(this.p,12,input);
			} else {
				this.messages.gtTx(this.p,12,input);
			}
		}
	}
};
LUTPreview.prototype.refresh = function() {
	if (typeof this.pre !== 'undefined') {
		this.changed = false;
		if (this.wform) {
			this.clearWaveform();
		}
		if (this.vscope) {
			this.clearVectorScope();
		}
		if (this.parade) {
			this.clearParade();
		}
		var max = Math.max(this.messages.getGammaThreads(),this.messages.getGamutThreads());
		this.upd++;
		for (var j=0; j<max; j++) {
			this.line = j;
			var input = {line: this.line, upd:this.upd, o: this.pre.buffer.slice(this.line*this.rastSize,(this.line+1)*this.rastSize), leg:this.leg, eiMult: this.eiMult, to: ['o']};
			if (this.inputs.d[0].checked) {
				this.messages.gaTx(this.p,12,input);
			} else {
				this.messages.gtTx(this.p,12,input);
			}
		}
	}
};
LUTPreview.prototype.testXY = function() {
	if (this.show && this.defOpt === this.chromOpt) {
		this.messages.gtTx(3,19,{});
	}
};
LUTPreview.prototype.updateXY = function(data) {
	var scale = 0.9 * this.height;
	var width = this.width;
	var height = this.height;
	var offset = (height - scale) / 2;
	var m = data.length;
	var b = m/2;
	var ctx = this.oCtx;
	ctx.clearRect(0, 0, this.width, this.height);
	var x,y;
	var u,v,den;
	ctx.font = '18pt "Avant Garde", Avantgarde, "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	ctx.textBaseline = 'middle';
	ctx.textAlign = 'left';
	// Input
	ctx.beginPath();
	ctx.lineWidth = 2;
	ctx.strokeStyle = 'RGB(240,64,64)';
	ctx.fillStyle = 'RGB(240,64,64)';
	x = offset + (scale * data[0]);
	y = scale * (1 - data[1]);
	ctx.moveTo(x + 2.5, y);
	ctx.arc(x, y, 2.5, 0, 2 * Math.PI, false);
	x = offset + (scale * data[2]);
	y = scale * (1 - data[3]);
	ctx.moveTo(x, y);
	for (var j=2; j<b; j += 2) {
		x = offset + (scale * data[j]);
		y = scale * (1 - data[j+1]);
		ctx.lineTo(x,y);
	}
	ctx.closePath();
	den = (12 * data[1]) - (2 * data[0]) + 3;
	u = ((4*data[0]/den)*scale/0.65) - (1.5*offset) + (width/2);
	v = scale - ((6*data[1]/den)*scale/0.65) - (1.5*offset);
	ctx.moveTo(u + 2.5, v);
	ctx.arc(u, v, 2.5, 0, 2 * Math.PI, false);
	den = (12 * data[3]) - (2 * data[2]) + 3;
	u = ((4*data[2]/den)*scale/0.65) - (1.5*offset) + (width/2);
	v = scale - ((6*data[3]/den)*scale/0.65) - (1.5*offset);
	ctx.moveTo(u, v);
	for (var j=2; j<b; j += 2) {
		den = (12 * data[j+1]) - (2 * data[j]) + 3;
		u = ((4*data[j]/den)*scale/0.65) - (1.5*offset) + (width/2);
		v = scale - ((6*data[j+1]/den)*scale/0.65) - (1.5*offset);
		ctx.lineTo(u,v);
	}
	ctx.closePath();
	ctx.fillText('Recorded: ' + this.inputs.inGamut.options[this.inputs.inGamut.selectedIndex].lastChild.nodeValue, width/4,0.15*height);
	ctx.stroke();
	// Output
	ctx.beginPath();
	ctx.lineWidth = 2;
	ctx.strokeStyle = 'RGB(90,90,240)';
	ctx.fillStyle = 'RGB(90,90,240)';
	x = offset + (scale * data[b]);
	y = scale * (1 - data[b+1]);
	ctx.moveTo(x + 2.5, y);
	ctx.arc(x, y, 2.5, 0, 2 * Math.PI, false);
	x = offset + (scale * data[b+2]);
	y = scale * (1 - data[b+3]);
	ctx.moveTo(x, y);
	for (var j=b+2; j<m; j += 2) {
		x = offset + (scale * data[j]);
		y = scale * (1 - data[j+1]);
		ctx.lineTo(x,y);
	}
	ctx.closePath();
	den = (12 * data[b+1]) - (2 * data[b]) + 3;
	u = ((4*data[b]/den)*scale/0.65) - (1.5*offset) + (width/2);
	v = scale - ((6*data[b+1]/den)*scale/0.65) - (1.5*offset);
	ctx.moveTo(u + 2.5, v);
	ctx.arc(u, v, 2.5, 0, 2 * Math.PI, false);
	den = (12 * data[b+3]) - (2 * data[b+2]) + 3;
	u = ((4*data[b+2]/den)*scale/0.65) - (1.5*offset) + (width/2);
	v = scale - ((6*data[b+3]/den)*scale/0.65) - (1.5*offset);
	ctx.moveTo(u, v);
	for (var j=b+2; j<m; j += 2) {
		den = (12 * data[j+1]) - (2 * data[j]) + 3;
		u = ((4*data[j]/den)*scale/0.65) - (1.5*offset) + (width/2);
		v = scale - ((6*data[j+1]/den)*scale/0.65) - (1.5*offset);
		ctx.lineTo(u,v);
	}
	ctx.closePath();
	ctx.fillText('Output: ' + this.inputs.outGamut.options[this.inputs.outGamut.selectedIndex].lastChild.nodeValue, width/4,(0.15*height)+30);
	ctx.stroke();
};
// General helper functions
LUTPreview.prototype.sl3ToLin = function(input) {
 	if (input >= 0.1673609920) {
		return (Math.pow(10,(input - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
	} else {
		return (0.1677922920*input) - 0.0155818840;
	}
};
LUTPreview.prototype.createRadioElement = function(name, checked) {
    var radioInput;
    try {
        var radioHtml = '<input type="radio" name="' + name + '"';
        if ( checked ) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += '/>';
        radioInput = document.createElement(radioHtml);
    } catch( err ) {
        radioInput = document.createElement('input');
        radioInput.setAttribute('type', 'radio');
        radioInput.setAttribute('name', name);
        if ( checked ) {
            radioInput.setAttribute('checked', 'checked');
        }
    }
    return radioInput;
};
LUTPreview.prototype.getCanVal = function(x,y) {
	x = Math.round(x*960);
	y = Math.round(y*540);
	var t;
	var out = new Float64Array(3);
	var xj, yk;
	var div;
	for (var j=0; j<3; j++) {
		for (var k=0; k<3; k++) {
			xj = x + j;
			if (xj < 0) {
				xj = 0;
			} else if (xj > 960) {
				xj = 960;
			}
			yk = y + k;
			if (yk < 0) {
				yk = 0;
			} else if (yk > 540) {
				yk = 540;
			}
			t = (x + (y*960))*3;
			if (j === 1 && k === 1) {
				div = 4;
			} else if (j === 1 || k === 1) {
				div = 8;
			} else {
				div = 16;
			}
			out[0] += this.pre[ t ]/div;
			out[1] += this.pre[t+1]/div;
			out[2] += this.pre[t+2]/div;
		}
	}
	var s = Math.pow(Math.pow(out[0],2) + Math.pow(out[1],2) + Math.pow(out[2],2),0.5);
	return out;
};
// Event responses
LUTPreview.prototype.toggle = function(showPre) {
	if (showPre) {
		this.show = false;
	}
	if (this.show) {
		this.pBox.className = 'preview-box-hide';
		this.wCan.className = 'can-hide';
		this.vCan.className = 'can-hide';
		this.rgbCan.className = 'can-hide';
		this.fieldset.className = 'shadowbox-hide';
		this.sizeButton.className = 'base-button-hide';
		this.fileButton.className = 'base-button-hide';
		this.defSelect.className = 'base-select-hide';
		this.show = false;
		this.preButton.value = 'Preview';
	} else {
		if (this.small) {
			this.pCan.className = 'can-1-small';
			this.sCan.className = 'can-2-small';
			this.pBox.className = 'preview-box-small';
			if (this.defOpt === this.chromOpt) {
				this.oCan.className = 'can-3-small';
			} else {
				this.oCan.className = 'can-hide';
			}
			if (this.wavCheck.checked) {
				this.wCan.className = 'can-small';
			} else {
				this.wCan.className = 'can-hide';
			}
			if (this.vecCheck.checked) {
				this.vCan.className = 'can-small';
			} else {
				this.vCan.className = 'can-hide';
			}
			if (this.rgbCheck.checked) {
				this.rgbCan.className = 'can-small';
			} else {
				this.rgbCan.className = 'can-hide';
			}
		} else {
			this.pBox.className = 'preview-box-large';
			this.pCan.className = 'can-1-large';
			this.sCan.className = 'can-2-large';
			if (this.defOpt === this.chromOpt) {
				this.oCan.className = 'can-3-large';
			} else {
				this.oCan.className = 'can-hide';
			}
			if (this.wavCheck.checked) {
				this.wCan.className = 'can-large';
			} else {
				this.wCan.className = 'can-hide';
			}
			if (this.vecCheck.checked) {
				this.vCan.className = 'can-large';
			} else {
				this.vCan.className = 'can-hide';
			}
			if (this.rgbCheck.checked) {
				this.rgbCan.className = 'can-large';
			} else {
				this.rgbCan.className = 'can-hide';
			}
		}
		this.fieldset.className = 'shadowbox';
		this.sizeButton.className = 'base-button';
		this.fileButton.className = 'base-button';
		this.defSelect.className = 'base-select';
		this.show = true;
		this.preButton.value = 'Hide Preview';
		this.refresh();
	}
	this.inputs.showPreview = this.show;
	this.messages.showPreview();
};
LUTPreview.prototype.toggleSize = function() {
	if (this.small) {
		this.pBox.className = 'preview-box-large';
		this.pCan.className = 'can-1-large';
		this.sCan.className = 'can-2-large';
		if (this.defOpt === this.chromOpt) {
			this.oCan.className = 'can-3-large';
		} else {
			this.oCan.className = 'can-hide';
		}
		if (this.wavCheck.checked) {
			this.wCan.className = 'can-large';
		} else {
			this.wCan.className = 'can-hide';
		}
		if (this.vecCheck.checked) {
			this.vCan.className = 'can-large';
		} else {
			this.vCan.className = 'can-hide';
		}
		if (this.rgbCheck.checked) {
			this.rgbCan.className = 'can-large';
		} else {
			this.rgbCan.className = 'can-hide';
		}
		this.sizeButton.value = 'Small Image';
		this.small = false;
		this.inputs.small = false;
	} else {
		this.pBox.className = 'preview-box-small';
		this.pCan.className = 'can-1-small';
		this.sCan.className = 'can-2-small';
		if (this.defOpt === this.chromOpt) {
			this.oCan.className = 'can-3-small';
		} else {
			this.oCan.className = 'can-hide';
		}
		if (this.wavCheck.checked) {
			this.wCan.className = 'can-small';
		} else {
			this.wCan.className = 'can-hide';
		}
		if (this.vecCheck.checked) {
			this.vCan.className = 'can-small';
		} else {
			this.vCan.className = 'can-hide';
		}
		if (this.rgbCheck.checked) {
			this.rgbCan.className = 'can-small';
		} else {
			this.rgbCan.className = 'can-hide';
		}
		this.sizeButton.value = 'Large Image';
		this.small = true;
		this.inputs.small = true;
	}
};
LUTPreview.prototype.toggleDefault = function() {
	this.defOpt = this.defSelect.options.selectedIndex;
	if (this.defOpt === this.chromOpt) {
		if (this.small) {
			this.oCan.className = 'can-3-small';
		} else {
			this.oCan.className = 'can-3-large';
		}
		this.testXY();
	} else {
		this.oCan.className = 'can-hide';
	}
	this.changed = true;
	this.pre = this.def[this.defOpt];
	this.refresh();
};
LUTPreview.prototype.toggleRange = function() {
	if (this.preLeg.checked) {
		this.leg = true;
	} else {
		this.leg = false;
	}
	this.refresh();
};
LUTPreview.prototype.toggleWaveform = function() {
	if (this.wavCheck.checked) {
		this.wform = true;
		if (this.small) {
			this.wCan.className = 'can-small';
		} else {
			this.wCan.className = 'can-large';
		}
	} else {
		this.wform = false;
		this.wCan.className = 'can-hide';
	}
	this.refresh();
};
LUTPreview.prototype.toggleVectorscope = function() {
	if (this.vecCheck.checked) {
		this.vscope = true;
		if (this.small) {
			this.vCan.className = 'can-small';
		} else {
			this.vCan.className = 'can-large';
		}
	} else {
		this.vscope = false;
		this.vCan.className = 'can-hide';
	}
	this.refresh();
};
LUTPreview.prototype.toggleParade = function() {
	if (this.rgbCheck.checked) {
		this.parade = true;
		if (this.small) {
			this.rgbCan.className = 'can-small';
		} else {
			this.rgbCan.className = 'can-large';
		}
	} else {
		this.parade = false;
		this.rgbCan.className = 'can-hide';
	}
	this.refresh();
};
LUTPreview.prototype.rgbVals = function(x,y) {
	var rect = this.pCan.getBoundingClientRect();
	x = Math.round(960*(x - rect.left)/rect.width);
	y = 960*Math.round(540*(y - rect.top)/rect.height);
	var i = (x + y)*3;
	this.rgbR.innerHTML = Math.min(1023,Math.round(876*this.pRaw[ i ])+64).toString();
	this.rgbG.innerHTML = Math.min(1023,Math.round(876*this.pRaw[i+1])+64).toString();
	this.rgbB.innerHTML = Math.min(1023,Math.round(876*this.pRaw[i+2])+64).toString();
};
LUTPreview.prototype.rgbSamples = function(gridX,gridY) {
	var m = gridX.length; // sample count
	var out = new Float64Array(m*3); // r,g,b samples list to return to twk-samples.js
//	var stop = new Float64Array(m);
	var k,l;
	var x,y,i;
//	var r,g,b;
	var step = 3*960;
	for (var j=0; j<m; j++) {
		l = j*3;
		x = Math.min(958,Math.max(1,Math.round(960*gridX[j])));
		y = 960 * Math.min(538,Math.max(1,Math.round(540*gridY[j])));
		i = (x + y)*3;
		out[ l ] = this.pRaw[ i ];
		out[l+1] = this.pRaw[i+1];
		out[l+2] = this.pRaw[i+2];
		out[ l ] += this.pRaw[i-3];
		out[l+1] += this.pRaw[i-2];
		out[l+2] += this.pRaw[i-1];
		out[ l ] += this.pRaw[i+3];
		out[l+1] += this.pRaw[i+4];
		out[l+2] += this.pRaw[i+5];
		out[ l ] += this.pRaw[ i  + step];
		out[l+1] += this.pRaw[i+1 + step];
		out[l+2] += this.pRaw[i+2 + step];
		out[ l ] += this.pRaw[ i  - step];
		out[l+1] += this.pRaw[i+1 - step];
		out[l+2] += this.pRaw[i+2 - step];
		out[ l ] += this.pRaw[i-3 + step]*0.7;
		out[l+1] += this.pRaw[i-2 + step]*0.7;
		out[l+2] += this.pRaw[i-1 + step]*0.7;
		out[ l ] += this.pRaw[i-3 - step]*0.7;
		out[l+1] += this.pRaw[i-2 - step]*0.7;
		out[l+2] += this.pRaw[i-1 - step]*0.7;
		out[ l ] += this.pRaw[i+3 + step]*0.7;
		out[l+1] += this.pRaw[i+4 + step]*0.7;
		out[l+2] += this.pRaw[i+5 + step]*0.7;
		out[ l ] += this.pRaw[i+3 - step]*0.7;
		out[l+1] += this.pRaw[i+4 - step]*0.7;
		out[l+2] += this.pRaw[i+5 - step]*0.7;
		out[ l ] /= 7.8;
		out[l+1] /= 7.8;
		out[l+2] /= 7.8;
//		r = this.pre[ i ] + this.pre[i-3] + this.pre[i+3] + this.pre[ i  + step] + this.pre[ i  - step] + ((this.pre[i-3 + step] + this.pre[i-3 - step] + this.pre[i+3 + step] + this.pre[i+3 - step])*0.7);
//		g = this.pre[i+1] + this.pre[i-2] + this.pre[i+4] + this.pre[i+1 + step] + this.pre[i+1 - step] + ((this.pre[i-2 + step] + this.pre[i-2 - step] + this.pre[i+4 + step] + this.pre[i+4 - step])*0.7);
//		g = this.pre[i+2] + this.pre[i-1] + this.pre[i+5] + this.pre[i+2 + step] + this.pre[i+2 - step] + ((this.pre[i-1 + step] + this.pre[i-1 - step] + this.pre[i+5 + step] + this.pre[i+5 - step])*0.7);
//		stop[j] = ((0.21507582011558746*r) + (0.8850685017437284*g) + (-0.10014432185931582*b))/7.8;
	}
	return {
		title:this.defSelect.options[this.defSelect.selectedIndex].text,
		samples: out
//		stops: stop
	};
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* lutinfobox.js
* LUTCalc / Gamma / Gamut information UI objects for the LUTCalc Web App.
* 7th October 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTInfoBox(fieldset,inputs,messages) {
	this.box = document.createElement('fieldset');
	this.inputs = inputs;
	this.messages = messages;
	this.p = 6;
	this.messages.addUI(this.p,this);
	this.build();
	fieldset.appendChild(this.box);
	lutcalcReady(this.p);
}
LUTInfoBox.prototype.build = function() {
 this.io();
 this.ui();
};
LUTInfoBox.prototype.io = function() {
	this.instructionsBut = document.createElement('input');
	this.instructionsBut.setAttribute('type','button');
	this.instructionsBut.id = 'infoinsbutton';
	this.instructionsBut.value = 'Instructions';
	this.gammaInfoBut = document.createElement('input');
	this.gammaInfoBut.setAttribute('type','button');
	this.gammaInfoBut.value = 'Tables';
	this.gammaChartBut = document.createElement('input');
	this.gammaChartBut.setAttribute('type','button');
	this.gammaChartBut.value = 'Charts';
	this.gammaPrintBut = document.createElement('input');
	this.gammaPrintBut.setAttribute('type','button');
	this.gammaPrintBut.value = 'Print Chart';
	this.gammaPrintBut.className = 'print-button';
	this.printBox = document.getElementById('printable');
	this.printTitle = document.createElement('h1');
	this.printBox.appendChild(this.printTitle);
	this.printDetails = document.createElement('p');
	this.printBox.appendChild(this.printDetails);
};
LUTInfoBox.prototype.ui = function() {
	this.instructionsBox = document.createElement('div');
	this.instructionsBox.id = 'instructions-box';
	this.instructions();
	this.instructionsBox.className = 'info-tab-hide';
	this.gammaInfoBox = document.createElement('div');
	this.gammaInfo();
	this.gammaInfoBox.className = 'info-tab-hide';
	this.gammaChartBox = document.createElement('div');
	this.gammaChart();
	this.gammaChartBox.className = 'info-tab';
	this.box.appendChild(this.instructionsBut);
	this.box.appendChild(this.gammaInfoBut);
	this.box.appendChild(this.gammaChartBut);
	this.box.appendChild(this.gammaPrintBut);
	this.box.appendChild(this.instructionsBox);
	this.box.appendChild(this.gammaInfoBox);
	this.box.appendChild(this.gammaChartBox);
	this.printChartBox = document.createElement('div');
	this.printBox.appendChild(this.printChartBox);
};
LUTInfoBox.prototype.events = function() {
	this.insMainCam.onclick = function(here){ return function(){ here.showCamInfo(); };}(this);
	this.insCamBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.insMainGam.onclick = function(here){ return function(){ here.showGamInfo(); };}(this);
	this.insGamBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.insMainTwk.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.insMainLut.onclick = function(here){ return function(){ here.showLutInfo(); };}(this);
	this.insLutBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.insMainPre.onclick = function(here){ return function(){ here.showPreInfo(); };}(this);
	this.insPreBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.insMainGen.onclick = function(here){ return function(){ here.showGenInfo(); };}(this);
	this.insGenBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.insMainGst.onclick = function(here){ return function(){ here.showGstInfo(); };}(this);
	this.insGstBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.insMainSet.onclick = function(here){ return function(){ here.showSetInfo(); };}(this);
	this.insSetBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.insMainInf.onclick = function(here){ return function(){ here.showInfInfo(); };}(this);
	this.insInfBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.creditsButton.onclick = function(here){ return function(){ here.showCdtInfo(); };}(this);
	this.insCdtBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.changelogButton.onclick = function(here){ return function(){ here.showClgInfo(); };}(this);
	this.insClgBack.onclick = function(here){ return function(){ here.showMainscreen(); };}(this);
	this.insCustHG.onclick = function(here){ return function(){ here.showCustHGInfo(); };}(this);
	this.custHGBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustWht.onclick = function(here){ return function(){ here.showCustWhtInfo(); };}(this);
	this.custWhtBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustColour.onclick = function(here){ return function(){ here.showCustColourInfo(); };}(this);
	this.custColourBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustKnee.onclick = function(here){ return function(){ here.showCustKneeInfo(); };}(this);
	this.custKneeBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustBhi.onclick = function(here){ return function(){ here.showCustBhiInfo(); };}(this);
	this.custBhiBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustDCC.onclick = function(here){ return function(){ here.showCustDCCInfo(); };}(this);
	this.custDCCBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustGlim.onclick = function(here){ return function(){ here.showCustGlimInfo(); };}(this);
	this.custGlimBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustSDRS.onclick = function(here){ return function(){ here.showCustSDRSInfo(); };}(this);
	this.custSDRSBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustBgm.onclick = function(here){ return function(){ here.showCustBgmInfo(); };}(this);
	this.custBgmBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustPsst.onclick = function(here){ return function(){ here.showCustPsstInfo(); };}(this);
	this.custPsstBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustASC.onclick = function(here){ return function(){ here.showCustASCInfo(); };}(this);
	this.custASCBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustMulti.onclick = function(here){ return function(){ here.showCustMultiInfo(); };}(this);
	this.custMultiBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustFC.onclick = function(here){ return function(){ here.showCustFCInfo(); };}(this);
	this.custFCBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustSamp.onclick = function(here){ return function(){ here.showCustSampInfo(); };}(this);
	this.custSampBack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.insCustLA.onclick = function(here){ return function(){ here.showCustLAInfo(); };}(this);
	this.custLABack.onclick = function(here){ return function(){ here.showCustscreen(); };}(this);
	this.instructionsBut.onclick = function(here){ return function(){
		here.instructionsOpt();
		here.messages.mobileOpt('inf');
	};}(this);
	this.chartType[0].onchange = function(here){ return function(){
		here.changeChart();
	};}(this);
	this.chartType[1].onchange = function(here){ return function(){
		here.changeChart();
	};}(this);
	this.chartType[2].onchange = function(here){ return function(){
		here.changeChart();
	};}(this);
	this.gammaInfoBut.onclick = function(here){ return function(){
		here.gammaInfoOpt();
		here.messages.mobileOpt('set');
	};}(this);
	this.gammaChartBut.onclick = function(here){ return function(){
		here.gammaChartOpt();
		here.messages.mobileOpt('set');
	};}(this);
	this.gammaPrintBut.onclick = function(here){ return function(){
		here.gammaPrint();
	};}(this);
};
// Construct the UI Box
LUTInfoBox.prototype.instructions = function() {
	this.instructionsBox.className = 'info-tab-ins';
	this.createMainscreen();
	this.instructionsBox.appendChild(this.mainscreen);
	this.createCamInfo();
	this.instructionsBox.appendChild(this.insCam);
	this.createGamInfo();
	this.instructionsBox.appendChild(this.insGam);
	this.createTwkInfo();
	this.instructionsBox.appendChild(this.insTwk);
	this.createLutInfo();
	this.instructionsBox.appendChild(this.insLut);
	this.createPreInfo();
	this.instructionsBox.appendChild(this.insPre);
	this.createGenInfo();
	this.instructionsBox.appendChild(this.insGen);
	this.createGstInfo();
	this.instructionsBox.appendChild(this.insGst);
	this.createSetInfo();
	this.instructionsBox.appendChild(this.insSet);
	this.createInfInfo();
	this.instructionsBox.appendChild(this.insInf);
	this.createCdtInfo();
	this.instructionsBox.appendChild(this.insCdt);
	this.createClgInfo();
	this.instructionsBox.appendChild(this.insClg);
	this.createCustColour();
	this.instructionsBox.appendChild(this.custColour);
	this.createCustWht();
	this.instructionsBox.appendChild(this.custWht);
	this.createCustPsst();
	this.instructionsBox.appendChild(this.custPsst);
	this.createCustASC();
	this.instructionsBox.appendChild(this.custASC);
	this.createCustMulti();
	this.instructionsBox.appendChild(this.custMulti);
	this.createCustHG();
	this.instructionsBox.appendChild(this.custHG);
	this.createCustKnee();
	this.instructionsBox.appendChild(this.custKnee);
	this.createCustBhi();
	this.instructionsBox.appendChild(this.custBhi);
	this.createCustSDRS();
	this.instructionsBox.appendChild(this.custSDRS);
	this.createCustBgm();
	this.instructionsBox.appendChild(this.custBgm);
	this.createCustDCC();
	this.instructionsBox.appendChild(this.custDCC);
	this.createCustGlim();
	this.instructionsBox.appendChild(this.custGlim);
	this.createCustFC();
	this.instructionsBox.appendChild(this.custFC);
	this.createCustSamp();
	this.instructionsBox.appendChild(this.custSamp);
	this.createCustLA();
	this.instructionsBox.appendChild(this.custLA);
};
LUTInfoBox.prototype.showMainscreen = function() {
	this.hideAll();
	this.mainscreen.className = 'info-page';
};
LUTInfoBox.prototype.showCamInfo = function() {
	this.hideAll();
	this.insCam.className = 'info-page';
};
LUTInfoBox.prototype.showGamInfo = function() {
	this.hideAll();
	this.insGam.className = 'info-page';
};
LUTInfoBox.prototype.showCustscreen = function() {
	this.hideAll();
	this.insTwk.className = 'info-page';
};
LUTInfoBox.prototype.showLutInfo = function() {
	this.hideAll();
	this.insLut.className = 'info-page';
};
LUTInfoBox.prototype.showPreInfo = function() {
	this.hideAll();
	this.insPre.className = 'info-page';
};
LUTInfoBox.prototype.showGenInfo = function() {
	this.hideAll();
	this.insGen.className = 'info-page';
};
LUTInfoBox.prototype.showGstInfo = function() {
	this.hideAll();
	this.insGst.className = 'info-page';
};
LUTInfoBox.prototype.showSetInfo = function() {
	this.hideAll();
	this.insSet.className = 'info-page';
};
LUTInfoBox.prototype.showInfInfo = function() {
	this.hideAll();
	this.insInf.className = 'info-page';
};
LUTInfoBox.prototype.showCdtInfo = function() {
	this.hideAll();
	this.insCdt.className = 'info-page';
};
LUTInfoBox.prototype.showClgInfo = function() {
	this.hideAll();
	this.insClg.className = 'info-page';
};
LUTInfoBox.prototype.showCustColourInfo = function() {
	this.hideAll();
	this.custColour.className = 'info-page';
};
LUTInfoBox.prototype.showCustWhtInfo = function() {
	this.hideAll();
	this.custWht.className = 'info-page';
};
LUTInfoBox.prototype.showCustPsstInfo = function() {
	this.hideAll();
	this.custPsst.className = 'info-page';
};
LUTInfoBox.prototype.showCustASCInfo = function() {
	this.hideAll();
	this.custASC.className = 'info-page';
};
LUTInfoBox.prototype.showCustMultiInfo = function() {
	this.hideAll();
	this.custMulti.className = 'info-page';
};
LUTInfoBox.prototype.showCustHGInfo = function() {
	this.hideAll();
	this.custHG.className = 'info-page';
};
LUTInfoBox.prototype.showCustKneeInfo = function() {
	this.hideAll();
	this.custKnee.className = 'info-page';
};
LUTInfoBox.prototype.showCustBhiInfo = function() {
	this.hideAll();
	this.custBhi.className = 'info-page';
};
LUTInfoBox.prototype.showCustSDRSInfo = function() {
	this.hideAll();
	this.custSDRS.className = 'info-page';
};
LUTInfoBox.prototype.showCustBgmInfo = function() {
	this.hideAll();
	this.custBgm.className = 'info-page';
};
LUTInfoBox.prototype.showCustDCCInfo = function() {
	this.hideAll();
	this.custDCC.className = 'info-page';
};
LUTInfoBox.prototype.showCustGlimInfo = function() {
	this.hideAll();
	this.custGlim.className = 'info-page';
};
LUTInfoBox.prototype.showCustFCInfo = function() {
	this.hideAll();
	this.custFC.className = 'info-page';
};
LUTInfoBox.prototype.showCustSampInfo = function() {
	this.hideAll();
	this.custSamp.className = 'info-page';
};
LUTInfoBox.prototype.showCustLAInfo = function() {
	this.hideAll();
	this.custLA.className = 'info-page';
};
LUTInfoBox.prototype.hideAll = function() {
	this.mainscreen.className = 'info-page-hide';
	this.insCam.className = 'info-page-hide';
	this.insGam.className = 'info-page-hide';
	this.insTwk.className = 'info-page-hide';
	this.insLut.className = 'info-page-hide';
	this.insPre.className = 'info-page-hide';
	this.insGen.className = 'info-page-hide';
	this.insGst.className = 'info-page-hide';
	this.insSet.className = 'info-page-hide';
	this.insInf.className = 'info-page-hide';
	this.insCdt.className = 'info-page-hide';
	this.insClg.className = 'info-page-hide';
	this.custColour.className = 'info-page-hide';
	this.custWht.className = 'info-page-hide';
	this.custPsst.className = 'info-page-hide';
	this.custASC.className = 'info-page-hide';
	this.custMulti.className = 'info-page-hide';
	this.custHG.className = 'info-page-hide';
	this.custKnee.className = 'info-page-hide';
	this.custBhi.className = 'info-page-hide';
	this.custSDRS.className = 'info-page-hide';
	this.custBgm.className = 'info-page-hide';
	this.custDCC.className = 'info-page-hide';
	this.custGlim.className = 'info-page-hide';
	this.custFC.className = 'info-page-hide';
	this.custSamp.className = 'info-page-hide';
	this.custLA.className = 'info-page-hide';
};
LUTInfoBox.prototype.createMainscreen = function() {
	this.mainscreen = document.createElement('div');
	this.mainscreen.id = 'ins-mainscreen';
	var click = document.createElement('p');
	click.innerHTML = 'Click an area for information:';
	this.mainscreen.appendChild(click);
	var mainBox = document.createElement('div');
	mainBox.id = 'ins-mainbox';
	this.mainscreen.appendChild(mainBox);

	var header = this.createFigure('empty','pngs/main-header.png',33.6842);
	header.id = 'ins-main-header';	
	mainBox.appendChild(header);
	var left = document.createElement('div');
	left.id = 'ins-main-left';
	mainBox.appendChild(left);
	var right = document.createElement('div');
	right.id = 'ins-main-right';
	mainBox.appendChild(right);
	var footer = this.createFigure('empty','pngs/main-footer.png',45.7143);
	footer.id = 'ins-main-footer';	
	mainBox.className = 'info-page-hide';
	mainBox.appendChild(footer);

	this.insMainCam = this.createFigure('main','pngs/main-cam.png',5.614);
	this.insMainCam.id = 'ins-main-cam';
	var camInf = document.createElement('p');
	camInf.className = 'ins-main-title';
	camInf.innerHTML = 'Set Camera';
	this.insMainCam.appendChild(camInf);
	left.appendChild(this.insMainCam);

	this.insMainGam = this.createFigure('main','pngs/main-gam.png',4.493);
	this.insMainGam.id = 'ins-main-gam';
	var gamInf = document.createElement('p');
	gamInf.className = 'ins-main-title';
	gamInf.innerHTML = 'Set Gamma / Gamut';
	this.insMainGam.appendChild(gamInf);
	left.appendChild(this.insMainGam);

	this.insMainTwk = this.createFigure('main','pngs/main-twk.png',1.1808);
	this.insMainTwk.id = 'ins-main-twk';
	var twkInf = document.createElement('p');
	twkInf.className = 'ins-main-title';
	twkInf.innerHTML = 'Adjustments';
	this.insMainTwk.appendChild(twkInf);
	left.appendChild(this.insMainTwk);

	var spacer = document.createElement('div');
	spacer.id = 'ins-main-spacer';	
	left.appendChild(spacer);

	this.insMainLut = this.createFigure('main','pngs/main-lut.png',2.4615);
	this.insMainLut.id = 'ins-main-lut';
	var genInf = document.createElement('p');
	genInf.className = 'ins-main-title';
	genInf.innerHTML = 'Generate LUT';
	this.insMainLut.appendChild(genInf);
	right.appendChild(this.insMainLut);

	var buttons = document.createElement('div');
	buttons.id = 'ins-main-buttons';
	right.appendChild(buttons);

	this.insMainPre = document.createElement('div');
	this.insMainPre.className = 'fig-but';
	var wrapper = document.createElement('div');
	this.insMainPre.appendChild(wrapper);
	var fig = document.createElement('div');
	wrapper.appendChild(fig);
	this.insMainPre.id = 'ins-main-pre';
	var preInf = document.createElement('p');
	preInf.className = 'ins-main-title';
	preInf.innerHTML = 'Preview Window';
	this.insMainPre.appendChild(preInf);
	buttons.appendChild(this.insMainPre);

	this.insMainGen = this.createFigure('but','pngs/main-but-gen.png',5.6667);
	this.insMainGen.id = 'ins-main-gen';
	buttons.appendChild(this.insMainGen);

	this.insMainGst = this.createFigure('but','pngs/main-but-gst.png',5.6667);
	this.insMainGst.id = 'ins-main-gst';
	buttons.appendChild(this.insMainGst);

	this.insMainSet = this.createFigure('but','pngs/main-but-set.png',3.75);
	this.insMainSet.id = 'ins-main-set';
	buttons.appendChild(this.insMainSet);

	this.insMainInf = this.createFigure('main','pngs/main-inf.png',1.3115);
	this.insMainInf.id = 'ins-main-inf';
	var infInf = document.createElement('p');
	infInf.className = 'ins-main-title';
	infInf.innerHTML = 'Charts / Tables / Instructions';
	this.insMainInf.appendChild(infInf);
	right.appendChild(this.insMainInf);

	var credits = document.createElement('h5');
	credits.className = 'creditbutton';

	this.changelogButton = document.createElement('a');
	this.changelogButton.innerHTML = 'Changelog';
	credits.appendChild(this.changelogButton);
	this.creditsButton = document.createElement('a');
	this.creditsButton.innerHTML = 'Credits';
	credits.appendChild(this.creditsButton);
	mainBox.appendChild(credits);
};
LUTInfoBox.prototype.createCamInfo = function() {
	this.insCam = document.createElement('div');
	this.insCam.id = 'ins-cam';
	this.insCamBack = document.createElement('input');
	this.insCamBack.setAttribute('type','button');
	this.insCamBack.value = 'Back';
	this.insCam.appendChild(this.insCamBack);
	this.insCamInfo = document.createElement('div');
	this.insCamInfo.setAttribute('class','infotext');
	this.insCamInfo.appendChild(this.createFigure('box','pngs/ins-cam-1.png',5.6));
	this.addInfo(this.insCamInfo,false,null,'This box defines which camera model the LUT generated is to be used with.');
	this.addInfo(this.insCamInfo,false,null,'Camera manufacturers take differing approaches to recording log, which primarily effect how exposure corrections are handled.');
	this.addInfo(this.insCamInfo,true,'The Sony Approach','Sony have arguably the most pure approach to log. The entire dynamic range of the camera is captured, with changes in ISO being stored purely as metadata in the clip file.');
	this.addInfo(this.insCamInfo,true,null,'Post production software is then expected to read the metadata and automatically do the exposure adjustment.');
	this.addInfo(this.insCamInfo,true,null,'In practice this does not currently always work, so LUTCalc can be used to create exposure corrected LUTs, eg LC709A with a 1-stop push.');
	this.addInfo(this.insCamInfo,true,null,"Exposure can be entered either as the CineEI ISO value used, or as a stop correction from the base ISO, which is shown as 'Native ISO' next to the camera model.");
	this.addInfo(this.insCamInfo,true,'The Canon Approach','The C300 has popularised log recording with CP Lock, but only records in 8-bit. Log is normally recorded in at least 10-bit, to ensure a broad spread of picture data even after the contrast is increased in post.');
	this.addInfo(this.insCamInfo,true,null,'In order to have a reasonable result in the midtones and highlights, C-Log spreads information very thinly in the shadows. Storing exposure shifts as metadata and performing the adjustment in post would work very badly when pushing to increase the ISO, so Canon bakes in the exposure shift.');
	this.addInfo(this.insCamInfo,true,null,'Consequently, the full dynamic range of the camera is only captured at the base ISO.');
	this.addInfo(this.insCamInfo,true,null,"LUTCalc allows you to generate exposure shifts, but as the ISO is arbitrary, it only shows the 'exposure correction' option for the Cine EOS cameras. LUTs for the C300 will also be appropriate for the C100 and C500");
	this.addInfo(this.insCamInfo,true,'The Arri Approach','Somewhere between the other two, in LogC Arri adjusts the log parameters with ISO, incorporating a slight knee at high ISOs. Combined with higher bit depths than in the C300, this means that the full dynamic range is always captured.');
	this.addInfo(this.insCamInfo,true,null,'Whilst adding complexity behind the scenes, this is arguably the most elegant approach, ensuring the edit sees footage exposed as intended regardless of metadata capabilities (unlike Sony) yet avoiding clipping the dynamic range (unlike Canon).');
	this.insCam.className = 'info-page-hide';
	this.insCam.appendChild(this.insCamInfo);
};
LUTInfoBox.prototype.createGamInfo = function() {
	this.insGam = document.createElement('div');
	this.insGam.id = 'ins-gam';
	this.insGamBack = document.createElement('input');
	this.insGamBack.setAttribute('type','button');
	this.insGamBack.value = 'Back';
	this.insGam.appendChild(this.insGamBack);
	this.insGamInfo = document.createElement('div');
	this.insGamInfo.setAttribute('class','infotext');
	this.insGamInfo.appendChild(this.createFigure('box','pngs/ins-gam-1.png',4.48));
	this.addInfo(this.insGamInfo,false,null,'This box is used to set the transfer function and colour space that the camera records to and the basic combination that the LUT is intended to output.');
	this.addInfo(this.insGamInfo,false,null,"The menus refer to 'Gamma' and 'Gamut' as these terms are in common use and generally understood in the context, though the accurate terms should be 'Transfer Function' and 'Colour Space'.");
	this.addInfo(this.insGamInfo,false,null,'There are four types of transfer function offered:');
	this.addInfo(this.insGamInfo,true,'Log Curves','These are designed to spread picture information evenly between stops and are how cameras are able to capture high dynamic range within limited bit depth whilst allowing extensive manipulation in post.');
	this.addInfo(this.insGamInfo,true,null,'They are not intended to be used uncorrected, appearing very flat and dull. For this reason they are also not very suitable for setting exposures to. Examples are S-Log, S-Log2 and S-Log3 on Sony cameras, C-Log on Canon cameras and LogC on Arris.');
	this.addInfo(this.insGamInfo,true,'Linear And Gamma Curves',"These are offered when 'Linear/Rec709' is selected in the gamma boxes. Pure linear is effectively the sensor response of the camera; the value is proportional to the number of photons hitting the sensor.");
	this.addInfo(this.insGamInfo,true,null,'Displays generally expect the linear signal to be adjusted with a power function, raising the linear value in relation to a power known as the gamma. sRGB is common in computing and photography, Rec709 is the standard for HDTV and Rec2020 is a slight refinement of Rec709 for UHDTV and deeper bit depths.');
	this.addInfo(this.insGamInfo,true,'Creative Curves','These are curves which are not defined by standards, though generally relate to them. An example is Rec709(800%) which is a Sony interpretation of Rec709 with a smooth knee to extend the dynamic range captured to 800% IRE at a recording level of 109%. These are the main choices for useful camera gammas.');
	this.addInfo(this.insGamInfo,true,'Hybrid Gamma Curves',"These are the high dynamic range (HDR) replacements for the current Rec709/Rec2020 curves in displays. Two systems with differing approaches have become standardised under ITU Rec2100.");
	this.addInfo(this.insGamInfo,true,null,"Hybrid-Log Gamma or HLG is a curve developed by the BBC in the UK and NHK in Japan. In the spec, 100% conventional gamma maps to 50% HLG, with values below this behaving as a conventional power curve gamma.  Above this though, HLG transitions to a log response, with an even distribution stop to stop in the highlights. As such, it is designed to offer compatibility with conventional screens, but with extended dynamic range for HDR screens. HLG is 'scene referred'.");
	this.addInfo(this.insGamInfo,true,null,"Perceptual Quantisation or PQ is a system developed by Dolby as a 'clean slate' HDR system. It spreads data based upon the human eye's ability to perceive gradations (ie banding) and is ultimately targeted at 12-bit transmission. PQ is display referenced.");
	this.addInfo(this.insGamInfo,true,null,"LUTCalc's model is based upon scene referred calculations, so includes display referred to scene referred options for PQ, known as OOTFs. These are the PQ reference OOTF, the HLG reference OOTF (to be used for conversions between PQ and HLG and back) and a 'no OOTF' PQ option.");
	this.addInfo(this.insGamInfo,true,null,"LUTCalc also includes a couple of earlier HDR proposals developed on the way to Rec2100.");
	this.addInfo(this.insGamInfo,false,null,'There are two main types of colour space:');
	this.addInfo(this.insGamInfo,true,'Matrix','These are gamuts where a picture can be changed from one to another via a 3x3 matrix performed on linear data. There are capture ones such as the S-Gamuts, Arri Wide Gamut and Canon Cinema Gamut, photometric and intermediate ones such as XYZ and ACES and output gamuts such as Rec709 and Rec2020 (the last two have very similar transfer functions, but the Rec2020 colour space is much wider than the Rec709 one).');
	this.addInfo(this.insGamInfo,true,'LUT','These are ones where the conversion from another colour space is complex and may be irreversible, so LUTCalc stores them as LUTs internally. The advantage is that they can have more complex responses than basic matrices, changing saturation with colour and exposure or tuning the look to favour skin tones or natural greens. Examples include LC709 and LC709A, based on the look profiles produced by Sony.');
	this.addInfo(this.insGamInfo,true,null,'LC709 as a colour space gives a similar though arguably subtler colour response than the basic Rec709 matrix');
	this.insGam.className = 'info-page-hide';
	this.insGam.appendChild(this.insGamInfo);
};
LUTInfoBox.prototype.createTwkInfo = function() {
	this.insTwk = document.createElement('div');
	this.insTwk.id = 'ins-twk';
	this.insCustBack = document.createElement('input');
	this.insCustBack.setAttribute('type','button');
	this.insCustBack.value = 'Back';
	this.insTwk.appendChild(this.insCustBack);
	var click = document.createElement('p');
	click.appendChild(document.createTextNode('Click an area for information:'));
	this.insTwk.appendChild(click);
	this.custscreen = document.createElement('div');
	this.custscreen.id = 'ins-custscreen';
	this.custbox = document.createElement('div');
	this.custbox.id = 'ins-cust-box';
	var header = document.createElement('div');
	header.id = 'ins-cust-header';	
	this.custbox.appendChild(this.createFigure('empty','pngs/cust-header.png',19.4348));
	this.insCustColour = this.createFigure('cust','pngs/cust-colour.png',15.9643);
	this.custbox.appendChild(this.insCustColour);
	this.insCustWht = this.createFigure('cust','pngs/cust-wht.png',15.9643);
	this.custbox.appendChild(this.insCustWht);
	this.insCustPsst = this.createFigure('cust','pngs/cust-psst.png',15.9643);
	this.custbox.appendChild(this.insCustPsst);
	this.insCustASC = this.createFigure('cust','pngs/cust-asc.png',15.9643);
	this.custbox.appendChild(this.insCustASC);
	this.insCustMulti = this.createFigure('cust','pngs/cust-multi.png',15.9643);
	this.custbox.appendChild(this.insCustMulti);
	this.insCustHG = this.createFigure('cust','pngs/cust-hg.png',15.9643);
	this.custbox.appendChild(this.insCustHG);
	this.insCustKnee = this.createFigure('cust','pngs/cust-knee.png',15.9643);
	this.custbox.appendChild(this.insCustKnee);
	this.insCustBhi = this.createFigure('cust','pngs/cust-bhi.png',15.9643);
	this.custbox.appendChild(this.insCustBhi);
	this.insCustBgm = this.createFigure('cust','pngs/cust-bgm.png',15.9643);
	this.custbox.appendChild(this.insCustBgm);
	this.insCustSDRS = this.createFigure('cust','pngs/cust-sdrs.png',15.9643);
	this.custbox.appendChild(this.insCustSDRS);
	this.insCustDCC = this.createFigure('cust','pngs/cust-dcc.png',15.9643);
	this.custbox.appendChild(this.insCustDCC);
	this.insCustGlim = this.createFigure('cust','pngs/cust-glim.png',15.9643);
	this.custbox.appendChild(this.insCustGlim);
	this.insCustFC = this.createFigure('cust','pngs/cust-fc.png',15.9643);
	this.custbox.appendChild(this.insCustFC);
	this.insCustSamp = this.createFigure('cust','pngs/cust-samp.png',15.9643);
	this.custbox.appendChild(this.insCustSamp);
	this.insCustLA = this.createFigure('cust','pngs/cust-la.png',6.4783);
	this.custbox.appendChild(this.insCustLA);
	this.custscreen.appendChild(this.custbox);
	this.custscreen.appendChild(document.createElement('br'));
	this.insTwk.className = 'info-page-hide';
	this.insTwk.appendChild(this.custscreen);
};
LUTInfoBox.prototype.createLutInfo = function() {
	this.insLut = document.createElement('div');
	this.insLut.id = 'ins-lut';
	this.insLutBack = document.createElement('input');
	this.insLutBack.setAttribute('type','button');
	this.insLutBack.value = 'Back';
	this.insLut.appendChild(this.insLutBack);
	this.insLutInfo = document.createElement('div');
	this.insLutInfo.setAttribute('class','infotext');
	this.insLutInfo.appendChild(this.createFigure('box','pngs/ins-lut-1.png',2.4615));
	this.addInfo(this.insLutInfo,false,null,'This is the box where the format of the LUT to be generated is decided.');
	this.addInfo(this.insLutInfo,false,null,"The first option is 'LUT Title / Filename'. As well as being used as the filename for saving the LUT, this appears within the file as the title. This may help keep track of LUTs in case filenames change. LUTCalc will make sure that it is appropriately formatted.");
	this.addInfo(this.insLutInfo,false,null,"Next to the title box is the 'Auto Title' button. Clicking this will generate a title based upon the current input and output choices, plus any black level and colour saturation customisation.");
	this.addInfo(this.insLutInfo,false,null,'LUTCalc produces 1D and 3D LUTs:');
	this.addInfo(this.insLutInfo,true,'1D','these are used for contrast control, with each colour channel changed independently.');
	this.addInfo(this.insLutInfo,true,null,'With a 1D LUT it is practical to store every possible 8-bit, 10-bit or 16-bit value. As such the adjustment can be arbitrarily complex, which may well be useful for storing an extensive grade, but with smooth curves such as those built in to LUTCalc and the use of cubic interpolation, considerably fewer control point are needed for an effective result.');
	this.addInfo(this.insLutInfo,true,'3D','3D LUTs input combinations of red, green and blue values to reference output values. This allows for sophisticated adjustment of colours across the gamut and exposure range. Where a 1024-point 1D LUT covers every possible 10-bit input value for one channel, a 3D LUT would need to be 1024x1024x1024-point to consider every possible RGB combination.');
	this.addInfo(this.insLutInfo,true,null,'This would be impractically large and complex, so 3D LUTs are generally of a much smaller dimension and use interpolation to obtain intermediate values. LUTCalc can produce the most common 3D sizes for a chosen LUT format.');
	this.addInfo(this.insLutInfo,true,null,'Sony F cameras accept 33x33x33 cubes and this size does a very good job of reproducing the kinds of effects possible in LUTCalc. 65x65x65 is much larger, but gives greater precision for post software where the size is less of an issue.');
	this.addInfo(this.insLutInfo,false,null,'After the dimension settings come the range options. Cube LUTs contain floating point values rather than integers, and generally map 0 to be black and 1 to be white. Values can actually be greater or less than these, but 0 and 1 are the reference points. What 0 and 1 actually represent depends on the video range used.');
	this.addInfo(this.insLutInfo,true,'100%',"10-bit binary can store 1024 different values, in the decimal range 0-1023. In analogue video picture information was stored within a voltage range defined as a percentage 0%-100%. Values just outside were that classed 'super black' and 'super white'.");
	this.addInfo(this.insLutInfo,true,null,"In digital video, 0% IRE has been defined as 10-bit 64 in decimal, with 100% IRE at 10-bit 940. With 'legal range' set 0 in the LUT equates to 0% IRE and 1 equates to 100% IRE. On this scale, 10-bit 0 would be -0.073 and 10-bit 1023 1.095.");
	this.addInfo(this.insLutInfo,true,null,"This is a commonly expected output range in software such as DaVinci Resolve and is the output range of Sony monitor LUTs (MLUTS).");
	this.addInfo(this.insLutInfo,true,'109%','this treats the full range of 10-bit values as mapping to the 0-1 LUT range. Technically, the top and bottom couple of values are generally reserved, but for the sake of simplicity that can be ignored here. LUTs can output values outside of the 0-1 range, but can only consider input values within it. If a log recording goes outside of legal range (generally only above 1), then the LUT input needs to be data range to make sure that no data is lost.');
	this.addInfo(this.insLutInfo,true,null,'S-Log2 and Canon C-Log both go above legal range, and for consistency Sony recommends working with S-Log3 set to data range in software such as Resolve. Sony MLUTs are data in, legal out.');
	this.addInfo(this.insLutInfo,false,null,'LUTCalc will generally default to data in, legal out, though if both the input and output gammas are log curves then it will set data in data out, on the assumption that further LUTs or corrections will be applied.');
	this.addInfo(this.insLutInfo,false,null,'It has also been suggested that the Lumetri plugin in Adobe Premiere CC expects data in, data out in order to give the correct look. The best suggestion is to test and compare in the software to be used in post.');
	this.addInfo(this.insLutInfo,false,null,'The final set of options sets the levels and output format correctly for a particular task or camera.');
	this.addInfo(this.insLutInfo,true,'Grading LUT','This brings up a set of options for generating LUTs suitable for postproduction software. The default option is a generic .cube file, but a number of alternate formats and specific pieces of software are also available.');
	this.addInfo(this.insLutInfo,true,'Camera LUT (MLUT)','This option is for generating LUT suitable for loading into a camera for use as a monitor LUT, or MLUT.');
	this.addInfo(this.insLutInfo,false,null,'Some LUT formats allow for scaling of the inputs, to allow for inputs which needs to lie outside of 0-1.0. An example would be a linear to log LUT, where the linear range between 0 and 1.0 is only a small portion of a log curve. Scaling means that the input range in this case could be between 0 and 12.0.');
	this.addInfo(this.insLutInfo,false,null,'Where a LUT format supports scaling, LUTCalc will display minimum and maximum boxes. These default to 0 and 1.0 respectively, and generally do not need to be changed.');
	this.insLutInfo.appendChild(this.createFigure('box','pngs/ins-lut-2.png',5.818));
	this.addInfo(this.insLutInfo,true,'Hard Clip','Many LUT formats permit output values beyond 0-1. This allows limited dynamic range conversions such as linear or Rec709 to be performed non-destructively, ie the overexposed data can still be pulled back into range.');
	this.addInfo(this.insLutInfo,true,null,'Some software does not handle out of range values correctly, so this drop down allows for clipping of black (0), white (1) or both black and white.');
	this.addInfo(this.insLutInfo,true,null,"If clipping is applied and the output range for LUTs is set to 'Data', an additional checkbox will appear, '0%-100%'. Check this and the clipping will be held to legal range, ie for 10-bit data range black is 64 and white 959 out of 1023.");
	this.addInfo(this.insLutInfo,true,null,'Use of hard clipping does mean that data outside of the clipped range is lost.');
	this.insLut.className = 'info-page-hide';
	this.insLut.appendChild(this.insLutInfo);
};
LUTInfoBox.prototype.createPreInfo = function() {
	this.insPre = document.createElement('div');
	this.insPre.id = 'ins-gen';
	this.insPreBack = document.createElement('input');
	this.insPreBack.setAttribute('type','button');
	this.insPreBack.value = 'Back';
	this.insPre.appendChild(this.insPreBack);
	this.insPreInfo = document.createElement('div');
	this.insPreInfo.setAttribute('class','infotext');
	this.insPreInfo.appendChild(this.createFigure('box','pngs/ins-pre-1.jpg',1.437));
	this.addInfo(this.insPreInfo,false,null,"Clicking 'Preview' brings up a test image below the row of buttons. By default it is displayed legal range and reflects any adjustments made.");
	this.addInfo(this.insPreInfo,false,null,'LUTCalc includes five test images built in, with the option to load an additional image.');
	this.addInfo(this.insPreInfo,true,'High Contrast','This image covers around eleven or twelve stops and with the brightest highlights around 5 1/2 stops above 18% gray.');
	this.addInfo(this.insPreInfo,true,'Low Contrast','This image is against greenscreen and stays within the dynamic range of Rec709, with highlights about 2 1/3 stops above 18% gray.');
	this.addInfo(this.insPreInfo,true,'Rec709 Gamut','This visualises colours across the entire Rec709 colour gamut. The layout matches the positions of the colours on a Rec709 vectorscope.');
	this.addInfo(this.insPreInfo,true,'xy / uv Chromacity','Here the entire gamut of human vision (CIE 1931 standard observer, XYZ) is displayed in standard chromacity charts. CIE1931 xy is the conventional representation of the XYZ gamut, where CIE1960 uv is a more linear representation used in colour temperature calculations. The Planck Locus (colour temperature line) is shown as a white curve.');
	this.insPreInfo.appendChild(this.createFigure('box','pngs/ins-pre-2.jpg',1.7778));
	this.addInfo(this.insPreInfo,true,null,'On top of this are overlaid triangles representing the primaries of the current selected recording gamut and the net output gamut after adjustment, plus dot markers of the white points. Highly nonlinear adjustments (ie PSST-CDL) are not factored in to the triangle calculation, though White Balance and ASC-CDL are. Complex colour spaces (eg LC709 and LC709A assume the Rec709 primaries as their base).');
	this.addInfo(this.insPreInfo,true,null,'the region where the two triangles overlap is a guide to the range of colours available in the finished image.');
	this.addInfo(this.insPreInfo,true,'Grayscale','A 16-stop grayscale. The upper portion smoothly shifts from 8 stops below mid gray to 7 stops above, with the lower portion going in one-stop steps. The vertical line marks 18% gray. On the waveform, this image will match up with the Stop/IRE chart.');
	this.addInfo(this.insPreInfo,false,null,'The high and low contrast images include a set of Rec709 75% and 100% primary and secondary boxes, a 16-stop grayscale and a colour chart on the right.');
	this.addInfo(this.insPreInfo,false,null,'The high contrast image also includes colour charts four stops above and below base and the low contrast chart two stops above and below.');
	this.addInfo(this.insPreInfo,false,null,'As the cursor moves over the preview window, the output 10-bit code values at that point are displayed above the image.');
	this.addInfo(this.insPreInfo,false,null,"An image recorded in a known colour space can also be loaded in place of the defaults by clicking 'Load Preview...'. The webapp version of LUTCalc accepts 8-bit formats, such as JPEG, PNG and BMP. LUTCalc For Mac can additionally read 16-bit TIFF and PNG images.");
	this.addInfo(this.insPreInfo,false,null,'Once loaded, the new image becomes available with the default selections.');
	this.addInfo(this.insPreInfo,false,null,"By default the preview image is displayed legal range (0%-100%), but by clicking '109%' the image is darkened a little to give a representation of extended range details (0%-109%).");
	this.addInfo(this.insPreInfo,false,null,"'Large Image' / 'Small Image' toggles between the default small preview image and a larger version which requires scrolling to view the scopes.");
	this.addInfo(this.insPreInfo,false,null,'Above the preview window are the scope options:');
	this.insPreInfo.appendChild(this.createFigure('box','pngs/ins-pre-3.png',4.7059));
	this.addInfo(this.insPreInfo,true,'WFM','Waveform monitor. The horizontal axis is the same as the test image, whilst the vertical axis is luma values of all the pixels in that column. The scale lines are blocks of 10% IRE and the full range runs from -7% to +109%.');
	this.addInfo(this.insPreInfo,true,'Vector','Vectorscope. This is a polar plot of the image chroma. LUTCalc includes standard 75% and 100% Rec709 boxes (the two rows of green circles). In pure Rec709 75% colourspace (gamma and gamut) colour bars should fall dead centre of the inner green circles.');
	this.addInfo(this.insPreInfo,true,null,'In addition there is a set of 75% Rec709 boxes that have been mapped to the current chosen colour space. These are the colour of their associated primary or secondary and will lie inside the green ones.');
	this.addInfo(this.insPreInfo,true,null,'These give a guide to the size and nature of the chosen colour space, and also where a test chart should lie for correcting colour casts without changing colour space.');
	this.addInfo(this.insPreInfo,true,'RGB','RGB Parade. Similar to the waveform, but the red, green and blue components are separated horizontally.');
	this.insPre.className = 'info-page-hide';
	this.insPre.appendChild(this.insPreInfo);
};
LUTInfoBox.prototype.createGenInfo = function() {
	this.insGen = document.createElement('div');
	this.insGen.id = 'ins-gen';
	this.insGenBack = document.createElement('input');
	this.insGenBack.setAttribute('type','button');
	this.insGenBack.value = 'Back';
	this.insGen.appendChild(this.insGenBack);
	this.insGenInfo = document.createElement('div');
	this.insGenInfo.setAttribute('class','infotext');
	this.addInfo(this.insGenInfo,false,'Generate','The GO button!');
	this.addInfo(this.insGenInfo,false,null,'In most browsers you will either be given a choice of where to save your LUT, or it will automatically go to the Downloads folder.');
	this.addInfo(this.insGenInfo,false,null,'In some versions of Safari it may just appear in a new browser tab. In that case you will need to save it manually.');
	this.addInfo(this.insGenInfo,false,null,'LUTCalc For Mac allows you to choose the destination for saving.');
	this.insGen.className = 'info-page-hide';
	this.insGen.appendChild(this.insGenInfo);
};
LUTInfoBox.prototype.createGstInfo = function() {
	this.insGst = document.createElement('div');
	this.insGst.id = 'ins-gst';
	this.insGstBack = document.createElement('input');
	this.insGstBack.setAttribute('type','button');
	this.insGstBack.value = 'Back';
	this.insGst.appendChild(this.insGstBack);
	this.insGstInfo = document.createElement('div');
	this.insGstInfo.setAttribute('class','infotext');
	this.addInfo(this.insGstInfo,false,'Generate Set','allows you to batch generate multiple versions of your LUT across a range of exposure compensations.');
	this.addInfo(this.insGstInfo,false,null,'The options available are to set the lower and upper bounds of the exposure range you wish to generate, then the step size in fractions of a stop.');
	this.addInfo(this.insGstInfo,false,null,'The default is to produce a set from two stops below native to two stops above, in steps of 1/3 of a stop.');
	this.insGst.className = 'info-page-hide';
	this.insGst.appendChild(this.insGstInfo);
};
LUTInfoBox.prototype.createSetInfo = function() {
	this.insSet = document.createElement('div');
	this.insSet.id = 'ins-set';
	this.insSetBack = document.createElement('input');
	this.insSetBack.setAttribute('type','button');
	this.insSetBack.value = 'Back';
	this.insSet.appendChild(this.insSetBack);
	this.insSetInfo = document.createElement('div');
	this.insSetInfo.setAttribute('class','infotext');
	this.addInfo(this.insSetInfo,false,'Settings','Here you have the option to save the current state of all the options and customisations in LUTCalc, or to reload preferred settings previously saved.');
	this.addInfo(this.insSetInfo,false,null,"The settings are saved in files ending '.lutcalc'.");
	this.insSet.className = 'info-page-hide';
	this.insSet.appendChild(this.insSetInfo);
};
LUTInfoBox.prototype.createInfInfo = function() {
	this.insInf = document.createElement('div');
	this.insInf.id = 'ins-inf';
	this.insInfBack = document.createElement('input');
	this.insInfBack.setAttribute('type','button');
	this.insInfBack.value = 'Back';
	this.insInf.appendChild(this.insInfBack);
	this.insInfPic = document.createElement('div');
	this.insInfPic.id = 'ins-inf-pic';
	this.insInf.appendChild(this.insInfPic);
	this.insInfInfo = document.createElement('div');
	this.insInfInfo.setAttribute('class','infotext');
	this.insInfInfo.appendChild(this.createFigure('box','pngs/ins-inf-1.png',1.3099));
	this.addInfo(this.insInfInfo,false,null,'This box contains provides information about the current LUT under construction including suggested exposure values and transfer curves, plus instructions for LUTCalc.');
	this.addInfo(this.insInfInfo,false,'Instructions','Hopefully fairly obvious, after all here you are!');
	this.addInfo(this.insInfInfo,false,'Tables','This shows tables of % IRE and 10-bit values for the current output curve, both for common reflectances and for stops above and below 18% gray. The Stop to stop values are given first for with the LUT applied, and then the pre-LUT equivalents. Useful if applying LUTs in a monitor with a pre-LUT waveform.');
	this.addInfo(this.insInfInfo,false,'Charts','This provides three different ways of comparing input and output levels:');
	this.addInfo(this.insInfInfo,true,'Ref/IRE','Reflectance levels of the scene (eg 18% gray, 90% white) against % IRE. The simplest chart, but as the x-axis is linear it is hard to read anything meaningful from it.');
	this.addInfo(this.insInfInfo,true,'Stop/IRE','Shows the output level against input stops. Clearly shows the difference between linear/gamma (keep increasing in slope), log curves (tend towards a straight line slope in the highlights and curves with knee (tend towards a horizontal line in the highlights). Also gives a good idea of dynamic range in stops.');
	this.addInfo(this.insInfInfo,true,null,'Areas beyond the range of the chosen camera are shaded. When the CineEI ISO is changed or Stop Correction is applied the level of 18% gray in the underlying recording is shown with a pink vertical line.');
	this.addInfo(this.insInfInfo,true,'LUT In/Out','similar to Stop/IRE, but better shows true black (black is technically minus infinity stops, so Stop/IRE never quite shows it).');
	this.addInfo(this.insInfInfo,false,null,'The charts tab also includes a table of % IRE and 10-bit values for the current curve.');
	this.insInf.className = 'info-page-hide';
	this.insInf.appendChild(this.insInfInfo);
};
LUTInfoBox.prototype.createCdtInfo = function() {
	this.insCdt = document.createElement('div');
	this.insCdt.id = 'ins-cdt';
	this.insCdtBack = document.createElement('input');
	this.insCdtBack.setAttribute('type','button');
	this.insCdtBack.value = 'Back';
	this.insCdt.appendChild(this.insCdtBack);
	this.insCdtInfo = document.createElement('div');
	this.insCdtInfo.setAttribute('class','infotext');
	this.addInfo(this.insCdtInfo,false,null,'All code written by Ben Turley except in the online version:');
	this.addInfo(this.insCdtInfo,true,'FileSaver.js','HTML5 saveAs() polyfill included in the online version of LUTCalc.');
	this.addInfo(this.insCdtInfo,true,null,'By Eli Gray under MIT licence on GitHub.');
	this.addInfo(this.insCdtInfo,true,'Blob.js','W3C Blob polyfill included in the online version of LUTCalc.');
	this.addInfo(this.insCdtInfo,true,null,'By Eli Gray & Devin Samarin under MIT licence on GitHub.');
	this.addInfo(this.insCdtInfo,false,null,'Where available curves and colourspaces included in LUTCalc are derived from publicly available technical documentation from manufacturers and standards bodies.');
	this.addInfo(this.insCdtInfo,false,null,'Other curves have been derived from analysis of my own test images, checked where possible against available sources such as LUTs and charts in marketing materials.');
	this.addInfo(this.insCdtInfo,false,null,'Links to many of the technical documents used in creating LUTCalc are available on the LUTCalc website at www.lutcalc.net.');
	this.insCdt.className = 'info-page-hide';
	this.insCdt.appendChild(this.insCdtInfo);
};
LUTInfoBox.prototype.createClgInfo = function() {
	this.insClg = document.createElement('div');
	this.insClg.id = 'ins-clg';
	this.insClgBack = document.createElement('input');
	this.insClgBack.setAttribute('type','button');
	this.insClgBack.value = 'Back';
	this.insClg.appendChild(this.insClgBack);
	this.insClgInfo = document.createElement('div');
	this.insClgInfo.setAttribute('class','infotext');
    this.addInfo(this.insClgInfo,false,null,"v4.09");
    this.addInfo(this.insClgInfo,true,null,"* New Feature - Blackmagic BMDFilm Gen 5.");
    this.addInfo(this.insClgInfo,true,null,"* New Feature - Fuji F-Log2.");
    this.addInfo(this.insClgInfo,false,null,"v4.08");
    this.addInfo(this.insClgInfo,true,null,"* New Feature - Additonal Sony camera presets.");
	this.addInfo(this.insClgInfo,false,null,"v4.06");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - Apple iPhone 15 Apple Log / Rec2020.");
	this.addInfo(this.insClgInfo,true,null,"* New Feature / Bugfix - ARRI give code value for recording log across the legal range or full range. With ARRI log Gammas, the option now comes up for setting the codec range to legal or full.");
	this.addInfo(this.insClgInfo,false,null,"v4.05");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - ARRI LogC4 and Wide Gamut 4.");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - CIE L* gamma function.");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - CIELAB gamut, combined with L* gamma, makes CIE LAB colourspace.");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - Additional camera presets - ARRI Alexa 35, DJI 4D, DJI Xenmuse X9.");	
	this.addInfo(this.insClgInfo,false,null,"v4.03");
	this.addInfo(this.insClgInfo,true,null,"* Bugfix - Fixed Nikon N-Log bug.");
	this.addInfo(this.insClgInfo,false,null,"v4.02");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - added DaVinci intermediate colourspace - uses green primary based on published matrices and current Resolve 17 rather than published primaries, pending Blackmagic decision on correcting their white paper.");
	this.addInfo(this.insClgInfo,false,null,"v4.0");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - Additional cameras; Sony, Panasonic, DJI, Nikon.");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - Sony Venice-tuned S-Gamut3 and S-Gamut3.cine using primaries calculated from Sony's IDTs (these shouldn't be camera-specific, the S-Gamut primaries should be set in stone, but Sony definitely offers different ones for the Venice).");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - Added Nikon N-Log gamma curve.");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - Fixed point precision setting within settings, so that LUT files can be more precise than the default six or eight decimal places. Good for scene linear output LUTs.");
	this.addInfo(this.insClgInfo,true,null,"* New Feature - Added Sony s709 colourspace, estimated using Venice ACES primaries to reduce green on FS7 / FX9. TBD if this is the right approach.");
	this.addInfo(this.insClgInfo,true,null,"* Feature Change - Improved Arri LogC high ISO highlight response.");
	this.addInfo(this.insClgInfo,true,null,"* Bugfix - Fixed Lumetri / Speedgrade cube linear and conventional gamma settings.");
	this.addInfo(this.insClgInfo,true,null,"* Feature Change - Added 33x LUT option to SmallHD, confirmed SmallHD preset over HDMI and SDI using FX9 and a6500 with latest PageOS4.");
	this.addInfo(this.insClgInfo,false,null,"v3.2 Beta 1");
	this.addInfo(this.insClgInfo,true,null,"New Feature - DJI DLog and DGamut (Zenmuse X5 and X7 version).");
	this.addInfo(this.insClgInfo,true,null,"New Feature - DJI DLog-M based upon test images taken by Mark Walter a Mavic 2.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - 'SDR Saturation' improves HLG compatibility on SDR displays by increasing saturation as per the BT.2390 spec. Available with all HDR options.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Black Gamma was not available for 1D LUTs.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Custom input scaling does not appear or be applied unless explicitly checked. Could cause unexpected results with DaVinci and Adobe cubes if not needed.");
	this.addInfo(this.insClgInfo,false,null,"v3.1.2");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Correct output of 'LUT_1D_INPUT_RANGE' or 'LUT_3D_INPUT_RANGE' in Resolve-style cube files with input scaling.");
	this.addInfo(this.insClgInfo,false,null,"v3.1.1");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - User preview images were not loading.");
	this.addInfo(this.insClgInfo,false,null,"v3.1");
	this.addInfo(this.insClgInfo,true,null,"New Feature - 'Display Colourspace Converter' tool to quickly convert current look to other base colourspaces (eg Rec709 version and then DCI-P3 version).");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Sony Cinegamma 3 and Cinegamma 4 based upon analysis of test images taken with an a7s.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Separation on Rec2100 OOTFs and OETF/EOTFs for display referred conversions in PQ and Hybrid-log Gamma.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Splash screen displays progress bar.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Full rewrite of the underlying high dynamic range (HDR) PQ and Hybrid-Log Gamma code.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - User interface improvements - online version now uses responsive design principals.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Colour sliders in 'MultiTone' tool now correctly reflect the Gamut Limiter.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fixed problem with saving 1D-only LUTAnalyst lacubes and laluts.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fixed issue with Mac App not reading LUTs with upper-case file extensions.");
	this.addInfo(this.insClgInfo,false,null,"v3.0");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Choice of tricubic, tetrahedral and trilinear interpolation for analysis and use in LUTAnalyst.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Completely new gamut limiter algorithm and code. Legalises colours and fixes potential LUT overshoots when going from a wide Gamut such as S-Gamut3 to a narrow one such as Rec709.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - P3 Colourspace now available with DCI, D60 and D65 white points.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Sony Standard Gammas STD 1-6.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - 'Auto Title' button. Clicking it creates a LUT title containing input and output gamma and gamut details, plus basic info of customisation (currently black level and saturation).");
	this.addInfo(this.insClgInfo,true,null,"New Feature - 'Declip' button on the LUTAnalyst tool. Where LUTs appear to have been clamped (ie the maximum output value is exactly 1.0 and or the minimum exactly 0.0), the declip process will attempt to extrapolate the clipped values, then limit them within a sensible range without hard clipping.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - 'DaVinci Resolve 12+ auto' preset option, to reflect that Resolve 12's default 'auto' clip range setting.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Custom Colour Space can now set primaries from a matrix and white point / illuminant.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Complete rewrite of 3D interpolation / extrapolation code for efficiency, accuracy, clarity and maintainability.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Extensive rewrite of LUTAnalyst code for improved accuracy.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Reworked 1D interpolation code for speed and efficiency.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - New code for estimating the gamut triangle on the 'xy / uv chromacity' preview. Much more robust and efficient.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change / Bugfix - Extensive rewrite of 'Custom Colour Space' code.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Improved interpretation of Canon EOS Standard and Normal gammas.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fixed Javascript policies which stopped LUTCalc working on Internet Explorer / Edge browser.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Gamut Limiter tool was blocking LUT generation.");
	this.addInfo(this.insClgInfo,false,null,"v2.91");
	this.addInfo(this.insClgInfo,true,null,"New Feature - RED Gamma 1 and RED Gamma 2 using data from https://github.com/videovillage/RED-Conversion-LUTs.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Bolex Log and Bolex Wide Gamut.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Reanalysed RED Gamma 4 against RED's 1D LUTs.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - BMD4.6kFilm Gamma output range.");
	this.addInfo(this.insClgInfo,false,null,"v2.90");
	this.addInfo(this.insClgInfo,true,null,"New Feature - BMDFilm4.6k Gamma.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Canon EOS Standard Gamma (plus a version scaled to within legal range).");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Canon Normal 1,2,3 & 4.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - BBC 0.4, 0.5 and 0.6 Gammas.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - RGB Sampler for sampling multiple points on preview images.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Reanalysed BMDFilm and BMDFilm4k Gamma.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fixed 'Print Chart' bug from the last update.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fixed issue in Mac App where white balances could not be taken from the CIE xy / uv preview image.");
	this.addInfo(this.insClgInfo,true,null,"Feature Removal - ALEXA-X-2 Gamut until I have reanalysed the tone map used.");
	this.addInfo(this.insClgInfo,false,null,"v2.60");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Batch-generate sets of exposure compensation LUTs across a user-selectable EI range and step size.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Gamut Limiter. Aims to contain the YPbPr of the output to within the display's range (Rec709/sRGB or Rec2020) when going from a wide gamut to a narrower one, even if the luminance is above legal and extended.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - White and Black clipping can be set individually, and either to the LUT's output range, or always legal.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Preview display and charts now reflect any legal-range clipping applied.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - The 'Log Info' information button is now 'Tables', and shows IRE and 10-bit values for the current output gamma, both for various common reflectances and for each of +/- 8 stops around 18% gray.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - 1350% reflectance has been replaced by 'Clip', to reflect the white clip level of the currently selected camera.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fixed broken ACEScc input code. ACEScc as a 'Rec Gamma' option now works as expected.");
	this.addInfo(this.insClgInfo,false,null,"v2.54");
	this.addInfo(this.insClgInfo,true,null,"Feature Change / Bugfix - RED Log3G10 code updated to version 2 of the spec, with bugfix to the chart input gamma code.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Rec2100 PQ gamma option including display linear code.");
	this.addInfo(this.insClgInfo,false,null,"v2.53");
	this.addInfo(this.insClgInfo,true,null,"New Feature - REDWideGamutRGB and Log3G10.");
	this.addInfo(this.insClgInfo,false,null,"v2.52");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fixed Canon C-Log3 bug.");
	this.addInfo(this.insClgInfo,false,null,"v2.51");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Canon C-Log3.");
	this.addInfo(this.insClgInfo,false,null,"v2.5");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Black Gamma.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Sony FS5 camera option.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Panasonic GH4 V-Log camera option.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - When using LUTAnalyst, the preview window was not automatically updating to reflect the analysed colour gamut.");
	this.addInfo(this.insClgInfo,false,null,"v2.4");
	this.addInfo(this.insClgInfo,true,null,"New Feature - LUTAnalyst automatically sets output gamma and gamut to the analysed LUT.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Alexa Classic 709 (Alexa-X-2) gamma and gamut.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Amira Rec709 gamma.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Improved LogC calculations from Arri's ACES IDTs.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Improved luminance coefficient calculation from colourspace primaries.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Improved flexibility in preset range settings for particular curve / format combinations.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - xy/uv gamut outlines were failing for LUTAnalyst colourspaces.");
	this.addInfo(this.insClgInfo,false,null,"v2.3.8");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Print out the Stop vs IRE chart, plus exposure table and IRE / 10-bit values for each stop from -8 to +8.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - ProPhoto / ROMM RGB colourspace and gamma.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Experimentally-derived DJI D-Log gamma for Zenmuse X3 / Osmo.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - added 14-bit (16384 point) output option to 1D cube files.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Linear and conventional gamma options are now listed under 'Linear / γ' rather than 'Linear / Rec709' to avoid confusion.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change / Provisional Bugfix - changed the way that Dolby PQ is scaled due to user feedback.");
	this.addInfo(this.insClgInfo,false,null,"v2.3.7");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - typo meant that SPI3D files were generated without the mesh sizes.");
	this.addInfo(this.insClgInfo,false,null,"v2.3.6");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Improved / more robust gamma reversal code for LUTAnalyst.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Provisional SmallHD preset based on SmallHD feedback - pending confirmation.");
	this.addInfo(this.insClgInfo,false,null,"v2.3.5");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Hybrid-log gamma.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - All Sony Hypergammas (1-8) plus Cinegammas 1 and 2 are now included (HG4 is also the same as Cinegamma 1, HG2 the same as Cinegamma 2).");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Rec709(800%) with black at 3% (the built-in LUT in Sony CineEI mode) is now included as an input gamma option. Not an ideal situation, but can be used to reverse an accidentally burnt-in LUT in CineEI mode.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Hypergammas 7 & 8 plus Rec709 (800%) have been recalculated along withe the other Hypergammas for precision.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - fixed slight offset to x-axis in LUT in / LUT out chart.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fixed initial black clip / white clip bounds on the stop chart not displaying.");
	this.addInfo(this.insClgInfo,false,null,"v2.3.4");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - More flexible PQ selection.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fixed settings loading bug.");
	this.addInfo(this.insClgInfo,false,null,"v2.3.3");
	this.addInfo(this.insClgInfo,true,null,"Reversion - New information confirms the original interpretation of V709. Removed the alternative and restored the .vlt preset.");
	this.addInfo(this.insClgInfo,false,null,"v2.3.2");
	this.addInfo(this.insClgInfo,true,null,"New Feature - FCP X Color Finale / Color Grading Central LUT Utility Preset.");
	this.addInfo(this.insClgInfo,false,null,"v2.3.1");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Generic camera option where the user selects the recorded gamma and gamut.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Gamma and gamut options properly hidden or revealed in OSX App.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - LUTAnalyst gamuts could become hidden when the format changed.");
	this.addInfo(this.insClgInfo,false,null,"v2.3");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Gammas and Gamuts available sorted by manufacturer, type (log, display, HDR Display, etc) or as the previous flat list.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Additional MLUT format presets: Zacuto Gratical, Divergent Scopebox, AJA LUT-box.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - 'Display gamma correction' preset for say mapping scene linear to Rec709 or γ2.4 to PQ.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - GoPro Protune Gamma and Gamut (from ACES devel matrix and Cineform blog).");
	this.addInfo(this.insClgInfo,true,null,"New Feature - DRAGONColor, DRAGONColor2, REDColor, REDColor2, REDColor3, REDColor4 gamuts (from ACES devel matrices).");
	this.addInfo(this.insClgInfo,true,null,"New Feature - REDGamma3 and REDGamma4 (from LUTs on manufacturer's website).");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Further Dolby PQ options listed by display nits for a 90% reference white.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Good Broyden's used to estimate gamut primary triangles for LUTAnalyst-read LUTs.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Binary file saving now works in the OSX App.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fixed different binary saving bug in Chrome App.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Re-analysed the Panasonic V-709 LUTs for both gamma and gamut. Lack of availability of a Varicam 35 has lead to uncertainty over the correct ranges to choose. Pending confirmation both interpretations of the gamma are given, though the .vlt preset assumes the new assumption of range.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Fix incomplete input scaling bugfix from v2.2, which meant that scaling was only applied if both lower and upper bounds were changed.");
	this.addInfo(this.insClgInfo,false,null,"v2.2.2");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Additional pure gamma curves, plus Rec709 and sRGB now show their effective pure gamma value with the actual exponent in brackets.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - LUTAnalyst has an undocumented feature of reversing analysed gammas to provide a 'Recorded Gamma' option. This was disabled and is now functioning again.");
	this.addInfo(this.insClgInfo,false,null,"v2.2");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Multitone. This combines two adjustments. You can set colour saturation on a stop-by-stop basis (eg for lower saturation in the highlights), and then set one or more colour 'washes' - a tint to zero saturation - at arbitrary stop levels. With Multitone you can create washes, duotones, tritones etc, or create alternatives to LC709A.");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Custom Colour Spaces. Select 'Custom' in the recorded or output gamut boxes and a new panel appears where you can define one or more custom colour spaces, either using xy white point and primaries, or by entering matrix values and selecting the intended internal or working colour space.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - LUTCalc For Mac now works on OSX 10.8 Mountain Lion.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Modal popup dialogs. Ensures that none of the other controls can be changed when a modal dialog box is up (eg 'Load Preview' details).");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - cube files which did not use input scaling would still include the scaling command, potentially breaking compatibility with some software.");
	this.addInfo(this.insClgInfo,false,null,"v2.1");
	this.addInfo(this.insClgInfo,true,null,"New Feature - Knee adjustment. Add or adjust a knee with any output gamma. clip levels, range and smoothness (from hard conventional video knee to smoothly curved 'cinegamma') are all adjustable.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - changing the output gamma was not correctly setting the output range for the chosen format preset.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - file format and details settings were not correctly stored or loaded with 'Save Settings' and 'Load Settings'.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix - Values in Resolve 'ilut' and 'olut' format LUTs were separated with spaces rather than commas.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Simplified the LUT output calculation process for easier maintainance and development.");
	this.addInfo(this.insClgInfo,true,null,"Feature Change - Colour charts on preview defaults now circles, allowing variation in the YPbPr values which will eventually allow larger dots on the Vectorscope.");
	this.addInfo(this.insClgInfo,false,null,"v2.0");
	this.addInfo(this.insClgInfo,true,null,"Updated instructions to reflect added features and changes to the interface.");
	this.addInfo(this.insClgInfo,true,null,"Added 'Lock Value' options to black level and highlight level adjustments.");
	this.addInfo(this.insClgInfo,true,null,"Black / highlight bug when loading settings fixed by 'Lock Value' options.");
	this.addInfo(this.insClgInfo,true,null,"Reintroduced nominal colour temperature select box for fluorescent adjustments.");
	this.addInfo(this.insClgInfo,true,null,"Removed fileSaver.js and Blob.js from Chrome App version - now all original code.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC18");
	this.addInfo(this.insClgInfo,true,null,"Current settings can now be saved and loaded later. At present black level / highlight level settings do not reload.");
	this.addInfo(this.insClgInfo,true,null,"CIE chromacity chart preview now overlays the output gamut triangle and white point where possible (currently all matrix-based colourspaces). It adapts to whitepoint and saturation shifts, though does not take into account PSST-CDL, with its scope for extreme nonlinearity.");
	this.addInfo(this.insClgInfo,true,null,"White balance picker handles more extreme colour choices.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC17");
	this.addInfo(this.insClgInfo,true,null,"Further improvement of White Balance code.");
	this.addInfo(this.insClgInfo,true,null,"Additional preview default showing the CIE 1931 xy and CIE 1960 uv chromacity diagrams with Planck locus. Gives a guide to the saturation limits / clipping of the current output colourspace.");
	this.addInfo(this.insClgInfo,true,null,"White Balance now includes a 'click on preview' option. Once activated, clicking a spot on the preview window will attempt to calculate the CCT and Duv at that point and apply them to the White Balance adjustments.");
	this.addInfo(this.insClgInfo,true,null,"Improvements to the Correlated Colour Temperature (CCT) calculation code.");
	this.addInfo(this.insClgInfo,true,null,"Preview images are now chosen from a selection list, rather than toggling from one to the next.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC16");
	this.addInfo(this.insClgInfo,true,null,"Overhaul of the white balance adjustments code and Planck Locus calculation.");
	this.addInfo(this.insClgInfo,true,null,"Planck locus data calculated from Planck equation and CIE 1931 data at 5nm intervals from 360-830.");
	this.addInfo(this.insClgInfo,true,null,"Colour temperature and Fluori adjustments combined into one 'White Balance' adjustement tool.");
	this.addInfo(this.insClgInfo,true,null,"Colour temperature shifts calculated from mired values rather than mappings from lighting gel data, then converted to working colour space's white point.");
	this.addInfo(this.insClgInfo,true,null,"Fluori adjustment fixes to ensure that it is a Duv shift at the lamp's nominal CCT.");
	this.addInfo(this.insClgInfo,true,null,"LUT file options and generate button now remain visible when the preview window is on.");
	this.addInfo(this.insClgInfo,true,null,"The cursor becomes a crosshair over the preview window, with 10-bit code values for the output image at that point displayed above.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC15");
	this.addInfo(this.insClgInfo,true,null,"Added ACEScg colour space (AP1) with ACEScc and ACESproxy gammas.");
	this.addInfo(this.insClgInfo,true,null,"Beta - added Nikon .NCP LUT format with initial Nikon styles support.");
	this.addInfo(this.insClgInfo,true,null,"LUT formats can now specify acceptable input gammas (eg Nikon styles for NCP).");
	this.addInfo(this.insClgInfo,true,null,"Refined and improved CAT calculations for colour temperature and fluori magenta/green shifts.");
	this.addInfo(this.insClgInfo,true,null,"Default CAT is now CIECAT02 throughout.");
	this.addInfo(this.insClgInfo,true,null,"Fixed Canon IDT out - daylight and tungsten calculated options are now the right way around.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC14");
	this.addInfo(this.insClgInfo,true,null,"Tweaked Preview 'data range' option so that black remains black (it shows 10-bit 64 to 10-bit 1023). Changed the options to '100%' and '109%'.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC13");
	this.addInfo(this.insClgInfo,true,null,"Fixed Highlight Gamut bug which could cause freezing / crashing");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC12");
	this.addInfo(this.insClgInfo,true,null,"Added legal / data toggle to the Preview so that it can be used to display the whole data range.");
	this.addInfo(this.insClgInfo,true,null,"Preview code adjustment to avoid reloading / glitches.");
	this.addInfo(this.insClgInfo,true,null,"Fixed MLUT clipping bug.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC11");
	this.addInfo(this.insClgInfo,true,null,"Colourspace calculation overhaul. All gamuts transforms are now calculated at startup from chromacity / whitepoint data. Luma coefficients and CATs are calculated from the choice of working gamut (currently S-Gamut3.cine), which can now be any of the available options.");
	this.addInfo(this.insClgInfo,true,null,"This makes it easier to add Gamuts / Colourspaces. DCI-P3, DCI-P3D60, Canon's DCI-P3+, Adobe RGB and Adobe Wide Gamut RGB have been added.");
	this.addInfo(this.insClgInfo,true,null,"New attempt at the C300 colourspace - still a work in progress!");
	this.addInfo(this.insClgInfo,true,null,"More accurate colour temperature shifts.");
	this.addInfo(this.insClgInfo,true,null,"Simplified fluorescent / LED green / magenta control.");
	this.addInfo(this.insClgInfo,true,null,"Fixed a bug where the output range was not adjusting correctly for non-log gammas.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC10");
	this.addInfo(this.insClgInfo,true,null,"LUTCalc For Mac can now read in 16-bit TIFFs and PNGs for use in the preview window.");
	this.addInfo(this.insClgInfo,true,null,"Added a 16-stop grayscale to the preview defaults.");
	this.addInfo(this.insClgInfo,true,null,"Updated instructions.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC9");
	this.addInfo(this.insClgInfo,true,null,"Added support for more LUT formats: .3dl (Flame / Assimilate flavour, Lustre flavour and Kodak flavour), .lut (assimilate flavour), .spi1d and .spi3d.");
	this.addInfo(this.insClgInfo,true,null,"LUTAnalyst support for nonlinear input values (shaper LUTs) and scaled input values (common with narrow dynamic range inputs such as linear or Rec709).");
	this.addInfo(this.insClgInfo,true,null,"Scaled inputs can be used with LUT generation (where the format allows it).");
	this.addInfo(this.insClgInfo,true,null,"LUTAnalyst will attempt to provide a reversed transfer function to the 'Recorded Gamma' options.");
	this.addInfo(this.insClgInfo,true,null,"Bugfixes");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC8");
	this.addInfo(this.insClgInfo,true,null,"Bugfix");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC7");
	this.addInfo(this.insClgInfo,true,null,"Simplified output range choices with usage and application selections. The user can choose to build a LUT intended for post grading, or one for use in a camera or on set (MLUT), and then choose the particular grading application or camera and LUTCalc will offer appropriate settings and save to the correct file format.");
	this.addInfo(this.insClgInfo,true,null,"Generalised LUT reading / writing code. LUTAnalyst can now understand .cubes, DaVinci .iluts and .oluts and Panasonic .vlts. LUTCalc can construct LUT files in these formats, and it is now straightforward to add more.");
	this.addInfo(this.insClgInfo,true,null,"Bugfix to PSST-CDL interpolation code - adjustments should now appear more logical.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC6");
	this.addInfo(this.insClgInfo,true,null,"Added an approximation of the forthcoming Canon Log 2 curve in the C300 mkII. This is derived from data in a chart shown in Canon's 'Introducing the Canon EOS C300 Mark II' video, hence is only an approximation. It appears to be very similar to Arri's LogC, with slightly lower-contrast shadows.");
	this.addInfo(this.insClgInfo,true,null,"Scrollbars now more smoothly adapt to display size, appearing only when the browser window cannot fit all information.");
	this.addInfo(this.insClgInfo,true,null,"The default previews now include a Rec709 colourwheel. This displays the range of colours available with the Rec709 gamut in an arrangement akin to a completely full vectorscope. The default previews cycle: High Contrast -> Low Contrast -> Rec709 Gamut -> back to High Contrast.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC5");
	this.addInfo(this.insClgInfo,true,null,"Added sensor black and white clip and 18% gray (when exposure compensation is applied) to Stop/IRE chart.");
	this.addInfo(this.insClgInfo,true,null,"Various bug fixes to PSST-CDL controls.");
	this.addInfo(this.insClgInfo,true,null,"Refined PSST-CDL parameters.");
	this.addInfo(this.insClgInfo,true,null,"Added PSST-CDL instructions.");
	this.addInfo(this.insClgInfo,true,null,"Fixed bug where Linear / Rec709 input gamma options were not generating LUTs.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC4");
	this.addInfo(this.insClgInfo,true,null,"Preview speedups.");
	this.addInfo(this.insClgInfo,true,null,"Bug Fixes.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC3");
	this.addInfo(this.insClgInfo,true,null,"Tidied and made consistent the code for customisation tweaks. Each tweak is now an individual object file, following a consistent basic structure both at the UI stage and in the calculation code.");
	this.addInfo(this.insClgInfo,true,null,"Added splash screen to immediately hide the Javascript warning and then hide the splash when the UI has loaded.");
	this.addInfo(this.insClgInfo,true,null,"Added initial code for 'PSST-CDL' customisation; (P)rimary (S)econdary (S)kin (T)one colour decision list. Quickly allows complex adjustment to individual sectors of the vectorscope using controls familiar from the ASC-CDL.");
	this.addInfo(this.insClgInfo,true,null,"Added option to False Colour to set the white clip level in stops above 18% gray.");
	this.addInfo(this.insClgInfo,true,null,"Improved the coefficients used for S-Gamut3.cine luminance.");
	this.addInfo(this.insClgInfo,true,null,"Initial tidying of UI control code to change from object.style.display approach over to object.className. Visuals are then completely controlled by style sheets, allowing fundamental reskinning for different platforms / applications.");
	this.addInfo(this.insClgInfo,true,null,"Speedup in preview from increased use of transferrable objects.");
	this.addInfo(this.insClgInfo,true,null,"Allow 1D LUTs to include the ASC-CDL customisation (minus the saturation control).");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC2");
	this.addInfo(this.insClgInfo,true,null,"Fixed bug which turned off customisations.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 RC1");
	this.addInfo(this.insClgInfo,true,null,"Fixed 'Highlight Level' maps to box bug.");
	this.addInfo(this.insClgInfo,true,null,"Allow black level and highlight level adjustment with log curves.");
	this.addInfo(this.insClgInfo,true,null,"Fixed Canon CP IDT not available in LUTAnalyst bug.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 Beta 9");
	this.addInfo(this.insClgInfo,true,null,"Simplified False Colour calculation. Now works with every output gamma / gamut / tweak option.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 Beta 8");
	this.addInfo(this.insClgInfo,true,null,"Added False Colour.");
	this.addInfo(this.insClgInfo,true,null,"Black Level and Highlight Level now take into account ASC-CDL.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 Beta 4");
	this.addInfo(this.insClgInfo,true,null,"Added ASC CDL controls tweak.");
	this.addInfo(this.insClgInfo,true,null,"Added Waveform.");
	this.addInfo(this.insClgInfo,true,null,"Added RGB Parade.");
	this.addInfo(this.insClgInfo,true,null,"Preview, Waveform, Vectorscope and Parade can now all be displayed at the same time.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 Beta 3");
	this.addInfo(this.insClgInfo,true,null,"Added green correction tool.");
	this.addInfo(this.insClgInfo,true,null,"Added Vectorscope option to previews. Includes Rec709 75% and 100% boxes, plus a set of Rec709 75% boxes mapped to the current colour space.");
	this.addInfo(this.insClgInfo,true,null,"Adjusted test image primary boxes to be Rec709 75% and 100% colours.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 Beta 2");
	this.addInfo(this.insClgInfo,true,null,"Fixed missing FileSaver.js and Blob.js files.");
	this.addInfo(this.insClgInfo,true,null,"Added Google Chrome packaged app code.");
	this.addInfo(this.insClgInfo,false,null,"v1.9 Beta 1");
	this.addInfo(this.insClgInfo,true,null,"Added real-time(ish) preview, currently with built-in low and high-contrast test images.");
	this.addInfo(this.insClgInfo,true,null,"Test images include 75% saturation primaries and secondaries in Rec709 and Rec2020, 16-stop grayscale and colour charts at correct exposure and +/- 2 stops (low contrast image) and  +/- 4 stops (high contrast image).");
	this.addInfo(this.insClgInfo,true,null,"Test images are 16-bit and stored as most significant bits (MSB) and least significant bits (LSB) 8-bit PNGs.");
	this.addInfo(this.insClgInfo,true,null,"Added colour temperature adjustment to tweaks. Available to 3D LUTs. Can be set as either CTO / CTB values or as recorded and desired colour temperature (advanced settings). Also under advanced various chromatic adaptation models are available for the adjustment.");
	this.addInfo(this.insClgInfo,true,null,"Added Rec2020 colour space.");
	this.addInfo(this.insClgInfo,true,null,"Fixed matrix bug from previous beta.");
	this.addInfo(this.insClgInfo,true,null,"Bumped version number to 1.9 as new features and changes are substantial enough for final release to be v2.0.");
	this.addInfo(this.insClgInfo,false,null,"v1.5 Beta 3");
	this.addInfo(this.insClgInfo,true,null,"Fixed a LUTAnalyst input gamut bug. Recalculated V709.");
	this.addInfo(this.insClgInfo,false,null,"v1.5 Beta 2");
	this.addInfo(this.insClgInfo,true,null,"Built-in colour-spaces based on LUTs now have their data stored in binary versions of LUTAnalyst files. Previously they were human-readable javascript variable declarations.");
	this.addInfo(this.insClgInfo,true,null,"The format now is Int32Array blobs stored in files ending 'labin'. LUTCalc uses Float64s internally (Javascript treats standard floats as 64-bit). Scaling 32-bit integers maintains much more precision than Float32s considering that the actual range is not generally more than 0-1 (the format allows -2 - +2).");
	this.addInfo(this.insClgInfo,true,null,"The format is little endian, first value the length of the transfer function (gamma) array, second value the length of the colour space array, then gamma and colour space data.");
	this.addInfo(this.insClgInfo,true,null,"This is a much more compact way to store the data, so 65x65x65 colour spaces are a little over twice the size of the previous 33x33x33 ones. Consequently LC709 and LC709A now produce SL3/SG3.cine to LC709(A) 3D LUTs numerically identical to the Sony look profiles.");
	this.addInfo(this.insClgInfo,true,null,"LC709 and LC709A colour spaces have been recalculated, Cine709 has been dropped (the transfer function is still available, and it is easy to import it with LUTAnalyst if needed).");
	this.addInfo(this.insClgInfo,true,null,"Tweaked the Brent method root finding code to be more robust.");
	this.addInfo(this.insClgInfo,false,null,"v1.5 Beta");
	this.addInfo(this.insClgInfo,true,null,"Major rewrite of the transfer function (gamma), colour space (gamut), LUT and LUTAnalyst code bases.");
	this.addInfo(this.insClgInfo,true,null,"Web workers are now used extensively for multithreading speed.");
	this.addInfo(this.insClgInfo,true,null,"Strided 1D typed arrays are gradually replacing multidimensional arrays for basic speed and for efficiency in passing to web workers.");
	this.addInfo(this.insClgInfo,true,null,"Linear interpolation code has been tidied up. Cubic is generally used, but with multithreading linear should be fast enough to allow real-time previews in a future version.");
	this.addInfo(this.insClgInfo,true,null,"Fixed a LUTAnalyst bug which could cause the wrong input gamut option to be used giving faulty results.");
	this.addInfo(this.insClgInfo,true,null,"Added a basic implementation of the Dolby PQ transfer function for high dynamic range displays. As it stands, rather than a nits scale, it is set to place 18% gray at the same 10-bit value as for Rec709.");
	this.addInfo(this.insClgInfo,true,null,"Added two alternative HDR transfer function proposals based on extending Rec709/Rec2020 with log highlights region. Both have 400% and 800% options.");
	this.addInfo(this.insClgInfo,true,null,"Added Panalog.");
	this.addInfo(this.insClgInfo,true,null,"Other small bugfixes.");
	this.addInfo(this.insClgInfo,false,null,"v1.3");
	this.addInfo(this.insClgInfo,true,null,"New Canon CP Lock output gamuts. Should be more reliable across the gamut for dropping in with Canon CP lock material.");
	this.addInfo(this.insClgInfo,false,null,"v1.22");
	this.addInfo(this.insClgInfo,true,null,"Added Panasonic Varicam V-Log and V-Gamut.");
	this.addInfo(this.insClgInfo,false,null,"v1.21");
	this.addInfo(this.insClgInfo,true,null,"Log gamma and LUTAnalyst range checking bugfixes.");
	this.addInfo(this.insClgInfo,false,null,"v1.2");
	this.addInfo(this.insClgInfo,true,null,"Added charts for % Reflectance against LUT % IRE and LUT % IRE in against LUT % IRE out.");
	this.addInfo(this.insClgInfo,true,null,"Fixed missing term in Arri LogC input equation.");
	this.addInfo(this.insClgInfo,false,null,"v1.1");
	this.addInfo(this.insClgInfo,true,null,"Canon CP Gamut In replaced by Canon CP IDT (Daylight) and Canon CP IDT (Tungsten). Beta testing. These use matrix coefficients from the ACES IDTs published by Canon for the C300, C500 and C100.Tungsten for 3200 or warmer, Daylight for 4300 and up.");
	this.addInfo(this.insClgInfo,true,null,"Canon CP Gamut Out replaced by LUTs derived from the IDTs using Newton-Raphson to invert. Alpha testing.");
	this.addInfo(this.insClgInfo,true,null,"CP Gamut In -> CP Gamut Out does not currently produce expected results. Possibly due to the reduced gamut of CP Rec709.");
	this.addInfo(this.insClgInfo,true,null,"Removed code duplication in the tricubic calculations, and made out-of-bounds handling more sensible. This has slowed the tricubic somewhat. I will look to optimise.");
	this.addInfo(this.insClgInfo,true,null,"Fixed MLUT bugs which meant that the appropriate clipping was not happening, and that changing to a log output gamma with MLUT checked would lead to the wrong output scaling.");
	this.addInfo(this.insClgInfo,true,null,"Provisional fix for an out-of-bounds (NaN) bug in LUTAnalyst with gammas of less dynamic range than S-Log3, ie Canon C-Log.");
	this.addInfo(this.insClgInfo,false,null,"v1.0");
	this.addInfo(this.insClgInfo,true,null,"Introduced 'LUTAnalyst' - a tool to convert 1D and 3D LUTs (currently cubes) to 1D S-Log3 to new transfer gamma LUTs plus 3D S-Gamut3.cine to new colour space gamut LUTs. LUTCalc can then use these to use the new gamma and / or gamut as you can with any of the built in options.");
	this.addInfo(this.insClgInfo,true,null,"Totally recoded the handling of LUTs as data sources in LUTCalc.");
	this.addInfo(this.insClgInfo,true,null,"Substantially improved LC709 and LC709A colour transforms - added in Cine+Rec709.");
	this.addInfo(this.insClgInfo,true,null,"Added initial cubic interpolation for 1D and tricubic interpolation for 3D code.");
	this.addInfo(this.insClgInfo,false,null,"v0.9991");
	this.addInfo(this.insClgInfo,true,null,"Released code on Github");
	this.addInfo(this.insClgInfo,true,null,"UI CSS tweaks and removal of Sentenza Desktop code for the time being as no binary release. Web App only again for now!");
	this.addInfo(this.insClgInfo,false,null,"v0.999");
	this.addInfo(this.insClgInfo,true,null,"Total rewrite of the code base to be modular and object oriented. Simplifies altering and adding features.");
	this.addInfo(this.insClgInfo,true,null,"Shifted UI to match between the Mac app and web app versions and hopefully make options as clear as possible.");
	this.addInfo(this.insClgInfo,true,null,"Added LUT-based Canon CP Lock Gamut in and out derived from analysing numerous side-by-side test images. Far from perfect and consider experimental, but seems to give a good match going from Sony to Canon and a really good match going from Canon to Sony. Definitely shows the advantage of the 10-bit, 14-stop Sony cameras! The main caveats are that limitations on the free Excel solver make the saturated blue and cyan trickier to optimize and I do not have a C300 to check against, just the (numerous) test images I took to build the gamut.");
	this.addInfo(this.insClgInfo,true,null,"Added Arri LogC gamma options along with Arri Wide Gamut. Arri's approach to log does odd things from ISO 1600 and up, feathering the highlight to avoid clipping. I have tried to factor in the shoulder point by comparing Arri LUT Generator LUTs with the stock equation. As such, this option is somewhere between experimental and more useful for comparing charts than producing LUTs :-).");
	this.addInfo(this.insClgInfo,false,null,"v0.991");
	this.addInfo(this.insClgInfo,true,null,"Fixed bug with customising Canon WideDR.");
	this.addInfo(this.insClgInfo,true,null,"Cleaned up layout.");
	this.addInfo(this.insClgInfo,false,null,"v0.99");
	this.addInfo(this.insClgInfo,true,null,"First version of Mac App.");
	this.addInfo(this.insClgInfo,true,null,"Total overhaul of colour transforms and recalculation of all estimated gammas.");
	this.addInfo(this.insClgInfo,true,null,"Colour transforms are now done either by conventional matrices, using colour LUTs or combinations of both.");
	this.addInfo(this.insClgInfo,true,null,"Calculated LC709 and LC709A colour LUTs from the Sony looks. This required an improved mapping of the gamma curves.");
	this.addInfo(this.insClgInfo,true,null,"Tweaks to the S-Log2 gamma calculation should mean better high ISO CineEI shifts. It has now been finessed using the Sony S-Log2 to Rec709 ilut in Resolve.");
	this.addInfo(this.insClgInfo,true,null,"Canon C-Log is now directly from an equation published by Canon.");
	this.addInfo(this.insClgInfo,true,null,"Added a table of IRE and 10-bit values for the current output gamma to the 'Gamma Info' tab. This includes any customisations so will give a good guide to appropriate recording levels.");
	this.addInfo(this.insClgInfo,false,null,"v0.981");
	this.addInfo(this.insClgInfo,true,null,"Housekeeping Release.");
	this.addInfo(this.insClgInfo,true,null,"Added fileSaver.js and Blob.js by Eli Grey (eligrey.com) to allow saving directly to .cube files rather than the new tab Kludge. Not only a lot easier and neater, by just saving to file the LUT process is MUCH quicker.");
	this.addInfo(this.insClgInfo,true,null,"To go with the file saving, the 'LUT Title' option has now become 'LUT Title / Filename', and will now be used as the filename for the .cube.");
	this.addInfo(this.insClgInfo,true,null,"When a log gamma is selected for output, the range defaults to 'data'. Other curves (and with MLUT selected) default to 'legal' range. This is more appropriate for further processing of log curves.");
	this.addInfo(this.insClgInfo,true,null,"3D Gamuts default to 'Passthrough' (gamma only), pending colour overhaul.");
	this.addInfo(this.insClgInfo,true,null,"LUT values are fixed length at 10 decimal places (that ought to do for now ;-) ).");
	this.addInfo(this.insClgInfo,false,null,"v0.98");
	this.addInfo(this.insClgInfo,true,null,"Added 'Rec709 Like' as options for both recorded and output gamma. This really means 'Gamma Corrected Linear', but to avoid confusion over the two meanings of gamma and to keep consistency with the 'Rec709 (No Knee) option of previous versions it's 'Rec709 Like' for now :-).");
	this.addInfo(this.insClgInfo,true,null,"Rec709 Like brings up an additional option box for selecting the gamma correction. The choices are currently 'Rec709', 'sRGB' and 'Linear'. The first two use the gammas specified in their respective standards and 'Linear' means a gamma of 1 (this doubles up on the output option of 'Linear', but allows for linear input and again maintains consistency with previous versions).");
	this.addInfo(this.insClgInfo,false,null,"v0.97");
	this.addInfo(this.insClgInfo,true,null,"Added 'Gamma Chart' button that displays the input and output gammas plotted data range value against stop (IE 9+, Safari 5.1+, Chrome, Firefox, Opera).");
	this.addInfo(this.insClgInfo,true,null,"Added S-Log as a gamma option (along with PMW-F3 and F35 as camera options).");
	this.addInfo(this.insClgInfo,false,null,"v0.96");
	this.addInfo(this.insClgInfo,true,null,"Added highlight scaling as an option for remapping preferred IRE values without affecting black. Also improved black scaling code to work with it.");
	this.addInfo(this.insClgInfo,true,null,"Started code cleanup.");
	this.addInfo(this.insClgInfo,true,null,"'Passthrough' is now a functional option for gamuts. It means that the colour gamut is unprocessed, ie a 3D LUT behaves like a 1D gamma only LUT. Use it for making an MLUT version of a 1D LUT.");
	this.addInfo(this.insClgInfo,true,null,"Added reflected value mapping IREs for various gammas to the 'Gamma Info' tab.");
	this.addInfo(this.insClgInfo,false,null,"v0.95");
	this.addInfo(this.insClgInfo,true,null,"Differently calculated, more precise LC709 / LC709A curves.");
	this.addInfo(this.insClgInfo,false,null,"v0.94");
	this.addInfo(this.insClgInfo,true,null,"Further range bugfix to LC709 / LC709A.");
	this.addInfo(this.insClgInfo,true,null,"Added separate input range and output range options. Sony Look Profiles are data input / legal output.");
	this.addInfo(this.insClgInfo,false,null,"v0.93");
	this.addInfo(this.insClgInfo,true,null,"Fixed errors in LC709 and LC709A from treating the Look Profiles as data (extended) range rather than legal range. Black level was set too low and white too high.");
	this.addInfo(this.insClgInfo,true,null,"Added options for creating either legal level (64-940, 0%-100% IRE) LUTs or data level (0-1023, -7%-109% IRE). Previously the LUTs were generated to work with a data levels workflow only.");
	this.addInfo(this.insClgInfo,true,null,"Added a check to the MLUT option to ensure the correct (legal) range.");
	this.addInfo(this.insClgInfo,false,null,"v0.92");
	this.addInfo(this.insClgInfo,true,null,"Gets named 'LUTCalc'");
	this.addInfo(this.insClgInfo,true,null,"Improved 709 matrix from profiling F55 in Custom Mode, rather than Sony published matrix.");
	this.addInfo(this.insClgInfo,true,null,"Added Canon Cinema Gamut from Canon published matrix.");
	this.addInfo(this.insClgInfo,true,null,"Added Canon WideDR Gamma out.");
	this.addInfo(this.insClgInfo,true,null,"Added info page about the log gammas.");
	this.addInfo(this.insClgInfo,false,null,"v0.91");
	this.addInfo(this.insClgInfo,true,null,"Improved Canon CP Lock matrix.");
	this.addInfo(this.insClgInfo,false,null,"v0.9");
	this.addInfo(this.insClgInfo,true,null,"Added 'Black Level' adjustment to customisation options for non-log output gammas.");
	this.addInfo(this.insClgInfo,false,null,"v0.8");
	this.addInfo(this.insClgInfo,true,null,"Added 'Camera MLUT' option to keep things in range for use in the camera (tested on v4.1).");
	this.addInfo(this.insClgInfo,false,null,"v0.7");
	this.addInfo(this.insClgInfo,true,null,"Added 'Canon CP Lock Gamut' as an input/output Gamut option. Combine with the C-Log Gamma option for quick matching of C300 material with F5/55.");
	this.addInfo(this.insClgInfo,true,null,"The gamma is accurate and from the official Canon LUT, but the gamut conversion is estimated from test shots");
	this.addInfo(this.insClgInfo,true,null,"Consider it experimental and test!");
	this.addInfo(this.insClgInfo,true,null,"I don't have a C300 available for further testing, so feedback would be great.");
	this.addInfo(this.insClgInfo,true,null,"Added 'Customisation' box, with 'Highlight Gamut' option.");
	this.addInfo(this.insClgInfo,true,null,"Highlight gamut is only available with 3D LUTs, and allows a transition to a second gamut/matrix in the highlights. This should allow more complex colour handling, as with the Type A Sony Look.");
	this.addInfo(this.insClgInfo,true,null,"Added 'B&W (Rec709 Luma)' as an output Gamut option.");
	this.addInfo(this.insClgInfo,true,null,"Fixed an IRE scaling bug on the 'Linear' output Gamma option.");
	this.addInfo(this.insClgInfo,true,null,"Fixed a silly bug with some input Gamut options which meant that S-Log2 and C-Log material were being treated as S-Gamut3.cine regardless of input Gamut choice.");
	this.addInfo(this.insClgInfo,false,null,"v0.6");
	this.addInfo(this.insClgInfo,true,null,"First release as Javascript web app.");
	this.addInfo(this.insClgInfo,true,null,"Initial inclusion of colour space matrices to 3D LUTs.");
	this.addInfo(this.insClgInfo,false,null,"v0.5");
	this.addInfo(this.insClgInfo,true,null,"Fixed incorrect LUT 3D SIZE in 65x65x65 version.");
	this.addInfo(this.insClgInfo,false,null,"v0.4");
	this.addInfo(this.insClgInfo,true,null,"Added Cineon.");
	this.addInfo(this.insClgInfo,true,null,"Fixed stupid error on S-Log2 input for 1D LUTs.");
	this.addInfo(this.insClgInfo,false,null,"v0.3");
	this.addInfo(this.insClgInfo,true,null,"Separate 33x33x33 and 65x65x65 versions. Added 1024-point 1D version.");
	this.addInfo(this.insClgInfo,true,null,"Cleaned up 'Calc' sheet for clarity and to allow 1D LUTs.");
	this.addInfo(this.insClgInfo,true,null,"Corrected curves against stop chart for clarity.");
	this.addInfo(this.insClgInfo,true,null,"Added 'Exposure Only' option that just shifts the input curve.");
	this.addInfo(this.insClgInfo,false,null,"v0.2");
	this.addInfo(this.insClgInfo,true,null,"65x65x65 LUTs.");
	this.addInfo(this.insClgInfo,false,null,"v0.1");
	this.addInfo(this.insClgInfo,true,null,"First Release.");
	this.insClg.className = 'info-page-hide';
	this.insClg.appendChild(this.insClgInfo);
};
LUTInfoBox.prototype.createCustColour = function() {
	this.custColour = document.createElement('div');
	this.custColour.id = 'cust-colour';
	this.custColourBack = document.createElement('input');
	this.custColourBack.setAttribute('type','button');
	this.custColourBack.value = 'Back';
	this.custColour.appendChild(this.custColourBack);
	this.custColourInfo = document.createElement('div');
	this.custColourInfo.setAttribute('class','infotext');
	this.addInfo(this.custColourInfo,false,'Custom Colour Space',"This panel appears for 3D LUTs when 'Custom' is selected as either the recorded or output gamut.");
	this.addInfo(this.custColourInfo,false,null,'It is a technical option for creating additional colour space / gamut options from either xy white point and primaries or via matrix values to one of the built-in options.');
	this.addInfo(this.custColourInfo,false,null,'As such it is a tool intended for a specific, specialist use.');
	this.addInfo(this.custColourInfo,false,null,'Put another way, as a cameraman it is not something I expect to find myself using!');
	this.custColourInfo.appendChild(this.createFigure('tweak','pngs/cust-colour-1.png',1.6654));
	this.addInfo(this.custColourInfo,false,'White Point & Primaries',"With this you define a colourspace by defining the white point either with xy values or from a drop-down list of standard illuminants. The primaries are then set by entering further xy values.");
	this.addInfo(this.custColourInfo,false,null,"LUTCalc's processing colourspace uses D65 as its white point, so if the custom colourspace uses a different white point, a chromatic adaptation transform, or CAT, is used. By default LUTCalc uses CIECAT02, though other options such as Bradford can be selected from the CAT model list.");
	this.custColourInfo.appendChild(this.createFigure('tweak','pngs/cust-colour-2.png',1.0067));
	this.addInfo(this.custColourInfo,false,'Matrix','with this panel you can enter matrix values directly. You can toggle between input and output matrix and LUTCalc will automatically generate the inverse. By default the working colourspace is set to Rec709, but this can be changed to whatever is appropriate for the matrix values.');
	this.addInfo(this.custColourInfo,false,'Set Primaries',"When an appropriately formed matrix is entered and differs from the matrices generated from the Primaries and White Point panel, a 'Set Primaries' button becomes available. Pressing this calculates the primaries from the matrix entered plus the white point and CAT chosen, and displays them in the 'Primaries and White Point' panel.");
	this.addInfo(this.custColourInfo,false,'Update With Colourspace','This option recalculates the matrix values whenever the colourspace is changed.');
	this.addInfo(this.custColourInfo,false,null,"As with the 'White Point & Primaries' panel, the CAT can be changed. With the 'Matrix' panel it is used to go between the selected working colourspace and LUTCalc's internal processing space.");
	this.addInfo(this.custColourInfo,false,null,'The matrices are applied to linear image data.');
	this.addInfo(this.custColourInfo,false,null,"Initially the 'Matrix' panel is completely independent of the 'White Point & Primaries' panel. If you change anything under 'White Point & Primaries', the matrix panel will lock to it and calculate from the white point and primary options.");
	this.addInfo(this.custColourInfo,false,'New / Remove',"You can create multiple custom colour spaces and save them with the main 'Save Settings' button.");
	this.addInfo(this.custColourInfo,false,'Input Choice / Output Choice',"Use these options to set which colourspaces will be used when the recorded and output gamuts are set to 'Custom'.");
	this.custColour.className = 'info-page-hide';
	this.custColour.appendChild(this.custColourInfo);
};
LUTInfoBox.prototype.createCustWht = function() {
	this.custWht = document.createElement('div');
	this.custWht.setAttribute('id','cust-cts');
	this.custWhtBack = document.createElement('input');
	this.custWhtBack.setAttribute('type','button');
	this.custWhtBack.value = 'Back';
	this.custWht.appendChild(this.custWhtBack);
	this.custWhtInfo = document.createElement('div');
	this.custWhtInfo.setAttribute('class','infotext');
	this.custWhtInfo.appendChild(this.createFigure('tweak','pngs/cust-wht-1.png',1.9227));
	this.addInfo(this.custWhtInfo,false,null,"'White Balance' warms or cools the picture to fine tune white balances, or to provide intermediate temperatures unavailable in camera (eg CineEI on the Sony F cameras) through a LUT.");
	this.addInfo(this.custWhtInfo,false,null,'It also includes the complementary green / magenta shift to correct for lightsources away from the nominal colour temperature.');
	this.addInfo(this.custWhtInfo,false,null,'Temperature adjustments can be made using a slider which approximates the values of CTO and CTB lighting gel, or for more photometrically precise adjustment the recorded and desired colour temperatures can be entered.');
	this.addInfo(this.custWhtInfo,false,null,'Green / magenta adjustments for correcting lighting such as fluorescents are made with a similar plus green / minus green slider.');
	this.addInfo(this.custWhtInfo,false,null,"the nature of the green / magenta shift is dependent upon the lightsource's nominal temperature relative to the reference white balance. By default this is locked to the colour temperature shift, but by clicking 'Unlock Lightsource From New White' you can set the lamp's nominal temperature separately from the CTO / CTB shift.");
	this.custWhtInfo.appendChild(this.createFigure('box','pngs/cust-wht-2.png',4.766));
	this.addInfo(this.custWhtInfo,false,null,"When the preview window is active, a button marked 'Preview Click For White' becomes available. Once activated, clicking on the preview window will cause LUTCalc to attempt to white balance to the chosen area.");
	this.addInfo(this.custWhtInfo,false,null,'Activating the advanced options brings up a selection of nominal temperatures for fluorescent lamps, rather than entering a colour temperature directly.');
	this.addInfo(this.custWhtInfo,false,null,'The adjustments are done using a Von Kries-style chromatic transform - by default the relatively standard CIECAT02 - but with the advanced option the choice of CAT matrix becomes user selectable.');
	this.custWht.className = 'info-page-hide';
	this.custWht.appendChild(this.custWhtInfo);
};
LUTInfoBox.prototype.createCustPsst = function() {
	this.custPsst = document.createElement('div');
	this.custPsst.setAttribute('id','cust-psst');
	this.custPsstBack = document.createElement('input');
	this.custPsstBack.setAttribute('type','button');
	this.custPsstBack.value = 'Back';
	this.custPsst.appendChild(this.custPsstBack);
	this.custPsstInfo = document.createElement('div');
	this.custPsstInfo.setAttribute('class','infotext');
	this.custPsstInfo.appendChild(this.createFigure('tweak','pngs/cust-psst-1.png',1.697));
	this.addInfo(this.custPsstInfo,false,null,'PSST-CDL is intended to take the controls provided by ASC-CDL and apply them selectively to specific ranges of colours on the vectorscope.');
	this.addInfo(this.custPsstInfo,false,null,"PSST stands for (P)rimary, (S)econdary and (S)kin (T)one. The default window allows adjustment to reds, greens and blues (primaries), magentas, yellows and cyans (secondaries) and skin tone (based on a combination of a Vectorscope 'I'-line and colour chart 'Light Skin' and 'Dark Skin' values). Adjustments are interpolated between these base colours.");
	this.addInfo(this.custPsstInfo,true,'Colour',"Similar to the 'Hue' in HSV and HSL, Colour here is the offset from the chosen base colour. PSST separates each base colour by a value of 1, so red to skin tone is 1, red to green is 3 and magenta to cyan in 5.");
	this.addInfo(this.custPsstInfo,true,null,'7 equates to a complete circuit (blue -> blue) and negative values are allowed (blue to green is 6 or -1).');
	this.addInfo(this.custPsstInfo,true,'Saturation','Adjusts the colour intensity within the chosen colour range. 1 is the default, 0 is a Rec709 grayscale.');
	this.addInfo(this.custPsstInfo,true,'Slope','Analogous to gain, an input value is multiplied by this. Defined as any value from 0 (a flat line) up, the default value is 1.0.');
	this.addInfo(this.custPsstInfo,true,null,'LUTCalc applies the PSST-CDL on linear data, so slope behaves like an exposure adjustment. 0.5 = one stop down, 0.25 = two stops. 2 = one stop up, 4 = two stops.');
	this.addInfo(this.custPsstInfo,true,'Offset',"a value simply added or subtracted from an input value, carried out after the slope");
	this.addInfo(this.custPsstInfo,true,'Power',"Analogous to 'gamma', once an input value has had the slope and offset applied, it is raised to the power of the power parameter. The range is any value from zero up.");
	this.addInfo(this.custPsstInfo,false,null,"The seven base colours allow for some interesting effects, but for greater control PSST-CDL can specify adjustments for intermediate colours. This is done by clicking 'Refinements'");
	this.custPsstInfo.appendChild(this.createFigure('tweak','pngs/cust-psst-2.jpg',1.4737));
	this.addInfo(this.custPsstInfo,false,null,'The Refinements window shows a set of vertical sliders which can be used to make adjustments to both the seven base colours and intermediate colours. Rather like a graphic equalizer.');
	this.addInfo(this.custPsstInfo,false,null,"The initial intermediate values are interpolated from any adjustments made in the 'Base Adjustments' window.");
	this.addInfo(this.custPsstInfo,false,null,'Refinements defaults to adjusting Saturation, but this can be changed to Colour, Slope, Offset or Power.');
	this.addInfo(this.custPsstInfo,false,null,'To fix an intermediate value, click on the checkbox beneath the slider. A ticked checkbox will not be interpolated by Base Adjustment changes.');
	this.addInfo(this.custPsstInfo,false,null,'The spectrum background displays the effect of PSST adjustments in the current colour space (top and bottom before, centre after).');
	this.custPsstInfo.appendChild(this.createFigure('box','pngs/cust-psst-3.png',6.137));
	this.addInfo(this.custPsstInfo,false,null,'The primaries and secondaries on a Rec709 vectorscope take the shape of a squashed hexagon, ie the distance from the centre (grayscale) to the edges (100% saturation) varies with colour. Equally, the luma (Y) value of a full saturation varies with colour, reflecting the sensitivity of human vision.');
	this.addInfo(this.custPsstInfo,false,null,'By default, when a PSST colour shift is applied, PSST-CDL will attempt to scale the magnitude on the vectorscope to match the difference between the values for the initial and final colours. For a full match, the Y value would also need to be scaled. However this tends to produce extreme results on real images, so is off by default.');
	this.addInfo(this.custPsstInfo,false,null,'The advanced settings in PSST-CDL allow these two scalings to be turned on or off.');
	this.custPsst.className = 'info-page-hide';
	this.custPsst.appendChild(this.custPsstInfo);
};
LUTInfoBox.prototype.createCustASC = function() {
	this.custASC = document.createElement('div');
	this.custASC.setAttribute('id','cust-cdl');
	this.custASCBack = document.createElement('input');
	this.custASCBack.setAttribute('type','button');
	this.custASCBack.value = 'Back';
	this.custASC.appendChild(this.custASCBack);
	this.custASCInfo = document.createElement('div');
	this.custASCInfo.setAttribute('class','infotext');
	this.custASCInfo.appendChild(this.createFigure('tweak','pngs/cust-asc-1.png',2.6047));
	this.addInfo(this.custASCInfo,false,null,'The ASC-CDL is a set of transforms developed by the American Society of Cinematographers intended to provide consistent adjustments across software and cameras.');
	this.addInfo(this.custASCInfo,false,null,'It is also a system of XML code for conveying those adjustments between systems and from frame to frame.');
	this.addInfo(this.custASCInfo,false,null,'LUTCalc provides the controls as a simple and clear way of adjusting the picture, but does not implement the full ASC-CDL system.');
	this.addInfo(this.custASCInfo,false,null,'The ASC-CDL is based around three basic parameters applied to each of the red, green and blue channels, plus a saturation parameter which couples all three:');
	this.addInfo(this.custASCInfo,true,'Slope','Analogous to gain, an input value is multiplied by this. Defined as any value from 0 (a flat line) up, the default value is 1.0.');
	this.addInfo(this.custASCInfo,true,null,'LUTCalc applies the ASC-CDL on linear data, so slope behaves like an exposure adjustment. 0.5 = one stop down, 0.25 = two stops. 2 = one stop up, 4 = two stops.');
	this.addInfo(this.custASCInfo,true,'Offset',"The definition and implementation of 'lift' can change between pieces of software, so the ASC uses the term 'offset' and defines it as a value simply added or subtracted from an input value. In the ASC-CDL this is carried out after the slope");
	this.addInfo(this.custASCInfo,true,'Power',"Analogous to 'gamma', once an input value has had the slope and offset applied, it is raised to the power of the power parameter. The range is any value from zero up.");
	this.addInfo(this.custASCInfo,true,'Saturation','All other ASC-CDL controls are applied on a colour channel by colour channel basis. Saturation takes the luma value of the RGB colour and scales the components such that a value of 0 gives a Rec709 grayscale, 1.0 leaves the image unaffected and anything above 1.0 increases the colour saturation.');
	this.addInfo(this.custASCInfo,false,null,'For simplicity, LUTCalc includes a luma channel alongside the red, green and blue and locking the individual channel adjustments together.');
	this.custASC.className = 'info-page-hide';
	this.custASC.appendChild(this.custASCInfo);
};
LUTInfoBox.prototype.createCustMulti = function() {
	this.custMulti = document.createElement('div');
	this.custMulti.setAttribute('id','cust-multi');
	this.custMultiBack = document.createElement('input');
	this.custMultiBack.setAttribute('type','button');
	this.custMultiBack.value = 'Back';
	this.custMulti.appendChild(this.custMultiBack);
	this.custMultiInfo = document.createElement('div');
	this.custMultiInfo.setAttribute('class','infotext');
	this.custMultiInfo.appendChild(this.createFigure('tweak','pngs/cust-multi-1.jpg',1.2308));
	this.addInfo(this.custMultiInfo,false,null,'Multitone combines two adjustments to quickly produce sophisticated colour effects tuned from stop to stop - saturation control and duotone.');
	this.addInfo(this.custMultiInfo,false,'Saturation Control','Within the limited data range of conventional digital recordings (8 or 10-bit integers) there is also a limit to the range of colours that can be represented for a given colourspace at a given luminence. This is the gamut.');
	this.addInfo(this.custMultiInfo,false,null,'Outside of this range colours will tend to clip. For pure primaries the result is solid blocks of colour, but for mixtures of the colour channels it can result in colours shifting away from expectation.');
	this.addInfo(this.custMultiInfo,false,null,"For example, Rec709 blue has a much lower luminence than green or red; as luminance increases past blue's limit, the other colour channels can take over.");
	this.addInfo(this.custMultiInfo,false,null,'The the row of saturation sliders in Multitone can be used to adjust saturation on a stop-by-stop basis, for example reducing the saturation as the level approaches 90% white (around 2 1/3 stops above 18% gray).');
	this.addInfo(this.custMultiInfo,false,null,"'Reset Saturation' will bring the colours back to their original intensity.");
	this.addInfo(this.custMultiInfo,false,'Duotone','A popular effect in traditional black and white printing is Duotone. This overlays a colour tint in the midtones and highlights with another in the shadows (generally black). The second control in Multitone extends this effect.');
	this.addInfo(this.custMultiInfo,false,null,"Clicking the 'Monochrome' button under the saturation sliders sets every stop to zero saturation. By default this means black and white.");
	this.addInfo(this.custMultiInfo,false,null,"At the most basic level this can be changed to a colour wash either by adjusting the 'Hue' and 'Saturation' sliders in the lower box, or by clicking on the gray square to bring up a colour picker.");
	this.custMultiInfo.appendChild(this.createFigure('box','pngs/cust-multi-2.jpg',1.3742));
	this.addInfo(this.custMultiInfo,false,null,'The picker shows the hue and saturation options of the Rec709 gamut mapped into the current colourspace. Most of the gamut options are wide enough to avoid clipping using any of these colours, though care should be taken when the output gamut is Rec709 that highly saturated choices - particularly blues - can lead to colour clipping in the highlights.');
	this.addInfo(this.custMultiInfo,false,null,"From the basic colour wash a duotone effect can be created by clicking the '+' button and selecting a second colour. The 'Stop' slider sets the luminance level where the colour choice is defined. Multitone interpolates between multiple colours.");
	this.addInfo(this.custMultiInfo,false,null,'Further colours can be added for tritone, quadtone, quintone etc.');
	this.addInfo(this.custMultiInfo,false,'Multitone','Combining the two effects can produce interesting results quickly. For example, saturation could be feathered downwards from 18% gray to 90% white, but towards a slightly warm wash, which then shifts towards pure grayscale in high highlights.');
	this.addInfo(this.custMultiInfo,false,null,"Coupled with the 'Knee' tool it is possible to produce very useful looks from the basic Rec709 gamma and gamut options which could hold up more robustly to further adjustment than LUT-derived colourspaces (such as LC709A).");
	this.custMulti.className = 'info-page-hide';
	this.custMulti.appendChild(this.custMultiInfo);
};
LUTInfoBox.prototype.createCustHG = function() {
	this.custHG = document.createElement('div');
	this.custHG.setAttribute('id','cust-gam');
	this.custHGBack = document.createElement('input');
	this.custHGBack.setAttribute('type','button');
	this.custHGBack.value = 'Back';
	this.custHG.appendChild(this.custHGBack);
	this.custHGInfo = document.createElement('div');
	this.custHGInfo.setAttribute('class','infotext');
	this.custHGInfo.appendChild(this.createFigure('tweak','pngs/cust-hg-1.png',2.8903));
	this.addInfo(this.custHGInfo,false,null,"With 'Highlight Gamut' a second colour space or gamut can be applied above a user-selectable exposure range.");
	this.addInfo(this.custHGInfo,false,null,'The transition can be calculated linearly, over a range of reflectance percentages (eg between 18% gray and 90% white) or logarithmically, set in stops above or below 18% gray.');
	this.addInfo(this.custHGInfo,false,null,'With this effects such as muted or black and white highlights with saturated midtones can be achieved in a LUT.');
	this.custHG.className = 'info-page-hide';
	this.custHG.appendChild(this.custHGInfo);
};
LUTInfoBox.prototype.createCustKnee = function() {
	this.custKnee = document.createElement('div');
	this.custKnee.setAttribute('id','cust-knee');
	this.custKneeBack = document.createElement('input');
	this.custKneeBack.setAttribute('type','button');
	this.custKneeBack.value = 'Back';
	this.custKnee.appendChild(this.custKneeBack);
	this.custKneeInfo = document.createElement('div');
	this.custKneeInfo.setAttribute('class','infotext');
	this.custKneeInfo.appendChild(this.createFigure('tweak','pngs/cust-knee-1.png',1.6057));
	this.addInfo(this.custKneeInfo,false,null,"The 'Knee' tool provides a means to capture a wide dynamic range whilst maintaining contrast in the midtones.");
	this.addInfo(this.custKneeInfo,false,'Legal Range / Extended Range','Sets the output IRE level at the defined white clip level. Legal range clips at 99% IRE (to allow for differences between colour channels). Extended range clips to 1% below 10-bit 1019.');
	this.addInfo(this.custKneeInfo,false,'Knee Start Level','The exposure level - in stops above 18% gray - at which the knee takes over from the base gamma.');
	this.addInfo(this.custKneeInfo,false,'Clip Level',"The exposure level - in stops above 18% gray - at which the knee reaches the clip level set with 'Legal Range / Extended Range'. For very wide dynamic ranges (Sony and Arri cameras can handle six or seven stops of headroom) keeping the knee start level low will help ensure a smooth rolloff.");
	this.addInfo(this.custKneeInfo,false,null,'Setting Knee Start Level too high with a high value of Clip Level can lead to ugly overshoots. These can be seen in and remedied with the charts normally visible where these instructions are.');
	this.addInfo(this.custKneeInfo,false,'Slope At Clip','The knee angle at the clip level. It is in % IRE per stop. A value of zero tends to lead to extremely compressed highlights and means that any values above white clip (such as in a grading LUT with exposure adjustment) will be indistinguishable, so a slight slope is generally advisable.');
	this.addInfo(this.custKneeInfo,false,'Smoothness','By default the LUTCalc creates a smooth, cubic knee rolloff. This is the prevailing approach in modern cameras. Adjusting the smoothness down will tend towards a hard, linear transition more akin to conventional video cameras such as Beta-SP and Digibeta.');
	this.addInfo(this.custKneeInfo,false,null,'With the current algorithm the cubic transition can overshoot where an extremely wide dynamic range is compressed into a very narrow range (high Knee Start Level). If that is required then setting smoothness to zero will avoid the overshoot.');
	this.custKnee.className = 'info-page-hide';
	this.custKnee.appendChild(this.custKneeInfo);
};
LUTInfoBox.prototype.createCustBhi = function() {
	this.custBhi = document.createElement('div');
	this.custBhi.setAttribute('id','cust-bhi');
	this.custBhiBack = document.createElement('input');
	this.custBhiBack.setAttribute('type','button');
	this.custBhiBack.value = 'Back';
	this.custBhi.appendChild(this.custBhiBack);
	this.custBhiInfo = document.createElement('div');
	this.custBhiInfo.setAttribute('class','infotext');
	this.custBhiInfo.appendChild(this.createFigure('tweak','pngs/cust-bhi-1.png',6.4));
	this.addInfo(this.custBhiInfo,false,null,'Black Level and Highlight Level apply an offset and scaling after all other adjustments and conversions have been applied.');
	this.custBhiInfo.appendChild(this.createFigure('tweak','pngs/cust-bhi-2.png',3.7333));
	this.addInfo(this.custBhiInfo,false,'Black Level','initially gives the % IRE level of 0% black in the output transfer function or gamma. This can then be fixed against highlight adjustments or reset, for example to thicken the black level by a measured amount.');
	this.addInfo(this.custBhiInfo,false,null,'Black Level and Highlight Level include ASC-CDL adjustments in their calculations, so any ASC-CDL adjustments should be made before Black Level and Highlight Level adjustments.');
	this.addInfo(this.custBhiInfo,false,null,"By default LUTCalc resets the Black and highlight levels when the underlying base level changes (eg when the output gamma is changed). 'Lock Value' prevents LUTCalc from changing the customised level.");
	this.custBhiInfo.appendChild(this.createFigure('tweak','pngs/cust-bhi-3.png',2.6988));
	this.addInfo(this.custBhiInfo,false,'Highlight Level','this will give the % IRE level of a selectable reflectance percentage (initially 90% white) for the output curve. Also shown is the equivalent % IRE in the Rec709 display gamma.');
	this.addInfo(this.custBhiInfo,false,null,'The output level can then be altered and LUTCalc will scale the output curve.');
	this.addInfo(this.custBhiInfo,false,null,'As with Black Level, Highlight Level incorporates ASC-CDL adjustments, so any ASC-CDL adjustments should be made before Black Level and Highlight Level adjustments.');
	this.addInfo(this.custBhiInfo,false,null,'Black and Highlight Level adjustments work together, for example to adjust the LC709 and LC709A curves from being legal range - peaking just below 100% - to extended range (Reflected 1350% maps to 108.9%) without changing the black level.');
	this.custBhi.className = 'info-page-hide';
	this.custBhi.appendChild(this.custBhiInfo);
};
LUTInfoBox.prototype.createCustSDRS = function() {
	this.custSDRS = document.createElement('div');
	this.custSDRS.setAttribute('id','cust-sdrs');
	this.custSDRSBack = document.createElement('input');
	this.custSDRSBack.setAttribute('type','button');
	this.custSDRSBack.value = 'Back';
	this.custSDRS.appendChild(this.custSDRSBack);
	this.custSDRSInfo = document.createElement('div');
	this.custSDRSInfo.setAttribute('class','infotext');
	this.custSDRS.className = 'info-page-hide';
	this.custSDRS.appendChild(this.custSDRSInfo);
};
LUTInfoBox.prototype.createCustBgm = function() {
	this.custBgm = document.createElement('div');
	this.custBgm.setAttribute('id','cust-bgm');
	this.custBgmBack = document.createElement('input');
	this.custBgmBack.setAttribute('type','button');
	this.custBgmBack.value = 'Back';
	this.custBgm.appendChild(this.custBgmBack);
	this.custBgmInfo = document.createElement('div');
	this.custBgmInfo.setAttribute('class','infotext');
	this.custBgmInfo.appendChild(this.createFigure('tweak','pngs/cust-bgm-1.png',3.8291));
	this.addInfo(this.custBgmInfo,false,null,'Black Gamma is a tool for adjusting contrast in the shadows without altering the level of black itself.');
	this.addInfo(this.custBgmInfo,false,'Stop Limit','This sets the maximum level at which black gamma has an effect. As with the other tools in LUTCalc, it is set based upon the real-world levels being recorded. The value is in stops, with zero being the level of an 18% gray target.');
	this.addInfo(this.custBgmInfo,false,'Feather','This attempts to smooth the transition between the black gamma and the underlying tone curve. It sets the number of stops below the stop limit in which to transition between the two.');
	this.addInfo(this.custBgmInfo,false,'Power','Sets the gamma or power value for the black gamma region. Values below 1 lead to reduced contrast, whilst values above 1 lead to increased contrast, emphasising shadows. A value of 1 has no effect.');
	this.custBgm.className = 'info-page-hide';
	this.custBgm.appendChild(this.custBgmInfo);
};
LUTInfoBox.prototype.createCustDCC = function() {
	this.custDCC = document.createElement('div');
	this.custDCC.setAttribute('id','cust-dcc');
	this.custDCCBack = document.createElement('input');
	this.custDCCBack.setAttribute('type','button');
	this.custDCCBack.value = 'Back';
	this.custDCC.appendChild(this.custDCCBack);
	this.custDCCInfo = document.createElement('div');
	this.custDCCInfo.setAttribute('class','infotext');
	this.custDCCInfo.appendChild(this.createFigure('tweak','pngs/cust-dcc-1.png',7.226));
	this.addInfo(this.custDCCInfo,false,null,"'Display Colourspace Converter' sits after all other colour adjustments and allows a look created for one colourspace to be adapted for another.");
	this.addInfo(this.custDCCInfo,false,null,"For example, it can be used to make a version of a look created for Rec709 displays that gives the same result on a DCI-P3 display.");
	this.custDCC.className = 'info-page-hide';
	this.custDCC.appendChild(this.custDCCInfo);
};
LUTInfoBox.prototype.createCustGlim = function() {
	this.custGlim = document.createElement('div');
	this.custGlim.setAttribute('id','cust-glim');
	this.custGlimBack = document.createElement('input');
	this.custGlimBack.setAttribute('type','button');
	this.custGlimBack.value = 'Back';
	this.custGlim.appendChild(this.custGlimBack);
	this.custGlimInfo = document.createElement('div');
	this.custGlimInfo.setAttribute('class','infotext');
	this.addInfo(this.custGlimInfo,false,null,'When going from a wide gamut, such as ACES or Arri Wide Gamut to a narrower one, such as Rec709 or sRGB, the range of colours outside of the destination gamut will generally result in RGB values beyond what is legal or even recordable within a limited codec range.');
	this.addInfo(this.custGlimInfo,false,null,'Tone maps and gamma corrections reduce this issue, and hard clipping can prevent it, but at the risk of unexpected colours and harsh transitions.');
	this.addInfo(this.custGlimInfo,false,null,'The Gamut Limiter tool aims to protect against out-of-bounds colours by desaturating anything too vibrant back within limits.');
	this.addInfo(this.custGlimInfo,false,null,'It can either be applied in linear space or more usually after all other tonemaps, gamma corrections and other contrast adjustments have been made.');
	this.custGlimInfo.appendChild(this.createFigure('tweak','pngs/cust-glim-1.png',4.766));
	this.addInfo(this.custGlimInfo,false,'Post Gamma','Applied after all other contrast adjustments, the Gamut Limiter will ensure that colour values do not go out of range on the final image.');
	this.addInfo(this.custGlimInfo,false,null,'By default, any pixel which has a difference of greater than 100% IRE between the brightest and darkest colour channel will be adjusted such that the difference is limited to 100% whilst maintaining the luma value.');
	this.addInfo(this.custGlimInfo,false,null,"The tolerance can be reduced, by adjusting the 'Level' value down, resulting in increasingly desaturated highlights, then midtones then shadows and can also be increased to 109%.");
	this.custGlimInfo.appendChild(this.createFigure('tweak','pngs/cust-glim-2.png',3.9298));
	this.addInfo(this.custGlimInfo,false,'Linear Space','This option applies the limiting to the pure, linear signal which is used for colour transform operations. It is rather less straightforward to use, with the level set according to the stops above 18% Mid Gray or 90% reflectance white.');
	this.addInfo(this.custGlimInfo,false,null,'As such, the effectiveness is determined by the white clip of the output gamma / tonemap used. The default fits to an un-kneed linear or basic gamma (Rec709, DCI). Log recordings potentially have considerably more highlight latitude available than this. The level should therefore be set with regard to white clip of the IRE vs Stop charts.');
	this.addInfo(this.custGlimInfo,false,null,"The potential usefulness of the linear space option is that it is mathematically simpler and arguably 'truer', with desaturation calculated against luminance.");
	this.custGlimInfo.appendChild(this.createFigure('tweak','pngs/cust-glim-3.png',3.9646));
	this.addInfo(this.custGlimInfo,false,'Gamut To Limit To','In addition to the output gamut, it is possible to limit chroma to within a second gamut. This might be useful where a finished clip may then be gamma and gamut corrected for a secondary use, such as Rec709 and P3 DCI versions.');
	this.addInfo(this.custGlimInfo,false,null,'Whilst limiting could be done separately for each version, applying to both offers the potential of consistency between different output applications.');
	this.addInfo(this.custGlimInfo,false,null,"By default when a second gamut is selected from the drop down box, both options will be limited to, and a tick box will show 'Protect Both'");
	this.addInfo(this.custGlimInfo,false,null,'Unticking this wil result in only the secondary gamut being considered in the limiting process.');
	this.custGlim.className = 'info-page-hide';
	this.custGlim.appendChild(this.custGlimInfo);
};
LUTInfoBox.prototype.createCustFC = function() {
	this.custFC = document.createElement('div');
	this.custFC.setAttribute('id','cust-fls');
	this.custFCBack = document.createElement('input');
	this.custFCBack.setAttribute('type','button');
	this.custFCBack.value = 'Back';
	this.custFC.appendChild(this.custFCBack);
	this.custFCInfo = document.createElement('div');
	this.custFCInfo.setAttribute('class','infotext');
	this.custFCInfo.appendChild(this.createFigure('tweak','pngs/cust-fc-1.png',1.4132));
	this.addInfo(this.custFCInfo,false,null,"'False Colour' changes luminance ranges to fixed colours as an exposure aid for wide dynamic range log recording.");
	this.addInfo(this.custFCInfo,false,null,'The colours and ranges LUTCalc uses are based on those used by Sony. They are:');
	this.addInfo(this.custFCInfo,true,'Purple','Black clip (actually 10 stops below 18% gray).');
	this.addInfo(this.custFCInfo,true,'Blue','Just above black clip. Default is 6.1 stops below 18% gray, but this can be changed to taste.');
	this.addInfo(this.custFCInfo,true,'Green','18% gray +/- 0.2 stops. Exposure datum.');
	this.addInfo(this.custFCInfo,true,'Pink','One stop over 18% gray +/- 0.175 stops. Common reference for caucasian skin.');
	this.addInfo(this.custFCInfo,true,'Orange','90% white +/- 0.175 stops. Off by default as not included by Sony, 90% white is a common datum in broadcast video.');
	this.addInfo(this.custFCInfo,true,'Yellow','Just below white clip. The default is 0.26 stops below clip, but this can also be changed.');
	this.addInfo(this.custFCInfo,true,'Red','White clip (5.95 stops above 18% gray).');
	this.addInfo(this.custFCInfo,false,null,'False colours map to the original real world exposure levels, regardless of the chosen input and output colour spaces.');
	this.addInfo(this.custFCInfo,false,null,'False colour LUTs should be 33x33x33 or larger.');
	this.custFC.className = 'info-page-hide';
	this.custFC.appendChild(this.custFCInfo);
};
LUTInfoBox.prototype.createCustSamp = function() {
	this.custSamp = document.createElement('div');
	this.custSamp.setAttribute('id','cust-samp');
	this.custSampBack = document.createElement('input');
	this.custSampBack.setAttribute('type','button');
	this.custSampBack.value = 'Back';
	this.custSamp.appendChild(this.custSampBack);
	this.custSampInfo = document.createElement('div');
	this.custSampInfo.setAttribute('class','infotext');
	this.custSampInfo.appendChild(this.createFigure('tweak','pngs/cust-samp-1.png',2.0645));
	this.addInfo(this.custSampInfo,false,null,"RGB Sampler is a tool for capturing sets of pixel RGB code values from the preview window. It becomes available when the preview window is visible.");
	this.addInfo(this.custSampInfo,false,null,'A grid of sample point can be constructed, and then used to compare preview images.');
	this.addInfo(this.custSampInfo,false,'Set Sample Grid',"Pressing this initially reveals two further buttons - 'Start Click To Add Sample Point' and 'Reset Grid'.");
	this.addInfo(this.custSampInfo,true,'Start Click To Add Sample Point',"Pressing this allows you to define points on the preview window you wish to sample. Take the cursor over to the preview, click and a circle should appear containing a number - initially '1'. Move and click again and a circle containing '2' will appear. In this way you can build up a set of points to sample. When you have all the points required, you can click 'Stop Click To Add Sample Point' to avoid accidentally adding more. The grid overlay can be hidden by clicking 'Hide Sample Grid'.");
	this.addInfo(this.custSampInfo,false,null,'The actual area sampled is a weighted average of nine pixels at the centre of the circle - much smaller than the circle itself.');
	this.addInfo(this.custSampInfo,true,'Reset Grid','Grayed out until you have created at least one a sample point, this will remove all sample points so that you can start again.');
	this.addInfo(this.custSampInfo,false,'File Name','This is filename under which the samples should be saved.');
	this.addInfo(this.custSampInfo,false,'Component Separator','The separator character to be used between the red, green and blue component values. Defaults to a tab.');
	this.addInfo(this.custSampInfo,false,'Sample Separator','The separator character to be used between each RGB sample. Defaults to a new line.');
	this.addInfo(this.custSampInfo,false,'Sample Precision','The scaling used on the sample values. 8, 10 or 12-bit integers covering full range, or floating point values from -0.07 to 1.09. The online version of LUTCalc is restricted to reading in user images at 8-bit depth, but the Mac App version can read 16-bit tiffs and pngs.');
	this.addInfo(this.custSampInfo,false,'Include Grid Coordinates',"When a set of samples is taken, it automatically includes the filename of the preview image followed by a list of the red, green and blue values. If 'Include Grid Coordinates' is selected, the file will also contain the coordinates on the image (between 0-1.0 of the width and height) of each sample point next to the relevent values. This may be useful if the grid is changed between samples.");
	this.addInfo(this.custSampInfo,false,'Take Samples','Click this to read a set of samples from the image.');
	this.addInfo(this.custSampInfo,false,'Save Samples','Save all currently collected samples to a file.');
	this.addInfo(this.custSampInfo,false,'Clear Sample Data','Clear all currently collected samples from memory. Once you have saved your sample file, you can either continue to build up more data or press this button to start afresh.');
	this.custSamp.className = 'info-page-hide';
	this.custSamp.appendChild(this.custSampInfo);
};
LUTInfoBox.prototype.createCustLA = function() {
	this.custLA = document.createElement('div');
	this.custLA.setAttribute('id','cust-lut');
	this.custLABack = document.createElement('input');
	this.custLABack.setAttribute('type','button');
	this.custLABack.value = 'Back';
	this.custLA.appendChild(this.custLABack);
	this.custLAInfo = document.createElement('div');
	this.custLAInfo.setAttribute('class','infotext');
	this.custLAInfo.appendChild(this.createFigure('tweak','pngs/cust-la-1.png',6.5882));
	this.addInfo(this.custLAInfo,false,null,'LUTAnalyst is a tool for reading LUT files and converting them for use on S-Log3/S-Gamut3.cine material.');
	this.addInfo(this.custLAInfo,false,null,'It currently understands the following formats: .cube, .3dl, .ilut, .olut, .lut (Assimilate format), .spi1D, .spi3D and .vlt.');
	this.addInfo(this.custLAInfo,false,null,'Once a file is loaded LUTCalc can create a generalised 1D LUT of the transfer function or gamma and a generally close approximation of the colour space.');
	this.addInfo(this.custLAInfo,false,null,"There are several potential uses for the 'LALUTs' produced:");
	this.addInfo(this.custLAInfo,true,'Information',"Visualise the response curves and exposure characteristics of customised or 'hand rolled' LUTs generated by grading software.");
	this.addInfo(this.custLAInfo,true,'Exposure Adjustment','Ideally software should read video file metadata to automatically apply exposure adjustment. Frequently this does not currently happen, so combining exposure adjustment and colour correction into one LUT can help whilst preventing data loss to clipped values.');
	this.addInfo(this.custLAInfo,true,'Camera Matching','If different camera models are used together, versions of a LUT tuned to each camera can be produced, hopefully simplifying the process of matching in post.');
	this.addInfo(this.custLAInfo,false,null,"By selecting 'Load Existing Analysed LA LUT' LUTAnalyst can load a precalculated LALUT file and add the gamma and gamut to the list of available options. LALUT files end in either .lalut or .labin.");
	this.addInfo(this.custLAInfo,false,null,"Selecting a functional cube LUT file under the 'Import New LUT' option starts a two-stage process.");
	this.custLAInfo.appendChild(this.createFigure('tweak','pngs/cust-la-2.png',1.8667));
	this.addInfo(this.custLAInfo,false,null,"If the LUT contains a title line, then this should appear under 'LUT Title'. If not, the filename is used which can then be changed.");
	this.addInfo(this.custLAInfo,false,null,'The input gamma and gamut that the LUT is designed for should then be specified.');
	this.addInfo(this.custLAInfo,false,null,'LUTAnalyst breaks up a LUT into a 1D transfer function and a 3D colour space. The dimension of the colour space LALUT can be 33x33x33 or 65x65x65. The way that LUTAnalyst now works, matching the analysis dimension to the LUT being analysed, but larger can sometimes be helpful, so 65x65x65 is the default.');
	this.addInfo(this.custLAInfo,false,null,'Analysis Method relates to the 3D interpolation technique used. Tricubic is smooth and complex, but prone to overshoots, tetrahedral is the most computationally simple and is becoming the standard approach in postproduction LUT use and trilinear is a 3D extension on linear interpolation. Tetrahedral is the default.');
	this.addInfo(this.custLAInfo,false,null,'The final main options are the input and output ranges of the LUT to be analysed. LUTCalc defaults to 109%->100% as this is a common setup, but diferences between range settings can be surprisingly subtle, so testing may well be required.');
	this.addInfo(this.custLAInfo,false,null,"Clicking the 'Advanced Settings' box brings up the option to specify the interpolation techniques used to apply the analysed LUT to the preview window and for final LUT generation.");
	this.addInfo(this.custLAInfo,false,null,"'Advanced Settings' also includes a 'Declip' button which becomes available when a LUT to be analysed has been clipped to within a range of 0-1.0. If this does not apply, the button is marked 'Unclipped' and grayed out. Otherwise 'Declip' attempts to extrapolate back the lost clipped data. It is not always an improvement, but can sometimes be helpful.");
	this.addInfo(this.custLAInfo,false,null,"Pressing 'New LUT' at any time restarts the whole process, but clicking 'Analyse' should start a process which takes a few seconds. When complete, the analysed LUT should appear as an option at the end of the gamma and gamut lists, and one or two new buttons should appear in the LUTAnalyst box.");
	this.custLAInfo.appendChild(this.createFigure('tweak','pngs/cust-la-3.png',1.3827));
	this.addInfo(this.custLAInfo,false,null,"'Save Cube' stores the 1D and 3D LUTAnalyst LUTs as a single file combining two cube files. 'Save Binary' stores them in a smaller, simpler binary format. LUTCalc For Mac cannot currently save the binary versions, though it can read them.");
	this.addInfo(this.custLAInfo,false,null,"'Re-Analyse' reperforms the analysis, for example if the LUT Range was incorrectly set.");
	this.custLA.className = 'info-page-hide';
	this.custLA.appendChild(this.custLAInfo);
};
LUTInfoBox.prototype.addInfo = function(infoBox,indent,title,text) {
	var para = document.createElement('p');
	if (indent) {
		para.className = 'indentpara';
	}
	if (typeof title === 'string') {
		var titleText = document.createElement('strong');
		titleText.appendChild(document.createTextNode(title));
		para.appendChild(titleText);
		para.appendChild(document.createTextNode(' - '));
	}
	para.appendChild(document.createTextNode(text));
	infoBox.appendChild(para);
};
LUTInfoBox.prototype.gammaInfo = function() {
	this.tableRefVals = new Float64Array([0,0.18,0.38,0.44,0.9,7.2,Math.pow(2,parseFloat(this.inputs.wclip))*0.18]);
	this.tableIREVals = new Float64Array(7);
	this.gammaInfoBox.className = 'info-tab';
	this.addText(this.gammaInfoBox,'Output gamma including any customisations:');
	var curires = document.createElement('table');
	curires.className = 'ref-table';
	var curiresHead = document.createElement('thead');
	curiresHead.appendChild(this.addRow(['Reflected %','0','18','38','44','90','720','Clip'], 'th'));
	curires.appendChild(curiresHead);
	var curiresBody = document.createElement('tbody');
	var curvarsRow = this.addRow(['10-bit Values','-','-','-','-','-','-','-'],'td');
	this.lutOutVals = [];
	[].push.apply(this.lutOutVals,curvarsRow.getElementsByTagName('td'));
	var curiresRow = this.addRow(['LUTted %IRE','-','-','-','-','-','-','-'],'td');
	this.lutOutIREs = [];
	[].push.apply(this.lutOutIREs,curiresRow.getElementsByTagName('td'));
	curiresBody.appendChild(curiresRow);
	curiresBody.appendChild(curvarsRow);
	curires.appendChild(curiresBody);
	this.gammaInfoBox.appendChild(curires);

	this.addText(this.gammaInfoBox,'Post LUT:');
	var tableStopsNeg = document.createElement('table');
	tableStopsNeg.className = 'ire-table';
	var tableStopsNegHead = document.createElement('thead');
	tableStopsNegHead.appendChild(this.addRow(['Stop','-8','-7','-6','-5','-4','-3','-2','-1','0'], 'th'));
	tableStopsNeg.appendChild(tableStopsNegHead);
	var tableStopsNegBody = document.createElement('tbody');
	var tableVarsNegRow = this.addRow(['10-bit','-','-','-','-','-','-','-','-','-'],'td');
	this.tableStopsNegVals = [];
	[].push.apply(this.tableStopsNegVals,tableVarsNegRow.getElementsByTagName('td'));
	var tableIREsNegRow = this.addRow(['%IRE','-','-','-','-','-','-','-','-','-'],'td');
	this.tableStopsNegIREs = [];
	[].push.apply(this.tableStopsNegIREs,tableIREsNegRow.getElementsByTagName('td'));
	tableStopsNegBody.appendChild(tableIREsNegRow);
	tableStopsNegBody.appendChild(tableVarsNegRow);
	tableStopsNeg.appendChild(tableStopsNegBody);
	this.gammaInfoBox.appendChild(tableStopsNeg);
	var tableStopsPos = document.createElement('table');
	tableStopsPos.className = 'ire-table';
	var tableStopsPosHead = document.createElement('thead');
	tableStopsPosHead.appendChild(this.addRow(['Stop','0','1','2','3','4','5','6','7','8'], 'th'));
	tableStopsPos.appendChild(tableStopsPosHead);
	var tableStopsPosBody = document.createElement('tbody');
	var tableVarsPosRow = this.addRow(['10-bit','-','-','-','-','-','-','-','-','-'],'td');
	this.tableStopsPosVals = [];
	[].push.apply(this.tableStopsPosVals,tableVarsPosRow.getElementsByTagName('td'));
	var tableIREsPosRow = this.addRow(['%IRE','-','-','-','-','-','-','-','-','-'],'td');
	this.tableStopsPosIREs = [];
	[].push.apply(this.tableStopsPosIREs,tableIREsPosRow.getElementsByTagName('td'));
	tableStopsPosBody.appendChild(tableIREsPosRow);
	tableStopsPosBody.appendChild(tableVarsPosRow);
	tableStopsPos.appendChild(tableStopsPosBody);
	this.gammaInfoBox.appendChild(tableStopsPos);

	this.preLUTLabel = document.createElement('p');
	this.preLUTLabel.innerHTML = 'Pre LUT - ' + this.gammaInName + ':';
	this.gammaInfoBox.appendChild(this.preLUTLabel);
	var tableStopsPreNeg = document.createElement('table');
	tableStopsPreNeg.className = 'ire-table';
	var tableStopsPreNegHead = document.createElement('thead');
	tableStopsPreNegHead.appendChild(this.addRow(['Stop','-8','-7','-6','-5','-4','-3','-2','-1','0'], 'th'));
	tableStopsPreNeg.appendChild(tableStopsPreNegHead);
	var tableStopsPreNegBody = document.createElement('tbody');
	var tableVarsPreNegRow = this.addRow(['10-bit','-','-','-','-','-','-','-','-','-'],'td');
	this.tableStopsPreNegVals = [];
	[].push.apply(this.tableStopsPreNegVals,tableVarsPreNegRow.getElementsByTagName('td'));
	var tableIREsPreNegRow = this.addRow(['%IRE','-','-','-','-','-','-','-','-','-'],'td');
	this.tableStopsPreNegIREs = [];
	[].push.apply(this.tableStopsPreNegIREs,tableIREsPreNegRow.getElementsByTagName('td'));
	tableStopsPreNegBody.appendChild(tableIREsPreNegRow);
	tableStopsPreNegBody.appendChild(tableVarsPreNegRow);
	tableStopsPreNeg.appendChild(tableStopsPreNegBody);
	this.gammaInfoBox.appendChild(tableStopsPreNeg);
	var tableStopsPrePos = document.createElement('table');
	tableStopsPrePos.className = 'ire-table';
	var tableStopsPrePosHead = document.createElement('thead');
	tableStopsPrePosHead.appendChild(this.addRow(['Stop','0','1','2','3','4','5','6','7','8'], 'th'));
	tableStopsPrePos.appendChild(tableStopsPrePosHead);
	var tableStopsPrePosBody = document.createElement('tbody');
	var tableVarsPrePosRow = this.addRow(['10-bit','-','-','-','-','-','-','-','-','-'],'td');
	this.tableStopsPrePosVals = [];
	[].push.apply(this.tableStopsPrePosVals,tableVarsPrePosRow.getElementsByTagName('td'));
	var tableIREsPrePosRow = this.addRow(['%IRE','-','-','-','-','-','-','-','-','-'],'td');
	this.tableStopsPrePosIREs = [];
	[].push.apply(this.tableStopsPrePosIREs,tableIREsPrePosRow.getElementsByTagName('td'));
	tableStopsPrePosBody.appendChild(tableIREsPrePosRow);
	tableStopsPrePosBody.appendChild(tableVarsPrePosRow);
	tableStopsPrePos.appendChild(tableStopsPrePosBody);
	this.gammaInfoBox.appendChild(tableStopsPrePos);
};
LUTInfoBox.prototype.gammaChart = function() {
	var m = 129;
	var d = m - 1;
	var k;
	this.gammaInName = '';
	this.gammaOutName = '';
	this.refX = new Float64Array(m);
	this.stopX = new Float64Array(m);
	this.lutIn = new Float64Array(m);
	for (var j=0; j<m; j++) {
		k = j/d;
		this.refX[j] = 14*k;
		this.stopX[j] = (16*k)-8;
		this.lutIn[j] = k;
	}
	this.refIn = new Float64Array(m);
	this.refOut = new Float64Array(m);
	this.stopIn = new Float64Array(m);
	this.stopOut = new Float64Array(m);
	this.lutOut = new Float64Array(m);

	this.gammaChartBox.className = 'info-tab';
	this.chartType = [];
	this.chartType[0] = this.createRadioElement('charttype', false);
	this.gammaChartBox.appendChild(this.chartType[0]);
	this.gammaChartBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Ref/IRE')));
	this.chartType[1] = this.createRadioElement('charttype', true);
	this.gammaChartBox.appendChild(this.chartType[1]);
	this.gammaChartBox.appendChild(document.createElement('label').appendChild(document.createTextNode('Stop/IRE')));
	this.chartType[2] = this.createRadioElement('charttype', false);
	this.gammaChartBox.appendChild(this.chartType[2]);
	this.gammaChartBox.appendChild(document.createElement('label').appendChild(document.createTextNode('LUT In/Out')));
	this.gammaChartBox.appendChild(document.createElement('br'));
	this.buildChart();
	// Tables for chart display
	this.gammaChartBox.appendChild(document.createTextNode('Output gamma including any customisations:'));
	var curires = document.createElement('table');
	curires.className = 'ref-table';
	var curiresHead = document.createElement('thead');
	curiresHead.appendChild(this.addRow(['Reflected %','0','18','38','44','90','720','Clip'], 'th'));
	curires.appendChild(curiresHead);
	var curiresBody = document.createElement('tbody');
	var curvarsRow = this.addRow(['10-bit Values','-','-','-','-','-','-','-'],'td');
	this.lutOutValsChart = [];
	[].push.apply(this.lutOutValsChart,curvarsRow.getElementsByTagName('td'));
	var curiresRow = this.addRow(['LUTted %IRE','-','-','-','-','-','-','-'],'td');
	this.lutOutIREsChart = [];
	[].push.apply(this.lutOutIREsChart,curiresRow.getElementsByTagName('td'));
	curiresBody.appendChild(curiresRow);
	curiresBody.appendChild(curvarsRow);
	curires.appendChild(curiresBody);
	this.gammaChartBox.appendChild(curires);
};
LUTInfoBox.prototype.printTables = function() {
	var printLabel = document.createElement('p');
	printLabel.innerHTML = 'Output gamma including any customisations:';
	this.printBox.appendChild(printLabel);
	var printires = document.createElement('table');
	printires.className = 'ref-table';
	var printiresHead = document.createElement('thead');
	printiresHead.appendChild(this.addRow(['Reflected %','0','18','38','44','90','720','Clip'], 'th'));
	printires.appendChild(printiresHead);
	var printiresBody = document.createElement('tbody');
	var printvarsRow = this.addRow(['10-bit Values','-','-','-','-','-','-','-'],'td');
	this.printOutVals = [];
	[].push.apply(this.printOutVals,printvarsRow.getElementsByTagName('td'));
	var printiresRow = this.addRow(['%IRE','-','-','-','-','-','-','-'],'td');
	this.printOutIREs = [];
	[].push.apply(this.printOutIREs,printiresRow.getElementsByTagName('td'));
	printiresBody.appendChild(printiresRow);
	printiresBody.appendChild(printvarsRow);
	printires.appendChild(printiresBody);
	this.printBox.appendChild(printires);
	this.printBox.appendChild(document.createElement('br'));
	var printstopsNeg = document.createElement('table');
	var printstopsNegHead = document.createElement('thead');
	printstopsNegHead.appendChild(this.addRow(['Stop','-8','-7','-6','-5','-4','-3','-2','-1','0'], 'th'));
	printstopsNeg.appendChild(printstopsNegHead);
	var printstopsNegBody = document.createElement('tbody');
	var printvarsNegRow = this.addRow(['10-bit','-','-','-','-','-','-','-','-','-'],'td');
	this.printstopsNegVals = [];
	[].push.apply(this.printstopsNegVals,printvarsNegRow.getElementsByTagName('td'));
	var printiresNegRow = this.addRow(['%IRE','-','-','-','-','-','-','-','-','-'],'td');
	this.printstopsNegIREs = [];
	[].push.apply(this.printstopsNegIREs,printiresNegRow.getElementsByTagName('td'));
	printstopsNegBody.appendChild(printiresNegRow);
	printstopsNegBody.appendChild(printvarsNegRow);
	printstopsNeg.appendChild(printstopsNegBody);
	this.printBox.appendChild(printstopsNeg);
	var printstopsPos = document.createElement('table');
	var printstopsPosHead = document.createElement('thead');
	printstopsPosHead.appendChild(this.addRow(['Stop','0','1','2','3','4','5','6','7','8'], 'th'));
	printstopsPos.appendChild(printstopsPosHead);
	var printstopsPosBody = document.createElement('tbody');
	var printvarsPosRow = this.addRow(['10-bit','-','-','-','-','-','-','-','-','-'],'td');
	this.printstopsPosVals = [];
	[].push.apply(this.printstopsPosVals,printvarsPosRow.getElementsByTagName('td'));
	var printiresPosRow = this.addRow(['%IRE','-','-','-','-','-','-','-','-','-'],'td');
	this.printstopsPosIREs = [];
	[].push.apply(this.printstopsPosIREs,printiresPosRow.getElementsByTagName('td'));
	printstopsPosBody.appendChild(printiresPosRow);
	printstopsPosBody.appendChild(printvarsPosRow);
	printstopsPos.appendChild(printstopsPosBody);
	this.printBox.appendChild(printstopsPos);
	this.printBox.appendChild(document.createElement('br'));
	var lutLabel = document.createElement('p');
	lutLabel.innerHTML = 'LUT In vs LUT out:';
	this.printBox.appendChild(lutLabel);
};
LUTInfoBox.prototype.buildChart = function() {
	var point = '18';
	var cwidth = 1120;
	var cheight = 600;
	var w = cwidth * 0.98;
	var h = cheight;
	var yMin = h / 15;
	var yMax = yMin*0.5;
	var dY = (h - (1.5*yMin))/1023;
	var yA = dY * 876;
	var yB = dY * 64;
	var y0 = h - yMin - yB;
	var x0 = w / 10;
	var dX = (w - x0)/16;
	//
	this.chartBoxes = {
		refIRE: document.createElement('div'),
		stopIRE: document.createElement('div'),
		lutLUT: document.createElement('div')
	};
	// Reflected Against IRE
	var canvas1 = document.createElement('canvas');
	canvas1.id = 'can-lin-bgrnd';
	var ctx1 = canvas1.getContext('2d');
	canvas1.width = cwidth;
	canvas1.height = cheight;
	dX = (w - x0)/14;
	ctx1.fillStyle = 'black';
	ctx1.font = point + 'pt "Avant Garde", Avantgarde, "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	ctx1.textBaseline = 'middle';
	ctx1.textAlign = 'right';
	ctx1.strokeStyle='black';
	ctx1.beginPath();
	ctx1.lineWidth = 2;
	ctx1.fillText('109.5%', x0 * 0.9,yMax);
	ctx1.fillText('100%', x0 * 0.9,y0 - yA);
	ctx1.fillText('0%', x0 * 0.9,h - yB - yMin);
	ctx1.fillText('-7.3%', x0 * 0.9,h - yMin);
	ctx1.moveTo(x0,y0);
	ctx1.lineTo(w,y0);
	ctx1.moveTo(x0,yMax);
	ctx1.lineTo(x0,h - yMin);
	ctx1.stroke();
	ctx1.beginPath();
	ctx1.strokeStyle='rgba(240, 176, 176, 0.5)';
	ctx1.moveTo(x0,h - yMin);
	ctx1.lineTo(w,h - yMin);
	ctx1.moveTo(x0,y0 - yA);
	ctx1.lineTo(w,y0 - yA);
	ctx1.moveTo(x0,yMax);
	ctx1.lineTo(w,yMax);
	ctx1.stroke();
	ctx1.beginPath();
	ctx1.strokeStyle='rgba(176, 176, 240, 0.5)';
	for (var i=1; i<10; i++){
		ctx1.fillText(parseInt(i*10).toString() + '%', x0 * 0.9,y0 - (yA*i/10));
		ctx1.moveTo(x0,y0 - (yA*i/10));
		ctx1.lineTo(w,y0 - (yA*i/10));
	}
	for (var i=0; i<15; i++){
		ctx1.translate(x0 + (i*dX) + (w/150) + 10,y0 + (1.75*yB) + 10);
		ctx1.rotate(1);
		ctx1.fillText(parseInt(i*100).toString() + '%', 0, 0);
		ctx1.rotate(-1);
		ctx1.translate(-x0 - (i*dX) - (w/150) - 10,-y0 - (1.75*yB) - 10);
		ctx1.moveTo(x0 + (dX*i),yMax);
		ctx1.lineTo(x0 + (dX*i),h - yMin);
	}
	ctx1.stroke();
	var recCanvas1 = document.createElement('canvas');
	recCanvas1.id = 'can-lin-rec';
	recCanvas1.width = canvas1.width;
	recCanvas1.height = canvas1.height;
	var outCanvas1 = document.createElement('canvas');
	outCanvas1.id = 'can-lin-out';
	outCanvas1.width = canvas1.width;
	outCanvas1.height = canvas1.height;
	var clipCanvas1 = document.createElement('canvas');
	clipCanvas1.id = 'can-lin-clip';
	clipCanvas1.width = canvas1.width;
	clipCanvas1.height = canvas1.height;
	this.refChart = {};
	this.refChart.rec = recCanvas1.getContext('2d');
	this.refChart.out = outCanvas1.getContext('2d');
	this.refChart.clip = clipCanvas1.getContext('2d');
	this.refChart.width = canvas1.width;
	this.refChart.w = w;
	this.refChart.x0 = x0;
	this.refChart.dX = dX;
	this.refChart.height = canvas1.height;
	this.refChart.h = h;
	this.refChart.y0 = y0;
	this.refChart.yMax = yMax;
	this.refChart.dY = yA;
	this.chartBoxes.refIRE.appendChild(canvas1);
	this.chartBoxes.refIRE.appendChild(clipCanvas1);
	this.chartBoxes.refIRE.appendChild(recCanvas1);
	this.chartBoxes.refIRE.appendChild(outCanvas1);
	// Stop Against IRE
	var canvas2 = document.createElement('canvas');
	canvas2.id = 'can-stop-bgrnd';
	var ctx2 = canvas2.getContext('2d');
	canvas2.width = cwidth;
	canvas2.height = cheight;
	dX = (w - x0)/18;
	ctx2.fillStyle = 'black';
	ctx2.font = point + 'pt "Avant Garde", Avantgarde, "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	ctx2.textBaseline = 'middle';
	ctx2.textAlign = 'right';
	ctx2.strokeStyle='black';
	ctx2.beginPath();
	ctx2.lineWidth = 2;
	ctx2.fillText('109.5%', x0 * 0.9,yMax);
	ctx2.fillText('100%', x0 * 0.9,y0 - yA);
	ctx2.fillText('0%', x0 * 0.9,h - yB - yMin);
	ctx2.fillText('-7.3%', x0 * 0.9,h - yMin);
	ctx2.moveTo(x0,y0);
	ctx2.lineTo(w,y0);
	ctx2.moveTo(x0 + (dX*9),yMax);
	ctx2.lineTo(x0 + (dX*9),h - yMin);
	ctx2.stroke();
	ctx2.beginPath();
	ctx2.strokeStyle='rgba(240, 176, 176, 0.5)';
	ctx2.moveTo(x0,h - yMin);
	ctx2.lineTo(w,h - yMin);
	ctx2.moveTo(x0,y0 - yA);
	ctx2.lineTo(w,y0 - yA);
	ctx2.moveTo(x0,yMax);
	ctx2.lineTo(w,yMax);
	ctx2.stroke();
	ctx2.beginPath();
	ctx2.strokeStyle='rgba(176, 176, 240, 0.5)';
	for (var i=1; i<10; i++){
		ctx2.fillText(parseInt(i*10).toString() + '%', x0 * 0.9,y0 - (yA*i/10));
		ctx2.moveTo(x0,y0 - (yA*i/10));
		ctx2.lineTo(w,y0 - (yA*i/10));
	}
	for (var i=0; i<19; i++){
		ctx2.fillText(parseInt(i-9).toString(), x0 + (i*dX) + (w/150),y0 + (1.75*yB));
		ctx2.moveTo(x0 + (dX*i),yMax);
		ctx2.lineTo(x0 + (dX*i),h - yMin);
	}
	ctx2.stroke();
	var recCanvas2 = document.createElement('canvas');
	recCanvas2.id = 'can-stop-rec';
	recCanvas2.width = canvas2.width;
	recCanvas2.height = canvas2.height;
	var outCanvas2 = document.createElement('canvas');
	outCanvas2.id = 'can-stop-out';
	outCanvas2.width = canvas2.width;
	outCanvas2.height = canvas2.height;
	var clipCanvas2 = document.createElement('canvas');
	clipCanvas2.id = 'can-stop-clip';
	clipCanvas2.width = canvas2.width;
	clipCanvas2.height = canvas2.height;
	this.stopChart = {};
	this.stopChart.rec = recCanvas2.getContext('2d');
	this.stopChart.out = outCanvas2.getContext('2d');
	this.stopChart.clip = clipCanvas2.getContext('2d');
	this.stopChart.width = canvas2.width;
	this.stopChart.w = w;
	this.stopChart.x0 = x0;
	this.stopChart.dX = dX;
	this.stopChart.height = canvas2.height;
	this.stopChart.h = h;
	this.stopChart.y0 = y0;
	this.stopChart.yMax = yMax;
	this.stopChart.dY = yA;
	this.chartBoxes.stopIRE.appendChild(canvas2);
	this.chartBoxes.stopIRE.appendChild(clipCanvas2);
	this.chartBoxes.stopIRE.appendChild(recCanvas2);
	this.chartBoxes.stopIRE.appendChild(outCanvas2);
	// LUT In Against LUT Out
	var canvas3 = document.createElement('canvas');
	canvas3.id = 'can-lut-bgrnd';
	var ctx3 = canvas3.getContext('2d');
	canvas3.width = cwidth;
	canvas3.height = cheight;
	dX = (w - x0)*876/1023;
//	var xMin = x0 + (64*876/1023);
	var xMin = x0 + (dX*64/876);
	ctx3.fillStyle = 'black';
	ctx3.font = point + 'pt "Avant Garde", Avantgarde, "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	ctx3.textBaseline = 'middle';
	ctx3.textAlign = 'right';
	ctx3.strokeStyle='black';
	ctx3.beginPath();
	ctx3.lineWidth = 2;
	ctx3.fillText('109.5%', x0 * 0.9,yMax);
	ctx3.fillText('100%', x0 * 0.9,y0 - yA);
	ctx3.fillText('0%', x0 * 0.9,h - yB - yMin);
	ctx3.fillText('-7.3%', x0 * 0.9,h - yMin);
	ctx3.fillText('-7.3%', x0+ (w/50),y0 + (1.75*yB));
	ctx3.fillText('0%', xMin + (w/50),y0 + (1.75*yB));
	ctx3.fillText('100%', xMin + dX + (w/50),y0 + (1.75*yB));
	ctx3.fillText('109.5%', w + (w/50),y0 + (1.75*yB));
	ctx3.moveTo(x0,y0);
	ctx3.lineTo(w,y0);
	ctx3.moveTo(xMin,yMax);
	ctx3.lineTo(xMin,h - yMin);
	ctx3.stroke();
	ctx3.beginPath();
	ctx3.strokeStyle='rgba(240, 176, 176, 1)';
	ctx3.moveTo(x0,yMax);
	ctx3.lineTo(x0,h - yMin);
	ctx3.moveTo(w,yMax);
	ctx3.lineTo(w,h - yMin);
	ctx3.moveTo(xMin + dX,yMax);
	ctx3.lineTo(xMin + dX,h - yMin);
	ctx3.moveTo(x0,h - yMin);
	ctx3.lineTo(w,h - yMin);
	ctx3.moveTo(x0,y0 - yA);
	ctx3.lineTo(w,y0 - yA);
	ctx3.moveTo(x0,yMax);
	ctx3.lineTo(w,yMax);
	ctx3.stroke();
	ctx3.beginPath();
	ctx3.strokeStyle='rgba(176, 176, 240, 0.5)';
	for (var i=1; i<10; i++){
		ctx3.fillText(parseInt(i*10).toString() + '%', x0 * 0.9,y0 - (yA*i/10));
		ctx3.moveTo(x0,y0 - (yA*i/10));
		ctx3.lineTo(w,y0 - (yA*i/10));
	}
	for (var i=1; i<10; i++){
		ctx3.fillText(parseInt(i*10).toString()+'%', xMin + (i*dX/10) + (w/50),y0 + (1.75*yB));
		ctx3.moveTo(xMin + (dX*i/10),yMax);
		ctx3.lineTo(xMin + (dX*i/10),h - yMin);
	}
	ctx3.stroke();
	var outCanvas3 = document.createElement('canvas');
	outCanvas3.id = 'can-lut-out';
	outCanvas3.width = canvas3.width;
	outCanvas3.height = canvas3.height;
	var rgbCanvas3 = document.createElement('canvas');
	rgbCanvas3.id = 'can-lut-rgb';
	rgbCanvas3.width = canvas3.width;
	rgbCanvas3.height = canvas3.height;
	this.lutChart = {};
	this.lutChart.out = outCanvas3.getContext('2d');
	this.lutChart.rgb = rgbCanvas3.getContext('2d');
	this.lutChart.width = canvas3.width;
	this.lutChart.w = w;
	this.lutChart.x0 = x0;
	this.lutChart.dX = dX;
	this.lutChart.height = canvas3.height;
	this.lutChart.h = h;
	this.lutChart.y0 = y0;
	this.lutChart.yMax = yMax;
	this.lutChart.dY = yA;
	this.chartBoxes.lutLUT.appendChild(canvas3);
	this.chartBoxes.lutLUT.appendChild(outCanvas3);
	this.chartBoxes.lutLUT.appendChild(rgbCanvas3);
	// Set up printing canvas
	this.printElements = {};
	var printStopBox = document.createElement('div');
	printStopBox.id = 'print-stop-box';
	var printCan2 = document.createElement('canvas');
	printCan2.id = 'print-stop-bgrnd';
	printCan2.width = canvas2.width;
	printCan2.height = canvas2.height;
	printCan2.getContext('2d').drawImage(canvas2, 0, 0);
	printStopBox.appendChild(printCan2);
	var printRec2 = document.createElement('canvas');
	printRec2.id = 'print-stop-rec';
	this.printElements.rec2 = printRec2.getContext('2d');
	printRec2.width = canvas2.width;
	printRec2.height = canvas2.height;
	printStopBox.appendChild(printRec2);
	var printOut2 = document.createElement('canvas');
	printOut2.id = 'print-stop-out';
	this.printElements.out2 = printOut2.getContext('2d');
	printOut2.width = canvas2.width;
	printOut2.height = canvas2.height;
	printStopBox.appendChild(printOut2);
	var printClip2 = document.createElement('canvas');
	printClip2.id = 'print-stop-clip';
	this.printElements.clip2 = printClip2.getContext('2d');
	printClip2.width = canvas2.width;
	printClip2.height = canvas2.height;
	printStopBox.appendChild(printClip2);	
	this.printBox.appendChild(printStopBox);	
	this.printTables();
	var printLUTBox = document.createElement('div');
	printLUTBox.id = 'print-lut-box';
	var printCan3 = document.createElement('canvas');
	printCan3.id = 'print-lut-bgrnd';
	printCan3.width = canvas3.width;
	printCan3.height = canvas3.height;
	printCan3.getContext('2d').drawImage(canvas3, 0, 0);
	printLUTBox.appendChild(printCan3);
	var printOut3 = document.createElement('canvas');
	printOut3.id = 'print-lut-out';
	this.printElements.out3 = printOut3.getContext('2d');
	printOut3.width = canvas3.width;
	printOut3.height = canvas3.height;
	printLUTBox.appendChild(printOut3);
	this.printBox.appendChild(printLUTBox);
	//
	this.chartBoxes.refIRE.className = 'canvas-tab-hide';
	this.chartBoxes.stopIRE.className = 'canvas-tab';
	this.chartBoxes.lutLUT.className = 'canvas-tab-hide';
	this.gammaChartBox.appendChild(this.chartBoxes.refIRE);
	this.gammaChartBox.appendChild(this.chartBoxes.stopIRE);
	this.gammaChartBox.appendChild(this.chartBoxes.lutLUT);
	this.gammaChartBox.appendChild(document.createElement('br'));
	// Draw The Lines
//	this.updateGamma();
};
LUTInfoBox.prototype.addText = function(infoBox,text,bold) {
	var para = document.createElement('p');
	if (bold) {
		para.className = 'bold';
	}
	para.appendChild(document.createTextNode(text));
	infoBox.appendChild(para);
};
LUTInfoBox.prototype.addRow = function(data,section) {
	var max = data.length;
	var row = document.createElement('tr');
	for (var i=0; i < max; i++) {
		var col = document.createElement(section);
		col.appendChild(document.createTextNode(data[i]));
		row.appendChild(col);
	}
	return row;
};
LUTInfoBox.prototype.createRadioElement = function(name, checked) {
    var radioInput;
    try {
        var radioHtml = '<input type="radio" name="' + name + '"';
        if ( checked ) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += '/>';
        radioInput = document.createElement(radioHtml);
    } catch( err ) {
        radioInput = document.createElement('input');
        radioInput.setAttribute('type', 'radio');
        radioInput.setAttribute('name', name);
        if ( checked ) {
            radioInput.setAttribute('checked', 'checked');
        }
    }
    return radioInput;
};
LUTInfoBox.prototype.createFigure = function(type, filename, ratio) {
	var box = document.createElement('div');
	box.className = 'fig-' + type;
	var wrapper = document.createElement('div');
	wrapper.className = 'fig-wrapper';
	wrapper.style.paddingBottom = (100/ratio).toFixed(2).toString() + '%';
	box.appendChild(wrapper);
	var fig = document.createElement('div');
	fig.className = 'fig-img';
	fig.style.backgroundImage = "url('" + filename + "')";
	wrapper.appendChild(fig);
	return box;
};
// Event Responses
LUTInfoBox.prototype.triggerSaveChart = function() {
        if (this.inputs.appleApp) {
            var custom = this.messages.isCustomGamma();
            var title = this.inputs.name.value;
            var recGamma;
            if (this.inputs.inGamma.options[this.inputs.inGamma.selectedIndex].value !== '9999') {
                recGamma = this.inputs.inGamma.options[this.inputs.inGamma.selectedIndex].lastChild.nodeValue;
            } else {
                recGamma = this.inputs.inLinGamma.options[this.inputs.inLinGamma.selectedIndex].lastChild.nodeValue;
            }
            var gamma;
            if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].value !== '9999') {
                gamma = this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue;
            } else {
                gamma = this.inputs.outLinGamma.options[this.inputs.outLinGamma.selectedIndex].lastChild.nodeValue;
            }
            if (title === 'Custom LUT') {
                if (custom) {
                    title = 'Customised ' + gamma;
                } else {
                    title = gamma;
                }
            } else if (custom) {
                title += ' based on ' + gamma;
            }
            var data = {
                title: title,
                camera: this.messages.getCamera(),
                recGamma: this.gammaInName,
                details: 'LUTCalc ' + this.inputs.version,
                inValues: Array.from(this.stopIn),
                outValues: Array.from(this.stopOut),
                lutIn: Array.from(this.lutIn),
                lutOut: Array.from(this.lutOut),
                minStop: this.stopX[0],
                maxStop: this.stopX[this.stopX.length - 1],
                reflectances: [0,0.18,0.38,0.44,0.9,7.2,Math.pow(2,parseFloat(this.inputs.wclip))*0.18],
                reflectanceValues: Array.from(this.tableIREVals),
                stops: [-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8],
                stopValues: Array.from(this.stopVals),
                blackClip: this.inputs.bclip,
                whiteClip: this.inputs.wclip
            };
             window.webkit.messageHandlers.saveCharts.postMessage(JSON.stringify(data));
     
        }};
LUTInfoBox.prototype.triggerInstructions = function() {
        console.log("instructions")
        this.instructionsOpt();
        this.messages.mobileOpt('inf');
}
LUTInfoBox.prototype.instructionsOpt = function() {
	this.showMainscreen();
	this.instructionsBox.className = 'info-tab-ins';
	this.gammaInfoBox.className = 'info-tab-hide';
	this.gammaChartBox.className = 'info-tab-hide';
	this.gammaPrintBut.className = 'print-button-hide';
};
LUTInfoBox.prototype.gammaInfoOpt = function() {
	this.instructionsBox.className = 'info-tab-hide';
	this.gammaInfoBox.className = 'info-tab';
	this.gammaChartBox.className = 'info-tab-hide';
	this.gammaPrintBut.className = 'print-button';
};
LUTInfoBox.prototype.gammaChartOpt = function() {
	this.instructionsBox.className = 'info-tab-hide';
	this.gammaInfoBox.className = 'info-tab-hide';
	this.gammaChartBox.className = 'info-tab';
	if (this.chartType[1].checked || this.chartType[2].checked) {
		this.gammaPrintBut.className = 'print-button';
	} else {
		this.gammaPrintBut.className = 'print-button-hide';
	}
};
LUTInfoBox.prototype.gammaPrint = function() {
	var custom = this.messages.isCustomGamma();
	var title = this.inputs.name.value;
    var recGamma;
    if (this.inputs.inGamma.options[this.inputs.inGamma.selectedIndex].value !== '9999') {
        recGamma = this.inputs.inGamma.options[this.inputs.inGamma.selectedIndex].lastChild.nodeValue;
    } else {
        recGamma = this.inputs.inLinGamma.options[this.inputs.inLinGamma.selectedIndex].lastChild.nodeValue;
    }
	var gamma;
	if (this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].value !== '9999') {
		gamma = this.inputs.outGamma.options[this.inputs.outGamma.selectedIndex].lastChild.nodeValue;
	} else {
		gamma = this.inputs.outLinGamma.options[this.inputs.outLinGamma.selectedIndex].lastChild.nodeValue;
	}
	if (title === 'Custom LUT') {
		if (custom) {
			title = 'Customised ' + gamma;
		} else {
			title = gamma;
		}
	} else if (custom) {
		title += ' based on ' + gamma;
	}
	this.printTitle.innerHTML = title;
	this.printDetails.innerHTML = 'Made with LUTCalc ' + this.inputs.version;
	this.printElements.rec2.clearRect(0, 0, this.stopChart.width, this.stopChart.height);
	this.printElements.out2.clearRect(0, 0, this.stopChart.width, this.stopChart.height);
	this.printElements.clip2.clearRect(0, 0, this.stopChart.width, this.stopChart.height);
	this.printElements.rec2.drawImage(document.getElementById('can-stop-rec'), 0, 0);
	this.printElements.out2.drawImage(document.getElementById('can-stop-out'), 0, 0);
	this.printElements.clip2.drawImage(document.getElementById('can-stop-clip'), 0, 0);
	this.printElements.out3.clearRect(0, 0, this.lutChart.width, this.lutChart.height);
	this.printElements.out3.drawImage(document.getElementById('can-lut-out'), 0, 0);
	if (this.inputs.appleApp) {
        var chartCanvas = document.createElement('canvas');
        chartCanvas.width = this.printElements.rec2.canvas.width;
        chartCanvas.height = this.printElements.rec2.canvas.height;
        var chartContext = chartCanvas.getContext('2d');
        chartContext.drawImage(this.printElements.rec2.canvas, 0, 0);
        chartContext.drawImage(this.printElements.out2.canvas, 0, 0);
        chartContext.drawImage(this.printElements.clip2.canvas, 0, 0);

        var data = {
            title: title,
            camera: this.messages.getCamera(),
            recGamma: this.gammaInName,
            details: 'LUTCalc ' + this.inputs.version,
            inValues: Array.from(this.stopIn),
            outValues: Array.from(this.stopOut),
            lutIn: Array.from(this.lutIn),
            lutOut: Array.from(this.lutOut),
            minStop: this.stopX[0],
            maxStop: this.stopX[this.stopX.length - 1],
            reflectances: [0,0.18,0.38,0.44,0.9,7.2,Math.pow(2,parseFloat(this.inputs.wclip))*0.18],
            reflectanceValues: Array.from(this.tableIREVals),
            stops: [-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8],
            stopValues: Array.from(this.stopVals),
            blackClip: this.inputs.bclip,
            whiteClip: this.inputs.wclip
        };
 		window.webkit.messageHandlers.printCharts.postMessage(JSON.stringify(data));
 
	} else if (this.inputs.isApp) {
		window.lutCalcApp.printCharts();
	} else {
		window.print();
	}
};
LUTInfoBox.prototype.updatePrintTables = function() {
	for (var j=0; j<7; j++) {
		if (this.tableIREVals[j] < -0.07305936073059) {
			this.tableIREVals[j] = -0.07305936073059;
		}
		this.printOutIREs[j+1].innerHTML = Math.round(this.tableIREVals[j]*100).toString();
		this.printOutVals[j+1].innerHTML = Math.round((this.tableIREVals[j]*876)+64).toString();
		if (parseInt(this.printOutVals[j+1].innerHTML) > 1023) {
			this.printOutVals[j+1].innerHTML = '-';
			this.printOutIREs[j+1].innerHTML = '-';
		}
	}
	for (var j=0; j<9; j++) {
		if (this.stopVals[j] < -0.07305936073059) {
			this.stopVals[j] = -0.07305936073059;
		}
		this.printstopsNegIREs[j+1].innerHTML = Math.round(this.stopVals[j]*100).toString();
		this.printstopsNegVals[j+1].innerHTML = Math.round((this.stopVals[j]*876)+64).toString();
		this.printstopsPosIREs[j+1].innerHTML = Math.round(this.stopVals[j+8]*100).toString();
		this.printstopsPosVals[j+1].innerHTML = Math.round((this.stopVals[j+8]*876)+64).toString();
		if (parseInt(this.printstopsNegVals[j+1].innerHTML) > 1023) {
			this.printstopsNegVals[j+1].innerHTML = '-';
			this.printstopsNegIREs[j+1].innerHTML = '-';
		}
		if (parseInt(this.printstopsPosVals[j+1].innerHTML) > 1023) {
			this.printstopsPosVals[j+1].innerHTML = '-';
			this.printstopsPosIREs[j+1].innerHTML = '-';
		}
	}
};
LUTInfoBox.prototype.updateTables = function() {
	for (var j=0; j<7; j++) {
		if (this.tableIREVals[j] < -0.07305936073059) {
			this.tableIREVals[j] = -0.07305936073059;
		}
		this.lutOutIREs[j+1].innerHTML = Math.round(this.tableIREVals[j]*100).toString();
		this.lutOutVals[j+1].innerHTML = Math.round((this.tableIREVals[j]*876)+64).toString();
		this.lutOutIREsChart[j+1].innerHTML = Math.round(this.tableIREVals[j]*100).toString();
		this.lutOutValsChart[j+1].innerHTML = Math.round((this.tableIREVals[j]*876)+64).toString();
		if (parseInt(this.lutOutVals[j+1].innerHTML) > 1019) {
			if (j<6) {
				this.lutOutVals[j+1].innerHTML = '-';
				this.lutOutIREs[j+1].innerHTML = '-';
				this.lutOutValsChart[j+1].innerHTML = '-';
				this.lutOutIREsChart[j+1].innerHTML = '-';
			} else {
				this.lutOutVals[j+1].innerHTML = '>1019';
				this.lutOutIREs[j+1].innerHTML = '>109';
				this.lutOutValsChart[j+1].innerHTML = '>1019';
				this.lutOutIREsChart[j+1].innerHTML = '>109';
			}
		}
	}
	this.preLUTLabel.innerHTML = 'Pre LUT - ' + this.gammaInName + ':';
	for (var j=0; j<9; j++) {
		if (this.stopVals[j] < -0.07305936073059) {
			this.stopVals[j] = -0.07305936073059;
		}
		this.tableStopsNegIREs[j+1].innerHTML = Math.round(this.stopVals[j]*100).toString();
		this.tableStopsNegVals[j+1].innerHTML = Math.round((this.stopVals[j]*876)+64).toString();
		this.tableStopsPosIREs[j+1].innerHTML = Math.round(this.stopVals[j+8]*100).toString();
		this.tableStopsPosVals[j+1].innerHTML = Math.round((this.stopVals[j+8]*876)+64).toString();
		if (parseInt(this.tableStopsNegVals[j+1].innerHTML) > 1019) {
			this.tableStopsNegVals[j+1].innerHTML = '-';
			this.tableStopsNegIREs[j+1].innerHTML = '-';
		}
		if (parseInt(this.tableStopsPosVals[j+1].innerHTML) > 1019) {
			this.tableStopsPosVals[j+1].innerHTML = '-';
			this.tableStopsPosIREs[j+1].innerHTML = '-';
		}
		if (this.stopPreVals[j] < -0.07305936073059) {
			this.stopPreVals[j] = -0.07305936073059;
		}
		this.tableStopsPreNegIREs[j+1].innerHTML = Math.round(this.stopPreVals[j]*100).toString();
		this.tableStopsPreNegVals[j+1].innerHTML = Math.round((this.stopPreVals[j]*876)+64).toString();
		this.tableStopsPrePosIREs[j+1].innerHTML = Math.round(this.stopPreVals[j+8]*100).toString();
		this.tableStopsPrePosVals[j+1].innerHTML = Math.round((this.stopPreVals[j+8]*876)+64).toString();
		if (parseInt(this.tableStopsPreNegVals[j+1].innerHTML) > 1019) {
			this.tableStopsPreNegVals[j+1].innerHTML = '-';
			this.tableStopsPreNegIREs[j+1].innerHTML = '-';
		}
		if (parseInt(this.tableStopsPrePosVals[j+1].innerHTML) > 1019) {
			this.tableStopsPrePosVals[j+1].innerHTML = '-';
			this.tableStopsPrePosIREs[j+1].innerHTML = '-';
		}
	}
};
LUTInfoBox.prototype.changeChart = function() {
	if (this.chartType[0].checked) {
		this.chartBoxes.refIRE.className =	'canvas-tab';
		this.chartBoxes.stopIRE.className =	'canvas-tab-hide';
		this.chartBoxes.lutLUT.className =	'canvas-tab-hide';
		this.gammaPrintBut.className = 'print-button-hide';
	} else if (this.chartType[1].checked) {
		this.chartBoxes.refIRE.className =	'canvas-tab-hide';
		this.chartBoxes.stopIRE.className =	'canvas-tab';
		this.chartBoxes.lutLUT.className =	'canvas-tab-hide';
		this.gammaPrintBut.className = 'print-button';
	} else{
		this.chartBoxes.refIRE.className =	'canvas-tab-hide';
		this.chartBoxes.stopIRE.className =	'canvas-tab-hide';
		this.chartBoxes.lutLUT.className =	'canvas-tab';
		this.gammaPrintBut.className = 'print-button';
	}
};
LUTInfoBox.prototype.gotIOGammaNames = function(d) {
	this.gammaInName = d.inName;
	if (typeof d.inG !== 'undefined' && d.inG !== '') {
		this.gammaInName += ' - ' + d.inG;
	}
	this.gammaOutName = d.outName;
	if (typeof d.outG !== 'undefined' && d.outG !== '') {
		this.gammaOutName += ' - ' + d.outG;
	}
	if (d.outName === 'LA' ) {
		this.gammaOutName += ' - ' + this.inputs.laTitle.value;
	}
	this.updateRefChart();
	this.updateStopChart();
	this.updateLutChart();
};
LUTInfoBox.prototype.updateRefChart = function() { // Ref Against IRE
	this.refChart.rec.clearRect(0, 0, this.refChart.width, this.refChart.height);
	this.refChart.out.clearRect(0, 0, this.refChart.width, this.refChart.height);
	this.refChart.clip.clearRect(0, 0, this.refChart.width, this.refChart.height);
	this.refChart.rec.font = '28pt "Avant Garde", Avantgarde, "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	this.refChart.rec.textBaseline = 'middle';
	this.refChart.rec.textAlign = 'left';
	this.refChart.rec.beginPath();
	this.refChart.rec.strokeStyle='rgba(240, 0, 0, 0.75)';	
	this.refChart.rec.fillStyle = 'rgba(240, 0, 0, 0.75)';
	this.refChart.rec.fillText('In: ' + this.gammaInName, 200,365);
	this.refChart.rec.lineWidth = 4;
	this.refChart.rec.moveTo(this.refChart.x0,this.refChart.y0 - (this.refIn[0] * this.stopChart.dY));
	var max = this.refX.length;
	for (var i=1; i<max; i++) {
		this.refChart.rec.lineTo(this.refChart.x0 + (this.refX[i] * this.refChart.dX),this.refChart.y0 - (this.refIn[i] * this.refChart.dY));
	}
	this.refChart.rec.stroke();
	this.refChart.out.font = '28pt "Avant Garde", Avantgarde, "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	this.refChart.out.textBaseline = 'middle';
	this.refChart.out.textAlign = 'left';
	this.refChart.out.beginPath();
	this.refChart.out.strokeStyle='rgba(0, 0, 240, 0.75)';	
	this.refChart.out.fillStyle = 'rgba(0, 0, 240, 0.75)';
	this.refChart.out.fillText('Out: ' + this.gammaOutName, 200,415);
	this.refChart.out.lineWidth = 4;
	this.refChart.out.moveTo(this.refChart.x0,this.refChart.y0 - (this.refOut[0] * this.stopChart.dY));
	for (var i=1; i<max; i++) {
		this.refChart.out.lineTo(this.refChart.x0 + (this.refX[i] * this.refChart.dX),this.refChart.y0 - (this.refOut[i] * this.refChart.dY));
	}
	this.refChart.out.stroke();
	this.refChart.rec.clearRect(0, 0, this.refChart.width, this.refChart.yMax);
	this.refChart.out.clearRect(0, 0, this.refChart.width, this.refChart.yMax);
};
LUTInfoBox.prototype.updateStopChart = function() { // Stop Against IRE
	this.stopChart.rec.clearRect(0, 0, this.stopChart.width, this.stopChart.height);
	this.stopChart.out.clearRect(0, 0, this.stopChart.width, this.stopChart.height);
	this.stopChart.clip.clearRect(0, 0, this.stopChart.width, this.stopChart.height);
	this.stopChart.rec.font = '28pt "Avant Garde", Avantgarde, "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	this.stopChart.rec.textBaseline = 'middle';
	this.stopChart.rec.textAlign = 'left';
	this.stopChart.rec.beginPath();
	this.stopChart.rec.strokeStyle='rgba(240, 0, 0, 0.75)';	
	this.stopChart.rec.fillStyle = 'rgba(240, 0, 0, 0.75)';
	this.stopChart.rec.fillText('In: ' + this.gammaInName, 140,85);
	this.stopChart.rec.lineWidth = 4;
	this.stopChart.rec.moveTo(this.stopChart.x0,this.stopChart.y0 - (this.stopIn[0] * this.stopChart.dY));
	var max = this.stopX.length;
	for (var i=1; i<max; i++) {
		this.stopChart.rec.lineTo(this.stopChart.x0 + ((this.stopX[i] + 9) * this.stopChart.dX),this.stopChart.y0 - (this.stopIn[i] * this.stopChart.dY));
	}
	this.stopChart.rec.stroke();
	this.stopChart.out.font = '28pt "Avant Garde", Avantgarde, "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	this.stopChart.out.textBaseline = 'middle';
	this.stopChart.out.textAlign = 'left';
	this.stopChart.out.beginPath();
	this.stopChart.out.strokeStyle='rgba(0, 0, 240, 0.75)';	
	this.stopChart.out.fillStyle = 'rgba(0, 0, 240, 0.75)';
	this.stopChart.out.fillText('Out: ' + this.gammaOutName, 140,135);
	this.stopChart.out.lineWidth = 4;
	this.stopChart.out.moveTo(this.stopChart.x0,this.stopChart.y0 - (this.stopOut[0] * this.stopChart.dY));
	for (var i=1; i<max; i++) {
		this.stopChart.out.lineTo(this.stopChart.x0 + ((this.stopX[i] + 9) * this.stopChart.dX),this.stopChart.y0 - (this.stopOut[i] * this.stopChart.dY));
	}
	this.stopChart.out.stroke();
	this.stopChart.rec.clearRect(0, 0, this.stopChart.width, this.stopChart.yMax);
	this.stopChart.out.clearRect(0, 0, this.stopChart.width, this.stopChart.yMax);
	this.stopChart.clip.beginPath();
	this.stopChart.clip.strokeStyle='rgba(128, 128, 128, 0.1)';	
	this.stopChart.clip.fillStyle = 'rgba(128, 128, 128, 0.1)';
	this.stopChart.clip.lineWidth = 0;
	var wclip = this.inputs.wclip;
	this.stopChart.clip.fillRect(this.stopChart.x0 + ((wclip+9) * this.stopChart.dX), this.stopChart.yMax, (9-wclip) * this.stopChart.dX, this.stopChart.y0 - this.stopChart.yMax);
	var bclip = this.inputs.bclip;
	this.stopChart.clip.fillRect(this.stopChart.x0, this.stopChart.yMax, (9+bclip) * this.stopChart.dX, this.stopChart.y0 - this.stopChart.yMax);
	this.stopChart.clip.stroke();
	var stopZero = parseFloat(this.inputs.stopShift.value);
	if (Math.abs(stopZero) > 0.001) {
		stopZero = 9 - stopZero;
		this.stopChart.clip.beginPath();
		this.stopChart.clip.strokeStyle='rgba(240, 180, 180, 0.75)';	
		this.stopChart.clip.lineWidth = 5;
		this.stopChart.clip.moveTo(this.stopChart.x0 + (stopZero*this.stopChart.dX), this.stopChart.yMax);
		this.stopChart.clip.lineTo(this.stopChart.x0 + (stopZero*this.stopChart.dX), this.stopChart.y0);
		this.stopChart.clip.stroke();
	}
};
LUTInfoBox.prototype.updateLutChart = function() { // Gamma In Against Gamma Out
	var xMin = this.lutChart.x0 + (64*876/1023);
	var dX = this.lutChart.dX*1023/876;
	this.lutChart.out.clearRect(0, 0, this.lutChart.width, this.lutChart.height);
	this.lutChart.out.font = '28pt "Avant Garde", Avantgarde, "Century Gothic", CenturyGothic, "AppleGothic", sans-serif';
	this.lutChart.out.textBaseline = 'middle';
	this.lutChart.out.textAlign = 'left';
	this.lutChart.out.beginPath();
	this.lutChart.out.strokeStyle='rgba(128, 128, 128, 0.75)';	
	this.lutChart.out.fillStyle = 'rgba(0, 0, 0, 1)';
	this.lutChart.out.fillText(this.gammaInName + ' -> ' + this.gammaOutName, 220,90);
	this.lutChart.out.lineWidth = 4;
	this.lutChart.out.moveTo(this.lutChart.x0,this.lutChart.y0 - (this.lutOut[0] * this.lutChart.dY));
	var max = this.lutIn.length;
	for (var i=1; i<max; i++) {
//		this.lutChart.out.lineTo( xMin + (((this.lutIn[i]*1023)-64)/876)*this.lutChart.dX,this.lutChart.y0 - (this.lutOut[i] * this.lutChart.dY));
		this.lutChart.out.lineTo( this.lutChart.x0 + (this.lutIn[i]*dX),this.lutChart.y0 - (this.lutOut[i] * this.lutChart.dY));
	}
	this.lutChart.out.stroke();
	this.lutChart.out.clearRect(0, 0, this.lutChart.width, this.lutChart.yMax);
	var yMin = this.lutChart.h / 15;
	this.lutChart.out.clearRect(0, this.lutChart.h - yMin, this.lutChart.width, this.lutChart.h);
};
LUTInfoBox.prototype.updateRGBChart = function(d) {
	var rIn = new Float64Array(d.rIn);
	var gIn = new Float64Array(d.gIn);
	var bIn = new Float64Array(d.bIn);
	var rOut = new Float64Array(d.rOut);
	var gOut = new Float64Array(d.gOut);
	var bOut = new Float64Array(d.bOut);
	var m = rIn.length;
	var xMin = this.lutChart.x0 + (64*876/1023);
	this.lutChart.rgb.clearRect(0, 0, this.lutChart.width, this.lutChart.height);
// Red
	this.lutChart.rgb.beginPath();
	this.lutChart.rgb.strokeStyle='rgba(240, 0, 0, 0.75)';	
	this.lutChart.rgb.fillStyle = 'rgba(0, 0, 0, 1)';
	this.lutChart.rgb.lineWidth = 4;
	this.lutChart.rgb.moveTo(this.lutChart.x0 + ((rIn[0]*this.lutChart.dX)*1023/876),this.lutChart.y0 - (rOut[0] * this.lutChart.dY));
	for (var j=1; j<m; j++) {
		this.lutChart.rgb.lineTo( this.lutChart.x0 + ((rIn[j]*this.lutChart.dX)*1023/876),this.stopChart.y0 - (rOut[j] * this.lutChart.dY));
	}
	this.lutChart.rgb.stroke();
// Green
	this.lutChart.rgb.beginPath();
	this.lutChart.rgb.strokeStyle='rgba(0, 240, 0, 0.75)';	
	this.lutChart.rgb.fillStyle = 'rgba(0, 0, 0, 1)';
	this.lutChart.rgb.lineWidth = 4;
	this.lutChart.rgb.moveTo(this.lutChart.x0 + ((gIn[j]*this.lutChart.dX)*1023/876),this.lutChart.y0 - (gOut[0] * this.lutChart.dY));
	for (var j=1; j<m; j++) {
		this.lutChart.rgb.lineTo( this.lutChart.x0 + ((gIn[j]*this.lutChart.dX)*1023/876),this.stopChart.y0 - (gOut[j] * this.lutChart.dY));
	}
	this.lutChart.rgb.stroke();
// Blue
	this.lutChart.rgb.beginPath();
	this.lutChart.rgb.strokeStyle='rgba(0, 0, 240, 0.75)';	
	this.lutChart.rgb.fillStyle = 'rgba(0, 0, 0, 1)';
	this.lutChart.rgb.lineWidth = 4;
	this.lutChart.rgb.moveTo(this.lutChart.x0 + ((bIn[j]*this.lutChart.dX)*1023/876),this.lutChart.y0 - (bOut[0] * this.lutChart.dY));
	for (var j=1; j<m; j++) {
		this.lutChart.rgb.lineTo( this.lutChart.x0 + ((bIn[j]*this.lutChart.dX)*1023/876),this.stopChart.y0 - (bOut[j] * this.lutChart.dY));
	}
	this.lutChart.rgb.stroke();
// Tidy
	this.lutChart.rgb.clearRect(0, 0, this.lutChart.width, this.lutChart.yMax);
	var yMin = this.lutChart.h / 15;
	this.lutChart.rgb.clearRect(0, this.lutChart.h - yMin, this.lutChart.width, this.lutChart.h);
};
LUTInfoBox.prototype.updateGamma = function() {
	this.messages.gaTx(this.p,10,null);
	this.messages.gaTx(this.p,11,null);
};
LUTInfoBox.prototype.gotChartVals = function(d) {
	this.refX = new Float64Array(d.refX);
	this.refIn = new Float64Array(d.refIn);
	this.refOut = new Float64Array(d.refOut);
	this.stopX = new Float64Array(d.stopX);
	this.stopIn = new Float64Array(d.stopIn);
	this.stopPreVals = new Float64Array(d.stopPreVals);
	this.stopVals = new Float64Array(d.stopVals);
	this.stopOut = new Float64Array(d.stopOut);
	this.lutIn = new Float64Array(d.lutIn);
	this.lutOut = new Float64Array(d.lutOut);
	this.tableIREVals = new Float64Array(d.table);
	this.updateRefChart();
	this.updateStopChart();
	this.updateLutChart();
	this.updateTables();
	this.updatePrintTables();
};
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
/* lutmobile.js
* Menu and control objects for using the LUTCalc Web App on mobiles.
* 9th March 2017
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTMobile(fieldset, inputs, messages, modalBox, objects) {
	this.inputs = inputs;
	this.messages = messages;
	this.modalBox = modalBox;
	this.objects = objects;
	this.box = fieldset;
	this.p = 16;
	this.messages.addUI(this.p,this);
	this.io();
	this.ui();
}
LUTMobile.prototype.io = function() {
	// Main 'Hamburger' menu button
	this.menuButton = document.createElement('div');
	this.menuButton.id = 'mob-menu-button';
	this.menuButton.appendChild(document.createElement('div'));
	this.menuButton.appendChild(document.createElement('div'));
	this.menuButton.appendChild(document.createElement('div'));
	// Status text carrier
	this.statusText = document.createElement('span');
	this.statusText.id = 'mob-status-text';
	this.statusText.innerHTML = 'LUTCalc ' + this.inputs.version;
	// Preview toggle button
	this.preButton = document.createElement('div');
	this.preButton.className = 'mob-preview-icon';
	// Main menu options
	this.genButton = document.createElement('input');
	this.genButton.setAttribute('type','button');
	this.genButton.className = 'mob-button';
	this.genButton.value = 'Generate LUT';
	this.setButton = document.createElement('input');
	this.setButton.setAttribute('type','button');
	this.setButton.className = 'mob-button';
	this.setButton.value = 'Base Settings';
	this.twkButton = document.createElement('input');
	this.twkButton.setAttribute('type','button');
	this.twkButton.className = 'mob-button';
	this.twkButton.value = 'Adjustments';
	this.infButton = document.createElement('input');
	this.infButton.setAttribute('type','button');
	this.infButton.className = 'mob-button';
	this.infButton.value = 'Instructions';
	// Mobile-specific elements for the main DOM
	this.generateButton = document.createElement('input');
	this.generateButton.setAttribute('type','button');
	this.generateButton.className = 'mob-genbutton';
	this.generateButton.value = 'Generate LUT';
	// Get the DOM objects for each of the main options
	this.boxes = {
		cam: document.getElementById('box-cam'),
		gam: document.getElementById('box-gam'),
		twk: document.getElementById('box-twk'),
		lut: document.getElementById('box-lut'),
		pre: document.getElementById('box-pre'),
		inf: document.getElementById('box-inf'),
		rhs: document.getElementById('right')
	};
	// Get the DOM objects for each of the tweak options
	var twkBoxes = document.getElementById('tweaksholder').childNodes;
	var m = twkBoxes.length;
	for (var j=0; j<m; j++) {
		this.boxes['twk-' + j.toString()] = twkBoxes[j];
	}
	// Preview status
	this.show = false;
};
LUTMobile.prototype.ui = function() {
	// Create the status bar
	this.statusBox = document.createElement('div');
	this.statusBox.id = 'mob-status';
	this.statusBox.appendChild(this.menuButton);
	this.statusBox.appendChild(this.preButton);
	this.statusBox.appendChild(this.statusText);
	this.box.appendChild(this.statusBox);
	// Create the main menu
	this.menuBox = document.createElement('div');
	this.menuBox.className = 'mob-main-menu-hide';
	this.menuBox.appendChild(this.genButton);
	this.menuBox.appendChild(this.setButton);
	this.menuBox.appendChild(this.twkButton);
	this.menuBox.appendChild(this.infButton);
	this.modalBox.appendChild(this.menuBox);
	// Add mobile-specific elements to main DOM
	this.boxes.lut.appendChild(this.generateButton);
	// Set the current page
	this.cur = 'set';
	this.showCur();
};
LUTMobile.prototype.events = function() {
	this.menuButton.onclick = function(here){ return function(){
		here.cur = 'main';
		here.modalBox.className = 'modalbox';
		here.showCur();
	};}(this);
	this.preButton.onclick = function(here){ return function(){
		here.modalBox.className = 'modalbox-hide';
		here.togglePreview();
	};}(this);
	this.infButton.onclick = function(here){ return function(){
		here.cur = 'inf';
		here.modalBox.className = 'modalbox-hide';
		here.showCur();
	};}(this);
	this.genButton.onclick = function(here){ return function(){
		here.cur = 'lut';
		here.modalBox.className = 'modalbox-hide';
		here.showCur();
	};}(this);
	this.setButton.onclick = function(here){ return function(){
		here.cur = 'set';
		here.modalBox.className = 'modalbox-hide';
		here.showCur();
	};}(this);
	this.twkButton.onclick = function(here){ return function(){
		here.cur = 'twk';
		here.modalBox.className = 'modalbox-hide';
		here.showCur();
	};}(this);
	this.generateButton.onclick = function(here){ return function(){
		here.objects.generate.generate();
	};}(this);
};
// Mobile-specific
LUTMobile.prototype.togglePreview = function() {
	this.show = !this.show;
	if (this.show) {
		this.preButton.className = 'mob-chart-icon';
	} else {
		this.preButton.className = 'mob-preview-icon';
	}
	this.objects.preview.toggle(this.show);
	this.showCur();
};
LUTMobile.prototype.hideAll = function() {
	this.menuBox.className = 'mob-main-menu-hide';
	this.boxes.inf.className = 'shadowbox-mob-hide';
	this.boxes.lut.className = 'shadowbox-mob-hide';
	this.boxes.cam.className = 'shadowbox-mob-hide';
	this.boxes.gam.className = 'shadowbox-mob-hide';
	this.boxes.pre.className = 'shadowbox-hide';
	this.boxes.twk.className = 'shadowbox-mob-hide';
};
LUTMobile.prototype.desktopCur = function(opt) {
	this.cur = opt;
	switch (this.cur) {
		case 'inf':
			this.hideAll();
			this.objects.info.gammaInfoBut.className = 'base-button-hide-mob';
			this.objects.info.gammaChartBut.className = 'base-button-hide-mob';
			this.boxes.inf.className = 'shadowbox-mob';
			break;
		case 'set':
			this.hideAll();
			this.boxes.cam.className = 'shadowbox-mob';
			this.boxes.gam.className = 'shadowbox-mob';
			this.objects.info.gammaInfoBut.className = 'base-button';
			this.objects.info.gammaChartBut.className = 'base-button';
			if (this.show) {
				this.boxes.pre.className = 'shadowbox-mob';
				this.preButton.className = 'mob-chart-icon';
			} else {
				this.boxes.inf.className = 'shadowbox-mob';
				this.preButton.className = 'mob-preview-icon';
			}
			break;
	}	
};
LUTMobile.prototype.showCur = function() {
	switch (this.cur) {
		case 'main':
			this.menuBox.className = 'mob-main-menu';
			break;
		case 'twk':
			this.hideAll();
			this.boxes.twk.className = 'tweakbox';
			this.objects.info.gammaInfoBut.className = 'base-button';
			this.objects.info.gammaChartBut.className = 'base-button';
			this.objects.info.gammaChartOpt();
			if (this.show) {
				this.boxes.pre.className = 'shadowbox-mob';
				this.preButton.className = 'mob-chart-icon';
			} else {
				this.boxes.inf.className = 'shadowbox-mob';
				this.preButton.className = 'mob-preview-icon';
			}
			break;
		case 'inf':
			this.hideAll();
			this.objects.info.gammaInfoBut.className = 'base-button-hide-mob';
			this.objects.info.gammaChartBut.className = 'base-button-hide-mob';
			this.boxes.inf.className = 'shadowbox-mob';
			this.objects.info.instructionsOpt();
			break;
		case 'lut':
			this.hideAll();
			this.boxes.lut.className = 'shadowbox-mob';
			this.objects.info.gammaInfoBut.className = 'base-button';
			this.objects.info.gammaChartBut.className = 'base-button';
			this.preButton.className = 'mob-no-icon';
			this.objects.info.gammaChartOpt();
			break;
		case 'set':
			this.hideAll();
			this.boxes.cam.className = 'shadowbox-mob';
			this.boxes.gam.className = 'shadowbox-mob';
			this.objects.info.gammaInfoBut.className = 'base-button';
			this.objects.info.gammaChartBut.className = 'base-button';
			this.objects.info.gammaChartOpt();
			if (this.show) {
				this.boxes.pre.className = 'shadowbox-mob';
				this.preButton.className = 'mob-chart-icon';
			} else {
				this.boxes.inf.className = 'shadowbox-mob';
				this.preButton.className = 'mob-preview-icon';
			}
			break;
		default:
			this.hideAll();
			this.boxes[this.cur].className = 'shadowbox-mob';
			this.objects.info.gammaInfoBut.className = 'base-button';
			this.objects.info.gammaChartBut.className = 'base-button';
			this.objects.info.gammaChartOpt();
			if (this.show) {
				this.boxes.pre.className = 'shadowbox-mob';
			} else {
				this.boxes.inf.className = 'shadowbox-mob';
			}
	}
	maxHeights();
};
LUTMobile.prototype.updateUI = function() {
	this.showCur();
};
/* lutcalc.js
* Master Javascript file for the LUTCalc Web App.
* 7th October 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
// Loading progress bar
if (typeof splash !== 'undefined') {
	splashProg();
}
// Window resize adjustments
function maxHeights() {
	if (window.getComputedStyle(mobileBox).display === 'none') { // Wide screens
		var HF = parseInt(document.getElementById('titlebar').clientHeight) + parseInt(document.getElementById('footer').clientHeight);
		document.getElementById('instructions-box').style.height = '22em';
		document.getElementById('tweaksholder').style.height = 'auto';
		var VP = isNaN(window.innerHeight) ? window.clientHeight : window.innerHeight;
		var M = VP - HF - 12;
		var CG = parseInt(lutCameraBox.getHeight()) + parseInt(lutGammaBox.getHeight());
		var TWK = M - CG;
		lutTweaksBox.setMaxHeight(TWK);
		if (M < 420) {
			M = 420;
		}
		left.style.height = M.toString() + 'px';
		right.style.height = M.toString() + 'px';
	} else { // Narrow screens
		if (lutMobile && lutMobile.cur === 'inf') {
			left.style.height = 'auto';
			var VP = isNaN(window.innerHeight) ? window.clientHeight : window.innerHeight;
			var R = VP - left.clientHeight - document.getElementById('mob-status').clientHeight - 14;
			document.getElementById('instructions-box').style.height = (R-32).toString() + 'px';
			right.style.height = R.toString() + 'px';
		} else if (lutMobile && lutMobile.cur === 'twk') {
			right.style.height = 'auto';
			var VP = isNaN(window.innerHeight) ? window.clientHeight : window.innerHeight;
			var L = VP - right.clientHeight - document.getElementById('mob-status').clientHeight - 14;
			document.getElementById('tweaksholder').style.height = (L-16).toString() + 'px';
			left.style.height = L.toString() + 'px';
		} else {
			right.style.height = 'auto';
			var VP = isNaN(window.innerHeight) ? window.clientHeight : window.innerHeight;
			var L = VP - right.clientHeight - document.getElementById('mob-status').clientHeight - 14;
			left.style.height = L.toString() + 'px';
		}
	}
}
// Helper Functions
function lutcalcReady(p) {
	splashProg(9);
	if (lutInputs.isReady(p)) {
		clearInterval(splashInterval);
		if (window.getComputedStyle(mobileBox).display !== 'none') { // Mobile-specific CSS in use or external mobile test confirmed, assume that device is a mobile
			lutInputs.isMobile = true;
		}
		// Set Up Events
		lutFormats.events();
		lutCameraBox.events();
		lutGammaBox.events();
		lutTweaksBox.events();
		lutBox.events();
		lutGenerate.events();
		lutPreview.events();
		lutInfoBox.events();
		splash.style.display = 'none';
		document.getElementById('titlebar').className = 'titlebar';
		document.getElementById('lutcalcform').className = 'lutcalcform';
		document.getElementById('footer').className = 'footer';
		lutMobile = new LUTMobile(mobileBox, lutInputs, lutMessage, modalBox,{
			preview: lutPreview,
			generate: lutGenerate,
			info: lutInfoBox
		});
		lutMobile.events();
		window.onresize = function(){
			maxHeights();
		};
		window.onorientationchange = function(){
			maxHeights();
		};
		maxHeights();
		lutMessage.setReady();
		// Populate Settings
		lutMessage.gtSetParams();
		lutMessage.gaSetParams();
	}
}
function notifyUser(title,message) {
	if (lutInputs.canChromeNotify) {
		chrome.notifications.create(
			'lutcalc-' + Math.random().toString(),
			{
				type: 'basic',
				iconUrl: 'img/lutcalc-64.png',
				title: title,
				message: message,
				priority: 0
			},
			function(id) {
				timer = setTimeout(function(){
					chrome.notifications.clear(id);
				}, 2500);
			}
		);
	}
}
// DOM Functions
function fieldSet(parentElement,shadow,id) {
	var box = document.createElement('fieldset');
	if (id) {
		box.id = id;
	}
	if (shadow) {
		box.className = 'shadowbox';
	}
	parentElement.appendChild(box);
	return box;
}
function lutSlider(p, list) {
	// Collect all sliders in the DOM is requested
	if (typeof list !== 'undefined') {
		list.push(this);
	}
	// Set up the range
	this.min = 0;
	if (typeof p.min === 'number') {
		this.min = p.min;
	}
	this.max = 100;
	if (typeof p.max === 'number') {
		this.max = p.max;
	}
	this.val = 50;
	if (typeof p.value === 'number') {
		this.val = p.value;
	}
	this.def = this.val;
	// Build the slider
	this.element = document.createElement('div');
	// CSS Styling
	if (typeof p.style === 'string') {
		this.style = p.style;
	} else {
		this.style = 'slider';
	}
	this.v = false;
	if (typeof p.v === 'boolean' && p.v) {
		this.v = true;
		this.style += '-v';
	}
	this.element.className = this.style;
	// Slider title if defined
	if (typeof p.title === 'string') {
		var titleBox = document.createElement('div');
		titleBox.className = '_titlebox';
		this.element.appendChild(titleBox);
		this.title = document.createElement('span');
		this.title.innerHTML = p.title;
		titleBox.appendChild(this.title);
	}
	// Input Box limit to slider limit or not
	this.inputLim = true;
	if (typeof p.inputLim === 'boolean' && !p.inputLim) {
		this.inputLim = false;
	}
	// Input Box decimal places - default is 2, inputDP = false is unlimited
	this.inputDP = 10000;
	if (typeof p.inputDP === 'number' && parseInt(p.inputDP) >= 0) {
		this.inputDP = Math.pow(10,parseInt(p.inputDP));
	} else if (typeof p.inputDP === 'boolean' && !p.inputDP) {
		this.inputDP = false;
	}
	// Form Box - holds slider itself and inputs / labels to make horizontal / vertical easier
	this.formBox = document.createElement('div');
	this.formBox.className = '_formbox';
	this.element.appendChild(this.formBox);
	// Slider component
	this.sliderBox = document.createElement('div');
	this.sliderBox.className = '_sliderbox';
	this.formBox.appendChild(this.sliderBox);
	this.slider = document.createElement('input');
	this.slider.setAttribute('type','range');
	this.slider.className = '_slider';
	if (typeof p.step === 'number') {
		this.step = parseFloat(p.step);
	} else if (typeof p.step === 'string' && p.step.toLowerCase() === 'any') {
		this.step = 'any';
	} else {
		this.step = 1;
	}
	// Allow for logear (logarithmic) spread along the slider range
	if (typeof p.mid === 'number' && parseFloat(p.mid) !==  (this.min+this.max)/2) {
		this.mid = parseFloat(p.mid);
		this.log = true;
		this.a = ((this.min*this.min)-(2*this.min*this.mid)+(this.mid*this.mid))/(this.min-(2*this.mid)+this.max);
		this.b = Math.log(((this.max-this.min)/this.a)+1);
		this.c = this.min - this.a;
		this.slider.setAttribute('step','any');
		this.slider.setAttribute('min',0);
		this.slider.setAttribute('max',1);
		this.slider.setAttribute('value',Math.log((this.def-this.c)/this.a)/this.b);
		// Standard min / max / step values for a range slider
	} else {
		this.log = false;
		if (this.step) {
			this.slider.setAttribute('step',this.step);
		} else {
			this.slider.setAttribute('step','any');
		}
		this.slider.setAttribute('min',this.min);
		this.slider.setAttribute('max',this.max);
		this.slider.value = this.def;
	}
	// Rotatebox - to get around the annoying '-webkit-appearance: none' / -webkit-appearance: vertical slider' paradox
	var rotateBox = document.createElement('div');
	rotateBox.className = '_rotatebox';
	rotateBox.appendChild(this.slider);
	this.sliderBox.appendChild(rotateBox);
	// Labels and input box
	this.dataBox = document.createElement('div');
	this.dataBox.className = '_databox';
	this.formBox.appendChild(this.dataBox);
	var minSide = '';
	this.minSide = document.createElement('span');
	this.minSide.className = '_minside';
	if (typeof p.minLabel === 'string') {
		this.minSide.innerHTML = p.minLabel;
		minSide = p.minLabel;
	}
	var maxSide = '';
	this.maxSide = document.createElement('span');
	this.maxSide.className = '_maxside';
	if (typeof p.maxLabel === 'string') {
		this.maxSide.innerHTML = p.maxLabel;
		maxSide = p.maxLabel;
	}
	this.input = false;
	this.data = false;
	if (typeof p.input === 'string' || typeof p.reset !== 'undefined') {
		var inputBox = document.createElement('div');
		inputBox.className = '_inputbox';
		this.dataBox.appendChild(inputBox);
		if (typeof p.lhs === 'string') {
			var lhs = document.createElement('label');
			lhs.className = '_lhs';
			lhs.innerHTML = p.lhs;
			inputBox.appendChild(lhs);
		} else if (typeof p.lhs !== 'undefined' && typeof p.lhs !== 'boolean') {
			p.lhs.className = '_lhs';
			inputBox.appendChild(p.lhs);
		}
		// Number input - must be numeric and glows red if not in 'step'
		if (p.input === 'number') {
			this.input = document.createElement('input');
			this.input.className = '_input';
			this.input.setAttribute('type','number');
			if (this.step) {
				this.input.setAttribute('step',this.step);
			} else {
				this.input.setAttribute('step','any');
			}
			this.input.value = this.def;
			inputBox.appendChild(this.input);
		} else if (p.input === 'text') {
		// Text input - anything goes, so relies on lutSlider's bounds checking
			this.input = document.createElement('input');
			this.input.className = '_input';
			this.input.setAttribute('type','text');
			this.input.value = this.def.toString();
			inputBox.appendChild(this.input);
		} else if (p.input === 'label') {
		// Label - not an input, but displays a numeric value for the slider position
			this.data = document.createElement('span');
			this.data.className = '_datalabel';
			// Text can be added for negative values, positive values and zero
			this.dataFormat = [ '-[[VALUE]]', '0', '[[VALUE]]' ];
			if (typeof p.dataFormat !== 'undefined') {
				if (typeof p.dataFormat.neg === 'string') {
					this.dataFormat[0] = p.dataFormat.neg;
				}
				if (typeof p.dataFormat.zero === 'string') {
					this.dataFormat[1] = p.dataFormat.zero;
				}
				if (typeof p.dataFormat.pos === 'string') {
					this.dataFormat[2] = p.dataFormat.pos;
				}
			}
			this.setData(parseFloat(this.def));
			inputBox.appendChild(this.data);
		}
		if (typeof p.rhs === 'string') {
			var rhs = document.createElement('label');
			rhs.className = '_rhs';
			rhs.innerHTML = p.rhs;
			inputBox.appendChild(rhs);
		} else if (typeof p.rhs !== 'undefined' && typeof p.rhs !== 'boolean') {
			p.rhs.className = '_rhs';
			inputBox.appendChild(p.rhs);
		}
		this.resetButton = false;
		if (typeof p.reset === 'string') {
			this.resetButton = document.createElement('input');
			this.resetButton.setAttribute('type','button');
			this.resetButton.className = '_reset';
			this.resetButton.value = p.reset;
			inputBox.appendChild(this.resetButton);
		} else if (typeof p.reset === 'boolean' && p.reset) {
			this.resetButton = document.createElement('input');
			this.resetButton.setAttribute('type','button');
			this.resetButton.className = '_reset';
			this.resetButton.value = 'Reset';
			inputBox.appendChild(this.resetButton);
		}
		this.resetAllButton = false;
		if (typeof p.resetAll === 'string') {
			this.resetAllButton = document.createElement('input');
			this.resetAllButton.setAttribute('type','button');
			this.resetAllButton.className = '_reset';
			this.resetAllButton.value = p.reset;
			inputBox.appendChild(this.resetAllButton);
		} else if (typeof p.resetAll === 'boolean' && p.resetAll) {
			this.resetAllButton = document.createElement('input');
			this.resetAllButton.setAttribute('type','button');
			this.resetAllButton.className = '_reset';
			this.resetAllButton.value = 'Reset All';
			inputBox.appendChild(this.resetAllButton);
		}
	} else {
		var input = document.createElement('span');
		input.className = '_noinput';
		input.innerHTML = (minSide.length > maxSide.length) ? minSide : maxSide;
		this.dataBox.appendChild(input);
	}
	this.dataBox.appendChild(this.minSide);
	this.dataBox.appendChild(this.maxSide);
	// Set up events
	this.events();
};
lutSlider.prototype.events = function() {
	if (this.log) {
		this.slider.addEventListener('input', function(here){ return function(e){
			e.stopImmediatePropagation();
			e.stopPropagation();
			here.testNLData(true);
			here.action();
		};}(this), false);
		this.slider.addEventListener('change', function(here){ return function(e){
			e.stopImmediatePropagation();
			e.stopPropagation();
			here.testNLData(true);
			here.action();
		};}(this), false);
		if (this.input) {
			this.input.addEventListener('change', function(here){ return function(e){
				e.stopImmediatePropagation();
				e.stopPropagation();
				here.testNLData(false);
				here.action();
			};}(this), false);
		}
	} else {
		this.slider.addEventListener('input', function(here){ return function(e){
			e.stopImmediatePropagation();
			e.stopPropagation();
			here.testData(true);
			here.action();
		};}(this), false);
		this.slider.addEventListener('change', function(here){ return function(e){
			e.stopImmediatePropagation();
			e.stopPropagation();
			here.testData(true);
			here.action();
		};}(this), false);
		if (this.input) {
			this.input.addEventListener('change', function(here){ return function(e){
				e.stopImmediatePropagation();
				e.stopPropagation();
				here.testData(false);
				here.action();
			};}(this), false);
		}
	}
	if (this.resetButton) {
		this.resetButton.onclick = function(here){ return function(){
			here.reset();
			here.action();
		};}(this);
	}
	if (this.resetAllButton) {
		this.resetAllButton.onclick = function(here){ return function(){
			here.resetAll();
		};}(this);
	}
};
lutSlider.prototype.testData = function(slider) {
	var val;
	if (slider) {
		if (this.input || this.data) {
			val = parseFloat(this.slider.value);
			if (this.inputDP === 1) {
				val = Math.round(val);
			} else if (this.inputDP > 1) {
				val = Math.round(val*this.inputDP)/this.inputDP;
			}
			if (this.input) {
				this.input.value = val;
			} else {
				this.setData(val);
			}
		}
	} else {
		val = parseFloat(this.input.value);
		if (isNaN(val)) {
			val = parseFloat(this.slider.value);
		} else if (val < this.min) {
			val = this.min;
		} else if (this.inputLim && val > this.max) {
			val = this.max;
		} else {
			if (this.step) {
				val = (Math.round((val-this.min)/this.step)*this.step)+this.min;
			}
			if (this.inputDP === 1) {
				val = Math.round(val);
			} else if (this.inputDP > 1) {
				val = Math.round(val*this.inputDP)/this.inputDP;
			}
		}
		this.input.value = val;
		this.slider.value = val;
	}
};
lutSlider.prototype.testNLData = function(slider) {
	var val;
	if (slider) {
		val = (this.a*Math.exp(this.b*parseFloat(this.slider.value)))+this.c;
		if (this.step) {
			var s = (Math.round((val-this.min)/this.step)*this.step)+this.min;
			if (val !== s) {
				this.slider.value = Math.log((s-this.c)/this.a)/this.b;
			}
			val = s;
		}
		if (this.input || this.data) {
			if (this.inputDP === 1) {
				val = Math.round(val);
			} else if (this.inputDP > 1) {
				val = Math.round(val*this.inputDP)/this.inputDP;
			}
			if (this.input) {
				this.input.value = val;
			} else {
				this.setData(val);
			}
		}
	} else {
		val = parseFloat(this.input.value);
		if (isNaN(val)) {
			val = (this.a*Math.exp(this.b*parseFloat(this.slider.value)))+this.c;
		} else if (val < this.min) {
			val = this.min;
		} else if (this.inputLim && val > this.max) {
			val = this.max;
		} else {
			if (this.step) {
				val = (Math.round((val-this.min)/this.step)*this.step)+this.min;
			}
			if (this.inputDP === 1) {
				val = Math.round(val);
			} else if (this.inputDP > 1) {
				val = Math.round(val*this.inputDP)/this.inputDP;
			}
		}
		this.input.value = val;
		this.slider.value = Math.log((val-this.c)/this.a)/this.b;
	}
};
lutSlider.prototype.setMobile = function(isMob) {
	if (isMob) {
		this.element.className = this.style + '-mob';
	} else {
		this.element.className = this.style;
	}
};
lutSlider.prototype.setData = function(val) {
	val = parseFloat(val);
	if (val < 0) {
		this.data.innerHTML = this.dataFormat[0].replace('[[VALUE]]',Math.abs(val));
	} else if (val > 0) {
		this.data.innerHTML = this.dataFormat[2].replace('[[VALUE]]',Math.abs(val));
	} else {
		this.data.innerHTML = this.dataFormat[1];
	}
};
lutSlider.prototype.getValue = function() {
	if (this.input) {
		return parseFloat(this.input.value);
	} else {
		var val;
		if (this.log) {
			return (this.a*Math.exp(this.b*parseFloat(this.slider.value)))+this.c;
		} else {
			return parseFloat(this.slider.value);
		}
	}
};
lutSlider.prototype.setValue = function(val) {
	if (!isNaN(val)) {
		if (this.input) {
			this.input.value = parseFloat(val);
			if (this.log) {
				this.testNLData(false);
			} else {
				this.testData(false);
			}
		} else {
			if (this.log) {
				this.slider.value = Math.log((parseFloat(val)-this.c)/this.a)/this.b;
				this.testNLData(true);
			} else {
				this.slider.value = parseFloat(val);
				this.testData(true);
			}
		}
	}
};
lutSlider.prototype.setMax = function(val) {
	if (!isNaN(val)) {
		this.max = parseFloat(val);
		if (this.log) {
			this.a = ((this.min*this.min)-(2*this.min*this.mid)+(this.mid*this.mid))/(this.min-(2*this.mid)+this.max);
			this.b = Math.log(((this.max-this.min)/this.a)+1);
			this.c = this.min - this.a;
		} else {
			this.slider.setAttribute('max',this.max);
		}
		if (this.input) {
			if (this.log) {
				this.testNLData(false);
			} else {
				this.testData(false);
			}
		} else {
			if (this.log) {
				if ((this.a*Math.exp(this.b*parseFloat(this.slider.value)))+this.c > this.max) {
					this.slider.value = 1;
				}
				this.testNLData(true);
			} else {
				if (parseFloat(this.slider.value) > this.max) {
					this.slider.value = this.max;
				}
				this.testData(true);
			}
		}
	}
};
lutSlider.prototype.reset = function() {
	if (this.input) {
		this.input.value = this.def;
		if (this.log) {
			this.testNLData(false);
		} else {
			this.testData(false);
		}
	} else {
		if (this.log) {
			this.slider.value = Math.log((parseFloat(this.def)-this.c)/this.a)/this.b;
			this.testNLData(true);
		} else {
			this.slider.value = parseFloat(this.def);
			this.testData(true);
		}
	}
};
lutSlider.prototype.show = function() {
	this.element.className = this.style;
};
lutSlider.prototype.hide = function() {
	this.element.className = this.style + '-hide';
};
lutSlider.prototype.resetAll = function() {
	// empty function to be replaced with whatever item-specific action is required.
};
lutSlider.prototype.action = function() {
	// empty function to be replaced with whatever item-specific action is required post bounds-checking.
};
function lutRadioElement(name, checked) {
    var radioInput;
    try {
        var radioHtml = '<input type="radio" name="' + name + '"';
        if ( checked ) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += '/>';
        radioInput = document.createElement(radioHtml);
    } catch( err ) {
        radioInput = document.createElement('input');
        radioInput.setAttribute('type', 'radio');
        radioInput.setAttribute('name', name);
        if ( checked ) {
            radioInput.setAttribute('checked', 'checked');
        }
    }
    return radioInput;
};

// Declare variables
var lutCalcForm,
	mobileBox,
	lutMessage,
	lutFile,
	left,
	lutCameraBox,
	lutTweaksBox,
	right,
	lutPreview,
	lutBox,
	lutGenerate,
	lutInfoBox,
	lutMobile;
// Build app once the DOM is loaded
document.addEventListener("DOMContentLoaded", function() { // setTimeout gives time for asynchronous browser tests to finish (eg inline web workers)
	// Housekeeping
	lutCalcForm = document.getElementById('lutcalcform');
	// Build UI
	lutMessage = new LUTMessage(lutInputs);
	lutTests.isTransTest(lutMessage.getWorker());
	lutFile = new LUTFile(lutInputs, lutMessage);
	lutFormats = new LUTFormats(lutInputs, lutMessage, lutFile);
	document.getElementById('version').appendChild(document.createTextNode(lutInputs.version));
	// Create HTML Structure
	document.getElementById('main').className = 'base-main';
	document.getElementById('main').appendChild(modalBox);
	modalBox.className = 'modalbox';
	mobileBox = fieldSet(lutCalcForm,false,'mob-box');
	right = fieldSet(lutCalcForm,false,'right');
	right.className = 'right-base';
	left = fieldSet(lutCalcForm,false,'left');
	left.className = 'left-base';
	lutCameraBox = new LUTCameraBox(fieldSet(left,true,'box-cam'), lutInputs, lutMessage);
	lutGammaBox = new LUTGammaBox(fieldSet(left,true,'box-gam'), lutInputs, lutMessage);
	lutTweaksBox = new LUTTweaksBox(fieldSet(left,true,'box-twk'), lutInputs, lutMessage, lutFile, lutFormats);
	lutBox = new LUTLutBox(fieldSet(right,true,'box-lut'), lutInputs, lutMessage, lutFormats);
	lutGenerate = new LUTGenerateBox(fieldSet(right,false,'box-gen'), lutInputs, lutMessage, lutFile, lutFormats);
	lutPreview = new LUTPreview(fieldSet(right,true,'box-pre'), lutInputs, lutMessage, lutFile);
	lutPreview.uiExternal(lutGenerate.getBox());
	lutInfoBox = new LUTInfoBox(fieldSet(right,true,'box-inf'),lutInputs, lutMessage);
	// Set Up Data
	lutMessage.gaTx(0,5,{});
	lutMessage.gtTx(0,5,{});
	lutMessage.gtTx(0,11,{});
	lutGammaBox.oneOrThree();
});
