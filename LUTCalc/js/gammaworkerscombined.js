/* gamma.js
* Transfer functions (gamma) web worker object for the LUTCalc Web App.
* 27th June 2015
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTGamma() {
	this.lutMaker = new LUTs();
	this.nul = false;
	this.gammas = [];
	this.isTrans = false;
	this.ver = 0;
	this.curIn = 0;
	this.curOut = 0;
	this.eiMult = 1;
	this.stopShift = 0;
	this.inL = false;
	this.outL = true;
	this.clip = true;
	this.clipB = true;
	this.clipW = false;
	this.clipL = true;
	
	this.sIn = false;
	this.sMin = 0;
	this.sMax = 1;

	this.bClip = 0;
	this.mClip = 67025937;

	this.linList = [];
	this.inList = [];	
	this.outList = [];
	this.disList = [];
	this.catList = [];
	this.subNames = [];
	this.gammaSub = [];
	this.gammaDat = [];
	this.gammaExt = [];

	this.kSmooth = 1;

	this.doBlkHi = false;
	this.doASCCDL = false;
	this.doBlkGam = false;
	this.doDisplay = false;
	
	this.blkGamLStop = -1.5;
	this.blkGamFStop = 2;
	this.blkGamUL = 0.1;
	this.blkGamLL = 0.09;
	this.blkGamF = this.blkGamUL-this.blkGamLL;
	this.blkGamP = 1;
	this.blkGamR = 0.1;

	this.gts = [];
	this.disGts = [];
	this.disM = new Float64Array([1,0,0, 0,1,0, 0,0,1]);
	this.disInM = [];
	this.disOutM = [];
	this.displayCSMatrices();
	this.dispInGt = 0;
	this.dispOutGt = 0;

	this.camClip = 11.52;

	this.hdrOut = false;

	this.al = 1;
	this.bl = 0;
	this.ad = 1;
	this.bd = 0;
	this.highRef = 0.9;
	this.asc = new Float64Array([
		1,1,1,	// s - Slope / Gain
		0,0,0,	// o - Offset / Lift
		1,1,1,	// p - Power / Gamma
		1		// sat - Saturation
	]);
	this.gammaList();
}
// Prepare transfer functions
LUTGamma.prototype.subIdx = function(cat) {
	switch (cat) {
		case 'Sony': return 0;
		case 'ARRI': return 1;
		case 'Canon': return 2;
		case 'Apple': return 3;
		case 'Panasonic': return 4;
		case 'RED': return 5;
		case 'GoPro': return 6;
		case 'Panavision': return 7;
		case 'Blackmagic': return 8;
		case 'Bolex': return 9;
		case 'Fujifilm': return 10;
		case 'Nikon': return 11;
		case 'DJI': return 12;
		case 'Log': return 13;
		case 'Display': return 14;
		case 'HDR Display': return 15;
		case 'Linear / γ': return 16;
	}
	return false;
};
LUTGamma.prototype.gammaList = function() {
	this.subNames = [	'Sony',
						'ARRI',
						'Canon',
						'Apple',
						'Panasonic',
						'RED',
						'GoPro',
						'Panavision',
						'Blackmagic',
						'Bolex',
						'Fujifilm',
						'Nikon',
						'DJI',
						'Log',
						'Display',
						'HDR Display',
						'Linear / γ',
						'All'
	];
	this.SL3Idx = 0;
	this.gammas.push(new LUTGammaLog(
		'S-Log3', [ 0.1677922920,-0.0155818840, 0.2556207230, 4.7368421060,10.0000000000, 0.4105571850, 0.0526315790, 0.1673609920, 0.0125000000 ]));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Log')]);
	this.gts.push('Sony S-Gamut3.cine');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'S-Log2', [ 0.330000000129966,-0.0291229262672453,0.3705223107287920,0.7077625570776260,10,0.6162444730868150,0.0375840001141552,0.0879765396,0 ]));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Log')]);
	this.gts.push('Sony S-Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'S-Log', [ 0.3241960136,-0.0286107171, 0.3705223110, 1,10.0000000000, 0.6162444740, 0.0375840000, 0.0882900450, 0.000000000000001 ]));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Log')]);
	this.gts.push('Sony S-Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);

/*
	this.gammas.push(new LUTGammaLog2('LOGCalc Scaler', 7.46633, -0.0411526));
	this.gammaSub.push(this.subIdx(['Log']));
	this.gts.push('Sony S-Gamut3.cine');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
*/
	this.arriIdxList = [this.gammas.length];
	this.gammas.push(new LUTGammaLogC4(
		'LogC4'));
	this.gammaSub.push([this.subIdx('ARRI'),this.subIdx('Log')]);
	this.gts.push('ARRI Wide Gamut 4');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	
	this.arriIdxList.push(this.gammas.length);
	this.gammas.push(new LUTGammaArri(
		'LogC (Sup 3.x & 4.x)',3));
	this.gammaSub.push([this.subIdx('ARRI'),this.subIdx('Log')]);
	this.gts.push('Alexa Wide Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaArri(
		'LogC (Sup 2.x)',2));
	this.gammaSub.push([this.subIdx('ARRI'),this.subIdx('Log')]);
	this.gts.push('Alexa Wide Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Canon C-Log2', [ 0.045164984,-0.006747091156,0.241360772,87.09937546,10,0.092864125,1,0,-0.006747091156 ]));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Log')]);
	this.gts.push('Canon Cinema Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaCLog3(
		'Canon C-Log3'));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Log')]);
	this.gts.push('Canon Cinema Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'C-Log', [ 0.3734467748,-0.0467265867, 0.45310179472141, 10.1596, 10, 0.1251224801564, 1, 0.00391002619746, -0.0452664 ]));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Log')]);
	this.gts.push('Rec709');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaAppleLog(
		'Apple Log'));
	this.gammaSub.push([this.subIdx('Apple'),this.subIdx('Log')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(true);
	this.gammaExt.push(true);

	this.gammas.push(new LUTGammaCineon(
		'Cineon', {cv:1023, bp:95, wp: 685, nGamma: 0.6, cv2d:0.002}));
	this.gammaSub.push([this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Panasonic V-Log', [ 0.198412698,-0.024801587, 0.241514, 0.9, 10, 0.598206, 0.00873, 0.181, 0.009 ]));
	this.gammaSub.push([this.subIdx('Panasonic'),this.subIdx('Log')]);
	this.gts.push('Panasonic V-Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Fujifilm F-Log2', [ 0.12627036, -0.011725971, 0.245281, 5.0000004, 10, 0.384316, 0.064829, 0.100686685, 0.000987778 ]));
	this.gammaSub.push([this.subIdx('Fujifilm'),this.subIdx('Log')]);
	this.gts.push('Fujifilm F-Log Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Fujifilm F-Log', [ 0.1144737, -0.010630486, 0.344676, 0.5000004, 10, 0.790453, 0.009468, 0.100537775, 0.000988889 ]));
	this.gammaSub.push([this.subIdx('Fujifilm'),this.subIdx('Log')]);
	this.gts.push('Fujifilm F-Log Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaCineon(
		'REDLogFilm', {cv:1023, bp:95, wp: 685, nGamma: 0.6, cv2d:0.002}));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLogLog(
		'RED Log3G10', [ 0.224282,155.975327,0.01 ]));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);

	this.gammas.push(new LUTGammaLog(
		'BMDFilm Gen5', [ 0.156642493, -0.022202504, 0.074437531, 0.9, 2.718281828, 0.516414159, 0.005494072, 0.177206446, 0.005555556 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('Blackmagic Wide Gamut');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaDaVinci('DaVinci Intermediate'));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('DaVinci Wide Gamut');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaLog(
		'BMD Pocket Film', [ 0.195367159 / 0.9, -0.014273567 / 0.9, 0.36274758, 1.05345192 * 0.9, 10, 0.63659829, 0.027616437, 0.096214896, 0.004523664 * 0.9 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'BMD Film', [ 0.261115778 * 0.9, -0.024248528 * 0.9, 0.367608577, 0.86786483 / 0.9, 10, 0.644065346, 0.03135747, 0.114002127, 0.005519226 / 0.9 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'BMD Film4k', [ 0.37237694 * 0.9, -0.034580801 * 0.9, 0.582240088, 2.617961052 / 0.9, 10, 0.461883884, 0.231964429, 0.10772883, 0.005534931 / 0.9 ]));
//		'BMD Film4k', [ 0.37237694, -0.034580801, 0.582240088, 2.617961052, 10, 0.461883884, 0.231964429, 0.10772883, 0.005534931 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
/*
	this.gammas.push(new LUTGammaLog(
		'BMD Film4.6k', [ 0.195367159, -0.014273567, 0.36274758, 1.05345192, 10, 0.63659829, 0.027616437, 0.096214896, 0.004523664 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
*/
	this.gammas.push(new LUTGammaLog(
		'BMD Film4.6k', [ 0.195367159 / 0.9, -0.014273567 / 0.9, 0.36274758, 1.05345192 * 0.9, 10, 0.63659829, 0.027616437, 0.096214896, 0.004523664 * 0.9 ]));
	this.gammaSub.push([this.subIdx('Blackmagic'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Bolex Log', [ 1/(5.9861078*0.9), -0.0625265/(0.9*5.9861078), 0.2756705, 5, 10, 0.4150634, 0.0280665, 0.1520070, 0.014948/0.9 ]));
	this.gammaSub.push([this.subIdx('Bolex'),this.subIdx('Log')]);
	this.gts.push('Bolex Wide Gamut');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Panalog', [ 0.324196014, -0.020278938, 0.434198361, 0.956463747, 10, 0.665276427, 0.040913561, 0.088290045, 0 ]));
	this.gammaSub.push([this.subIdx('Panavision'),this.subIdx('Log')]);
	this.gts.push('Rec709');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLog(
		'Protune', [ 0,0, 876/1023, 53.39427221, 113, 64/1023, 1, 0, 0 ]));
	this.gammaSub.push([this.subIdx('GoPro'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaLog(
		'DJI X5/X7/X9 DLog', [ 1/(6.025*0.9), -0.0929/(6.025*0.9), 0.256663, 0.9892 * 0.9, 10, 0.584555, 0.0108, 0.14, 0.0078 * 0.9 ]));
	this.gammaSub.push([this.subIdx('DJI'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.DLogM = this.gammas.length;
	this.gammas.push(new LUTGammaDLog('DJI DLog-M'));
	this.gammaSub.push([this.subIdx('DJI'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaLogClip(
		'DJI X3 DLog', [ 0.188272019, -0.011778504, 0.473218054, 6.086793376, 10, 0.419294419, 0.169033387, 0.095812746, 0.00625, 0.902863937, 1.59668525, 22.90700861, -17.39462704 ]));
	this.gammaSub.push([this.subIdx('DJI'),this.subIdx('Log')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaIOLUT(
		'DJI Mini 2',
		{
			rec: {
				lut: new Float64Array([
					0.02513830, 0.03474122, 0.04434413, 0.05394705, 0.06354996, 0.07315288, 0.08274788, 0.09241272,
					0.10271576, 0.11311513, 0.12351429, 0.13391345, 0.14431261, 0.15471177, 0.16513320, 0.17361913,
					0.18110689, 0.18812930, 0.19473345, 0.20096606, 0.20686704, 0.21247143, 0.21780622, 0.22289498,
					0.22776349, 0.23220360, 0.23715250, 0.24470811, 0.25063847, 0.25650566, 0.26230818, 0.26802904,
					0.27366776, 0.27922389, 0.28469820, 0.29009155, 0.29540394, 0.30063666, 0.30579119, 0.31086787,
					0.31586840, 0.32079436, 0.32564634, 0.33042651, 0.33513583, 0.33977568, 0.34434806, 0.34885353,
					0.35329444, 0.35767138, 0.36198634, 0.36624039, 0.37043494, 0.37457151, 0.37865104, 0.38267530,
					0.38664498, 0.39056190, 0.39442666, 0.39824102, 0.40200558, 0.40572187, 0.40939073, 0.41301326,
					0.41659065, 0.42012350, 0.42361340, 0.42706051, 0.43046663, 0.43383182, 0.43715761, 0.44044453,
					0.44369326, 0.44690512, 0.45008015, 0.45321988, 0.45632454, 0.45939486, 0.46243198, 0.46543587,
					0.46840787, 0.47134835, 0.47422700, 0.47702901, 0.47995529, 0.48316779, 0.48666135, 0.49065065,
					0.49522288, 0.49965819, 0.50408629, 0.50851850, 0.51295463, 0.51739460, 0.52183816, 0.52628528,
					0.53073572, 0.53518944, 0.53964626, 0.54410607, 0.54856878, 0.55303423, 0.55750237, 0.56197304,
					0.56644619, 0.57092168, 0.57539945, 0.57987941, 0.58436144, 0.58884551, 0.59333149, 0.59781936,
					0.60230899, 0.60680034, 0.61129335, 0.61578793, 0.62028405, 0.62478161, 0.62928058, 0.63378090,
					0.63828252, 0.64278538, 0.64728943, 0.65179464, 0.65630094, 0.66080831, 0.66531669, 0.66982604
				])
			},
			out: {
				lut: new Float64Array([
					-0.020612427,-0.014156041,-0.007699656,-0.00124327, 0.005213115, 0.011669500, 0.018125886, 0.024582271,
					0.031038657, 0.037495042, 0.043951427, 0.050407813, 0.056762235, 0.062724266, 0.068686298, 0.074648329,
					0.080610361, 0.086572392, 0.092534424, 0.098496455, 0.104458487, 0.110420518, 0.117722628, 0.125979289,
					0.134842844, 0.144357903, 0.154572353, 0.165537602, 0.177308837, 0.189945300, 0.203510588, 0.211860347,
					0.222265361, 0.232860935, 0.243661342, 0.254680420, 0.265931684, 0.277428413, 0.289183731, 0.301210667,
					0.313522213, 0.326131374, 0.339051208, 0.352294865, 0.365875622, 0.379806912, 0.394102353, 0.408775777,
					0.423841250, 0.439313096, 0.455205924, 0.471534640, 0.488314476, 0.505561005, 0.523290160, 0.541518256,
					0.560262004, 0.579538537, 0.599365420, 0.619760673, 0.640742792, 0.662330762, 0.680356837, 0.694388877,
					0.708396075, 0.722380208, 0.736342926, 0.750285754, 0.764210104, 0.778117286, 0.792008513, 0.805884910,
					0.819747522, 0.833597316, 0.847435193, 0.861261986, 0.875078470, 0.888885365, 0.902683339, 0.916473014,
					0.930254967, 0.944029734, 0.957797814, 0.971559671, 0.985315736, 0.999066410, 1.012812066, 1.026553051,
					1.040289687, 1.054022275, 1.067751094, 1.081476404, 1.095198446, 1.108917447, 1.122633615, 1.136347145,
					1.150058220, 1.163767007, 1.177473664, 1.191178339, 1.204881166, 1.218582273, 1.232281778, 1.245979791,
					1.259676414, 1.273371744, 1.287065868, 1.300758869, 1.314450825, 1.328141808, 1.341831883, 1.355521113,
					1.369209557, 1.382897268, 1.396584296, 1.410270688, 1.423956488, 1.437641737, 1.451326471, 1.465010727,
					1.478694537, 1.492377932, 1.506060940, 1.519743588, 1.533425900, 1.547107899, 1.560789607, 1.574471044
				])
			}
		}));
	this.gammaSub.push([this.subIdx('DJI'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);


	this.gammas.push(new LUTGammaACEScc(
		'ACEScc', {}));
	this.gammaSub.push([this.subIdx('Log')]);
	this.gts.push('ACES AP0');
	this.gammaDat.push(true);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaACESProxy(
		'ACESproxy10', 10));
	this.gammaSub.push([this.subIdx('Log')]);
	this.gts.push('ACEScg AP1');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaACESProxy(
		'ACESproxy12', 12));
	this.gammaSub.push([this.subIdx('Log')]);
	this.gts.push('ACEScg AP1');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'Amira709',
		new Float64Array(
				[ 0.0629449254, 0.0638344316, 0.0652122451, 0.0671149365, 0.0696389939, 0.0727578155, 0.0765583221, 0.0810732533,
				  0.0863050714, 0.0923235097, 0.0991202854, 0.1071573521, 0.1173890946, 0.1289127766, 0.1418248775, 0.1563577288,
				  0.1727759907, 0.1909101927, 0.2109039553, 0.2321740755, 0.2540878735, 0.2767513785, 0.3000392795, 0.3239141187,
				  0.3482661335, 0.3730445064, 0.3981118279, 0.4233801358, 0.4484330041, 0.4733441630, 0.4980799790, 0.5226516916,
				  0.5470832745, 0.5713748957, 0.5955474508, 0.6196006037, 0.6435589843, 0.6674248274, 0.6912186286, 0.7150335873,
				  0.7380830785, 0.7604458639, 0.7808803039, 0.7989996910, 0.8151693266, 0.8293147178, 0.8419315718, 0.8532432154,
				  0.8632844800, 0.8721146308, 0.8798286573, 0.8865081114, 0.8922250204, 0.8970825043, 0.9011319655, 0.9044962896,
				  0.9072088251, 0.9094085307, 0.9111140581, 0.9124771261, 0.9135050778, 0.9143603587, 0.9150416855, 0.9157172449,
				  0.9163807382 ]
		)
	));
	this.gammaSub.push([this.subIdx('ARRI'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'Alexa-X-2',
		new Float64Array(
				[ 0.0591392525, 0.0597741050, 0.0612907229, 0.0636891061, 0.0670061726, 0.0713627697, 0.0766277967, 0.0826389777,
				  0.0892340370, 0.0962854910, 0.1039625761, 0.1129939936, 0.1252220091, 0.1381401480, 0.1513807635, 0.1651563807,
				  0.1799534361, 0.1962251040, 0.2139885968, 0.2330129188, 0.2532175057, 0.2745268479, 0.2973340978, 0.3215684734,
				  0.3464667648, 0.3712822467, 0.3957529493, 0.4204032336, 0.4450817523, 0.4696146868, 0.4938866713, 0.5180413154,
				  0.5420558969, 0.5658776148, 0.5894644299, 0.6129189039, 0.6361895435, 0.6591598802, 0.6817136956, 0.7042566286,
				  0.7267405614, 0.7484349074, 0.7686102390, 0.7868717883, 0.8037179215, 0.8191567127, 0.8331581208, 0.8456621871,
				  0.8565103390, 0.8659197184, 0.8741749179, 0.8815532343, 0.8878611055, 0.8930654735, 0.8974118356, 0.9011455804,
				  0.9042495877, 0.9065156533, 0.9082180048, 0.9096408106, 0.9109571560, 0.9118628170, 0.9125228715, 0.9131824676,
				  0.9140666658 ]
		)
	));
	this.gammaSub.push([this.subIdx('ARRI'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaIOLUT(
		's709',
		{
			rec: {
				lut: new Float64Array([
					-0.128429281, -0.087857693, -0.047286105, -0.006714517, 0.033857071, 0.074428659, 0.109404416, 0.142251149,
					0.169103206, 0.191383375, 0.211313326, 0.22941725, 0.246207651, 0.261136216, 0.27457494, 0.286937936,
					0.298350035, 0.309228929, 0.319721904, 0.329938595, 0.339920481, 0.349708889, 0.35935577, 0.368893896,
					0.378339425, 0.387726702, 0.39709087, 0.406494373, 0.415959965, 0.425504727, 0.435091864, 0.444721031,
					0.454388469, 0.464097425, 0.473848584, 0.483636782, 0.493448049, 0.503261998, 0.5130866, 0.522936843,
					0.532878688, 0.542918355, 0.553067402, 0.56328643, 0.57360374, 0.58404873, 0.594627852, 0.605423139,
					0.61654015, 0.6284926, 0.64151266, 0.6558432, 0.671742369, 0.689757007, 0.710737854, 0.736194343,
					0.770900272, 0.831346604, 1.079267818, 2.077062181, 3.074856545, 4.072650908, 5.070445272, 6.068239635
				])
			},
			out: {
				lut: new Float64Array([
					0.05040000, 0.05652381, 0.06269047, 0.06866184, 0.07493765, 0.08147611, 0.08894732, 0.09601165,
					0.10345157, 0.11143212, 0.12031592, 0.13072851, 0.14217459, 0.1545754, 0.16823161, 0.18258277,
					0.19847487, 0.21647519, 0.23646249, 0.25861883, 0.28225966, 0.30694373, 0.33251343, 0.35871242,
					0.38535787, 0.41224989, 0.43899291, 0.46540198, 0.49160841, 0.51763835, 0.54348663, 0.5691883,
					0.59485339, 0.62044621, 0.64569807, 0.67053983, 0.69508328, 0.71918342, 0.74276274, 0.76534268,
					0.78580574, 0.80409842, 0.8205254, 0.83516611, 0.84814976, 0.85956961, 0.86957328, 0.8781925,
					0.88538127, 0.89133381, 0.89630257, 0.90038219, 0.9036953, 0.90632778, 0.90827715, 0.90984446,
					0.91135117, 0.91290709, 0.91514511, 0.917036, 0.91794384, 0.91884742, 0.91911605, 0.91937392
				])
			}
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);


	this.gammas.push(new LUTGammaLUTSL3(
		'LC709A',
		new Float64Array(
				[ 0.0690751760484848,0.0728297103786901,0.0769850051182796,0.0815808343707722,0.0864978758256109,0.0915715413065494,0.0969774025141740,0.1028781916478983,
				  0.1091478390349951,0.1155131300480449,0.1225782317505376,0.1309263253436461,0.1403471537869012,0.1508689079248778,0.1623594253036168,0.1746108013986315,
				  0.1878784532660801,0.2022370183965786,0.2180209309622678,0.2356278321531769,0.2549427384062561,0.2761380900003911,0.2987492565998045,0.3224798721943793,
				  0.3469975840860214,0.3719286248248777,0.3971008726561094,0.4222027128650537,0.4472788568813294,0.4722718767181329,0.4971765759100684,0.5219774783500978,
				  0.5466479949763440,0.5711842754669599,0.5955026274948191,0.6197116512439393,0.6432306188590422,0.6651852019544967,0.6865648023053763,0.7082626223616812,
				  0.7296929317130010,0.7507956301978983,0.7708870295194525,0.7891859348525904,0.8059247656203324,0.8210325331867545,0.8346382669036169,0.8468258306587488,
				  0.8576597322080157,0.8672077039163734,0.8755439358443793,0.8827308391279569,0.8888714829059629,0.8940610364006844,0.8983856104977517,0.9019299878681326,
				  0.9047933223781036,0.9070732102109482,0.9088591070866080,0.9102383165201858,0.9113148913094820,0.9121898344043498,0.9129595988637339,0.9137217752193059,
				  0.9145739540027369 ]
		)
	));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'LC709',
		new Float64Array(
				[ 0.0681458330432062,0.0691434801575758,0.0705829599217986,0.0724372206445259,0.0747874173998045,0.0776429161732649,0.0811920325388074,0.0855419981338221,
				  0.0909454307534702,0.0976690797726784,0.1057777820895406,0.1155958029012708,0.1266116066854350,0.1383486226503910,0.1510262218009775,0.1646815963955523,
				  0.1793847118819159,0.1951918111528836,0.2121812541317693,0.2304357320288367,0.2499984938760508,0.2709281624411535,0.2932613077270772,0.3170617964918866,
				  0.3423063612379277,0.3695615137341154,0.3971217829388074,0.4231725001074290,0.4486077701176930,0.4736812772283969,0.4984996145517106,0.5232706256325024,
				  0.5479442434314760,0.5725367356025903,0.5970569416109482,0.6215751675531770,0.6459232811886606,0.6699759671530302,0.6936750809141740,0.7170080478474583,
				  0.7397128428660801,0.7617580170455522,0.7824392672742913,0.8009083916954056,0.8175656376203322,0.8324964241259040,0.8457970340590418,0.8575570277373410,
				  0.8678819918256108,0.8768748757833822,0.8846331515440858,0.8912549486405668,0.8968412437341152,0.9014929560172531,0.9053083874291300,0.9083859090127075,
				  0.9108262326490713,0.9127307504679862,0.9141957927663734,0.9153135383675464,0.9161978338220919,0.9170093433528834,0.9176997927663735,0.9182731424731183,
				  0.9187333528836756 ]
		)
	));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'Sony Cine+709',
		new Float64Array(
				[ 0.09536,0.095478,0.095477,0.095487,0.096065,0.098802,0.100993,0.103192,
				  0.105328,0.107778,0.110405,0.113748,0.118809,0.125443,0.134203,0.14799,
				  0.163574,0.182266,0.204615,0.230647,0.259499,0.291063,0.326191,0.363425,
				  0.402596,0.443342,0.484945,0.526625,0.566841,0.604381,0.640827,0.67481,
				  0.707318,0.737661,0.766663,0.792151,0.814736,0.836382,0.85493,0.870464,
				  0.883507,0.895957,0.90574,0.913164,0.920182,0.927134,0.933985,0.940772,
				  0.94755,0.954329,0.961108,0.967887,0.974666,0.981445,0.988224,0.995003,
				  1.001782,1.008561,1.01534,1.022119,1.028898,1.035677,1.042456,1.049235 ]
		)
	));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'Varicam V709',
		new Float64Array(
				[ 0.03093963,0.03517715,0.03975096,0.04459771,0.0498902,0.05557408,0.06190443,0.06897675,
				  0.07677725,0.08537468,0.09473446,0.10541067,0.11868528,0.13311738,0.1487007,0.16548566,
				  0.1835071,0.20262917,0.22283545,0.24403145,0.26617877,0.28925105,0.31327642,0.33809209,
				  0.3635757,0.3896826,0.41631627,0.44341889,0.47081168,0.49848151,0.52623353,0.55406649,
				  0.58169329,0.60913806,0.63624608,0.66303621,0.68930935,0.71517113,0.73981736,0.76273104,
				  0.78514678,0.80792983,0.82988348,0.85024823,0.86926131,0.88683223,0.90300653,0.91783703,
				  0.93129966,0.94331701,0.95391642,0.96327691,0.97138937,0.97818037,0.98361305,0.98799011,
				  0.99133483,0.9937684,0.9951962,0.99614917,0.99691692,0.9975211,0.99811777,0.99867865,
				  0.9992434 ]
		)
	));
	this.gammaSub.push([this.subIdx('Panasonic'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSL3(
		'REDGamma',
		new Float64Array(
				[
					0.122209, 0.122628, 0.123047, 0.123466, 0.123864, 0.124153, 0.124373, 0.126399,
					0.132256, 0.139311, 0.144668, 0.150222, 0.157654, 0.166187, 0.175914, 0.18672,
					0.198454, 0.211823, 0.226955, 0.244314, 0.2638, 0.284623, 0.307611, 0.333972,
					0.363098, 0.394923, 0.4287, 0.464298, 0.501315, 0.539313, 0.576918, 0.614116,
					0.650874, 0.685866, 0.718698, 0.749114, 0.777078, 0.80297, 0.825409, 0.842033,
					0.854127, 0.861731, 0.867448, 0.871675, 0.875699, 0.879379, 0.882654, 0.885762,
					0.888901, 0.891917, 0.894805, 0.897616, 0.900351, 0.903046, 0.905325, 0.906683,
					0.907624, 0.908566, 0.909507, 0.910449, 0.91139, 0.912332, 0.913273, 0.914215 ]
		)
	));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'REDGamma2',
		new Float64Array(
				[
					0.108361, 0.109008, 0.109654, 0.110301, 0.110914, 0.111361, 0.113363, 0.117263,
					0.12595, 0.13667, 0.145798, 0.155437, 0.166925, 0.17921, 0.192282, 0.206362,
					0.221594, 0.237788, 0.2549, 0.272774, 0.291467, 0.311447, 0.332405, 0.353942,
					0.37623, 0.399321, 0.423152, 0.447735, 0.473302, 0.499739, 0.526754, 0.554079,
					0.581395, 0.608528, 0.635397, 0.661888, 0.687921, 0.713102, 0.737264, 0.760012,
					0.781281, 0.800987, 0.818704, 0.834386, 0.848327, 0.860566, 0.871203, 0.880394,
					0.888265, 0.894957, 0.90053, 0.904801, 0.907617, 0.908281, 0.908509, 0.908737,
					0.908965, 0.909193, 0.909421, 0.909649, 0.909877, 0.910105, 0.910333, 0.910561 ]
		)
	));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'REDGamma3',
		new Float64Array(
				[ -0.03714517,-0.00423269,0.0286798,0.06159228,0.08210614,0.08742128,0.09352044,0.10024791,0.10760079,0.11612612,
				  0.12508897,0.13477347,0.14708845,0.16039003,0.17473353,0.19047034,0.20764301,0.22600144,0.24574689,0.26695764,
				  0.28923082,0.31230737,0.33598015,0.36085173,0.3858281,0.41159915,0.43762202,0.46412136,0.49040391,0.51679063,
				  0.54330912,0.56927544,0.59476868,0.61927984,0.64375537,0.66689702,0.68910742,0.71075087,0.73073736,0.74993632,
				  0.76768928,0.78399945,0.79911844,0.81328213,0.82578649,0.8370763,0.84742981,0.85645727,0.86438563,0.87143002,
				  0.87786935,0.88346431,0.88841647,0.89282182,0.89677137,0.9002692,0.90328175,0.90617316,0.90922153,0.91226993,
				  0.91531834,0.91836678,0.92141523,0.92446369,0.92751216 ]
		)
	));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSL3(
		'REDGamma4',
		new Float64Array(
				[
					0.053893,0.056375,0.058856,0.061338,0.063694,0.066402,0.071655,0.078517,
					0.086253,0.094471,0.102953,0.112794,0.125421,0.139898,0.156136,0.174021,
					0.193439,0.214284,0.236454,0.259851,0.284385,0.309967,0.336515,0.363952,
					0.392203,0.421199,0.450864,0.481018,0.511437,0.541908,0.572226,0.602196,
					0.63163,0.660345,0.688159,0.714896,0.740381,0.764439,0.786892,0.807565,
					0.826276,0.842863,0.857382,0.870007,0.880892,0.890167,0.897948,0.904337,
					0.909429,0.913312,0.916075,0.917816,0.918669,0.918866,0.918866,0.918866,
					0.918866,0.918866,0.918866,0.918866,0.918866,0.918866,0.918866,0.918866 ]
		)
	));
	this.gammaSub.push([this.subIdx('RED'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Rec709 (800%)',
		{
			rec: {
				lut: new Float64Array([
					-0.0446421313,	-0.0204893067,	0.0036635180,	0.0278163427,	0.0519691674,	0.0761219921,	0.1002707756,	0.1244698215,	0.1486224622,	0.1716290677,
					0.1906642455,	0.2085204718,	0.2254012975,	0.2413982532,	0.2565166388,	0.2708530435,	0.2844393079,	0.2973183908,	0.3096854620,	0.3215533433,
					0.3328146131,	0.3436401143,	0.3540168103,	0.3639875695,	0.3735997301,	0.3828629905,	0.3917793547,	0.4004128911,	0.4088059207,	0.4169027148,
					0.4247147130,	0.4322985725,	0.4396753339,	0.4468468853,	0.4538127938,	0.4605775118,	0.4671640916,	0.4735878362,	0.4798545760,	0.4860006009,
					0.4920048747,	0.4977093585,	0.5038431061,	0.5116567043,	0.5181791292,	0.5247650308,	0.5315938853,	0.5385493314,	0.5456541485,	0.5530263072,
					0.5606487371,	0.5686002240,	0.5768926044,	0.5855586010,	0.5948269850,	0.6046748461,	0.6152549633,	0.6269138470,	0.6396734938,	0.6541629455,
					0.6710471506,	0.6915209719,	0.7181498682,	0.7574674791,	0.8445913579
				])
			},
			out: {
				lut: new Float64Array([
					0.0289066996,	0.0390080746,	0.0491133029,	0.0592146779,	0.0693160529,	0.0794212813,	0.0895274289,	0.0996411169,	0.1097173681,	0.1197901614,
					0.1300004174,	0.1408247747,	0.1535938980,	0.1670471322,	0.1812353271,	0.1961807539,	0.2118897750,	0.2285885784,	0.2462546509,	0.2650729108,
					0.2848894628,	0.3059138202,	0.3282876301,	0.3520647492,	0.3773249255,	0.4041951748,	0.4326924843,	0.4630104118,	0.4953512291,	0.5296917198,
					0.5663211163,	0.6052213632,	0.6468385483,	0.6811695613,	0.7179664821,	0.7526207094,	0.7849335846,	0.8147522501,	0.8419881738,	0.8664954100,
					0.8881412487,	0.9073422173,	0.9239607990,	0.9381992542,	0.9503103153,	0.9605564777,	0.9690464375,	0.9762167750,	0.9819309464,	0.9867203043,
					0.9904006942,	0.9934500190,	0.9956787345,	0.9979577502,	0.9998967591,	1.0018141003,	1.0037311922,	1.0056480668,	1.0075647537,	1.0094812760,
					1.0113976563,	1.0133139134,	1.0152300629,	1.0171461197,	1.0190620951
				])
			}
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'EOS Standard',
		{
			clip: 3.7455,
			loggy: 0.01197,
			lut: new Float64Array(
				[	0.062561095,0.074860431,0.092233233,0.113525362,
					0.148197424,0.190542723,0.248921196,0.320439745,
					0.417441612,0.518356119,0.637094759,0.739691491,
					0.833001228,0.904285437,0.955849432,0.986588392,
					0.997301612 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'EOS Standard (Legal)',
		{
			clip: 3.7455,
			loggy: 0.01197,
			lut: new Float64Array(
				[	0.062561095,0.073828375,0.089743398,0.109248871,
					0.141011547,0.179803585,0.23328343,0.298800746,
					0.387663035,0.480109649,0.588884745,0.682872425,
					0.768352397,0.833655037,0.880892217,0.909051823,
					0.91886608 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Canon Normal 1',
		{
			clip: 4.9166,
			loggy: 0.002377,
			lut: new Float64Array(
				[	0.082111437,0.090584133,0.102121123,0.117689768,
					0.140853869,0.179297916,0.229246771,0.288545875,
					0.355002175,0.443743628,0.567289457,0.709945913,
					0.855432239,0.912823502,0.973847336,1.053094692,
					1.344984113 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Canon Normal 2',
		{
			clip: 3.6795,
			loggy: 0.010815,
			lut: new Float64Array(
				[	0.082111437,0.097513279,0.113845203,0.134727251,
					0.167041692,0.204979095,0.252646999,0.299167176,
					0.354210924,0.42337854,0.51044802,0.608850484,
					0.724959368,0.850680674,0.89267391,0.933266716,
					0.982099746 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Canon Normal 3',
		{
			clip: 3.675,
			loggy: 0.011418,
			lut: new Float64Array(
				[	0.082111437,0.09988293,0.119699608,0.143422866,
					0.178649187,0.214574932,0.258160103,0.305496005,
					0.366356945,0.432842236,0.517627699,0.615737774,
					0.729766182,0.852693579,0.891819699,0.933451248,
					0.982740453 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Canon Normal 4',
		{
			clip: 3.70456,
			loggy: 0.0093,
			lut: new Float64Array(
				[	0.082111437,0.098467583,0.117300597,0.140493024,
					0.176093124,0.219716004,0.271868112,0.32123868,
					0.36749718,0.427104487,0.506362752,0.603335607,
					0.716870955,0.848059317,0.893373102,0.934937886,
					0.983834278 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaNLog('Nikon N-Log'));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Log')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(true);
	this.gammaExt.push(true);


	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Standard',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090182450305,
						0.114844812055, 0.147037855967, 0.170190534243, 0.182505160319, 0.195266314669, 0.203853784990, 0.211095737876, 0.219221792780, 0.227999341155,
						0.236282183331, 0.243254666213, 0.249799997985, 0.256337363135, 0.262712725704, 0.268527439248, 0.273815628826, 0.278801564019, 0.283644789095,
						0.288392421002, 0.293133710416, 0.297755513447, 0.302175617216, 0.306502426672, 0.310752741262, 0.314959622924, 0.319114515832, 0.323165229840,
						0.327112045597, 0.330908933709, 0.334586176331, 0.338175148420, 0.341680833810, 0.345139426450, 0.348544714039, 0.351947325653, 0.355371475627,
						0.358794773339, 0.362214961661, 0.365622412467, 0.368960430415, 0.372229078201, 0.375549771636, 0.378978477443, 0.382437665513, 0.385876364569,
						0.389311177226, 0.392717070632, 0.396099211847, 0.399596228751, 0.403257717617, 0.406948529183, 0.410631822241, 0.414307485422, 0.417949748127,
						0.421597747322, 0.425300362807, 0.429011956465, 0.432665489009, 0.436293179570, 0.439950131174, 0.443618495668, 0.447217356045, 0.450752752428,
						0.454308147167, 0.457896600163, 0.461486503027, 0.465077971802, 0.468649625500, 0.472179139518, 0.475681843863, 0.479172398173, 0.482643830686,
						0.486071715900, 0.489456560345, 0.492829660552, 0.496199806504, 0.499557029186, 0.502883973225, 0.506202425833, 0.509583182445, 0.513027270364,
						0.516439758293, 0.519795229070, 0.523139387370, 0.526486431936, 0.529841782722, 0.533239406650, 0.536673918577, 0.540201395758, 0.543843468628,
						0.547563839344, 0.551365664452, 0.555211858630, 0.559065206970, 0.562987330755, 0.567008663481, 0.571141048171, 0.575388384633, 0.579852755032,
						0.584596219521, 0.589656886066, 0.595013785817, 0.600608182746, 0.606593136633, 0.612862738119, 0.619558115806, 0.627134629835, 0.635771882841,
						0.646090898198, 0.702378530367, 0.761472498521, 0.820637751415, 0.879845357987, 0.939077825206, 0.998324880860, 1.057576659021, 1.116828424985,
						1.176080190950, 1.235331956914, 1.294583722879  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063440922871, 0.065939828995, 0.068461377294, 0.071083719271, 0.073457071312, 0.075178362835,
						0.076926716563, 0.078377767373, 0.079774496126, 0.082090196935, 0.087053858463, 0.091985226944, 0.096851206605, 0.101597266466, 0.108640869604,
						0.117026469673, 0.124564288309, 0.131532001666, 0.138653050872, 0.147207407755, 0.156488919267, 0.165859362460, 0.175652722265, 0.186927260407,
						0.199243267088, 0.212044116616, 0.225041844751, 0.238895615805, 0.253240133306, 0.267917983908, 0.283304261071, 0.299792645427, 0.317160501155,
						0.335057795993, 0.352889810206, 0.370819575819, 0.389352213885, 0.407101174185, 0.424871237485, 0.442772100713, 0.459451481748, 0.476039712868,
						0.492777153962, 0.509246934718, 0.526027527985, 0.542712928580, 0.559913284646, 0.576928975938, 0.593971033204, 0.611344689037, 0.628930013031,
						0.646950916067, 0.665096433879, 0.683435767729, 0.701243173150, 0.719444395779, 0.737622227049, 0.755320491138, 0.772001056736, 0.787997434894,
						0.803729034995, 0.818764033383, 0.832972783544, 0.845877373044, 0.857555748351, 0.868473696665, 0.878489111063, 0.887958347868, 0.896363952038,
						0.903591827347, 0.910315723114, 0.915372062462, 0.918298748293, 0.918941618409, 0.918972202977, 0.919075471565, 0.919879717190, 0.920939802190,
						0.921973664508, 0.923007251183, 0.924040581079, 0.925073671761, 0.926106539583, 0.927139199777, 0.928171666527, 0.929203953044, 0.930236071632,
						0.931268033751, 0.932299850078, 0.933331530557, 0.934363084451, 0.935394520390, 0.936425846414, 0.937457070013, 0.938488198167, 0.939519237376,
						0.940550193699, 0.941581072781, 0.942611879880, 0.943642619897, 0.944673297399, 0.945703916640, 0.946734481587, 0.947764995932, 0.948795463120,
						0.949825886359, 0.950856268638, 0.951886612744, 0.952916921275, 0.953947196648, 0.954977441120, 0.956007656792, 0.957037845623, 0.958068009437,
						0.959098149936, 0.960128268706, 0.961158367223  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Neutral',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090370277129,
						0.111261816878, 0.130837070772, 0.154724281799, 0.167748578657, 0.175153042048, 0.183813600540, 0.193613893606, 0.201845384547, 0.208862712809,
						0.216240385882, 0.223891266282, 0.231266341219, 0.238137235412, 0.244526657912, 0.250600574579, 0.256676156574, 0.262573904298, 0.268179682113,
						0.273510523045, 0.278725079401, 0.283798074261, 0.288755859858, 0.293711495514, 0.298540024556, 0.303202660636, 0.307723722115, 0.312136686485,
						0.316510929668, 0.320823103675, 0.325061599754, 0.329250845847, 0.333404903584, 0.337481786689, 0.341478003981, 0.345410076747, 0.349276802698,
						0.353155050352, 0.357055174830, 0.360924326908, 0.364761909620, 0.368534160768, 0.372219561935, 0.375965970561, 0.379837133354, 0.383697823226,
						0.387509788827, 0.391294383841, 0.395027283063, 0.398805761668, 0.402714808096, 0.406648722824, 0.410557207556, 0.414440514338, 0.418281270173,
						0.422101311085, 0.425921487535, 0.429708258188, 0.433414855526, 0.437113588260, 0.440894188305, 0.444702269231, 0.448484157653, 0.452247923518,
						0.455979626530, 0.459680464278, 0.463339649468, 0.466960507431, 0.470544248238, 0.474091256304, 0.477614456193, 0.481114289829, 0.484597025237,
						0.488049600937, 0.491511604916, 0.495056838882, 0.498638495167, 0.502143788814, 0.505593447821, 0.509025317989, 0.512445400947, 0.515831817485,
						0.519169669140, 0.522481361650, 0.525786987556, 0.529082557203, 0.532387937393, 0.535693607451, 0.539042131765, 0.542445907579, 0.545931580767,
						0.549599723684, 0.553417839780, 0.557224827183, 0.561055098051, 0.564975986003, 0.568990380621, 0.573121964995, 0.577399927778, 0.581947100667,
						0.586726717568, 0.591716948652, 0.596740236407, 0.601900927218, 0.607552931270, 0.614097227575, 0.621247444919, 0.628629296746, 0.636894410971,
						0.647118201427, 0.701473594388, 0.759117452800, 0.816827933730, 0.874580070648, 0.932356983196, 0.990148625585, 1.047946225923, 1.105743851253,
						1.163541476583, 1.221339101914, 1.279136727244  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063424532172, 0.066451860312, 0.069540979037, 0.072767011953, 0.075906919979, 0.078853518191,
						0.081631137728, 0.084115161140, 0.086479804114, 0.090146659344, 0.098326897931, 0.105813214308, 0.112411325511, 0.118632105327, 0.126340654717,
						0.135121024858, 0.143188481435, 0.151214506061, 0.159704595685, 0.168946154075, 0.178917743693, 0.188988933153, 0.199496185802, 0.210829472801,
						0.222607262009, 0.234859080761, 0.247268132837, 0.260349232373, 0.274083476359, 0.288130112770, 0.302582467828, 0.317331828344, 0.332620806037,
						0.348365834915, 0.364049610993, 0.379997823816, 0.396454197491, 0.412256458371, 0.428299584401, 0.444563625444, 0.460140581966, 0.475797913493,
						0.491724507182, 0.507769291577, 0.524243967159, 0.540321153567, 0.556518544281, 0.572986274856, 0.589827764317, 0.607037655073, 0.624500979893,
						0.642132788801, 0.659260502589, 0.676925684511, 0.694832172329, 0.713193903044, 0.731687117698, 0.750046927552, 0.767681303891, 0.783847467497,
						0.799775652757, 0.815021702518, 0.829406565570, 0.842479215886, 0.854706468324, 0.866698387523, 0.877330903455, 0.886205655894, 0.894607432632,
						0.902626621574, 0.909273722489, 0.914867761327, 0.918285650651, 0.918940220570, 0.918992912762, 0.919122306060, 0.919952578245, 0.921038681814,
						0.922098555256, 0.923158146120, 0.924217473745, 0.925276556137, 0.926335410063, 0.927394051136, 0.928452493899, 0.929510751894, 0.930568837735,
						0.931626763171, 0.932684539147, 0.933742175856, 0.934799682795, 0.935857068813, 0.936914342150, 0.937971510485, 0.939028580973, 0.940085560280,
						0.941142454614, 0.942199269764, 0.943256011120, 0.944312683707, 0.945369292206, 0.946425840978, 0.947482334089, 0.948538775326, 0.949595168219,
						0.950651516058, 0.951707821906, 0.952764088621, 0.953820318865, 0.954876515118, 0.955932679692, 0.956988814742, 0.958044922274, 0.959101004161,
						0.960157062147, 0.961213097856, 0.962269112803  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Vivid',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090022266287,
						0.124983618100, 0.174358067479, 0.200885292861, 0.210394128231, 0.219679538515, 0.229782588225, 0.237527072241, 0.243640168554, 0.250127754776,
						0.257349865517, 0.264748252859, 0.270564224518, 0.275807100363, 0.280794974454, 0.285678082679, 0.290496609151, 0.295301613189, 0.299695171061,
						0.303797972903, 0.307751983351, 0.311586237919, 0.315404817492, 0.319170201075, 0.322828977424, 0.326392115832, 0.329816995605, 0.333116458736,
						0.336347797973, 0.339521970675, 0.342645003881, 0.345727309828, 0.348765618565, 0.351808171675, 0.354882352416, 0.357954246165, 0.360988936855,
						0.363995548567, 0.366968530013, 0.369872023109, 0.372746601324, 0.375718615365, 0.378835757890, 0.382015542918, 0.385197001913, 0.388398496231,
						0.391560845343, 0.394665368289, 0.397769976495, 0.400928640905, 0.404115357104, 0.407272557992, 0.410397071901, 0.413502895037, 0.416589818624,
						0.419660824008, 0.422740719992, 0.425840284669, 0.428929810665, 0.431975923618, 0.434993999602, 0.438037471593, 0.441136068781, 0.444236363145,
						0.447275819442, 0.450270537122, 0.453286432626, 0.456347163141, 0.459436026617, 0.462554221976, 0.465705641406, 0.468868557494, 0.472022133151,
						0.475193176007, 0.478429604773, 0.481730408691, 0.485010213005, 0.488233925164, 0.491463556240, 0.494758069364, 0.498091267968, 0.501401033442,
						0.504676474735, 0.507998529829, 0.511426279031, 0.514894259405, 0.518319250205, 0.521742852369, 0.525265607959, 0.528889614943, 0.532532949141,
						0.536178537282, 0.539893166950, 0.543690024018, 0.547605615691, 0.551688497347, 0.555854084117, 0.560050009191, 0.564521264881, 0.569347955800,
						0.574322784361, 0.579510092645, 0.584961457677, 0.590754171202, 0.597105965002, 0.604106477697, 0.611752014152, 0.620589041280, 0.630734397016,
						0.641901685999, 0.704513814536, 0.767045464082, 0.829654095144, 0.892306570909, 0.954983997519, 1.017675103286, 1.080368518869, 1.143061934456,
						1.205755350042, 1.268448765629, 1.331142181216  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063422106433, 0.065166902090, 0.066857240455, 0.068727634913, 0.070315430976, 0.071522246881,
						0.072621736604, 0.073632345620, 0.074546172578, 0.075767169852, 0.077558928054, 0.079330994587, 0.081062569715, 0.082816923899, 0.087517230265,
						0.094217660090, 0.100822872848, 0.106844083563, 0.113466488200, 0.123209893266, 0.132666302326, 0.141121837628, 0.149492480790, 0.160487736691,
						0.172594382415, 0.185184084790, 0.198017570112, 0.212665734218, 0.228431904394, 0.244606313346, 0.261721930295, 0.280252238739, 0.299659730327,
						0.319685136453, 0.339583171500, 0.359954596243, 0.380963884464, 0.400400861762, 0.419544431276, 0.439164017255, 0.458393958826, 0.477973742903,
						0.497810160738, 0.517555133739, 0.537693887480, 0.557430697093, 0.577710884416, 0.597523047859, 0.616894400479, 0.636145035402, 0.654723587302,
						0.673606897408, 0.691989257762, 0.710506630240, 0.728218016286, 0.745983563913, 0.762868835952, 0.779520832114, 0.795442039283, 0.810311738796,
						0.824686064119, 0.837470043276, 0.849512612712, 0.860724908386, 0.870992043119, 0.880028241330, 0.888298577234, 0.895604283736, 0.901898605243,
						0.907772519766, 0.913241598575, 0.917684640033, 0.918890180731, 0.918814825701, 0.918933210545, 0.918973452193, 0.919720908703, 0.920724222029,
						0.921701328915, 0.922678175291, 0.923654778984, 0.924631156594, 0.925607323580, 0.926583294335, 0.927559082266, 0.928534699858, 0.929510158739,
						0.930485469742, 0.931460642955, 0.932435687778, 0.933410612965, 0.934385426672, 0.935360136499, 0.936334749524, 0.937309272342, 0.938283711099,
						0.939258071520, 0.940232358939, 0.941206578328, 0.942180734318, 0.943154831224, 0.944128873068, 0.945102863597, 0.946076806303, 0.947050704440,
						0.948024561041, 0.948998378932, 0.949972160744, 0.950945908934, 0.951919625787, 0.952893313435, 0.953866973864, 0.954840608925, 0.955814220343,
						0.956787809726, 0.957761378572, 0.958734928277  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Monochrome',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090129558931,
						0.118513428992, 0.161557439104, 0.183585697405, 0.200093975652, 0.208057578622, 0.215970131333, 0.225002608116, 0.233879495392, 0.240662071274,
						0.247338185443, 0.254230227189, 0.261105306305, 0.267394020451, 0.272873708978, 0.278074662081, 0.283101734765, 0.288019832776, 0.292944821742,
						0.297672426491, 0.302032614613, 0.306221352992, 0.310269266663, 0.314275256213, 0.318250784779, 0.322119607870, 0.325888885467, 0.329541475946,
						0.333079047674, 0.336554832203, 0.339984067915, 0.343360976958, 0.346693108790, 0.349974270211, 0.353182034904, 0.356320329348, 0.359418720617,
						0.362492160458, 0.365529954410, 0.368516385984, 0.371436781625, 0.374369295393, 0.377384246411, 0.380449869114, 0.383514484285, 0.386579658573,
						0.389634808054, 0.392647838871, 0.395627110133, 0.398638883870, 0.401722968051, 0.404834439823, 0.407921483765, 0.410994007883, 0.414057208753,
						0.417103783757, 0.420145602950, 0.423212741133, 0.426311460699, 0.429399300683, 0.432442612510, 0.435466396352, 0.438510650641, 0.441585590904,
						0.444654826762, 0.447678826870, 0.450678493363, 0.453724102095, 0.456831012284, 0.459983753466, 0.463189922895, 0.466448049052, 0.469692451023,
						0.472914434645, 0.476132751775, 0.479351891463, 0.482571917094, 0.485795265077, 0.489003126931, 0.492300997063, 0.495805683520, 0.499380185386,
						0.502849518582, 0.506282440542, 0.509735949913, 0.513204774156, 0.516641723170, 0.520030088579, 0.523424396172, 0.526834100575, 0.530287729731,
						0.533858145421, 0.537543411008, 0.541400840406, 0.545443580335, 0.549638874781, 0.553990299209, 0.558400834273, 0.562991914893, 0.567987937632,
						0.572992749012, 0.578023423534, 0.583389324988, 0.589449547730, 0.596237282899, 0.603370029808, 0.610812834357, 0.618810651619, 0.628449397199,
						0.641209364072, 0.656079610743, 0.670851711888, 0.685633413195, 0.700423865429, 0.715221980601, 0.730026806070, 0.744837506804, 0.759653351062,
						0.774473698233, 0.789297986894, 0.804125719542  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063411298637, 0.065473225005, 0.067709381852, 0.069944812343, 0.071995254172, 0.073304162528,
						0.074720219671, 0.076007169791, 0.077253960239, 0.078699062445, 0.081546572735, 0.084481566293, 0.087397030027, 0.090312742629, 0.096416171392,
						0.104602992261, 0.111880792294, 0.118525378827, 0.125502768452, 0.134622916852, 0.143692343699, 0.152481137891, 0.161711453810, 0.172700686416,
						0.184604076215, 0.196978236277, 0.209564548601, 0.223672279297, 0.238726919005, 0.254134628935, 0.270374429331, 0.287668992396, 0.305595138142,
						0.324155748053, 0.343639382930, 0.363686479761, 0.384465305893, 0.404456370194, 0.424425227873, 0.444796339648, 0.464510678743, 0.484388513840,
						0.504418236358, 0.524172308005, 0.544292886223, 0.564185830752, 0.584416939007, 0.603905098281, 0.622720493201, 0.641667395658, 0.660613507070,
						0.679425795473, 0.696693040387, 0.714409322616, 0.732049896563, 0.750029943547, 0.767754182324, 0.784375558828, 0.799577226262, 0.813738486503,
						0.827318392881, 0.839525636331, 0.851714184079, 0.862831025734, 0.872171976419, 0.880858961930, 0.889141803850, 0.896959604445, 0.903627190101,
						0.909264232179, 0.913744505556, 0.917827820241, 0.921965195577, 0.926097506034, 0.930228497746, 0.934358028270, 0.938486197832, 0.942613099722,
						0.946738820786, 0.950863441875, 0.954987038264, 0.959109680045, 0.963231432487, 0.967352356368, 0.971472508295, 0.975591940984, 0.979710703538,
						0.983828841690, 0.987946398044, 0.992063412282, 0.996179921373, 1.000295959754, 1.004411559510, 1.008526750532, 1.012641560668, 1.016756015863,
						1.020870140294, 1.024983956485, 1.029097485424, 1.033210746667, 1.037323758437, 1.041436537713, 1.045549100319, 1.049661460998, 1.053773633490,
						1.057885630599, 1.061997464257, 1.066109145582, 1.070220684937, 1.074332091976, 1.078443375701, 1.082554544497, 1.086665606179, 1.090776568032,
						1.094887436845, 1.098998218942, 1.103108920220  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Portrait',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090377297204,
						0.111226442710, 0.130633567550, 0.154389555468, 0.167484430608, 0.174839594233, 0.183469996634, 0.193294111001, 0.201590147870, 0.208632209126,
						0.215987405560, 0.223629338832, 0.231017469096, 0.237919995757, 0.244328495635, 0.250389900549, 0.256464961207, 0.262363127247, 0.267986335890,
						0.273335963136, 0.278548689567, 0.283619640858, 0.288574227782, 0.293525082167, 0.298362229115, 0.303041988045, 0.307568668181, 0.311976904229,
						0.316346477308, 0.320656949316, 0.324898573361, 0.329092080323, 0.333253752423, 0.337335390357, 0.341329550890, 0.345261031804, 0.349127299667,
						0.353006646136, 0.356915623834, 0.360789759371, 0.364625604109, 0.368397738648, 0.372080006233, 0.375820505631, 0.379695767711, 0.383563170183,
						0.387373448545, 0.391156890498, 0.394891149850, 0.398666495274, 0.402574220925, 0.406510206401, 0.410414856020, 0.414296056300, 0.418138859891,
						0.421960984406, 0.425782809615, 0.429572667473, 0.433281562063, 0.436977734201, 0.440756156341, 0.444565180033, 0.448345285966, 0.452106942345,
						0.455840644695, 0.459545962435, 0.463207496528, 0.466829072947, 0.470414623672, 0.473964223990, 0.477488781828, 0.480988569456, 0.484470908978,
						0.487924337343, 0.491384406479, 0.494925495146, 0.498507119369, 0.502014399827, 0.505463972776, 0.508895331480, 0.512316255254, 0.515704743895,
						0.519044770981, 0.522357771953, 0.525665262942, 0.528962750745, 0.532271028161, 0.535581223979, 0.538931946024, 0.542336228199, 0.545819335767,
						0.549487438103, 0.553313651701, 0.557125889811, 0.560955468698, 0.564878349439, 0.568897239861, 0.573033256488, 0.577313495907, 0.581857451013,
						0.586635041242, 0.591627926730, 0.596657408025, 0.601816456841, 0.607467824225, 0.614007423583, 0.621166374566, 0.628556362922, 0.636811644190,
						0.647065080028, 0.699367091432, 0.753605174839, 0.807897396769, 0.862229480648, 0.916586008425, 0.970957527998, 1.025337298823, 1.079717878082,
						1.134098457344, 1.188479036605, 1.242859615866  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063423136263, 0.066462881746, 0.069554089606, 0.072792511194, 0.075979139105, 0.078932975596,
						0.081758133236, 0.084242338721, 0.086596467332, 0.090414496703, 0.098632787117, 0.106105448010, 0.112691707091, 0.118886717045, 0.126607307194,
						0.135381970506, 0.143446256435, 0.151488012869, 0.159970471694, 0.169194405121, 0.179186968869, 0.189265265898, 0.199781372605, 0.211087600159,
						0.222882010816, 0.235146602782, 0.247564852184, 0.260618796978, 0.274368775975, 0.288433493799, 0.302881118328, 0.317614474157, 0.332918076574,
						0.348667044053, 0.364322697224, 0.380282324822, 0.396752589681, 0.412531634149, 0.428585041949, 0.444846606680, 0.460417216218, 0.476090075277,
						0.492011628887, 0.508051391505, 0.524528209215, 0.540603806442, 0.556812950525, 0.573270231981, 0.590112805234, 0.607317141768, 0.624784484757,
						0.642417689555, 0.659550111550, 0.677221493533, 0.695127386540, 0.713484669929, 0.731966315749, 0.750300629233, 0.767925373457, 0.784054829694,
						0.799974605754, 0.815195868133, 0.829558770206, 0.842627040471, 0.854840162809, 0.866820716862, 0.877438793785, 0.886299046904, 0.894688794916,
						0.902697672504, 0.909338504065, 0.914892130237, 0.918231731742, 0.918915083032, 0.919043476065, 0.919239149469, 0.920136059151, 0.921288779755,
						0.922415251170, 0.923541422251, 0.924667313553, 0.925792944212, 0.926918332049, 0.928043493659, 0.929168444498, 0.930293198958, 0.931417770448,
						0.932542171453, 0.933666413606, 0.934790507742, 0.935914463954, 0.937038291645, 0.938161999576, 0.939285595908, 0.940409088244, 0.941532483668,
						0.942655788782, 0.943779009735, 0.944902152257, 0.946025221689, 0.947148223006, 0.948271160844, 0.949394039523, 0.950516863068, 0.951639635232,
						0.952762359509, 0.953885039159, 0.955007677216, 0.956130276510, 0.957252839678, 0.958375369175, 0.959497867293, 0.960620336166, 0.961742777781,
						0.962865193993, 0.963987586528, 0.965109956997  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaIOLUT(
		'Nikon Landscape',
		{
			rec: {
				lut: new Float64Array(
					[	-0.342551352061, -0.288177568708, -0.233803785356, -0.179430002004, -0.125056218652, -0.070682435300, -0.016308651953, 0.038065131380, 0.090014281627,
						0.125262756783, 0.175394871323, 0.201468245826, 0.210914156758, 0.220255090663, 0.230320004433, 0.237899490783, 0.244037210321, 0.250534903571,
						0.257758397707, 0.265125636355, 0.270861063964, 0.276088839523, 0.281077811268, 0.285962815933, 0.290792094924, 0.295589187329, 0.299952875638,
						0.304038876382, 0.307985999261, 0.311823369684, 0.315647582100, 0.319412786133, 0.323068235362, 0.326624111035, 0.330039441071, 0.333332259731,
						0.336562154474, 0.339737539911, 0.342863954371, 0.345947530923, 0.348988934054, 0.352034941511, 0.355105612192, 0.358169762222, 0.361200953136,
						0.364207980690, 0.367181171002, 0.370081303694, 0.372961364740, 0.375946473112, 0.379070635127, 0.382250836990, 0.385437951772, 0.388644687165,
						0.391806775547, 0.394912899124, 0.398023732258, 0.401189225678, 0.404377387650, 0.407533994910, 0.410661186470, 0.413769752051, 0.416856569741,
						0.419928375398, 0.423011688238, 0.426113673928, 0.429202840995, 0.432247581554, 0.435269097809, 0.438320205573, 0.441423089653, 0.444521471455,
						0.447557800230, 0.450556342802, 0.453581499220, 0.456648032790, 0.459742607442, 0.462868813548, 0.466028335421, 0.469195953395, 0.472352862884,
						0.475531499554, 0.478780564930, 0.482087135150, 0.485363351397, 0.488586918940, 0.491824446382, 0.495130114255, 0.498468340983, 0.501777107483,
						0.505058400010, 0.508397188549, 0.511840110704, 0.515312142846, 0.518738499960, 0.522176040842, 0.525720612003, 0.529356285838, 0.532997521466,
						0.536642367114, 0.540365200664, 0.544175285378, 0.548107328251, 0.552192349558, 0.556349227616, 0.560560482382, 0.565069214291, 0.569899347725,
						0.574871037285, 0.580070468084, 0.585551663364, 0.591351930507, 0.597726675336, 0.604734853205, 0.612436678142, 0.621316593050, 0.631412155268,
						0.642407361803, 0.705185166051, 0.768799223484, 0.832491771003, 0.896228587957, 0.959990352659, 1.023765329935, 1.087542056186, 1.151318782440,
						1.215095508694, 1.278872234948, 1.342648961202  ]
				)
			},
			out: {
				lut: new Float64Array(
					[	0.049218249549, 0.050340760298, 0.051463271048, 0.052585781797, 0.053708292546, 0.054830803295, 0.055953314045, 0.057075824794, 0.058198335543,
						0.059320846293, 0.060443357042, 0.061565867791, 0.063424602387, 0.065158719093, 0.066844337216, 0.068684208620, 0.070266797005, 0.071428317343,
						0.072543802315, 0.073565478875, 0.074487180884, 0.075615127884, 0.077358107033, 0.079057203638, 0.080785142809, 0.082568609461, 0.087086590075,
						0.093769852277, 0.100367927146, 0.106434856177, 0.113007625398, 0.122717469882, 0.132201743401, 0.140683305794, 0.149045991690, 0.160057857913,
						0.172146745702, 0.184714602362, 0.197531016229, 0.212198748641, 0.227944458602, 0.244092918950, 0.261202823820, 0.279731408185, 0.299105025428,
						0.319106165979, 0.339034794480, 0.359391749047, 0.380382823923, 0.399821157211, 0.418933430124, 0.438529485049, 0.457746216431, 0.477300192906,
						0.497127504497, 0.516859464506, 0.536977578582, 0.556704529271, 0.576955897034, 0.596747644730, 0.616086030400, 0.635316040970, 0.653874499813,
						0.672741331452, 0.691099597289, 0.709588441640, 0.727270882484, 0.745001904949, 0.761868035665, 0.778540245167, 0.794460294454, 0.809377586481,
						0.823762555425, 0.836596499610, 0.848686298910, 0.859908326372, 0.870238967260, 0.879342623248, 0.887630917192, 0.894981327227, 0.901356587391,
						0.907285193365, 0.912856265123, 0.917595172338, 0.918922145184, 0.918818251367, 0.918920088871, 0.918943684746, 0.919674534281, 0.920661245730,
						0.921621755491, 0.922582009166, 0.923542024281, 0.924501817154, 0.925461402979, 0.926420795907, 0.927380009116, 0.928339054879, 0.929297944628,
						0.930256689010, 0.931215297944, 0.932173780667, 0.933132145787, 0.934090401321, 0.935048554738, 0.936006612998, 0.936964582584, 0.937922469536,
						0.938880279483, 0.939838017669, 0.940795688979, 0.941753297967, 0.942710848875, 0.943668345656, 0.944625791994, 0.945583191322, 0.946540546837,
						0.947497861522, 0.948455138154, 0.949412379321, 0.950369587435, 0.951326764746, 0.952283913348, 0.953241035193, 0.954198132101, 0.955155205767,
						0.956112257773, 0.957069289591, 0.958026302593  ]
				)
			}
		}));
	this.gammaSub.push([this.subIdx('Nikon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
//
	this.pqOOTF = new LUTGammaOOTFPQ('Display PQ OOTF (nits)', {Lw: 10000, scale: 'nits'});
	this.hlgOOTF = new LUTGammaOOTFHLG('Display HLG OOTF (nits)', {Lw: 1000, Lb: 0, scale: 'nits'});
	this.pqNoOOTF = new LUTGammaOOTFNone('Scene Linear (nits)', {Lw: 10000});
	this.pqOOTFNorm = new LUTGammaOOTFPQ('Display PQ OOTF (Normalised)', {Lw: 10000, scale: 'normalised'});
	this.hlgOOTFNorm = new LUTGammaOOTFHLG('Display HLG OOTF (Normalised)', {Lw: 1000, Lb: 0, scale: 'normalised'});
//
	this.PQ = this.gammas.length;
	this.gammas.push(new LUTGammaPQ(
		'Rec2100 PQ (PQ OOTF)', this.pqOOTF));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaPQ(
		'Rec2100 PQ (HLG OOTF)', this.hlgOOTF));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.HLG = this.gammas.length;
	this.gammas.push(new LUTGammaHLG(
		'Rec2100 HLG', {a: 0.17883277, b: 0.28466892, c: 0.55991073}));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.pqEOTFIdx = this.gammas.length;
	this.gammas.push(new LUTGammaPQ(
		'PQ (EOTF Only)', this.pqNoOOTF));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
//
	this.gammas.push(new LUTGammaLUTSimple(
		'HG3250G36 (HG1)',
		{
			clip: 4.607,
			loggy: 0.00896,
			lut: new Float64Array(
				[	0.08797654,0.10544838,0.130894073,0.167872574,
					0.194834348,0.226358779,0.266268941,0.31582866,
					0.377990009,0.453504879,0.541509091,0.636928684,
					0.731022684,0.813771264,0.877502171,0.919831827,
					0.936196343 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG4600G30 (HG2)',
		{
			clip: 5.471,
			loggy: 0.00491,
			lut: new Float64Array(
				[	0.08797654,0.104192531,0.126464534,0.15295782,
					0.176615948,0.205826206,0.243989699,0.292906636,
					0.356424356,0.436709059,0.533166639,0.639815303,
					0.74453493,0.833365445,0.8969974,0.934175897,
					0.946701781 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG3259G40 (HG3)',
		{
			clip: 5.424,
			loggy: 0.00527,
			lut: new Float64Array(
				[	0.08797654,0.106966953,0.136197387,0.179217692,
					0.211658973,0.251242869,0.302925063,0.368355366,
					0.451618812,0.552562868,0.666187509,0.780975438,
					0.881914932,0.95753893,1.005027748,1.027378519,
					1.032819393 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG4609G33 (HG4)',
		{
			clip: 4.987,
			loggy: 0.0129,
			lut: new Float64Array(
				[	0.08797654,0.116808731,0.151974786,0.180100256,
					0.210030322,0.24682835,0.291407476,0.346545743,
					0.414273303,0.495344317,0.588468737,0.688544076,
					0.787019889,0.874636069,0.942887027,0.991399694,
					1.011271456 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG8000G36 (HG5)',
		{
			clip: 5.8,
			loggy: 0.033475,
			lut: new Float64Array(
				[	0.086897445,0.174053304,0.226750469,0.282647061,
					0.346604743,0.419397456,0.499103345,0.58154343,
					0.661222354,0.732765443,0.792295168,0.838670413,
					0.872336124,0.895357636,0.910092389,0.919082976,
					0.922720436 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG8000G30 (HG6)',
		{
			clip: 6.3,
			loggy: 0.0184378,
			lut: new Float64Array(
				[	0.086897445,0.158925131,0.199263137,0.241244264,
					0.290010228,0.348221239,0.417126792,0.496076175,
					0.581700745,0.667766242,0.746717346,0.812590251,
					0.86214621,0.895831084,0.91668667,0.927087485,
					0.930959367 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG8009G40 (HG7)',
		{
			clip: 6.324,
			loggy: 0.0072,
			lut: new Float64Array(
				[	0.08797654,0.128135647,0.186195571,0.226012647,
					0.274212921,0.335341074,0.412483511,0.505912502,
					0.61090837,0.717257525,0.81246933,0.887758829,
					0.940377098,0.973389141,0.991844955,1.001278468,
					1.004289649 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'HG8009G33 (HG8)',
		{
			clip: 5.568,
			loggy: 0.0114,
			lut: new Float64Array(
				[	0.08797654,0.122144207,0.163936124,0.193789797,
					0.228638656,0.271257909,0.324762115,0.391105031,
					0.471722516,0.564565892,0.663932304,0.76057611,
					0.844909521,0.911004616,0.956498789,0.986149734,
					0.997564399 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'Cinegamma1',
		{
			clip: 4.987,
			loggy: 0.0129,
			lut: new Float64Array(
				[	0.08797654,0.116808731,0.151974786,0.180100256,
					0.210030322,0.24682835,0.291407476,0.346545743,
					0.414273303,0.495344317,0.588468737,0.688544076,
					0.787019889,0.874636069,0.942887027,0.991399694,
					1.011271456 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'Cinegamma2',
		{
			clip: 5.471,
			loggy: 0.00491,
			lut: new Float64Array(
				[	0.08797654,0.104192531,0.126464534,0.15295782,
					0.176615948,0.205826206,0.243989699,0.292906636,
					0.356424356,0.436709059,0.533166639,0.639815303,
					0.74453493,0.833365445,0.8969974,0.934175897,
					0.946701781 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Cinegamma3',
		{
			clip: 4.1,
			loggy: 0.01,
			lut: new Float64Array(
				[	0.078131789,0.09920475,0.122162118,0.151981053,
					0.181906428,0.220375167,0.267387627,0.325563795,
					0.394207316,0.484397908,0.591913512,0.681441253,
					0.753396056,0.817388645,0.879105528,0.936594209,
					0.994314701 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'Cinegamma4',
		{
			clip: 4.5,
			loggy: 0.01,
			lut: new Float64Array(
				[	0.077769272,0.095397854,0.120450392,0.156824535,
					0.196163068,0.242764534,0.297417162,0.357887286,
					0.430140946,0.515413669,0.618592194,0.705057939,
					0.771271414,0.832072263,0.885754684,0.936822309,
					0.987590161 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD1',
		{
			clip: 4,
			loggy: 0.017629,
			lut: new Float64Array(
				[	0.08797654,0.102779743,0.123103793,0.15204128,
					0.192300409,0.24825427,0.324632702,0.399870573,
					0.47660843,0.556285815,0.644181507,0.735266384,
					0.810806802,0.866443347,0.90467502,0.941259156,
					0.988794595 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD2 - x4.5',
		{
			clip: 4,
			loggy: 0.008254,
			lut: new Float64Array(
				[	0.08797654,0.098622061,0.114272152,0.137276217,
					0.171038737,0.220119176,0.274837007,0.33335793,
					0.399208497,0.472934824,0.558776425,0.660553828,
					0.764298918,0.842427286,0.893359663,0.933816378,
					0.985740801 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD3 - x3.5',
		{
			clip: 4,
			loggy: 0.020241,
			lut: new Float64Array(
				[	0.08797654,0.10445177,0.126912437,0.158425349,
					0.201870238,0.255736464,0.311556741,0.372989109,
					0.44362902,0.523307566,0.615503441,0.718323954,
					0.802280114,0.862208212,0.90256618,0.937483433,
					0.982351386 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD4 - SMPTE240M',
		{
			clip: 4,
			loggy: 0.019905,
			lut: new Float64Array(
				[	0.08797654,0.109381233,0.138901447,0.176210165,
					0.216932275,0.263165877,0.315600146,0.375268835,
					0.445421661,0.524947756,0.617187794,0.719160107,
					0.802696756,0.862488014,0.902446754,0.93785016,
					0.983542491 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD5 - Rec709',
		{
			clip: 4,
			loggy: 0.0203,
			lut: new Float64Array(
				[	0.08797654,0.112246952,0.145387857,0.183126966,
					0.224110408,0.270392689,0.323005008,0.382133984,
					0.451705404,0.530572659,0.621946987,0.722476974,
					0.804668815,0.863536358,0.903322935,0.938810956,
					0.984511672 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLUTSimple(
		'Sony STD6 - x5',
		{
			clip: 4,
			loggy: 0.019855,
			lut: new Float64Array(
				[	0.08797654,0.115025696,0.15175495,0.201870505,
					0.251515315,0.301256018,0.354820624,0.413032596,
					0.480142153,0.554913856,0.640879024,0.733933755,
					0.810921922,0.866540067,0.904779871,0.940303144,
					0.98630421 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Sony'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
/*
	this.gammas.push(new LUTGammaGen(
		'Canon WideDR',
		{
			blk: [ 4.143864904, 0.062733691 ],
			bot: [ 4.143864904, 0.062733691 ],
			low: [ 1.123724397, 0.023399556, 0.725329449, 1.793298155, 1.618753622, 1.512604528, 0.010239171 ],
			mid: [ 1.175009007, -0.889534156, 0.366778059, 1.74451447, 0.920944271, 0.662662566, 0.200816705 ],
			high: [ 1.075984367, 0.080088043, 0.54850957, 1.222465712, 1.162090342, 1.216780039, 1.001012923 ],
			top: [ 1.184590585, 0.32981997, 0.381916345, 1.047595142, 1.356034214, 1.40672617, 3.213458281 ]
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gammaDat.push(false);
	this.gammaExt.push(true);
*/
	this.gammas.push(new LUTGammaLUTSimple(
		'Canon WideDR',
		{
			clip: 6,
			loggy: 0.003936,
			lut: new Float64Array(
				[	0.062561095,0.083588769,0.114009387,0.15660632,
					0.208062502,0.270138527,0.344705558,0.433179626,
					0.533196849,0.625617722,0.710704057,0.787648239,
					0.854327941,0.909579605,0.954325784,0.993866446,
					1.028803 ]
			)
		}));
	this.gammaSub.push([this.subIdx('Canon'),this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(true);
	this.rec709 = this.gammas.length;
	this.gammas.push(new LUTGammaGam(
		'Rec709', [ 1/0.45, 4.50000000, 0.09900000, 0.01800000, 0.08100000, 1.9 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'Rec2020 12-bit', [ 1/0.45, 4.50000000, 0.09930000, 0.01810000, 0.08145000, 1.9 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'sRGB', [ 2.40000000,12.92000000, 0.05500000, 0.00313080, 0.04015966, 2.2 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('sRGB');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'DCI', [ 2.6,1, 0, 0.0000001, 0.0000001, 2.6 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLin(
		'Scene Linear IRE', 0.2));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaLin(
		'Scene Reflectance', 0.18));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaGam(
		'CIE L*', [ 3.0,24389.0 / 2700.0, 0.16, 216.0 / 24389.0 , 216.0 / 2700.0, 2.45 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('sRGB');
	this.gammaDat.push(false);
	this.gammaExt.push(false);

	this.gammas.push(new LUTGammaBBCGam(
		'BBC 0.4', [ 0.4,5, -0.02262, 0.037703, Math.pow((0.037703-0.02262)/(1-0.02262),0.4), false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaBBCGam(
		'BBC 0.5', [ 0.5,5, -0.01011, 0.020202, Math.pow((0.020202-0.01011)/(1-0.01011),0.5), false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaBBCGam(
		'BBC 0.6', [ 0.6,5, -0.00334, 0.008857, Math.pow((0.008857-0.00334)/(1-0.00334),0.6), false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('Rec709');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'ProPhoto / ROMM', [ 1.8,16, 0, Math.pow(16,1.8/-0.8), Math.pow(Math.pow(16,1.8/-0.8),1/1.8), 1.8 ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('ProPhoto RGB');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ1.5', [ 1.5,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ1.6', [ 1.6,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ1.7', [ 1.7,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ1.8', [ 1.8,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ1.9', [ 1.9,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.0', [ 2.0,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.1', [ 2.1,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.2', [ 2.2,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.3', [ 2.3,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.4', [ 2.4,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.5', [ 2.5,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaGam(
		'γ2.6', [ 2.6,1, 0, 0.0000001, 0.0000001, false ]));
	this.gammaSub.push([this.subIdx('Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
//
	this.pqOOTFIdx = this.gammas.length;
	this.gammas.push(this.pqOOTF);
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(this.pqOOTFNorm);
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.hlgOOTFIdx = this.gammas.length;
	this.gammas.push(this.hlgOOTF);
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(this.hlgOOTFNorm);
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('Rec2020');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
//
	this.gammas.push(new LUTGammaITUProp(
		'ITU Proposal (400%)', {m: 0.12314858 }));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaITUProp(
		'ITU Proposal (800%)', {m: 0.083822216783 }));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaBBC283(
		'BBC WHP283 (400%)', {m: 0.139401137752}));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaBBC283(
		'BBC WHP283 (800%)', {m: 0.097401889128}));
	this.gammaSub.push([this.subIdx('HDR Display')]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.LA = this.gammas.length;
	this.gammas.push(new LUTGammaLA(
		'LA', this.lutMaker));
	this.gammaSub.push([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]);
	this.gts.push('*');
	this.gammaDat.push(false);
	this.gammaExt.push(false);
	this.gammas.push(new LUTGammaNull(
		'Null'));
	this.gammaSub.push([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]);
	this.gts.push('*');
	this.gammaDat.push(true);
	this.gammaExt.push(false);
	var max = this.gammas.length;
	var logList = [], linList = [], genList = [], hdrList = [], ioList = [];
	var firstLin = false;
	var disList = [];
	for (var i=0; i < max; i++) {
		if (i === this.LA) {
			this.inList.push({name: 'Linear / γ', idx: 9999});
			this.outList.push({name: 'Linear / γ', idx: 9999});
		}
		this.catList[i] = this.gammas[i].cat;
		switch(this.gammas[i].cat) {
			case 0: logList.push({name: this.gammas[i].name, idx: i});
					this.inList.push({name: this.gammas[i].name, idx: i});
					this.outList.push({name: this.gammas[i].name, idx: i});
					break;
			case 1: /* if (!firstLin) {
						this.inList.push({name: 'Linear / γ', idx: 9999});
						this.outList.push({name: 'Linear / γ', idx: 9999});
						firstLin = true;
					} */
					if (this.gammas[i].gamma !== '') {
						this.linList.push({name: this.gammas[i].name + ' - ' + this.gammas[i].gamma, idx: i});
					} else {
						this.linList.push({name: this.gammas[i].name, idx: i});
					}
					if (this.gammas[i].name.indexOf('DCI') !== -1) {
						this.disList.push({name: 'DCI-P3', idx: i});
						this.disGts.push('P3 - DCI');
						this.disList.push({name: 'DCI-D60', idx: i});
						this.disGts.push('P3 - D60');
						this.disList.push({name: 'DCI-D65', idx: i});
						this.disGts.push('P3 - D65');
					} else if (this.gammas[i].name.indexOf('OOTF') === -1) {
						this.disList.push({name: this.gammas[i].name, idx: i});
						this.disGts.push(this.gts[i]);
					}
					this.dispInIdx = this.rec709;
					this.dispOutIdx = this.rec709;
/*
					// This allows HDR OOTFs to be on both the main list and the linear sublist
					if (this.gammas[i].hdrOOTF) {
						hdrList.push({name: this.gammas[i].name, idx: i});
						this.inList.push({name: this.gammas[i].name, idx: i});
						this.outList.push({name: this.gammas[i].name, idx: i});					}
*/
					break;

			case 2: genList.push({name: this.gammas[i].name, idx: i});
					this.outList.push({name: this.gammas[i].name, idx: i});
					break;
			case 3: this.outList.push({name: this.gammas[i].name, idx: i});
					break;
			case 5:
			case 7: hdrList.push({name: this.gammas[i].name, idx: i});
					this.inList.push({name: this.gammas[i].name, idx: i});
					this.outList.push({name: this.gammas[i].name, idx: i});
					if (this.gammas[i].name.indexOf('Rec2100') !== -1 || this.gammas[i].name.indexOf('PQ') !== -1) {
						disList.push({name: this.gammas[i].name, idx: i});
					}
					break;
			case 6: ioList.push({name: this.gammas[i].name, idx: i});
					this.inList.push({name: this.gammas[i].name, idx: i});
					this.outList.push({name: this.gammas[i].name, idx: i});
					break;
			default: break;
		}
	}
	max = disList.length;
	for (var i=0; i<max; i++) {
		this.disList.push(disList[i]);
		this.disGts.push(this.gts[disList[i].idx]);
	}
};
LUTGamma.prototype.displayCSMatrices = function() {
	// Rec709 toSys
	this.disInM.push(new Float64Array([0.6456794776099916, 0.25911454699971487, 0.09520597539029335, 0.08752999151186006, 0.7596995625540708, 0.1527704459340693, 0.03695741988752366, 0.12928090476633824, 0.8337616753461381]));
	// Rec2020 toSys
	this.disInM.push(new Float64Array([1.038144061903922, -0.0954526919638479, 0.0573086300599257, 0.047948922098344345, 0.7938618492737212, 0.15818922862793428, 0.030132054285551286, 0.040885792893120027, 0.9289821528213285]));
	// sRGB toSys
	this.disInM.push(new Float64Array([0.6456794776099916, 0.25911454699971487, 0.09520597539029335, 0.08752999151186006, 0.7596995625540708, 0.1527704459340693, 0.03695741988752366, 0.12928090476633824, 0.8337616753461381]));
	// DCI-P3 toSys
	this.disInM.push(new Float64Array([0.7284052217293149, 0.16972007915418877, 0.10187469911649552, 0.06583664487264183, 0.7683322228321781, 0.16583113229518043, 0.022366516069157787, 0.07128319107748499, 0.9063502928533571]));
	// DCI-D60 toSys
	this.disInM.push(new Float64Array([0.7946914170629898, 0.1026408043822886, 0.10266777855472128, 0.07452398482107307, 0.758588312905917, 0.16688770227300992, 0.024364185140024742, 0.06406449308408323, 0.9115713217758921]));
	// DCI-P65 toSys
	this.disInM.push(new Float64Array([0.7781515518174815, 0.1172862388356883, 0.10456220934682967, 0.07226831516524734, 0.7599479371836014, 0.16778374765115117, 0.023460426860374018, 0.0608411362976594, 0.9156984368419665]));
	// ProPhotoRGB toSys
	this.disInM.push(new Float64Array([1.2555250198288999, -0.17208107153730076, -0.0834439482915996, 0.005084768090106999, 0.8440643991075522, 0.15085083280234088, 0.03723287615234582, 0.018430596881984247, 0.9443365269656698]));
	// Rec709 fromSys
	this.disOutM.push(new Float64Array([1.626947409729081, -0.5401385388696355, -0.08680887085944519, -0.1785155271148767, 1.4179409274640788, -0.23942540034920257, -0.04443611500929754, -0.19591996617201543, 1.240356081181313]));
	// Rec2020 fromSys
	this.disOutM.push(new Float64Array([0.960046343810585, 0.11953297884015643, -0.07957932265074112, -0.052239479550917664, 1.2643057472387877, -0.21206626768786963, -0.028840506704261047, -0.05952096816347168, 1.088361474867733]));
	// sRGB fromSys
	this.disOutM.push(new Float64Array([1.626947409729081, -0.5401385388696355, -0.08680887085944519, -0.1785155271148767, 1.4179409274640788, -0.23942540034920257, -0.04443611500929754, -0.19591996617201543, 1.240356081181313]));
	// DCI-P3 fromSys
	this.disOutM.push(new Float64Array([1.4031705894567847, -0.30041923567015294, -0.10275135378663051, -0.11470806752635113, 1.3485540776963754, -0.23384601017002465, -0.025605199914686478, -0.09864828978558927, 1.124253489700276]));
	// DCI-D60 fromSys
	this.disOutM.push(new Float64Array([1.2771466836937062, -0.16317957410992093, -0.11396710958378524, -0.1198100995203766, 1.3542477763440348, -0.23443767682365865, -0.02571500923777254, -0.0908140240587726, 1.116529033296545]));
	// DCI-P65 fromSys
	this.disOutM.push(new Float64Array([1.306409074362619, -0.19250496531591546, -0.11390410904670316, -0.11858463137123738, 1.3529440482926134, -0.23435941692137607, -0.025591493745000585, -0.08496072664984984, 1.1105522203948506]));
	// ProPhotoRGB fromSys
	this.disOutM.push(new Float64Array([0.7945082685980932, 0.16100660920522486, 0.04448512219668231, 0.0008150912135569344, 1.1890558318454256, -0.18987092305898276, -0.031341423040583696, -0.029554874825018167, 1.060896297865602]));
};
// Matrix operations
LUTGamma.prototype.mInverse = function(M) {
	var det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
				(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
				(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	if (det === 0) {
		return false;
	}
	return new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
LUTGamma.prototype.mMult = function(m1,m2) {
	if (m1.length !== 9) {
		return false;
	}
	var len = m2.length;
	if (len === 3) {
		var out = new Float64Array(3);
		out[0] = (m1[0]*m2[0]) + (m1[1]*m2[1]) + (m1[2]*m2[2]);
		out[1] = (m1[3]*m2[0]) + (m1[4]*m2[1]) + (m1[5]*m2[2]);
		out[2] = (m1[6]*m2[0]) + (m1[7]*m2[1]) + (m1[8]*m2[2]);
		return out;
	} else if (len === 9) {
		var out = new Float64Array(9);
		out[0] = (m1[0]*m2[0]) + (m1[1]*m2[3]) + (m1[2]*m2[6]);
		out[1] = (m1[0]*m2[1]) + (m1[1]*m2[4]) + (m1[2]*m2[7]);
		out[2] = (m1[0]*m2[2]) + (m1[1]*m2[5]) + (m1[2]*m2[8]);
		out[3] = (m1[3]*m2[0]) + (m1[4]*m2[3]) + (m1[5]*m2[6]);
		out[4] = (m1[3]*m2[1]) + (m1[4]*m2[4]) + (m1[5]*m2[7]);
		out[5] = (m1[3]*m2[2]) + (m1[4]*m2[5]) + (m1[5]*m2[8]);
		out[6] = (m1[6]*m2[0]) + (m1[7]*m2[3]) + (m1[8]*m2[6]);
		out[7] = (m1[6]*m2[1]) + (m1[7]*m2[4]) + (m1[8]*m2[7]);
		out[8] = (m1[6]*m2[2]) + (m1[7]*m2[5]) + (m1[8]*m2[8]);
		return out;
	} else {
		return false;
	}
};
// Parameter setting functions
LUTGamma.prototype.setASCCDL = function(params) {
	var out = {};
	this.doASCCDL = false;
	this.changedASCCDL = false;
	if (this.tweaks && typeof params.twkASCCDL !== 'undefined') {
		var p = params.twkASCCDL;
		if (typeof p.doASCCDL === 'boolean') {
			var didASCCDL = this.doASCCDL;
			this.doASCCDL = p.doASCCDL;	
			if (didASCCDL && !this.doASCCDL) {
				this.changedASCCDL = true;
			}
		}
		if (typeof p.cdl !== 'undefined') {
			var newCDL = new Float64Array(p.cdl);
			for (var j=0; j<10; j++) {
				if (newCDL[j] !== this.asc[j]) {
					this.asc = newCDL;
					if (j < 9) {
						this.changedASCCDL = true;
					}
					break;
				}
			}
		}
	}
	out.doASCCDL = this.doASCCDL;
	return out;
};
LUTGamma.prototype.setKnee = function(params) {
	var out = {};
	this.doKnee = false;
	if (this.tweaks && typeof params.twkKnee !== 'undefined') {
		var p = params.twkKnee;
		if (typeof p.doKnee === 'boolean') {
			this.doKnee = p.doKnee;	
		}
		var legal = true;
		if (typeof p.legal === 'boolean') {
			legal = p.legal;
		}
		var max = false;
		for (var j=8; j>0; j -= 0.1) {
			if (this.f(j) <= 0.95) {
				max = j;
				break;
			}
		}
		out.max = max;
		if (typeof p.smoothness === 'number') {
			this.kSmooth = p.smoothness;
		}
		if (typeof p.kneeStart !== 'number' || typeof p.kneeClip !== 'number' || typeof p.clipSlope !== 'number') {
			this.doKnee = false;
		} else {
			this.kS = p.kneeStart;
			if (this.kS > max) {
				this.kS = max;
				out.kneeStart = this.kS;
			}
			this.kL = Math.pow(2,this.kS)*0.2;
			this.kC = p.kneeClip;
			if (this.doASCCDL) {
				var kC = Math.pow(2,this.kC)*0.2;
				var rA,gA,bA;
				rA = (kC*this.asc[0])+this.asc[3];
				rA = 0.2126*((rA<0)?rA:Math.pow(rA,this.asc[6]));
				gA = (kC*this.asc[1])+this.asc[4];
				gA = 0.7152*((gA<0)?gA:Math.pow(gA,this.asc[7]));
				bA = (kC*this.asc[2])+this.asc[5];
				bA = 0.0722*((bA<0)?bA:Math.pow(bA,this.asc[8]));
				kC = ((isNaN(rA)?0:rA)+(isNaN(gA)?0:gA)+(isNaN(bA)?0:bA));	// if ASCCDL ends up pushing highlights higher, change kCl, if not leave as is
				this.kC = Math.log(kC/0.2)/Math.LN2;
			}
			this.kR = this.kC - this.kS;
			this.kp0 = this.f(this.kS);
			if (legal) {
				this.kp2 = 0.99;
			} else {
				this.kp2 = (959/876)-0.01;
			}
			this.kd0 = (this.f(this.kS+0.001)-this.f(this.kS-0.001))*this.kR/0.002;
			this.kD2 = p.clipSlope/100;
			this.kd2 = this.kD2*this.kR;

			var a = (2 * this.kp0) + this.kd0 - (2 * this.kp2) + this.kd2;
			var b = - (3 * this.kp0) - (2 * this.kd0) + (3 * this.kp2) - this.kd2;
			var c = this.kd0;
			var d = this.kp0;
			this.ks = 0.5;
			this.kp1 = ((((((a * this.ks) + b) * this.ks) + c) * this.ks) + d);
			this.kd1 = ((((((a * (this.ks+0.001)) + b) * (this.ks+0.001)) + c) * (this.ks+0.001))-(((((a * (this.ks-0.001)) + b) * (this.ks-0.001)) + c) * (this.ks-0.001)))/0.002;

			this.kd0 /= 2;
			this.kd1 /= 2;
			this.kd2 /= 2;
			if (this.kd0 < 0) {
				this.doKnee = false;
				out.doKnee = false;
			} else {
				var a0,b0,c0,sqr0,sqrt0,r0p,r0m;
				var a1,b1,c1,sqr1,sqrt1,r1p,r1m;
				var rat;
				var kd0,kd1a,kd1b,kd2;
				var kp1 = this.kp1;
				var kd1 = this.kd1;

				this.kp1 = Math.min(this.kp1,(0.1*this.kp0)+((0.9)*this.kp2));
				this.kd1 = Math.max(this.kd1,(this.kp2-this.kp1)/0.9);

				kd0 = this.kd0 / (2*(1-this.ks));
				kd1a = this.kd1 / (2*(1-this.ks));
				kd1b = this.kd1 / (2*this.ks);
				kd2 = this.kd2 / (2*this.ks);

				a0 = (2 * this.kp0) + kd0 - (2 * this.kp1) + kd1a;
				b0 = - (3 * this.kp0) - (2 * kd0) + (3 * this.kp1) - kd1a;
				c0 = kd0;
				sqr0 = (b0*b0) - (3*a0*c0);
				a1 = (2 * this.kp1) + kd1b - (2 * this.kp2) + kd2;
				b1 = - (3 * this.kp1) - (2 * kd1b) + (3 * this.kp2) - kd2;
				c1 = kd1b;
				sqr1 = (b1*b1) - (3*a1*c1);

				if (sqr0 >=0 || sqr1 >= 0) { // real roots
					sqrt0 = Math.pow(sqr0,0.5);
					r0p = (- b0 + sqrt0)/(3*a0);
					r0m = (- b0 - sqrt0)/(3*a0);
//					sqrt1 = Math.pow(sqr1,0.5);
//					r1p = (- b1 + sqrt1)/(3*a1);
//					r1m = (- b1 - sqrt1)/(3*a1);
					if (!isNaN(sqrt0) && ((r0p>0 && r0p<1) || (r0m>0 && r0m<1))) { // the knee is not monotonic
						this.kp1 = (0.1*this.kp0)+((0.9)*this.kp2);
						this.kd1 = (this.kp1 - this.kp0)*1.29/6.59;
						this.ks = ((10.89*this.kd1)/(1.29*this.kd0));
					}
				}
			}
		}
	}
	return out;
};
LUTGamma.prototype.setBlkHi = function(params) {
	var out = {};
	this.al = 1;
	this.bl = 0;
	this.ad = 1;
	this.bd = 0;
	this.doBlkHi = false;
	if (this.tweaks && typeof params.twkBlkHi !== 'undefined') {
		var p = params.twkBlkHi;
		var changedRef = false;
		if (typeof p.highRef === 'number') {
			if (this.highRef !== p.highRef) {
				changedRef = true;
			}
			this.highRef = p.highRef;
		} else {
			this.highRef = 0.9;
		}
		var bhDef = new Float64Array([ 0,this.highRef/0.9 ]);
		this.getLumVals(bhDef.buffer);
		var blackDefault = bhDef[0];
		var highDefault = bhDef[1];
		var blackLock = false;
		if (typeof p.blackLock === 'boolean') {
			blackLock = p.blackLock;
		}
		var highLock = false;
		if (typeof p.highLock === 'boolean') {
			highLock = p.highLock;
		}
		var blackMap;
		if (typeof p.blackLevel === 'number') {
			if (blackLock || (Math.abs(blackDefault-p.blackLevel)>0.0001 && !this.changedOut && !this.changedASCCDL && !this.changedHDR)) {
				blackMap = p.blackLevel;
			} else {
				blackMap = blackDefault;
			}
		} else {
			blackMap = blackDefault;
		}
		var highMap;
		if (typeof p.highMap === 'number') {
			if (highLock || (Math.abs(highDefault-p.highMap)>0.0001 && !this.changedOut && !changedRef && !this.changedASCCDL && !this.changedHDR)) {
				highMap = p.highMap;
			} else {
				highMap = highDefault;
			}
		} else {
			highMap = highDefault;
		}
		out.blackDef = blackDefault;
		out.blackLevel = blackMap;
		out.highRef = this.highRef;
		out.highDef = highDefault;
		out.high709 = this.gammas[this.rec709].linToLegal(this.highRef/0.9);
		out.highMap = highMap;
		out.hmmm=p;
		if (typeof p.doBlkHi === 'boolean' && p.doBlkHi) {
			if (!p.doBlack) {
				blackMap = blackDefault;
			}
			if (!p.doHigh) {
				highMap = highDefault;
			}
			if (!this.nul && (p.doBlack || p.doHigh)) {
				this.al = (highMap - blackMap)/(highDefault - blackDefault);
				this.bl = blackMap - (blackDefault * this.al);
				this.ad = this.al;
				this.bd = ((876*(blackMap - (this.al*blackDefault))) + (64*(1- this.al)))/1023;
				this.doBlkHi = true;
			}
		}
	} else {
		var bhDef = new Float64Array([ 0,this.highRef/0.9 ]);
		this.getLumVals(bhDef.buffer);
		var blackDefault = bhDef[0];
		var highDefault = bhDef[1];
		out.blackDef = blackDefault;
		out.blackLevel = blackDefault;
		out.highRef = 0.9;
		out.highDef = highDefault;
		out.high709 = this.gammas[this.rec709].linToLegal(this.highRef/0.9);
		out.highMap = highDefault;
	}
	if (this.gammas[this.curOut].cat === 3){
		this.doBlkHi = false;
	}
	out.doBlkHi = this.doBlkHi;
	return out;
};
LUTGamma.prototype.setBlkGam = function(params) {
	var out = {};
	this.doBlkGam = false;
	if (this.tweaks && typeof params.twkBlkGam !== 'undefined') {
		var p = params.twkBlkGam;
		if (typeof p.doBlkGam === 'boolean') {
			this.doBlkGam = p.doBlkGam;	
		}
		if (typeof p.upperLim === 'number') {
			this.blkGamLStop = p.upperLim;
		}
		if (typeof p.feather === 'number') {
			this.blkGamFStop = p.feather;
		}
		if (typeof p.power === 'number') {
			this.blkGamP = p.power;
		}
	}
	var vals = new Float64Array([
		0,
		Math.pow(2,this.blkGamLStop)*0.2,
		Math.pow(2,this.blkGamLStop - this.blkGamFStop)*0.2
	]);
	this.getLumVals(vals.buffer);
	if (this.doBlkHi) {
		this.blkLevel = (vals[0]*this.al)+this.bl;
		this.blkGamUL = (vals[1]*this.al)+this.bl;
		this.blkGamLL = (vals[2]*this.al)+this.bl;
	} else {
		this.blkLevel = vals[0];
		this.blkGamUL = vals[1];
		this.blkGamLL = vals[2];
	}
	this.blkGamF = this.blkGamUL - this.blkGamLL;
/*
	this.blkGamLL = this.blkGamUL-this.blkGamF;
	out.doBlkGam = this.doBlkGam;
	var blk = new Float64Array([ 0 ]);
	this.getLumVals(blk.buffer);
	if (this.doBlkHi) {
		this.blkLevel = (blk[0]*this.al)+this.bl;

	} else {
		this.blkLevel = blk[0];
	}
*/
	this.blkGamR = this.blkGamUL-this.blkLevel;
	out.blkLevel = this.blkLevel;
	return out;
};
LUTGamma.prototype.setDisplay = function(params) {
	var out = {};
	this.doDisplay = false;
	if (this.tweaks && typeof params.twkDisplay !== 'undefined') {
		var p = params.twkDisplay;
		if (typeof p.doDisplay === 'boolean') {
			this.doDisplay = p.doDisplay;	
		}
		if (typeof p.inIdx === 'number') {
			this.dispInIdx = p.inIdx;
		}
		if (typeof p.outIdx === 'number') {
			this.dispOutIdx = p.outIdx;
		}
		if (typeof p.inGt === 'number') {
			this.dispInGt = p.inGt;
		}
		if (typeof p.outGt === 'number') {
			this.dispOutGt = p.outGt;
		}
		if (this.doDisplay) {
			this.disM = this.mMult(this.disOutM[this.dispOutGt], this.disInM[this.dispInGt]);
		}
	}
	return out;
};
// Adjustment functions
LUTGamma.prototype.f = function(x) {
	x = Math.pow(2,x)/5;
	if (this.nul) {
		return x;
	} else {
		var out = x;
		return this.gammas[this.curOut].linToLegal(out);
	}
};
LUTGamma.prototype.getLumVals = function(linBuff, p) {
	var lin = new Float64Array(linBuff);
	var m = lin.length;
	var vals = new Float64Array(m*3);
	var buff = vals.buffer;
	for (var j=0; j<m; j++) {
		vals[ (j*3) ] = lin[j];
		vals[(j*3)+1] = lin[j];
		vals[(j*3)+2] = lin[j];
	}
	if (p) {
		if (this.doASCCDL) {
			this.ASCCDLOut(buff, p)
		}
		if (this.doKnee) {
			this.kneeOut(buff, p);
		} else {
			this.gammas[this.curOut].linToL(buff, p);
		}
	} else {
		if (this.doASCCDL) {
			this.ASCCDLOut(buff)
		}
		if (this.doKnee) {
			this.kneeOut(buff);
		} else {
			this.gammas[this.curOut].linToL(buff);
		}
	}
	for (var j=0; j<m; j++) {
		lin[j] =  (0.2126*vals[ (j*3) ]) + (0.7152*vals[(j*3)+1]) + (0.0722*vals[(j*3)+2]);
	}
};
LUTGamma.prototype.kneeVal = function(lin) {
	var out = lin;
	out = this.gammas[this.curOut].linToLegal(out);
	if (lin >= this.kL) {
		var s = Math.log(lin/0.2)/Math.LN2;
		var s,s2;
		var kd0,kd1,kd2;
		var a,b,c,d;
		if (s < this.kC) {
			s = (s - this.kS) / (this.kC - this.kS);
			if (s < this.ks) {
				kd0 = this.kd0 / (2*(1-this.ks));
				kd1 = this.kd1 / (2*(1-this.ks));
				s2 = s/this.ks;
				a = (2 * this.kp0) + kd0 - (2 * this.kp1) + kd1;
				b = - (3 * this.kp0) - (2 * kd0) + (3 * this.kp1) - kd1;
				c = kd0;
				d = this.kp0;
			} else {
				kd1 = this.kd1 / (2*this.ks);
				kd2 = this.kd2 / (2*this.ks);
				s2 = (s-this.ks)/(1-this.ks);
				a = (2 * this.kp1) + kd1 - (2 * this.kp2) + kd2;
				b = - (3 * this.kp1) - (2 * kd1) + (3 * this.kp2) - kd2;
				c = kd1;
				d = this.kp1;
			}
			out = (((((((a * s2) + b) * s2) + c) * s2) + d)*this.kSmooth) + (((this.kp0*(1-s))+(this.kp2*s))*(1-this.kSmooth));
		} else {
			out = this.kp2 + ((s - this.kC)*this.kD2);
		}
	}
	return out;
};
LUTGamma.prototype.ASCCDLOut = function(buff) {
	var vals = new Float64Array(buff);
	var m = vals.length;
	var l;
	for (var j=0; j<m; j += 3) {
		// Red
		l = vals[ j ];
		l = (l*this.asc[0])+this.asc[3];
		l = ((l<0)?l:Math.pow(l,this.asc[6]));
		vals[ j ] = (isNaN(l)?0:l);
		// Green
		l = vals[j+1];
		l = (l*this.asc[1])+this.asc[4];
		l = ((l<0)?l:Math.pow(l,this.asc[7]));
		vals[j+1] = (isNaN(l)?0:l);
		// Blue
		l = vals[j+2];
		l = (l*this.asc[2])+this.asc[5];
		l = ((l<0)?l:Math.pow(l,this.asc[8]));
		vals[j+2] = (isNaN(l)?0:l);
	}
};
LUTGamma.prototype.kneeOut = function(buff, p) {
	var lin = new Float64Array(buff.slice(0));
	var out = new Float64Array(buff);
	if (p) {
		this.gammas[this.curOut].linToL(buff,p);
	} else {
		this.gammas[this.curOut].linToL(buff);
	}
	var m = out.length;
	var s,s2;
	var kd0,kd1,kd2;
	var a,b,c,d;
	for (var j=0; j<m; j++) {
		if (lin[j] >= this.kL) {
			s = Math.log(lin[j]/0.2)/Math.LN2;
			if (s < this.kC) {
				s = (s - this.kS) / (this.kC - this.kS);
				if (s < this.ks) {
					kd0 = this.kd0 / (2*(1-this.ks));
					kd1 = this.kd1 / (2*(1-this.ks));
					s2 = s/this.ks;
					a = (2 * this.kp0) + kd0 - (2 * this.kp1) + kd1;
					b = - (3 * this.kp0) - (2 * kd0) + (3 * this.kp1) - kd1;
					c = kd0;
					d = this.kp0;
				} else {
					kd1 = this.kd1 / (2*this.ks);
					kd2 = this.kd2 / (2*this.ks);
					s2 = (s-this.ks)/(1-this.ks);
					a = (2 * this.kp1) + kd1 - (2 * this.kp2) + kd2;
					b = - (3 * this.kp1) - (2 * kd1) + (3 * this.kp2) - kd2;
					c = kd1;
					d = this.kp1;
				}
				out[j] = (((((((a * s2) + b) * s2) + c) * s2) + d)*this.kSmooth) + (((this.kp0*(1-s))+(this.kp2*s))*(1-this.kSmooth));
			} else {
				out[j] = this.kp2 + ((s - this.kC)*this.kD2);
			}
		}
	}
};
LUTGamma.prototype.blkHiOut = function(buff) {
	var out = new Float64Array(buff);
	var m = out.length;
	for (var j=0; j<m; j++) {
		out[j] = (out[j]*this.al)+this.bl;
	}
};
LUTGamma.prototype.blkGamOut = function(buff) {
	var out = new Float64Array(buff);
	var m = out.length;
	var r,bg;
	for (var j=0; j<m; j++) {
		if (out[j] > this.blkLevel && out[j] <= this.blkGamUL) {
			if (out[j] > this.blkGamLL) {
				bg = (Math.pow((out[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
				if (out[j] <= bg) {
					out[j] = bg;
				} else {
					r = (out[j]-this.blkGamLL)/this.blkGamF;
					r *= r;
					out[j] = (r*out[j]) + ((1-r)*bg);
				}
			} else {
				out[j] = (Math.pow((out[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
			}
		}
	}
};
LUTGamma.prototype.gamutLimOut = function(buff, gY, gL, ogb, gLimB) {
	var o = new Float64Array(buff);
	var m = o.length;
	var gMX, gMN, gSat, og;
	if (typeof ogb !== 'undefined') { // Protect Secondary
		// Knee
		if (this.doKnee) {
			this.kneeOut(ogb, { rgb: true });
		} else {
			this.gammas[this.curOut].linToL(ogb, { rgb: true });
		}
		// Black Level / Highlight Level
		if (this.doBlkHi) {
			this.blkHiOut(ogb);
		}
		// Black Gamma
		if (this.doBlkGam) {
			this.blkGamOut(ogb);
		}
		// Display Colourspace Conversion
		if (this.doDisplay) {
			this.displayOut(ogb, { rgb: true });
		}
		og = new Float64Array(ogb);
		if (gLimB) { // Protect Both
			for (var j=0; j<m; j += 3) {
				o[ j ] = Math.max(0, o[ j ]);
				o[j+1] = Math.max(0, o[j+1]);
				o[j+2] = Math.max(0, o[j+2]);
				var gMX2, gMN2;
				gMX = Math.max(og[ j ], og[j+1], og[j+2]);
				gMN = Math.min(og[ j ], og[j+1], og[j+2]);
				gMX2 = Math.max(o[ j ], o[j+1], o[j+2]);
				gMN2 = Math.min(o[ j ], o[j+1], o[j+2]);
				gSat = Math.max(gMX - gMN, gMX2 - gMN2)/gL;
				if (gSat > 1) {
					Y = (gY[0]*o[j])+(gY[1]*o[j+1])+(gY[2]*o[j+2]);
					o[ j ] = Y + ((o[ j ]-Y)/gSat);
					o[j+1] = Y + ((o[j+1]-Y)/gSat);
					o[j+2] = Y + ((o[j+2]-Y)/gSat);
				}
			}
		} else { // Protect Secondary
			for (var j=0; j<m; j += 3) {
				o[ j ] = Math.max(0, o[ j ]);
				o[j+1] = Math.max(0, o[j+1]);
				o[j+2] = Math.max(0, o[j+2]);
				gMX = Math.max(og[ j ], og[j+1], og[j+2]);
				gMN = Math.min(og[ j ], og[j+1], og[j+2]);
				gSat = (gMX - gMN)/gL;
				if (gSat > 1) {
					Y = (gY[0]*o[j])+(gY[1]*o[j+1])+(gY[2]*o[j+2]);
					o[ j ] = Y + ((o[ j ]-Y)/gSat);
					o[j+1] = Y + ((o[j+1]-Y)/gSat);
					o[j+2] = Y + ((o[j+2]-Y)/gSat);
				}
			}
		}
	} else { // Protect Primary
		for (var j=0; j<m; j += 3) {
			o[ j ] = Math.max(0, o[ j ]);
			o[j+1] = Math.max(0, o[j+1]);
			o[j+2] = Math.max(0, o[j+2]);
			gMX = Math.max(o[ j ], o[j+1], o[j+2]);
			if (gMX > gL) {
				gMN = Math.min(o[ j ], o[j+1], o[j+2]);
				gSat = (gMX - gMN)/gL;
				if (gSat > 1) {
					Y = (gY[0]*o[j])+(gY[1]*o[j+1])+(gY[2]*o[j+2]);
					o[ j ] = Y + ((o[ j ]-Y)/gSat);
					o[j+1] = Y + ((o[j+1]-Y)/gSat);
					o[j+2] = Y + ((o[j+2]-Y)/gSat);
				}
			}
		}
	}
};
LUTGamma.prototype.displayOut = function(buff, p) {
	if (p) {
		p.out = true;
		this.gammas[this.dispInIdx].linFromL(buff,p);
		if (p.rgb && this.dispInGt !== this.dispOutGt) {
			var c = new Float64Array(buff);
			var m = c.length;
			var M = this.disM;
			var r,g,b;
			for (var j=0; j<m; j+= 3) {
				r = c[ j ];
				g = c[j+1];
				b = c[j+2];
				c[ j ] = (M[0]*r)+(M[1]*g)+(M[2]*b);
				c[j+1] = (M[3]*r)+(M[4]*g)+(M[5]*b);
				c[j+2] = (M[6]*r)+(M[7]*g)+(M[8]*b);
			}
		}
		this.gammas[this.dispOutIdx].linToL(buff,p);
	} else {
		this.gammas[this.dispInIdx].linFromL(buff, { out: true });
		this.gammas[this.dispOutIdx].linToL(buff);
	}
};
LUTGamma.prototype.fcOut = function(fcBuff,outBuff) {
	var fc = new Uint8Array(fcBuff);
	var o = new Float64Array(outBuff);
	var m = o.length;
	var l = 0;
	for (var j=0; j<m; j+= 3) {
		switch(fc[l]) {
			case 0: o[ j ] = 0.75;	o[j+1] = 0;		o[j+2] = 0.75;	// Purple
				break;
			case 1: o[ j ] = 0;		o[j+1] = 0;		o[j+2] = 0.75;	// Blue
				break;
			case 3: o[ j ] = 0;		o[j+1] = 0.7;	o[j+2] = 0;		// Green
				break;
			case 5: o[ j ] = 0.75;	o[j+1] = 0.35;	o[j+2] = 0.35;	// Pink
				break;
			case 7: o[ j ] = 0.9;	o[j+1] = 0.45;	o[j+2] = 0;		// Orange
				break;
			case 9: o[ j ] = 0.7;	o[j+1] = 0.7;	o[j+2] = 0;		// Yellow
				break;
			case 10: o[ j ] = 0.75;	o[j+1] = 0;		o[j+2] = 0;		// Red
				break;
		}
		l++;
	}
};
LUTGamma.prototype.finalOut = function(buff,cb) {
	var out = new Float64Array(buff);
	var m = out.length;
	var cMin,cMax;
	if (this.outL) {
		if (cb) {
			cMin = 0;
		} else {
			cMin = (this.bClip - 64)/876;
		}
		cMax = (this.wClip - 64)/876;
	} else {
		if (cb) {
			cMin = 64/1023;
		} else {
			cMin = this.bClip / 1023;
		}
		cMax = this.wClip / 1023;
	}
	if (this.clip) {
		if (this.outL || !this.clipL) {
			if (this.clipB && cMin<0) {
				cMin = 0;
			}
			if (this.clipW && cMax>1) {
				cMax = 1;
			}
		} else {
			if (this.clipB && cMin<64/1023) {
				cMin = 64/1023;
			}
			if (this.clipW && cMax>959/1023) {
				cMax = 959/1023;
			}
		}
	}
	if (this.hdrOut && !this.doDisplay) {
		var mx = this.gammas[this.curOut].mxO;
		if (this.outL) {
			if (mx < cMax) {
				cMax = mx;
			}
		} else {
			mx = (mx * 0.85630498533724) + 0.06256109481916;
			if (mx < cMax) {
				cMax = mx;
			}
		}
	}
	for (var j=0; j<m; j++) {
		if (!this.outL) {
			out[j] = ((out[j]*876)+64)/1023;
		}
		out[ j ] = Math.min(cMax,Math.max(cMin,out[ j ]));
	}
};
// Transfer function calculation objects
// Generalised Log
function LUTGammaLog(name,params) {
	this.name = name;
	this.params = params;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaLog.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLog.prototype.changeContrast = function(rec,out) {
};
LUTGammaLog.prototype.changeRange = function(rec,out) {
};
LUTGammaLog.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[8]) {
			c[j] = (this.params[2] * Math.log((c[j] * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
		} else if (this.params[0] === 0) {
			c[j] = (this.params[2] * Math.log((0.000000000000001 * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
		} else {
			c[j] = (c[j] - this.params[1])/this.params[0];
		}
	}
};
LUTGammaLog.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLog.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[7]) {
			c[j] = (Math.pow(this.params[4],(c[j] - this.params[5])/this.params[2]) - this.params[6])/this.params[3];		
		} else {
			c[j] = (this.params[0]*c[j]) + this.params[1];
		}
	}
};
LUTGammaLog.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaLog.prototype.linToData = function(input) {
	if (input >= this.params[8]) {
		return (this.params[2] * Math.log((input * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
	} else if (this.params[0] === 0) {
		return (this.params[2] * Math.log((0.000000000000001 * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
	} else {
		return (input - this.params[1])/this.params[0];
	}
};
LUTGammaLog.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaLog.prototype.linFromData = function(input) {
	if (input >= this.params[7]) {
		return (Math.pow(this.params[4],(input - this.params[5])/this.params[2]) - this.params[6])/this.params[3];		
	} else {
		return (this.params[0]*input) + this.params[1];
	}
};
LUTGammaLog.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// Generalised Log with a soft clip
function LUTGammaLogClip(name,params) {
	this.name = name;
	this.params = params;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaLogClip.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLogClip.prototype.changeContrast = function(rec,out) {
};
LUTGammaLogClip.prototype.changeRange = function(rec,out) {
};
LUTGammaLogClip.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[10]) {
			c[j] = ((Math.log(c[j]/0.2)/Math.log(2)) - this.params[12])/this.params[11];
		} else if (c[j] >= this.params[8]) {
			c[j] = (this.params[2] * Math.log((c[j] * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
		} else if (this.params[0] === 0) {
			c[j] = (this.params[2] * Math.log((0.000000000000001 * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
		} else {
			c[j] = (c[j] - this.params[1])/this.params[0];
		}
	}
};
LUTGammaLogClip.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLogClip.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[9]) {
			c[j] = Math.pow(2,(this.params[11]*c[j]) + this.params[12])*0.2;
		} else if (c[j] >= this.params[7]) {
			c[j] = (Math.pow(this.params[4],(c[j] - this.params[5])/this.params[2]) - this.params[6])/this.params[3];		
		} else {
			c[j] = (this.params[0]*c[j]) + this.params[1];
		}
	}
};
LUTGammaLogClip.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaLogClip.prototype.linToData = function(input) {
	if (input >= this.params[10]) {
		return ((Math.log(input/0.2)/Math.log(2)) - this.params[12])/this.params[11];
	} else if (input >= this.params[8]) {
		return (this.params[2] * Math.log((input * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
	} else if (this.params[0] === 0) {
		return (this.params[2] * Math.log((0.000000000000001 * this.params[3]) + this.params[6])/Math.log(this.params[4])) + this.params[5];
	} else {
		return (input - this.params[1])/this.params[0];
	}
};
LUTGammaLogClip.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaLogClip.prototype.linFromData = function(input) {
	if (input >= this.params[9]) {
		return Math.pow(2,(this.params[11]*input) + this.params[12])*0.2;
	} else if (input >= this.params[7]) {
		return (Math.pow(this.params[4],(input - this.params[5])/this.params[2]) - this.params[6])/this.params[3];		
	} else {
		return (this.params[0]*input) + this.params[1];
	}
};
LUTGammaLogClip.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// Cineon Variants
function LUTGammaCineon(name,params) {
	this.name = name;
	this.cv = params.cv
	this.mul = params.cv2d/params.nGamma;
	this.wp = params.wp;
	this.bl = Math.pow(10,(params.bp-this.wp)*this.mul);
	this.den = 0.9*(1 - this.bl);
	this.p0 = (Math.pow(10,-this.wp*this.mul) - this.bl)/this.den;
	this.d0 = (((Math.pow(10,((0.0001*this.cv)-this.wp)*this.mul) - this.bl)/this.den)-this.p0)/0.0001;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaCineon.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaCineon.prototype.changeContrast = function(rec,out) {
};
LUTGammaCineon.prototype.changeRange = function(rec,out) {
};
LUTGammaCineon.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < this.p0) {
			c[j] = (c[j] - this.p0)/this.d0;
		} else {
			c[j] = ((Math.log((c[j]*this.den)+this.bl)/(Math.LN10*this.mul))+this.wp)/this.cv;
		}
	}
};
LUTGammaCineon.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaCineon.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = (c[j]*this.d0) + this.p0;
		} else {
			c[j] = (Math.pow(10,((c[j]*this.cv)-this.wp)*this.mul) - this.bl)/this.den;
		}
	}
};
LUTGammaCineon.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaCineon.prototype.linToData = function(input) {
	if (input < this.p0) {
		return (input - this.p0)/this.d0;
	} else {
		return ((Math.log((input*this.den)+this.bl)/(Math.LN10*this.mul))+this.wp)/this.cv;
	}
};
LUTGammaCineon.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaCineon.prototype.linFromData = function(input) {
	if (input < 0) {
		return (input*this.d0) + this.p0;
	} else {
		return (Math.pow(10,((input*this.cv)-this.wp)*this.mul) - this.bl)/this.den;
	}
};
LUTGammaCineon.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// ARRI LogC
function LUTGammaArri(name,sup) {
	this.name = name;
	this.sup = sup;
	this.iso = 800;
	this.cat = 0;
	this.params = [];
	this.tHK = [];
	this.fHK = [];
	this.tHS = 0.0;
	this.fHS = 0.0;
	this.knee = false;
	this.xm = 0.0;
	if (this.sup === 2) {
		this.recleg = false;
		this.outleg = false;
		this.nominalEI = 400;
		this.blackSignal = 0.003907;
		this.blackOffset = 0.000977;
		this.midGraySignal = 0.01;
		this.encodingGain = 0.256598;
		this.encodingOffset = 0.391007;		
	} else {
		this.recleg = true;
		this.outleg = true;
		this.nominalEI = 400;
		this.blackSignal = 16.0 / 4095.0;
		this.blackOffset = 0.0; // unused
		this.midGraySignal = 0.01;
		this.encodingGain = (500.0 / 1023.0) * 0.525;
		this.encodingOffset = 400.0 / 1023.0;
	}
	this.changeISO(this.iso);
}
LUTGammaArri.prototype.getParams = function(ei) {
	var gain = ei / this.nominalEI;
	var out = [];
	if (this.sup === 2) {
		var encGain = (Math.log(gain)/Math.LN2 * (0.89 - 1) / 3 + 1) * this.encodingGain;
		var midGray = this.midGraySignal + this.blackOffset;
		var f16 = (Math.log((((this.blackSignal) 				- this.blackSignal) * gain + this.blackOffset) / midGray)/Math.LN10) * encGain + this.encodingOffset;
		var f17 = (Math.log((((this.blackSignal + 1.0 / 4095.0) - this.blackSignal) * gain + this.blackOffset) / midGray)/Math.LN10) * encGain + this.encodingOffset;
		out[0] = this.blackSignal;										// cut
		out[4] = this.encodingOffset;									// d
		out[3] = encGain;											// c
		out[2] = this.blackOffset / midGray;								// b
		out[1] = (gain / midGray)/(gain * (0.18 / this.midGraySignal));	// a
		out[6] = f16;												// f
		out[5] = 4095.0 * (f17-f16)/(gain*(0.18 / this.midGraySignal));	// e
		out[7] = 0.0;												// xm - not used in sup 2
		out[8] = 0.0;												// x1 - not used in sup 2
		out[9] = 0.0;												// x2 - not used in sup 2
		out[10] = 0.0;												// not used in sup 2
		out[11] = 0.0;												// not used in sup 2
		out[12] = 0.0;												// not used in sup 2
		out[13] = 0.0;												// not used in sup 2
	} else {
		out[0] = 1.0 / 9.0;											// cut
		var slope = 1.0 / (out[0] * Math.LN10);
		var offset = (Math.log(out[0]) / Math.LN10) - slope * out[0];
		var gray = this.midGraySignal / gain;
		var encGain = (Math.log(gain)/Math.LN2 * (0.89 - 1.0) / 3.0 + 1.0) * this.encodingGain;
		var encOffset = this.encodingOffset;
		var nz = 0.0;
		for (var j=0; j<3; j++) {
			nz = ((95.0 / 1023.0 - encOffset) / encGain - offset) / slope;
			encOffset = this.encodingOffset - (Math.log(1 + nz) / Math.LN10) * encGain;
		}
		var xm = (Math.log((1 - this.blackSignal) / gray + nz) / Math.LN10) * encGain + encOffset;
		out[1] = 1.0 / gray;										// a
		out[2] = nz - this.blackSignal / gray;						// b
		out[5] = slope * out[1] * encGain;							// e
		out[6] = encGain * (slope * out[2] + offset) + encOffset;	// f
		var s = 4.0 / (0.18 * ei);
		var t = this.blackSignal;
		out[2] = out[2] + out[1] * t;
		out[1] *= s;
		out[6] = out[6] + out[5] * t;
		out[5] *= s;
		out[3] = encGain;											// c
		out[4] = encOffset;											// d
		out[0] = (out[0] - out[2]) / out[1];
		out[7] = xm;												// xm
		out[8] = 0.8;												// x1
		out[9] = 1;													// x2
		out[10] = 0.8;
		out[11] = xm;
		out[12] = 1.0;
		out[13] = ((5.0 * xm) - 4.0) * ((5.0 * xm) - 4.0);
	}
	return out;
}
LUTGammaArri.prototype.setHighKnee = function(x1, x2, v1, v2, v3, v4) {
	var hk = [];
	var d3 = x2-x1;
	d3 = d3 * d3 * d3;
	// Arri adjusts the log curve with a form of highlight knee for high ISOs.
	// Whether it happens is determined by a claculation - xm being above 1.0
	// For xm values above 1.0, the cubic knee kicks in for LogC values above
	// 0.8 on a 0-1.0 data range scale
	// Arri's calculations are presented in parametric form, I've disentangled
	// things to generate four cubic coefficients when the ISO changes, for
	// fewer and simpler calculations on pixels (multiply and adds)
	// a x^3
	hk[0] =		v1 * 2.0;
	hk[0] +=	v2 * -2.0;
	hk[0] +=	v3 * (x2 - x1);
	hk[0] +=	v4 * (x2 - x1);
	hk[0] /=	d3;
	// b x^2
	hk[1] =		v1 * -3.0 * (x1 + x2);
	hk[1] +=	v2 * 3.0 * (x1 + x2);
	hk[1] +=	v3 * ((x1 * x1) + (x1 * x2) - (2.0 * x2 * x2));
	hk[1] +=	v4 * ((2.0 * x1 * x1) - (x1 * x2) - (x2 * x2));
	hk[1] /=	d3;
	// c x
	hk[2] =		v1 * 6.0 * x1 * x2;
	hk[2] +=	v2 * -6.0 * x1 * x2;
	hk[2] +=	v3 * ((-2.0 * x1 * x1 * x2) + (x1 * x2 * x2) + (x2 * x2 * x2));
	hk[2] +=	v4 * ((2.0 * x1 * x2 * x2) - (x1 * x1 * x2) - (x1 * x1 * x1));
	hk[2] /=	d3;
	// d
	hk[3] =		v1 * ((x2 * x2 * x2) - (3.0 * x1 * x2 * x2));
	hk[3] +=	v2 * ((3.0 * x1 * x1 * x2) - (x1 * x1 * x1));
	hk[3] +=	v3 * ((x1 * x1 * x2 * x2) - (x1 * x2 * x2 * x2));
	hk[3] +=	v4 * ((x1 * x1 * x1 * x2) - (x1 * x1 * x2 * x2));
	hk[3] /=	d3;
	
	// This replaces the LogC values above 0.8 BEFORE going log -> lin, but for lin -> log
	// have fun inverting arbitrary cubics. easy life is to calculate a cubic approximation
	// it's a short stretch of monotonic cubic, and we can extrapolate above 1.0
	var fd0 = 1 / ((1.92 * hk[0]) + (1.6 * hk[1]) + hk[2]);
	var fd1 = 1 / ((3 * hk[0]) + (2 * hk[1]) + hk[2]);
	var fxm = this.xm - 0.8;
	this.tHK[0] = (((fd0+fd1) * fxm) -0.4)/(fxm * fxm * fxm);
	this.tHK[2] = 1.0;
	this.tHK[3] = 0.8;
	this.tHK[1] = (fd1/(2 * fxm)) - (1.5 * fxm * this.tHK[0]) - (this.tHK[2] / (2 * fxm));
	this.tHS = (((0.6 * this.tHK[0]) + 0.4) * this.tHK[1]) + this.tHK[2];
	this.fHK[0] = hk[0];
	this.fHK[1] = hk[1];
	this.fHK[2] = hk[2];
	this.fHK[3] = hk[3];
	this.fHS = (3 * this.fHK[0]) + (2 * this.fHK[1]) + this.fHK[2];
	this.knee = true;
}
LUTGammaArri.prototype.changeISO = function(iso) {
	this.iso = iso;
	var arri = this.getParams(iso);
	this.params[0] = 1.0 / arri[5];					// lin slope
	this.params[1] = -arri[6] / arri[5];			// lin offset
	this.params[2] = arri[3];						// log slope
	this.params[3] = arri[1];						// input slope
	this.params[4] = 10;							// base
	this.params[5] = arri[4];						// log offset
	this.params[6] = arri[2];						// input offset
	this.params[7] = (arri[5] * arri[0]) + arri[6];	// log input crossover
	this.params[8] = arri[0];						// log output crossover
	// set up some reciprocal values, as multiplies are quicker than divides later on.
	this.params[9] = arri[5]; // reciprocal of p0, multiplies are faster than divides.
	this.params[10] = 1.0 / this.params[2];
	this.params[11] = 1.0 / this.params[3];
	this.params[12] = this.params[2] / Math.log(this.params[4]);
	// if superblacks are undefined, clamp before reaching NaN (hard black). Not the case here, but we're on a roll.
	this.params[13] = (this.params[12] * Math.log((0.000000000000001 * this.params[3]) + this.params[6])) + this.params[5];
	// Think-of-everything Arri have a log rolloff for high ISO - add an extra bit of complexity. Fun.
	this.xm = arri[7];
	if (this.xm > 1.0) {
		this.setHighKnee(arri[8], arri[9], arri[10], arri[11], arri[12], arri[13]);
	} else {
		this.knee = false;
	}
}
LUTGammaArri.prototype.changeContrast = function(rec,out) {
};
LUTGammaArri.prototype.changeRange = function(rec,out) {
	if (this.sup !== 2) {
		this.recleg = rec;
		this.outleg = out;
	}
};
LUTGammaArri.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = c[j] * 0.9;
		if (c[j] >= this.params[8]) {
			c[j] = (Math.log((c[j] * this.params[3]) + this.params[6]) * this.params[12]) + this.params[5];
		} else if (this.params[0] === 0.0) {
			c[j] = this.params[13];
		} else {
			c[j] = (c[j] - this.params[1]) * this.params[9];
		}
	}
	if (this.knee) {
		for (var j=0; j<m; j++) {
			if (c[j] > 0.8) {
				if (c[j] > this.xm) {
					c[j] = ((c[j] - this.xm) * this.tHS) + 1;
				} else {
					c[j] -= 0.8
					c[j] = (((((this.tHK[0] * c[j]) + this.tHK[1]) * c[j]) + this.tHK[2]) * c[j]) + this.tHK[3];
				}
			}
		}
	}
	var legal = this.outleg;
	if (p && p.rec) {
		legal = this.recleg;
	}
	if (legal) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
		}
	}
};
LUTGammaArri.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToD(buff, p);
	} else {
		this.linToD(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaArri.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (this.recleg) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
		}
	}
	if (this.knee) {
		for (var j=0; j<m; j++) {
			if (c[j] > 0.8) {
				if (c[j] > 1.0) {
					c[j] = ((c[j] - 1.0) * this.fHS) + 1.0;
				} else {
					c[j] = (((((this.fHK[0] * c[j]) + this.fHK[1]) * c[j]) + this.fHK[2]) * c[j]) + this.fHK[3];
				}
			}
		}
	}
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[7]) {
			c[j] = (Math.pow(this.params[4],(c[j] - this.params[5]) * this.params[10]) - this.params[6]) * this.params[11] / 0.9;
		} else {
			c[j] = ((c[j] * this.params[0]) + this.params[1]) / 0.9;
		}
	}
};
LUTGammaArri.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaArri.prototype.linToData = function(input, p) {
	var out;
	input *= 0.9;
	var legal = this.outleg;
	if (p && p.rec) {
		legal = this.recleg;
	}

	if (input >= this.params[8]) {
		out = (Math.log((input * this.params[3]) + this.params[6]) * this.params[12]) + this.params[5];
	} else if (this.params[0] === 0.0) {
		out = this.params[13];
	} else {
		out = (input - this.params[1]) * this.params[9];
	}
	if (this.knee) {
		if (input > 0.8) {
			if (input > this.xm) {
				out = ((input - this.xm) * this.tHS) + 1;
			} else {
				input -= 0.8;
				out = (((((this.tHK[0] * input) + this.tHK[1]) * input) + this.tHK[2]) * input) + this.tHK[3];
			}
		}
	}
	if (legal) {
		out = (out * 0.85630498533724) + 0.06256109481916;
	}
	return out;
};
LUTGammaArri.prototype.linToLegal = function(input, p) {
	if (p) {
		return (this.linToData(input, p) - 0.06256109481916) / 0.85630498533724;
	} else {
		return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
	}
	
};
LUTGammaArri.prototype.linFromData = function(input) {
	var out;
	if (this.recleg) {
		input = (input - 0.06256109481916) / 0.85630498533724;
	}
	if (this.knee) {
		if (input > 0.8) {
			if (input > 1.0) {
				input = ((input - 1.0) * this.fHS) + 1.0;
			} else {
				input = (((((this.fHK[0] * input) + this.fHK[1]) * input) + this.fHK[2]) * input) + this.fHK[3];
			}
		}
	}
	if (input >= this.params[7]) {
		return (Math.pow(this.params[4],(input - this.params[5]) * this.params[10]) - this.params[6]) * this.params[11] / 0.9;
	} else {
		return ((input * this.params[0]) + this.params[1]) / 0.9;
	}
};
LUTGammaArri.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// ARRI LogC4
function LUTGammaLogC4(name) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;
	this.recleg = true;
	this.outleg = true;
	this.a = (Math.pow(2.0, 18) - 16.0) / 117.45;
	this.oneovera = 1.0 / this.a;
	this.b = (1023.0 - 95.0) / 1023.0;
	this.c = 95.0 / 1023.0;
	this.s = 7.0 * Math.LN2 * Math.pow(2, 7 - (14 * this.c / this.b)) / (this.a * this.b);
	this.oneovers = 1.0 / this.s;
	this.t = (Math.pow(2, (-14.0 * this.c / this.b) + 6) - 64.0) / this.a;
	this.bund14 = 14.0 / this.b;
	this.bdiv14 = 1.0 / this.bund14;
}
LUTGammaLogC4.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLogC4.prototype.changeContrast = function(rec,out) {
};
LUTGammaLogC4.prototype.changeRange = function(rec,out) {
	this.recleg = rec;
	this.outleg = out;
};
LUTGammaLogC4.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = c[j] * 0.9;
		if (c[j] >= this.t) {
			c[j] = ((Math.log2((this.a * c[j]) + 64.0) - 6.0) * this.bdiv14) + this.c;
		} else {
			c[j] = (c[j] - this.t) * this.oneovers;
		}
	}
	var legal = this.outleg;
	if (p && p.rec) {
		legal = this.recleg;
	}
	if (legal) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
		}
	}
};
LUTGammaLogC4.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToD(buff, p);
	} else {
		this.linToD(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLogC4.prototype.linFromD = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	if (this.recleg) {
		for (var j=0; j<m; j++) {
			o[j] = (o[j] - 0.06256109481916) / 0.85630498533724;
		}
	}
	for (var j=0; j<m; j++) {
		if (o[j] >= 0) {
			o[j] = (Math.pow(2,(this.bund14 * (o[j] - this.c)) + 6.0) - 64.0) * this.oneovera / 0.9;
		} else {
			o[j] = ((o[j] * this.s) + this.t) / 0.9;
		}
	}
};
LUTGammaLogC4.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaLogC4.prototype.linToData = function(input, p) {
	input *= 0.9;

	var legal = this.outleg;
	if (p && p.rec) {
		legal = this.recleg;
	}
	if (legal) {
		var out;
		if (input >= this.t) {
			out = ((Math.log2((this.a * input) + 64.0) - 6.0) * this.bdiv14) + this.c;
		} else {
			out = (input - this.t) * this.oneovers;
		}
		return (out * 0.85630498533724) + 0.06256109481916;
	} else {
		if (input >= this.t) {
			return ((Math.log2((this.a * input) + 64.0) - 6.0) * this.bdiv14) + this.c;
		} else {
			return (input - this.t) * this.oneovers;
		}
	}
};
LUTGammaLogC4.prototype.linToLegal = function(input, p) {
	if (p) {
		return (this.linToData(input, p) - 0.06256109481916) / 0.85630498533724;
	} else {
		return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLogC4.prototype.linFromData = function(input) {
	if (this.recleg) {
		input = (input - 0.06256109481916) / 0.85630498533724;
	}
	if (input >= 0) {
		return (Math.pow(2,(this.bund14 * (input - this.c)) + 6.0) - 64.0) * this.oneovera / 0.9;
	} else {
		return ((input * this.s) + this.t) / 0.9;
	}
};
LUTGammaLogC4.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// Canon C-Log3
function LUTGammaCLog3(name) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaCLog3.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaCLog3.prototype.changeContrast = function(rec,out) {
};
LUTGammaCLog3.prototype.changeRange = function(rec,out) {
};
LUTGammaCLog3.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaCLog3.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < -0.014) {
			c[j] = -(Math.log((-c[j]*14.98325)+1)*0.42889912/Math.LN10)+0.07623209;
		} else if (c[j] <= 0.014) {
			c[j] = (c[j]*2.3069815)+0.073059361;
		} else {
			c[j] = (Math.log((c[j]*14.98325)+1)*0.42889912/Math.LN10)+0.069886632;
		}
	}
};
LUTGammaCLog3.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaCLog3.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < 0.04076162) {
			c[j] = -(Math.pow(10,(0.07623209-c[j])/0.42889912)-1) / (14.98325);
		} else if (c[j] <= 0.105357102) {
			c[j] = (c[j]-0.073059361) / (2.3069815);
		} else {
			c[j] = (Math.pow(10,(c[j]-0.069886632)/0.42889912)-1) / (14.98325);
		}
	}
};
LUTGammaCLog3.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaCLog3.prototype.linToLegal = function(input) {
	if (input < -0.014) {
		return -(Math.log((-input*14.98325)+1)*0.42889912/Math.LN10)+0.07623209;
	} else if (input <= 0.014) {
		return (input*2.3069815)+0.073059361;
	} else {
		return (Math.log((input*14.98325)+1)*0.42889912/Math.LN10)+0.069886632;
	}
};
LUTGammaCLog3.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaCLog3.prototype.linFromLegal = function(input) {
	if (input < 0.04076162) {
		return -(Math.pow(10,(0.07623209 - input)/0.42889912)-1) / (14.98325);
	} else if (input <= 0.105357102) {
		return (input - 0.073059361) / (2.3069815);
	} else {
		return (Math.pow(10,(input - 0.069886632)/0.42889912)-1) / (14.98325);
	}
};
// Nikon N-Log
function LUTGammaNLog(name) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;
	this.logCut = 451.7887494 / 1023;
}
LUTGammaNLog.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaNLog.prototype.changeContrast = function(rec,out) {
};
LUTGammaNLog.prototype.changeRange = function(rec,out) {
};
LUTGammaNLog.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] *= 0.9;
		if (c[j] >= 0.328) {
			c[j] = ((150 * Math.log(c[j])) + 619) / 1023;
		} else {
			c[j] = Math.cbrt(c[j] + 0.0075) * 650.1864339 / 1023;
		}
	}
};
LUTGammaNLog.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaNLog.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.logCut) {
			c[j] = Math.exp(((c[j] * 1023) - 619)/150);		
		} else {
			c[j] = Math.pow(c[j] * 1023 / 650.1864339, 3) - 0.0075;
		}
		c[j] /= 0.9;
	}
};
LUTGammaNLog.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaNLog.prototype.linToData = function(input) {
	input *= 0.9;
	if (input >= 0.328) {
		return ((150 * Math.log(input)) + 619) / 1023;
	} else {
		return Math.cbrt(input + 0.0075) * 650.1864339 / 1023;
	}
};
LUTGammaNLog.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaNLog.prototype.linFromData = function(input) {
	if (input >= this.logCut) {
		return (Math.exp(((input * 1023) - 619)/150) / 0.9);
	} else {
		return ((Math.pow(input * 1023/ 650.1864339, 3) - 0.0075) / 0.9);
	}
};
LUTGammaNLog.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// Log and Log across threshold (RED Log3G10)
function LUTGammaLogLog(name,params) {
	this.name = name;
	this.params = params;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaLogLog.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLogLog.prototype.changeContrast = function(rec,out) {
};
LUTGammaLogLog.prototype.changeRange = function(rec,out) {
};
LUTGammaLogLog.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaLogLog.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] *= 0.9;
		c[j] += this.params[2];
		if (c[j] < 0) {
			c[j] = -this.params[0]*Math.log((-c[j]*this.params[1])+1)/Math.LN10;
		} else {
			c[j] = this.params[0]*Math.log((c[j]*this.params[1])+1)/Math.LN10;
		}
	}
};
LUTGammaLogLog.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaLogLog.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = (((Math.pow(10,-c[j]/this.params[0])-1)/-this.params[1])-this.params[2])/0.9;
		} else {
			c[j] = (((Math.pow(10,c[j]/this.params[0])-1)/this.params[1])-this.params[2])/0.9;
		}
	}
};
LUTGammaLogLog.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaLogLog.prototype.linToLegal = function(input) {
	input *= 0.9;
	input += this.params[2];
	if (input < 0) {
		return -this.params[0]*Math.log((-input*this.params[1])+1)/Math.LN10;
	} else {
		return this.params[0]*Math.log((input*this.params[1])+1)/Math.LN10;
	}
};
LUTGammaLogLog.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaLogLog.prototype.linFromLegal = function(input) {
	if (input < 0) {
		return (((Math.pow(10,-input/this.params[0])-1)/-this.params[1])-this.params[2])/0.9;
	} else {
		return (((Math.pow(10,input/this.params[0])-1)/this.params[1])-this.params[2])/0.9;
	}
};
// DaVinci Intermediate
function LUTGammaDaVinci(name) {
	this.name = name;
	this.a = 0.0075;
	this.b = 7.0;
	this.c = 0.07329248;
	this.m = 10.44426855;
	this.lin_cut = 0.00262409;
	this.log_cut = 0.02740668;
	this.rescale = 1.0 / 0.9;
	this.iso = 800;
	this.cat = 0;
}
LUTGammaDaVinci.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaDaVinci.prototype.changeContrast = function(rec,out) {
};
LUTGammaDaVinci.prototype.changeRange = function(rec,out) {
};
LUTGammaDaVinci.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaDaVinci.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] *= 0.9;
		if (c[j] > this.lin_cut) {
			c[j] = (Math.log2(c[j] + this.a) + this.b) * this.c;
		} else {
			c[j] = c[j] * this.m;
		}
	}
};
LUTGammaDaVinci.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaDaVinci.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.log_cut) {
			c[j] = Math.pow(2, (c[j] / this.c) - this.b) - this.a;
		} else {
			c[j] = c[j] / this.m;
		}
		c[j] *= this.rescale;
	}
};
LUTGammaDaVinci.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaDaVinci.prototype.linToLegal = function(input) {
	input *= 0.9;
	if (input >= this.lin_cut) {
		return (Math.log2(input + this.a) + this.b) * this.c;
	} else {
		return input * this.m;
	}
};
LUTGammaDaVinci.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaDaVinci.prototype.linFromLegal = function(input) {
	if (input >= this.log_cut) {
		return (Math.pow(2, (input / this.c) - this.b) - this.a) * this.rescale;
	} else {
		return input / this.m;
	}
};
// Apple Log
function LUTGammaAppleLog(name,params) {
	this.name = name;
	this.params = params;
	this.iso = 800;
	this.cat = 0;
	this.R0 = -0.05641088;
	this.Rt = 0.01;
	this.cc = 47.28711236;
	this.beta = 0.00964052;
	this.gamma = 0.08550479;
	this.delta = 0.69336945;
	this.Pt = this.cc * (this.Rt - this.R0) * (this.Rt - this.R0);
}
LUTGammaAppleLog.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaAppleLog.prototype.changeContrast = function(rec,out) {
};
LUTGammaAppleLog.prototype.changeRange = function(rec,out) {
};
LUTGammaAppleLog.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] *= 0.9;
		if (c[j] < this.R0) {
			c[j] = 0;
		} else if (c[j] > this.Rt) {
			c[j] = (this.gamma * Math.log2(c[j] + this.beta)) + this.delta;
		} else {
			c[j] = this.cc * (c[j] - this.R0) * (c[j] - this.R0);
		}
	}
};
LUTGammaAppleLog.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaAppleLog.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = this.R0;
		} else if (c[j] >= this.Pt) {
			c[j] = Math.pow(2, (c[j] - this.delta) / this.gamma) - this.beta;
		} else {
			c[j] = Math.sqrt(c[j] / this.cc) + this.R0;
		}
		c[j] /= 0.9;
	}
};
LUTGammaAppleLog.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaAppleLog.prototype.linToData = function(input) {
	input *= 0.9;
	if (input < this.r0) {
		return 0;
	} else if (input > this.rt) {
		return (this.gamma * Math.log2(input + this.beta)) + this.delta;
	} else {
		return this.cc * (input - this.r0) * (input - this.r0);
	}
};
LUTGammaAppleLog.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaAppleLog.prototype.linFromData = function(input) {
	if (input < 0) {
		return this.R0 / 0.9;
	} else if (input >= this.Pt) {
		return (Math.pow(2, (input - this.delta) / this.gamma) - this.beta) / 0.9;
	} else {
		return (Math.sqrt(input / this.cc) + this.R0) / 0.9;
	}
};
LUTGammaAppleLog.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// *************************************************************
// Log2 - encoding log for LOGCalc
// *************************************************************
function LUTGammaLog2(name, linearMaximum, linearMinimum) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;

	this.linMax = linearMaximum;
	this.linMin = linearMinimum;
	this.cut = 0.01125; // 0.01125;
	this.cutLog = Math.log(this.cut) / Math.LN2;
	this.stopMax = (Math.log(linearMaximum - linearMinimum + this.cut) / Math.LN2) - this.cutLog;
	this.stopVert = 1.0 / this.stopMax;
	this.rLowSlope = this.cut * Math.LN2 * this.stopMax;
	this.fLowSlope = 1.0 / this.rLowSlope;
	this.linOffset = this.cut - this.linMin;
	this.drMul = this.stopMax * Math.LN2;
	this.dfMul = 1.0 / this.drMul;
}
LUTGammaLog2.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLog2.prototype.changeContrast = function(rec,out) {
};
LUTGammaLog2.prototype.changeRange = function(rec,out) {
};
LUTGammaLog2.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] *= 0.9;
		if (c[j] <= this.linMin) {
			c[j] -= this.linMin;
			c[j] *= this.fLowSlope;
		} else {
			c[j] += this.linOffset;
			c[j] = Math.log(c[j]) / Math.LN2;
			c[j] -= this.cutLog;
			c[j] *= this.stopVert;
		}
	}
};
LUTGammaLog2.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLog2.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] <= 0) {
			c[j] *= this.rLowSlope;
			c[j] += this.linMin;
		} else {
			c[j] *= this.stopMax;
			c[j] += this.cutLog;
			c[j] = Math.pow(2, c[j]);
			c[j] -= this.linOffset;
		}
		c[j] /= 0.9;
	}
};
LUTGammaLog2.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaLog2.prototype.linToData = function(input) {
	input *= 0.9;
	if (input <= this.linMin) {
		input -= this.linMin;
		input *= this.fLowSlope;
	} else {
		input += this.linOffset;
		input = Math.log(input) / Math.LN2;
		input -= this.cutLog;
		input *= this.stopVert;
	}
	return input;
};
LUTGammaLog2.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaLog2.prototype.linFromData = function(input) {
	if (input <= 0) {
		input *= this.rLowSlope;
		input += this.linMin;
	} else {
		input *= this.stopMax;
		input += this.cutLog;
		input = Math.pow(2, input);
		input -= this.linOffset;
	}
	input /= 0.9;
	return input;
};
LUTGammaLog2.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// *************************************************************
// *************************************************************

// Conventional Gamma
function LUTGammaGam(name,params) {
	this.name = name;
	this.params = params;
	if (!params[5] && params[0] !== 1) {
		this.gamma = '';
	} else if (params[5] !== params[0]) {
		this.gamma = 'γ' + params[5].toFixed(2).toString() + ' (exp' + params[0].toFixed(2).toString() + ')';
	} else {
		this.gamma = 'γ' + params[0].toFixed(2).toString();
	}
	this.iso = 800;
	this.cat = 1;
}
LUTGammaGam.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaGam.prototype.changeContrast = function(rec,out) {
};
LUTGammaGam.prototype.changeRange = function(rec,out) {
};
LUTGammaGam.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaGam.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[3]) {
			c[j] = ((1 + this.params[2]) * Math.pow(c[j],1 / this.params[0])) - this.params[2];
		} else {
			c[j] = this.params[1] * c[j];
		}
	}
};
LUTGammaGam.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaGam.prototype.linFromL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= this.params[4]) {
			c[j] = Math.pow((c[j] + this.params[2])/(1 + this.params[2]),this.params[0]);		
		} else {
			c[j] = (c[j] / this.params[1]);
		}
	}
};
LUTGammaGam.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaGam.prototype.linToLegal = function(input) {
	if (input >= this.params[3]) {
		return ((1 + this.params[2]) * Math.pow(input,1 / this.params[0])) - this.params[2];
	} else {
		return this.params[1] * input;
	}
};
LUTGammaGam.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaGam.prototype.linFromLegal = function(input) {
	if (input >= this.params[4]) {
		return Math.pow((input + this.params[2])/(1 + this.params[2]),this.params[0]);		
	} else {
		return (input / this.params[1]);
	}
};
function LUTGammaBBCGam(name,params) {
	this.name = name;
	this.params = params;
	if (!params[5] && params[0] !== 1) {
		this.gamma = '';
	} else if (params[5] !== params[0]) {
		this.gamma = 'γ' + params[5].toFixed(2).toString() + ' (exp' + params[0].toFixed(2).toString() + ')';
	} else {
		this.gamma = 'γ' + params[0].toFixed(2).toString();
	}
	this.iso = 800;
	this.cat = 1;
}
LUTGammaBBCGam.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaBBCGam.prototype.changeContrast = function(rec,out) {
};
LUTGammaBBCGam.prototype.changeRange = function(rec,out) {
};
LUTGammaBBCGam.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaBBCGam.prototype.linToL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] > this.params[3]) {
			c[j] = Math.pow((c[j] + this.params[2])/(1 + this.params[2]),this.params[0]);		
		} else {
			c[j] = c[j] * this.params[1];
		}
	}
};
LUTGammaBBCGam.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaBBCGam.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] > this.params[4]) {
			c[j] = ((1 + this.params[2]) * Math.pow(c[j],1 / this.params[0])) - this.params[2];
		} else {
			c[j] = c[j] / this.params[1];
		}
	}
};
LUTGammaBBCGam.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaBBCGam.prototype.linToLegal = function(input) {
	if (input > this.params[3]) {
		return Math.pow((input + this.params[2])/(1 + this.params[2]),this.params[0]);		
	} else {
		return input * this.params[1];
	}
};
LUTGammaBBCGam.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaBBCGam.prototype.linFromLegal = function(input) {
	if (input >= this.params[4]) {
		return ((1 + this.params[2]) * Math.pow(input,1 / this.params[0])) - this.params[2];
	} else {
		return (input / this.params[1]);
	}
};
// Linear
function LUTGammaLin(name, zero) {
	this.name = name;
	this.iso = 800;
	this.zero = zero / 0.2;
	this.gamma = 'γ1.0 (18% Gray = ' + zero + ')';
	this.cat = 1;
}
LUTGammaLin.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLin.prototype.changeContrast = function(rec,out) {
};
LUTGammaLin.prototype.changeRange = function(rec,out) {
};
LUTGammaLin.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * this.zero * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaLin.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = c[j] * this.zero;
	}
};
LUTGammaLin.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / (0.85630498533724 * this.zero);
	}
};
LUTGammaLin.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = c[j] / this.zero;
	}
};
LUTGammaLin.prototype.linToData = function(input) {
	return (input * this.zero * 0.85630498533724) + 0.06256109481916;
};
LUTGammaLin.prototype.linToLegal = function(input) {
	return input * this.zero;
};
LUTGammaLin.prototype.linFromData = function(input) {
	return (input - 0.06256109481916) / (0.85630498533724 * this.zero);
};
LUTGammaLin.prototype.linFromLegal = function(input) {
	return input / this.zero;
};
// Rec2100 PQ
function LUTGammaPQ(name,ootf) {
	this.name = name;
	this.ootf = ootf;
	this.cat = 7;
	this.m1 = (2610/16384);
	this.m2 = (2523/4096)*128;
	this.c1 = (3424/4096);
	this.c2 = (2413/4096)*32;
	this.c3 = (2392/4096)*32;
	this.iso = 800;
	this.setLw();
}
LUTGammaPQ.prototype.setLw = function() {
	var r = Math.pow(Math.max(0,this.ootf.LwI)/10000,this.m1);
	this.mxI = Math.pow((this.c1+(this.c2*r))/(1+(this.c3*r)),this.m2);
	var r = Math.pow(Math.max(0,this.ootf.LwO)/10000,this.m1);
	this.mxO = Math.pow((this.c1+(this.c2*r))/(1+(this.c3*r)),this.m2);
};
LUTGammaPQ.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaPQ.prototype.changeContrast = function(rec,out) {
};
LUTGammaPQ.prototype.changeRange = function(rec,out) {
};
LUTGammaPQ.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToL(buff, p);
	} else {
		this.linToL(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaPQ.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var r;
	var m1 = this.m1;
	var m2 = this.m2;
	var c1 = this.c1;
	var c2 = this.c2;
	var c3 = this.c3;
	var mx;
	if (p) {
		this.ootf.linToL(buff, p);
		if (p.rec) {
			mx = this.mxI;
		} else {
			mx = this.mxO;
		}
	} else {
		this.ootf.linToL(buff);
		mx = this.mxO;
	}
	for (var j=0; j<m; j++) {
		r = Math.pow(Math.max(0,c[j])/10000,m1);
		c[j] = Math.min(mx,Math.pow((c1+(c2*r))/(1+(c3*r)),m2));
	}
};
LUTGammaPQ.prototype.linFromD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	if (p) {
		this.linFromL(buff, p);
	} else {
		this.linFromL(buff);
	}
};
LUTGammaPQ.prototype.linFromL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var r;
	var m1 = this.m1;
	var m2 = this.m2;
	var c1 = this.c1;
	var c2 = this.c2;
	var c3 = this.c3;
	var e = this.linToLegal(0);
	for (var j=0; j<m; j++) {
		if (c[j] <= e) {
			c[j] = 0;
		} else {
			r = Math.pow(c[j],1/m2);
			c[j] = Math.pow((r-c1)/(c2-(c3*r)),1/m1) * 10000;
		}
	}
	if (p) {
		this.ootf.linFromL(buff, p);
	} else {
		this.ootf.linFromL(buff);
	}
};
LUTGammaPQ.prototype.linToData = function(input, p) {
	if (p) {
		return (this.linToLegal(input,p) * 0.85630498533724) + 0.06256109481916;
	} else {
		return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaPQ.prototype.linToLegal = function(input, p) {
	var mx, r;
	if (p) {
		var r = Math.pow(Math.max(0,this.ootf.linToLegal(input, p))/10000,this.m1);
		if (p.rec) {
			mx = this.mxI;
		} else {
			mx = this.mxO;
		}
	} else {
		var r = Math.pow(Math.max(0,this.ootf.linToLegal(input))/10000,this.m1);
		mx = this.mxO;
	}
	return Math.min(mx,Math.pow((this.c1+(this.c2*r))/(1+(this.c3*r)),this.m2));
};
LUTGammaPQ.prototype.linFromData = function(input, p) {
	if (p) {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724, p);
	} else {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
	}
};
LUTGammaPQ.prototype.linFromLegal = function(input, p) {
	var r = Math.pow(input,1/this.m2);
	if (p) {
		input = this.ootf.linFromLegal(Math.pow((r-this.c1)/(this.c2-(this.c3*r)),1/this.m1) * 10000, p);
	} else {
		input = this.ootf.linFromLegal(Math.pow((r-this.c1)/(this.c2-(this.c3*r)),1/this.m1) * 10000);
	}
	if (isNaN(input)) {
		return 0;
	} else {
		return input;
	}
};
// Rec2100 Hybrid-Log Gamma (HLG)
function LUTGammaHLG(name,params) {
	this.name = name;
	this.a = params.a;
	this.b = params.b;
	this.c = params.c;
	this.cat = 5;
	this.iso = 800;
	this.nbI = 1;
	this.nbO = 1;
}
LUTGammaHLG.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaHLG.prototype.changeContrast = function(rec,out) {
};
LUTGammaHLG.prototype.changeRange = function(rec,out) {
};
LUTGammaHLG.prototype.setBBC = function(bbcIn, bbcOut) {
	if (bbcIn) {
		this.nbI = 2.821251498;
	} else {
		this.nbI = 1;
	}
	if (bbcOut) {
		this.nbO = 2.821251498;
	} else {
		this.nbO = 1;
	}
};
LUTGammaHLG.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToL(buff, p);
	} else {
		this.linToL(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaHLG.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var r;
	var nb;
	if (p && p.rec) {
		nb = this.nbI;
	} else {
		nb = this.nbO;
	}
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = 0;
		} else if (c[j] <= 1/nb) {
			c[j] = Math.pow(c[j]*nb,0.5) / 2;
		} else {
			c[j] = (this.a * Math.log((c[j]*nb) - this.b)) + this.c;
		}
	}
};
LUTGammaHLG.prototype.linFromD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	if (p) {
		this.linFromL(buff, p);
	} else {
		this.linFromL(buff);
	}
};
LUTGammaHLG.prototype.linFromL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var r;
	var nb;
	if (p && p.out) {
		nb = this.nbO;
	} else {
		nb = this.nbI;
	}
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = 0;
		} else if (c[j] <= 0.5) {
			c[j] = Math.pow(2*c[j],2)/nb;
		} else {
			c[j] = (Math.exp((c[j] - this.c)/this.a) + this.b)/nb;
		}
	}
};
LUTGammaHLG.prototype.linToData = function(input, p) {
	if (p) {
		return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
	} else {
		return (this.linToLegal(input, p) * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaHLG.prototype.linToLegal = function(input, p) {
	var nb;
	if (p && p.rec) {
		nb = this.nbI;
	} else {
		nb = this.nbO;
	}
	if (input < 0) {
		return 0;
	} else if (input <= 1/nb) {
		return Math.pow(input * nb,0.5) / 2;
	} else {
		return (this.a * Math.log((input * nb) - this.b)) + this.c;
	}
};
LUTGammaHLG.prototype.linFromData = function(input, p) {
	if (p) {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724, p);
	} else {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
	}
};
LUTGammaHLG.prototype.linFromLegal = function(input, p) {
	var nb;
	if (p && p.out) {
		nb = this.nbO;
	} else {
		nb = this.nbI;
	}
	if (input < 0) {
		return 0;
	} else if (input <= 0.5) {
		return Math.pow(2*input,2) / nb;
	} else {
		return (Math.exp((input - this.c)/this.a) + this.b) / nb;
	}
};
// Rec2100 PQ OOTF
function LUTGammaOOTFPQ(name, params) {
	this.name = name;
	if (typeof params.scale === 'string') {
		switch(params.scale.toLowerCase()) {
			case 'normalised':
				this.s = 1/100;
				break;
			case 'nits':
			default:
				this.s = 100;
				break;
		}
	} else {
		this.s = 100; // default nits
	}
	this.setLw(params.Lw, params.Lw);
	this.iso = 800;
	this.gamma = '';
	this.cat = 1;
	this.hdrOOTF = true;
}
LUTGammaOOTFPQ.prototype.setLw = function(LwIn, LwOut) {
	this.LwI = LwIn;
	var out = false;
	if (LwOut !== this.LwO) {
		out = true;
	}
	this.LwO = LwOut;
	this.eI = this.linToLegal(0, { rec: true });
	this.eO = this.linToLegal(0);
	return out;
};
LUTGammaOOTFPQ.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaOOTFPQ.prototype.changeContrast = function(rec,out) {
};
LUTGammaOOTFPQ.prototype.changeRange = function(rec,out) {
};
LUTGammaOOTFPQ.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToL(buff,p);
	} else {
		this.linToL(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFPQ.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var e, Lw;
	if (p && p.rec) {
		e = this.eI;
		Lw = this.LwI / 100;
	} else {
		e = this.eO;
		Lw = this.LwO / 100;
	}
	var s = this.s;
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = e;
		} else {
			c[j] /= 100;
			if (c[j] > 0.0003024) {
				c[j] = (1.099*Math.pow(59.5208*c[j],0.45))-0.099;
			} else {
				c[j] = 267.84*Math.max(c[j],0);
			}
			c[j] = Math.min(Lw,Math.pow(c[j],2.4))*s;
		}
	}
};
LUTGammaOOTFPQ.prototype.linFromD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	if (p) {
		this.linFromL(buff, p);
	} else {
		this.linFromL(buff);
	}
};
LUTGammaOOTFPQ.prototype.linFromL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.s;
	var e;
	if (p && p.out) {
		e = this.eO;
	} else {
		e = this.eI;
	}
	for (var j=0; j<m; j++) {
		if (c[j] <= e) {
			c[j] = 0;
		} else {
			c[j] = Math.pow(c[j]/s,1/2.4);
			if (c[j] > 0.080994816) {
				c[j] = Math.pow((c[j] + 0.099)/1.099,1/0.45)/59.5208;
			} else {
				c[j] /= 267.84;
			}
			c[j] *= 100;
		}
	}
};
LUTGammaOOTFPQ.prototype.linToData = function(input, p) {
	if (p) {
		return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
	} else {
		return (this.linToLegal(input, p) * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFPQ.prototype.linToLegal = function(input, p) {
	var e, Lw;
	if (p && p.rec) {
		e = this.eI;
		Lw = this.LwI / 100;
	} else {
		e = this.eO;
		Lw = this.LwO / 100;
	}
	if (input < 0) {
		return e;
	} else {
		input /= 100;
		if (input > 0.0003024) {
			input = (1.099*Math.pow(59.5208*input,0.45))-0.099;	
		} else {
			input = 267.84*Math.max(input,0);
		}
		return Math.min(Lw,Math.pow(input,2.4))*this.s;
	}
}
LUTGammaOOTFPQ.prototype.linFromData = function(input, p) {
	if (p) {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724, p);
	} else {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
	}
};
LUTGammaOOTFPQ.prototype.linFromLegal = function(input, p) {
	if (p && p.out) {
		e = this.eO;
	} else {
		e = this.eI;
	}
	if (input <= e) {
		return 0;
	} else {
		input = Math.pow(input/this.s,1/2.4);
		if (input > 0.080994816) {
			input = Math.pow((input + 0.099)/1.099,1/0.45)/59.5208;
		} else {
			input /= 267.84;
		}
		return input * 100;
	}
};
// Rec2100 HLG OOTF
function LUTGammaOOTFHLG(name, params) {
	this.name = name;
	if (typeof params.scale === 'string') {
		switch(params.scale.toLowerCase()) {
			case 'normalised':
				this.s = 1/1000;
				break;
			case 'nits':
			default:
				this.s = 1;
				break;
		}
	} else {
		this.s = 1; // default nits
	}
	this.setLw(params.Lw, params.Lw, params.Lb, params.Lb);
	this.nbI = 1;
	this.nbO = 1;
	this.iso = 800;
	this.gamma = '';
	this.cat = 1;
	this.hdrOOTF = true;
}
LUTGammaOOTFHLG.prototype.setBBC = function(bbcIn, bbcOut) {
	if (bbcIn) {
		this.nbI = 2.821251498;
	} else {
		this.nbI = 1;
	}
	var old = false;
	if  (this.nbO) {
		old = this.nbO;
	}
	if (bbcOut) {
		this.nbO = 2.821251498;
	} else {
		this.nbO = 1;
	}
	if (old && old !== this.nbO) {
		return true;
	} else {
		return false;
	}
};
LUTGammaOOTFHLG.prototype.setLw = function(LwIn, LwOut, LbIn, LbOut) {
	this.LwI = LwIn;
	var out = false;
	if (LwOut !== this.LwO) {
		out = true;
	}
	this.LwO = LwOut;
	if (typeof LbIn === 'number') {
		this.LbI = LbIn;
		if (typeof LbOut === 'number') {
			if (LbOut !== this.LbO) {
				out = true;
			}
			this.LbO = LbOut;
		}
	} else {
		this.LbI = 0;
		this.LbO = 0;
	}
	this.gI = (1.2 + (0.42*Math.log(this.LwI/1000)/Math.LN10));
	this.aI = (this.LwI-this.LbI)/Math.pow(12,this.gI);
	this.bI = this.LbI;
	this.gO = (1.2 + (0.42*Math.log(this.LwO/1000)/Math.LN10));
	this.aO = (this.LwO-this.LbO)/Math.pow(12,this.gO);
	this.bO = this.LbO;
	return out;
};
LUTGammaOOTFHLG.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaOOTFHLG.prototype.changeContrast = function(rec,out) {
};
LUTGammaOOTFHLG.prototype.changeRange = function(rec,out) {
};
LUTGammaOOTFHLG.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToL(buff, p);
	} else {
		this.linToL(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFHLG.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var g, a, b, nb, s, mx;
	if (p && p.rec) {
		g = this.gI;
		a = this.aI;
		b = this.bI;
		nb = this.nbI;
		s = this.s;
		mx = this.LwI * this.s;
	} else {
		g = this.gO;
		a = this.aO;
		b = this.bO;
		nb = this.nbO;
		s = this.s;
		mx = this.LwO * this.s;
	}
	if (p && p.rgb) {
		var y;
		for (var j=0; j<m; j += 3) {
			c[ j ] = Math.max(0,c[ j ]) * nb;
			c[j+1] = Math.max(0,c[j+1]) * nb;
			c[j+2] = Math.max(0,c[j+2]) * nb;
			y = (0.2627 * c[ j ]) + (0.6780 * c[j+1]) + (0.0593 * c[j+2]);
			c[ j ] = Math.min(mx,((a * Math.pow(y, g-1) * c[ j ]) + b) * s);
			c[j+1] = Math.min(mx,((a * Math.pow(y, g-1) * c[j+1]) + b) * s);
			c[j+2] = Math.min(mx,((a * Math.pow(y, g-1) * c[j+2]) + b) * s);
		}
	} else {
		for (var j=0; j<m; j++) {
			c[ j ] = Math.min(mx,((a * Math.pow(Math.max(0,c[ j ] * nb), g)) + b) * s);
		}
	}
};
LUTGammaOOTFHLG.prototype.linFromD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	if (p) {
		this.linFromL(buff, p);
	} else {
		this.linFromL(buff);
	}
};
LUTGammaOOTFHLG.prototype.linFromL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;	
	if (p && p.out) {
		g = this.gO;
		a = this.aO;
		b = this.bO;
		nb = this.nbO;
		s = this.s;
	} else {
		g = this.gI;
		a = this.aI;
		b = this.bI;
		nb = this.nbI;
		s = this.s;
	}
	if (p && p.rgb) {
		var y;
		for (var j=0; j<m; j += 3) {
			y = (0.2627 * c[ j ]) + (0.6780 * c[j+1]) + (0.0593 * c[j+2]);
			y = Math.pow(Math.max(0, (y / s) - b) / a, (1-g)/g) / (a*nb);
			c[ j ] = y * ((c[ j ] / s) - b);
			c[j+1] = y * ((c[j+1] / s) - b);
			c[j+2] = y * ((c[j+2] / s) - b);
		}
	} else {
		for (var j=0; j<m; j++) {
			c[ j ] = Math.pow(Math.max(0, (c[ j ] / s) - b)/a, 1/g)/nb;
		}
	}
};
LUTGammaOOTFHLG.prototype.linToData = function(input, p) {
	if(p) {
		return (this.linToLegal(input, p) * 0.85630498533724) + 0.06256109481916;
	} else {
		return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFHLG.prototype.linToLegal = function(input, p) {
	if (p && p.rec) {
		return Math.min(this.s*this.LwI,((this.aI * Math.pow(Math.max(0,input * this.nbI), this.gI)) + this.bI) * this.s);
	} else {
		return Math.min(this.s*this.LwO,((this.aO * Math.pow(Math.max(0,input * this.nbO), this.gO)) + this.bO) * this.s);
	}
};
LUTGammaOOTFHLG.prototype.linFromData = function(input, p) {
	if (p) {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724, p);
	} else {
		return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
	}
};
LUTGammaOOTFHLG.prototype.linFromLegal = function(input, p) {
	if (p && p.out) {
		return Math.pow(Math.max(0, (input / this.s) - this.bO)/this.aO, 1/this.gO)/this.nbO;
	} else {
		return Math.pow(Math.max(0, (input / this.s) - this.bI)/this.aI, 1/this.gI)/this.nbI;
	}
};
// Rec2100 No OOTF (Scaled Scene Linear)
function LUTGammaOOTFNone(name, params) {
	this.setLw(params.Lw, params.Lw);
}
LUTGammaOOTFNone.prototype.setLw = function(LwIn, LwOut) {
	this.LwI = LwIn;
	var out = false;
	if (LwOut !== this.LwO) {
		out = true;
	}
	this.LwO = LwOut;
	return out;
};
LUTGammaOOTFNone.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaOOTFNone.prototype.changeContrast = function(rec,out) {
};
LUTGammaOOTFNone.prototype.changeRange = function(rec,out) {
};
LUTGammaOOTFNone.prototype.linToD = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToL(buff, p);
	} else {
		this.linToL(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFNone.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var Lw;
	if (p && p.rec) {
		Lw = this.LwI;
	} else {
		Lw = this.LwO;
	}
	for (var j=0; j<m; j++) {
		c[ j ] = Math.min(c[ j ]*100, Lw);
	}
};
LUTGammaOOTFNone.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = ((c[j]/100) - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaOOTFNone.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[ j ] = c[ j ]/100;
	}
};
LUTGammaOOTFNone.prototype.linToData = function(input, p) {
	if (p) {
		return (this.linToLegal(input, p) * 0.85630498533724) + 0.06256109481916;
	} else {
		return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaOOTFNone.prototype.linToLegal = function(input, p) {
	if (p && p.rec) {
		return Math.min(input * 100, this.LwI);
	} else {
		return Math.min(input * 100, this.LwO);
	}
};
LUTGammaOOTFNone.prototype.linFromData = function(input) {
	return this.linFromLegal(((input / 100) - 0.06256109481916) / 0.85630498533724);
};
LUTGammaOOTFNone.prototype.linFromLegal = function(input) {
	return input / 100;
};
// ITU HDR Proposal
function LUTGammaITUProp(name,params) {
	this.name = name;
	this.iso = 800;
	this.cat = 5;
	this.setM(params.m);
}
LUTGammaITUProp.prototype.setM = function(m) {
	this.m = m;
	this.n = 0.45*1.09930000*Math.pow(m,0.45);
	this.r = (1.09930000*Math.pow(m,0.45)*(1-(0.45*Math.log(m)))) - 0.09930000;
	this.e = this.linToLegal(m);
};
LUTGammaITUProp.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaITUProp.prototype.changeContrast = function(rec,out) {
};
LUTGammaITUProp.prototype.changeRange = function(rec,out) {
};
LUTGammaITUProp.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaITUProp.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] > this.m) {
			c[j] = ((this.n*Math.log(c[j])) + this.r);
		} else if (c[j] >= 0.01810000) {
			c[j] = (1.09930000 * Math.pow(c[j],0.45)) - 0.09930000;
		} else {
			c[j] = 4.5 * c[j];
		}
	}
};
LUTGammaITUProp.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaITUProp.prototype.linFromL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] > this.e) {
			c[j] = Math.exp((c[j]-this.r)/this.n);
		} else if (c[j] >= 0.08145000) {
			c[j] = Math.pow((c[j] + 0.09930000)/(1.09930000),1/0.45);		
		} else {
			c[j] = (c[j] / 4.5);
		}
	}
};
LUTGammaITUProp.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaITUProp.prototype.linToLegal = function(input) {
	if (input > this.m) {
		return ((this.n*Math.log(input)) + this.r);
	} else if (input >= 0.01810000) {
		return (1.09930000 * Math.pow(input,0.45)) - 0.09930000;
	} else {
		return 4.5 * input;
	}
};
LUTGammaITUProp.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaITUProp.prototype.linFromLegal = function(input) {
	if (input > this.e) {
		return Math.exp((input-this.r)/this.n);
	} else if (input >= 0.08145000) {
		return Math.pow((input + 0.09930000)/(1.09930000),1/0.45);		
	} else {
		return (input / 4.5);
	}
};
// BBC White Paper 283
function LUTGammaBBC283(name,params) {
	this.name = name;
	this.iso = 800;
	this.cat = 5;
	this.setM(params.m);
	this.setS(1);
}
LUTGammaBBC283.prototype.setM = function(m) {
	this.m = m;
	this.n = Math.sqrt(m)/2;
	this.r = Math.sqrt(m)*(1-Math.log(Math.sqrt(m)));
	this.e = this.linToLegal(m);
};
LUTGammaBBC283.prototype.setS = function(s) { // System Gamma
	this.s = s;
};
LUTGammaBBC283.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaBBC283.prototype.changeContrast = function(rec,out) {
};
LUTGammaBBC283.prototype.changeRange = function(rec,out) {
};
LUTGammaBBC283.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaBBC283.prototype.linToL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] > this.m) {
			c[j] = ((this.n*Math.log(c[j])) + this.r);
		} else if (c[j]>0) {
			c[j] = Math.sqrt(c[j]);
		} else {
			c[j] = 0;
		}
	}
};
LUTGammaBBC283.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaBBC283.prototype.linFromL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >this.e) {
			c[j] = Math.exp(this.s*(c[j]-this.r)/this.n);
		} else {
			c[j] = Math.pow(c[j],2*this.s);
		}
	}
};
LUTGammaBBC283.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaBBC283.prototype.linToLegal = function(input) {
	if (input > this.m) {
		return ((this.n*Math.log(input)) + this.r);
	} else if (input>0) {
		return Math.sqrt(input);
	} else {
		return 0;
	}
};
LUTGammaBBC283.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaBBC283.prototype.linFromLegal = function(input) {
	if (input >this.e) {
		return Math.exp(this.s*(input-this.r)/this.n);
	} else {
		return Math.pow(input,2*this.s);
	}
};
// ACES Log
function LUTGammaACEScc(name,params) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;
	this.low = Math.pow(2,-15);
	this.m = ((Math.log(this.low*0.5)/Math.log(2)) + 9.72)/17.52;
	this.low2 = (9.72-15)/17.52;
	this.mid = ((Math.log(65504)/Math.log(2))+9.72)/17.52;
}
LUTGammaACEScc.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaACEScc.prototype.changeContrast = function(rec,out) {
};
LUTGammaACEScc.prototype.changeRange = function(rec,out) {
};
LUTGammaACEScc.prototype.linToL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < 0) {
			c[j] = this.m;
		} else if (c[j]<(this.low/0.9)) {
			c[j] = ((Math.log(Math.pow(2,-16) + (c[j]*0.45))/Math.log(2)) + 9.72)/17.52;
		} else {
			c[j] = ((Math.log(c[j]*0.9)/Math.log(2))+9.72)/17.52;
		}
	}
};
LUTGammaACEScc.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToL(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaACEScc.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
	this.linFromL(buff);
};
LUTGammaACEScc.prototype.linFromL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] < this.low2) {
			c[j] = (Math.pow(2,(c[j]*17.52)-9.72)-Math.pow(2,-16))*2/0.9;
		} else if (c[j] < this.mid) {
			c[j] = Math.pow(2,(c[j]*17.52)-9.72)/0.9;
		} else {
			c[j] = 65504/0.9;
		}
	}
};
LUTGammaACEScc.prototype.linToData = function(input) {
	return (this.linToLegal(input) * 0.85630498533724) + 0.06256109481916;
};
LUTGammaACEScc.prototype.linToLegal = function(input) {
		if (input < 0) {
			return this.m;
		} else if (input<(this.low/0.9)) {
			return ((Math.log(Math.pow(2,-16) + (input*0.45))/Math.log(2)) + 9.72)/17.52;
		} else {
			return ((Math.log(input*0.9)/Math.log(2))+9.72)/17.52;
		}
};
LUTGammaACEScc.prototype.linFromData = function(input) {
	return this.linFromLegal((input - 0.06256109481916) / 0.85630498533724);
};
LUTGammaACEScc.prototype.linFromLegal = function(input) {
	if (input < this.low2) {
		return (Math.pow(2,(input*17.52)-9.72)-Math.pow(2,-16))*2/0.9;
	} else if (input < this.mid) {
		return Math.pow(2,(input*17.52)-9.72)/0.9;
	} else {
		return 65504/0.9;
	}
};
// ACES Log Proxy (limited bit range for SDI)
function LUTGammaACESProxy(name,params) {
	this.name = name;
	this.iso = 800;
	this.cat = 0;
	if (params === 10) {
		this.blk = 64;
		this.mul = 50;
		this.off = 425;
		this.hi = 1023;
	} else {
		this.blk = 256;
		this.mul = 200;
		this.off = 1700;
		this.hi = 4095;
	}
	this.low = Math.pow(2,-9.72)/0.9;
}
LUTGammaACESProxy.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaACESProxy.prototype.changeContrast = function(rec,out) {
};
LUTGammaACESProxy.prototype.changeRange = function(rec,out) {
};
LUTGammaACESProxy.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] <= this.low) {
			c[j] = this.blk / this.hi;
		} else {
			c[j] = ((((Math.log(c[j]*0.9)/Math.log(2))+2.5) * this.mul) + this.off)/this.hi;
		}
	}
};
LUTGammaACESProxy.prototype.linToL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaACESProxy.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = Math.pow(2,(((c[j]*this.hi)-this.off)/this.mul)-2.5)/0.9;
	}
};
LUTGammaACESProxy.prototype.linFromL = function(buff) {
	var c= new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j]*0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaACESProxy.prototype.linToData = function(input) {
	if (input <= this.low) {
		return this.blk / this.hi;
	} else {
		return ((((Math.log(input*0.9)/Math.log(2))+2.5) * this.mul) + this.off) / this.hi;
	}
};
LUTGammaACESProxy.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaACESProxy.prototype.linFromData = function(input) {
	return Math.pow(2,(((input*this.hi)-this.off)/this.mul)-2.5)/0.9;
};
LUTGammaACESProxy.prototype.linFromLegal = function(input) {
	return (this.linFromData(input)*0.85630498533724) + 0.06256109481916;
};
// General Tone Curves (four part sigmoids)
function LUTGammaGen(name,params) {
	this.name = name;
	this.params = params;
	this.iso = 800;
	this.cat = 2;
}
LUTGammaGen.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaGen.prototype.changeContrast = function(rec,out) {
};
LUTGammaGen.prototype.changeRange = function(rec,out) {
};
LUTGammaGen.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var stop;
	for (var j=0; j<m; j++) {
		stop = -300;
		if (c[j] > 0) {
			stop = Math.log(c[j] / 0.2) / Math.LN2;
		}
		if ( c[j] > this.params.top[6] ) {
			c[j] = this.params.top[1] + ((this.params.top[0] - this.params.top[1])/Math.pow(1+(this.params.top[4] * Math.exp(-this.params.top[2]*(stop - this.params.top[5]))),1/this.params.top[3]));
		} else if ( c[j] > this.params.high[6] ) {
			c[j] = this.params.high[1] + ((this.params.high[0] - this.params.high[1])/Math.pow(1+(this.params.high[4] * Math.exp(-this.params.high[2]*(stop - this.params.high[5]))),1/this.params.high[3]));
		} else if ( c[j] > this.params.mid[6] ) {
			c[j] = this.params.mid[1] + ((this.params.mid[0] - this.params.mid[1])/Math.pow(1+(this.params.mid[4] * Math.exp(-this.params.mid[2]*(stop - this.params.mid[5]))),1/this.params.mid[3]));
		} else if ( c[j] > this.params.low[6] ) {
			c[j] = this.params.low[1] + ((this.params.low[0] - this.params.low[1])/Math.pow(1+(this.params.low[4] * Math.exp(-this.params.low[2]*(stop - this.params.low[5]))),1/this.params.low[3]));
		} else if ( c[j] <=0 ) {
			c[j] = (this.params.blk[0] * c[j]) + this.params.blk[1];
		} else {
			c[j] = (this.params.bot[0] * c[j]) + this.params.bot[1];
		}
	}
};
LUTGammaGen.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaGen.prototype.linToData = function(input) {
	var stop = -300;
	if (input > 0) {
		stop = Math.log(input / 0.2) / Math.LN2;
	}
	if ( input > this.params.top[6] ) {
		return this.params.top[1] + ((this.params.top[0] - this.params.top[1])/Math.pow(1+(this.params.top[4] * Math.exp(-this.params.top[2]*(stop - this.params.top[5]))),1/this.params.top[3]));
	} else if ( input > this.params.high[6] ) {
		return this.params.high[1] + ((this.params.high[0] - this.params.high[1])/Math.pow(1+(this.params.high[4] * Math.exp(-this.params.high[2]*(stop - this.params.high[5]))),1/this.params.high[3]));
	} else if ( input > this.params.mid[6] ) {
		return this.params.mid[1] + ((this.params.mid[0] - this.params.mid[1])/Math.pow(1+(this.params.mid[4] * Math.exp(-this.params.mid[2]*(stop - this.params.mid[5]))),1/this.params.mid[3]));
	} else if ( input > this.params.low[6] ) {
		return this.params.low[1] + ((this.params.low[0] - this.params.low[1])/Math.pow(1+(this.params.low[4] * Math.exp(-this.params.low[2]*(stop - this.params.low[5]))),1/this.params.low[3]));
	} else if ( input <=0 ) {
		return (this.params.blk[0] * input) + this.params.blk[1];
	} else {
		return (this.params.bot[0] * input) + this.params.bot[1];
	}
};
LUTGammaGen.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
// General Tone Curves (S-Log3->Output LUT based)
function LUTGammaLUTSL3(name,lut) {
	this.name = name;
	this.lut = new LUTQSpline(lut.buffer);
	this.iso = 800;
	this.cat = 2;
}
LUTGammaLUTSL3.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLUTSL3.prototype.changeContrast = function(rec,out) {
};
LUTGammaLUTSL3.prototype.changeRange = function(rec,out) {
};
LUTGammaLUTSL3.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= 0.0125) {
			c[j] = (0.2556207230 * Math.log((c[j] * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850;
		} else {
			c[j] = (c[j] + 0.0155818840)/0.1677922920;
		}
	}
	this.lut.FCub(buff);
};
LUTGammaLUTSL3.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLUTSL3.prototype.linToData = function(input) {
	if (input >= 0.0125) {
		return this.lut.fCub((0.2556207230 * Math.log((input * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850);
	} else {
		return this.lut.fCub((input + 0.0155818840)/0.1677922920);
	}
};
LUTGammaLUTSL3.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
// General Tone Curves (SimpleLog->Output LUT based)
function LUTGammaLUTSimple(name,params) {
	this.name = name;
	this.log = new Float64Array(5);
	this.log[0] = 5/Math.pow(2,params.clip);
	this.log[1] = params.loggy/params.clip;
	this.log[2] = (Math.log(1 + this.log[1])-Math.log(this.log[1]))/Math.LN10;
	this.log[3] = Math.log(this.log[1])/Math.LN10;
	this.log[4] = this.log[0] / (this.log[1] * this.log[2] * Math.LN10);
	this.spline = new LUTQSpline(params.lut.buffer);
	this.iso = 800;
	this.cat = 2;
}
LUTGammaLUTSimple.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLUTSimple.prototype.changeContrast = function(rec,out) {
};
LUTGammaLUTSimple.prototype.changeRange = function(rec,out) {
};
LUTGammaLUTSimple.prototype.linToD = function(buff) {
	var o = new Float64Array(buff);
	var m = o.length;
	var log = this.log;
	for (var j=0; j<m; j++) {
		if (o[j] >= 0) {
			o[j] = ((Math.log((o[j] * log[0]) + log[1])/Math.LN10)-log[3])/log[2];
		} else {
			o[j] = o[j]*log[4];
		}
	}
	this.spline.FCub(buff);
};
LUTGammaLUTSimple.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLUTSimple.prototype.linToData = function(input) {
	if (input >= 0) {
		input = ((Math.log((input * this.log[0]) + this.log[1])/Math.LN10)-this.log[3])/this.log[2];
	} else {
		input = input*this.log[4];
	}
	return this.spline.f(input);
};
LUTGammaLUTSimple.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
// General Tone Curves (Invertable LUT based)
function LUTGammaIOLUT(name,params) {
	this.name = name;
	this.rec = new LUTQSpline(params.rec.lut.buffer);
	this.out = new LUTQSpline(params.out.lut.buffer);
	this.iso = 800;
	this.cat = 6;
}
LUTGammaIOLUT.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaIOLUT.prototype.changeContrast = function(rec,out) {
};
LUTGammaIOLUT.prototype.changeRange = function(rec,out) {
};
LUTGammaIOLUT.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= 0.0125) {
			c[j] = (0.2556207230 * Math.log((c[j] * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850;
		} else {
			c[j] = (c[j] + 0.0155818840)/0.1677922920;
		}
	}
	this.out.FCub(buff);
};
LUTGammaIOLUT.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaIOLUT.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.rec.FCub(buff);
	for (var j=0; j<m; j++) {
		if (c[j] >= 0.1673609920) {
			c[j] = (Math.pow(10,(c[j] - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
		} else {
			c[j] = (0.1677922920 * c[j]) - 0.0155818840;
		}
	}
};
LUTGammaIOLUT.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaIOLUT.prototype.linToData = function(input) {
	if (input >= 0.0125) {
		return this.out.f((0.2556207230 * Math.log((input * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850);
	} else {
		return this.out.f((input + 0.0155818840)/0.1677922920);
	}
};
LUTGammaIOLUT.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaIOLUT.prototype.linFromData = function(input) {
	var data = this.rec.f(input);
	if (data >= 0.1673609920) {
		return (Math.pow(10,(data - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
	} else {
		return (0.1677922920 * data) - 0.0155818840;
	}
};
LUTGammaIOLUT.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// DJI DLog-M Curves
function LUTGammaDLog(name) {
	this.name = name;
	this.iso = 800;
	this.cat = 6;
	this.clip = 4.802951742;
	this.loggy = 0.02;
	this.log = new Float64Array(6);
	this.rec = [];
	this.out = [];
	this.reccon = 3;
	this.outcon = 3;
	this.loadLUTs();
}
LUTGammaDLog.prototype.loadLUTs = function() {
	// Contrast -3
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.027013881, 0.059898339, 0.090088157, 0.118437528,
						0.145610746, 0.172169533, 0.198613763, 0.227521773, 0.262056586, 0.302175407, 0.34492969, 0.385399436,
						0.424651585, 0.467275042, 0.510407243, 0.552759914, 0.592749573, 0.629826127, 0.664057729, 0.695758476,
						0.725291386, 0.752991781, 0.779146345, 0.803993306, 0.827729079, 0.850515908, 0.872488687, 0.893760574,
						0.914427454  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.12885289, 0.15885059, 0.19144138, 0.226199875, 0.262466189, 0.299384828, 0.334847065,
						0.364688823, 0.390416782, 0.413838603, 0.436630643, 0.46037471, 0.486584362, 0.509543387, 0.532318837,
						0.554970585, 0.57771412, 0.601166982, 0.625811624, 0.652038025, 0.680152405, 0.710384832, 0.742896012,
						0.777783434, 0.815087031, 0.854794442, 0.896845964, 0.941139238, 0.987533704, 1.035854869, 1.085898383,
						1.137433963  ]
				).buffer));
	// Contrast -2
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.031210281, 0.068285973, 0.101551761, 0.132158936,
						0.160893656, 0.188302321, 0.215465805, 0.245787053, 0.279449722, 0.315427111, 0.351812097, 0.386609889,
						0.423110071, 0.460310688, 0.49840922, 0.53710835, 0.575293346, 0.61215979, 0.647304693, 0.680626751,
						0.712198291, 0.742171033, 0.770721576, 0.798024375, 0.824240266, 0.849512889, 0.873968764, 0.897718877,
						0.920860756  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.125031422, 0.151121007, 0.179907158, 0.21124056, 0.244837237, 0.280317645, 0.316069712,
						0.347826102, 0.376601031, 0.403745563, 0.430511022, 0.458076706, 0.487569716, 0.512232259, 0.538212324,
						0.563787753, 0.589013066, 0.614435086, 0.640476557, 0.667481773, 0.695724061, 0.725412299, 0.756696709,
						0.789674087, 0.824392599, 0.860856239, 0.899029, 0.938838816, 0.980181311, 1.022923372, 1.066906563,
						1.111950408  ]
				).buffer));
	// Contrast -1
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.031210281, 0.083971133, 0.121494403, 0.154287516,
						0.183562707, 0.210419428, 0.238243695, 0.267538992, 0.297983064, 0.32913085, 0.360463177, 0.391461448,
						0.421734685, 0.453519587, 0.485544904, 0.518128718, 0.551268321, 0.584699085, 0.61821976, 0.651668307,
						0.684925468, 0.717912965, 0.750588498, 0.78293948, 0.814976874, 0.846729853, 0.878241601, 0.909566273,
						0.940767026  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.119702232, 0.140380917, 0.163951817, 0.190659752, 0.220743195, 0.254458113, 0.290796984,
						0.325213901, 0.357945224, 0.389621678, 0.420821249, 0.452083233, 0.483918385, 0.515547815, 0.546123016,
						0.576458327, 0.606169418, 0.635519362, 0.664689059, 0.693824954, 0.723042483, 0.752429059, 0.782046706,
						0.811934418, 0.842110312, 0.872573607, 0.903306472, 0.934275751, 0.965434601, 0.996724043, 1.028074436,
						1.059406888  ]
				).buffer));
	// Contrast 0
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.050605212, 0.101847391, 0.141801367, 0.174553642,
						0.202322185, 0.22874131, 0.255482461, 0.28250488, 0.309772209, 0.337252216, 0.364916477, 0.392740043,
						0.420701103, 0.44878065, 0.476962175, 0.505497001, 0.534850524, 0.564998669, 0.59599196, 0.62788934,
						0.660759718, 0.694683955, 0.729757441, 0.766093505, 0.803827992, 0.843125543, 0.884188395, 0.927269068,
						0.972689245  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.115301511, 0.13149171, 0.150709282, 0.173520311, 0.200596729, 0.232736113, 0.269479213,
						0.306121311, 0.342305347, 0.378112298, 0.41360763, 0.448844624, 0.483866883, 0.518710261, 0.553404354,
						0.587806017, 0.621210936, 0.653692164, 0.685268931, 0.715957019, 0.745769397, 0.77471673, 0.802807792,
						0.830049806, 0.856448717, 0.882009423, 0.906735956, 0.930631637, 0.9536992, 0.975940896, 0.997358579,
						1.017953772  ]
				).buffer));
	// Contrast +1
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.065301918, 0.122898589, 0.163791157, 0.195392233,
						0.222619063, 0.249062283, 0.274879392, 0.300175737, 0.325037946, 0.349539312, 0.373743447, 0.39770684,
						0.419269569, 0.442890208, 0.46719661, 0.492246446, 0.5186057, 0.546354484, 0.575623809, 0.606564753,
						0.639352843, 0.67419386, 0.711331721, 0.751059159, 0.793733115, 0.839797302, 0.889816948, 0.944534957,
						1.004968521  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.111565815, 0.123773786, 0.138880449, 0.157644772, 0.181032868, 0.210267605, 0.245497324,
						0.282372766, 0.320314165, 0.359178573, 0.398828899, 0.439131472, 0.47995439, 0.524196873, 0.564466885,
						0.603106531, 0.639442649, 0.673698044, 0.706021768, 0.736548095, 0.765398416, 0.792682782, 0.818501185,
						0.84294462, 0.866095988, 0.888030858, 0.908818132, 0.928520624, 0.947195571, 0.964895085, 0.981666562,
						0.997553059  ]
				).buffer));
	// Contrast +2
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.087126998, 0.14748523, 0.186008431, 0.215075483,
						0.241476046, 0.266270946, 0.289822865, 0.312379852, 0.334121161, 0.355181885, 0.375667304, 0.395661748,
						0.417935416, 0.437180913, 0.457332473, 0.478483044, 0.500910514, 0.525100922, 0.551252839, 0.579695788,
						0.610846553, 0.645240993, 0.683580724, 0.726803064, 0.776188158, 0.83352692, 0.901392061, 0.983599666,
						1.086113055  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.108032367, 0.116457848, 0.127644377, 0.14254077, 0.162414978, 0.188948062, 0.222967563,
						0.260543566, 0.300956216, 0.343919729, 0.389172406, 0.436469467, 0.485577963, 0.531756384, 0.579562028,
						0.623777205, 0.663826544, 0.700184042, 0.733216025, 0.763252327, 0.790590503, 0.815499305, 0.838221588,
						0.858976768, 0.87796295, 0.895358767, 0.911325024, 0.926006149, 0.939531523, 0.952016681, 0.963564429,
						0.974265872  ]
				).buffer));
	// Contrast +3
	this.rec.push(new LUTQSpline(new Float64Array(
					[	-0.25407191, -0.175972281, -0.097872652, -0.019773024, 0.116722074, 0.172097954, 0.205648193, 0.232954536,
						0.257670154, 0.280585291, 0.302163456, 0.322705091, 0.342418861, 0.361457313, 0.379936505, 0.397947655,
						0.417231908, 0.434077046, 0.451785726, 0.470466477, 0.490260298, 0.511730454, 0.535127682, 0.560854029,
						0.589456615, 0.621707867, 0.658750465, 0.702381845, 0.755678207, 0.824596336, 0.923217546, 1.100371354,
						1.772368213  ]
				).buffer));
	this.out.push(new LUTQSpline(new Float64Array(
					[	0.101661779, 0.104692578, 0.10957075, 0.11711386, 0.12845072, 0.145121036, 0.169194945, 0.20204223,
						0.240018043, 0.282187099, 0.328050167, 0.377151866, 0.429068134, 0.483397275, 0.537416608, 0.590950346,
						0.639494073, 0.682513621, 0.720644883, 0.754394462, 0.784219764, 0.81053462, 0.83371391, 0.854097428,
						0.871993164, 0.887680123, 0.901410791, 0.91341331, 0.923893425, 0.933036256, 0.941007907, 0.947956957,
						0.954015838  ]
				).buffer));
	// Log Parameters
	this.log[0] = 5/Math.pow(2,this.clip);
	this.log[1] = this.loggy/this.clip;
	this.log[2] = (Math.log(1 + this.log[1])-Math.log(this.log[1]))/Math.LN10;
	this.log[3] = Math.log(this.log[1])/Math.LN10;
	this.log[4] = this.log[0] / (this.log[1] * this.log[2] * Math.LN10);
	this.log[5] = this.out[this.reccon].f(0);
};
LUTGammaDLog.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaDLog.prototype.changeContrast = function(rec,out) {
		this.reccon = rec + 3;
		this.outcon = out + 3;
};
LUTGammaDLog.prototype.changeRange = function(rec,out) {
};
LUTGammaDLog.prototype.linToD = function(buff,p) {
	var c = new Float64Array(buff);
	var m = c.length;
	var log = this.log;
	for (var j=0; j<m; j++) {
		if (c[j] >= 0) {
			c[j] = ((Math.log((c[j] * log[0]) + log[1])/Math.LN10)-log[3])/log[2];
		} else {
			c[j] = c[j]*log[4];
		}
	}
	if (p && p.rec) {
		this.out[this.reccon].FCub(buff);
	} else {
		this.out[this.outcon].FCub(buff);
	}
};
LUTGammaDLog.prototype.linToL = function(buff, p) {
	var c = new Float64Array(buff);
	var m = c.length;
	if (p) {
		this.linToD(buff,p);
	} else {
		this.linToD(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaDLog.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var log = this.log;
	this.rec[this.reccon].FCub(buff);
	for (var j=0; j<m; j++) {
		if (c[j] >= log[5]) {
			c[j] = (Math.pow(10,(c[j] * log[2]) + log[3]) - log[1]) / log[0];		
		} else {
			c[j] = c[j] / log[4];
		}
	}
};
LUTGammaDLog.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaDLog.prototype.linToData = function(input,p) {
	if (p && p.rec) {
		if (input >= 0) {
			return this.out[this.reccon].f(((Math.log((input * this.log[0]) + this.log[1])/Math.LN10)-this.log[3])/this.log[2]);
		} else {
			return this.out[this.reccon].f(input*this.log[4]);
		}
	} else {
		if (input >= 0) {
			return this.out[this.outcon].f(((Math.log((input * this.log[0]) + this.log[1])/Math.LN10)-this.log[3])/this.log[2]);
		} else {
			return this.out[this.outcon].f(input*this.log[4]);
		}
	}
};
LUTGammaDLog.prototype.linToLegal = function(input,p) {
	if (p) {
		return (this.linToData(input,p) - 0.06256109481916) / 0.85630498533724;
	} else {
		return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaDLog.prototype.linFromData = function(input) {
	var data = this.rec[this.reccon].f(input);
	if (data >= this.log[5]) {
		return (Math.pow(10,(data * this.log[2]) + this.log[3]) - this.log[1]) / this.log[0];		
	} else {
		return data / this.log[4];
	}
};
LUTGammaDLog.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// LUTAnalyst
function LUTGammaLA(name, lutMaker) {
	this.lutMaker = lutMaker;
	this.name = name;
	this.iso = 800;
	this.cat = 4;
}
LUTGammaLA.prototype.setLUT = function(lut) {
	this.lut = this.lutMaker.newLUT({
		title: lut.title,
		format: lut.format,
		dims: lut.dims,
		s: lut.s,
		min: [lut.min[0],lut.min[1],lut.min[2]],
		max: [lut.max[0],lut.max[1],lut.max[2]],
		C: lut.C
	});
	this.rev = this.lutMaker.newLUT({
		title: lut.title,
		format: lut.format,
		dims: lut.dims,
		s: lut.sr,
		min: [lut.minR[0],lut.minR[1],lut.minR[2]],
		max: [lut.maxR[0],lut.maxR[1],lut.maxR[2]],
		C: lut.R
	});
};
LUTGammaLA.prototype.setTitle = function(name) {
	this.name = name;
};
LUTGammaLA.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaLA.prototype.changeContrast = function(rec,out) {
};
LUTGammaLA.prototype.changeRange = function(rec,out) {
};
LUTGammaLA.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		if (c[j] >= 0.0125) {
			c[j] = (0.2556207230 * Math.log((c[j] * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850;
		} else {
			c[j] = (c[j] + 0.0155818840)/0.1677922920;
		}
	}
	this.lut.FCub(buff);
};
LUTGammaLA.prototype.linToL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	this.linToD(buff);
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaLA.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = this.rev.fCub(c[j]);
		if (c[j] >= 0.1673609920) {
			c[j] = (Math.pow(10,(c[j] - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
		} else {
			c[j] = (0.1677922920*c[j]) + -0.0155818840;
		}
	}
};
LUTGammaLA.prototype.linFromL = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
	this.linFromD(buff);
};
LUTGammaLA.prototype.linToData = function(input) {
	if (input >= 0.0125) {
		return this.lut.fCub((0.2556207230 * Math.log((input * 4.7368421060) + 0.0526315790)/Math.LN10) + 0.4105571850);
	} else {
		return this.lut.fCub((input + 0.0155818840)/0.1677922920);
	}
};
LUTGammaLA.prototype.linToLegal = function(input) {
	return (this.linToData(input) - 0.06256109481916) / 0.85630498533724;
};
LUTGammaLA.prototype.linFromData = function(input) {
 	input = this.rev.fCub(input);
	if (input >= 0.1673609920) {
		return (Math.pow(10,(input - 0.4105571850)/0.2556207230) - 0.0526315790)/4.7368421060;		
	} else {
		return (0.1677922920*input) + -0.0155818840;
	}
};
LUTGammaLA.prototype.linFromLegal = function(input) {
	return this.linFromData((input * 0.85630498533724) + 0.06256109481916);
};
// Null
function LUTGammaNull(name) {
	this.name = name;
	this.iso = 800;
	this.cat = 3;
}
LUTGammaNull.prototype.changeISO = function(iso) {
	this.iso = iso;
};
LUTGammaNull.prototype.changeContrast = function(rec,out) {
};
LUTGammaNull.prototype.changeRange = function(rec,out) {
};
LUTGammaNull.prototype.linToD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] * 0.85630498533724) + 0.06256109481916;
	}
};
LUTGammaNull.prototype.linToL = function(buff) {
// Do Nothing (null)!
};
LUTGammaNull.prototype.linFromD = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	for (var j=0; j<m; j++) {
		c[j] = (c[j] - 0.06256109481916) / 0.85630498533724;
	}
};
LUTGammaNull.prototype.linFromL = function(buff) {
// Do nothing (null)!
};
LUTGammaNull.prototype.linToData = function(input) {
	return (input * 0.85630498533724) + 0.06256109481916;
};
LUTGammaNull.prototype.linToLegal = function(input) {
	return input;
};
LUTGammaNull.prototype.linFromData = function(input) {
	return (input - 0.06256109481916) / 0.85630498533724;
};
LUTGammaNull.prototype.linFromLegal = function(input) {
	return input;
};
// I/O functions
LUTGamma.prototype.setParams = function(params) {
	var out = {	t: 20, v: this.ver , changedGamma: false};
	if (typeof params.v !== 'number') {
		out.err = true;
		out.details = 'Missing version no.';
		return out;
	}
	if (typeof params.inGamma === 'number') {
		if (params.inGamma !== 9999) {
			if (params.inGamma !== this.curIn) {
				out.changedGamma = true;
			}
			this.curIn = params.inGamma;
			out.inGamma = this.curIn;
		} else {
			if (typeof params.inLinGamma === 'number') {
				if (params.inLinGamma !== this.curIn) {
					out.changedGamma = true;
				}
				this.curIn = params.inLinGamma;
				out.inLinGamma = this.curIn;
			}
		}
	}
	this.changedOut = false;
	if (typeof params.outGamma === 'number') {
		if (params.outGamma !== 9999) {
			if (params.outGamma !== this.curOut) {
				out.changedGamma = true;
				this.changedOut = true;
			}
			this.curOut = params.outGamma;
			out.outGamma = this.curOut;
			if (this.gammas[this.curOut].cat === 3) {
				this.nul = true;
			} else {
				this.nul = false;
			}
		} else {
			if (typeof params.outLinGamma === 'number') {
				if (params.outLinGamma !== this.curOut) {
					out.changedGamma = true;
					this.changedOut = true;
				}
				this.curOut = params.outLinGamma;
				out.outLinGamma = this.curOut;
				this.nul = false;
			}
		}
	}
	if (typeof params.defGamma === 'number') {
		var max = this.gammas.length;
		for (var j = 0; j < max; j++) {
			if (defGamma == this.gammas[j].name) {
				this.curIn = j;
				break;
			}
		}
		this.eiMult = Math.pow(2,this.stopShift);
	}
	if (typeof params.contrast !== 'undefined' && typeof params.contrast.rec === 'number' && typeof params.contrast.out === 'number') {
		this.gammas[this.DLogM].changeContrast(params.contrast.rec,params.contrast.out);
	}
	if (typeof params.arriLegalIn === 'boolean' && typeof params.arriLegalOut === 'boolean') {
		var max = this.arriIdxList.length;
		for (var j=0; j < max; j++) {
			this.gammas[this.arriIdxList[j]].changeRange(params.arriLegalIn, params.arriLegalOut);
		}
	
	}
	if (typeof params.newISO === 'number') {
		var max = this.gammas.length;
		for (var j = 0; j < max; j++) {
			this.gammas[j].changeISO(params.newISO);
		}
		if (typeof params.natISO === 'number' && typeof params.camType === 'number' && params.camType === 0) {
			this.eiMult = params.newISO / params.natISO;
		}
	}
	if (typeof params.stopShift === 'number') {
		this.eiMult = Math.pow(2,params.stopShift);
	}
	out.eiMult = this.eiMult;
	if (typeof params.camClip === 'number') {
		this.camClip = params.camClip;
	}
	if (typeof params.inL === 'boolean') {
		this.inL = params.inL;
	}
	if (typeof params.outL === 'boolean') {
		this.outL = params.outL;
	}
	if (typeof params.scaleCheck === 'boolean' && params.scaleCheck && typeof params.scaleMin === 'number' && typeof params.scaleMax === 'number') {
		this.sMin = params.scaleMin;
		this.sMax = params.scaleMax;
		if (this.sMin !== 0 || this.sMax !== 1) {
			this.sIn = true;
		} else {
			this.sIn = false;
		}
	} else {
		this.sMin = 0;
		this.sMax = 1;
		this.sIn = false;
	}
//
	if (this.curOut === this.PQ || this.curOut === (this.PQ+1) || this.curOut === this.pqEOTFIdx) {
		this.hdrOut = true;
	} else {
		this.hdrOut = false;
	}
	this.changedHDR = false;
	if (typeof params.hlgBBCIn === 'boolean' && typeof params.hlgBBCOut === 'boolean') {
		this.gammas[this.HLG].setBBC(params.hlgBBCIn, params.hlgBBCOut)
		if (this.hlgOOTF.setBBC(params.hlgBBCIn, params.hlgBBCOut)) {
			this.changedHDR = true;
		}
		this.hlgOOTFNorm.setBBC(params.hlgBBCIn, params.hlgBBCOut);
		this.gammas[this.PQ + 1].setLw();
	}
	if (typeof params.pqLwIn === 'number' && typeof params.pqLwOut === 'number') {
		if (this.pqOOTF.setLw(params.pqLwIn, params.pqLwOut)) {
			this.changedHDR = true;
		}
		this.pqOOTFNorm.setLw(params.pqLwIn, params.pqLwOut);
		this.gammas[this.PQ].setLw();
	}
	if (typeof params.pqEOTFLwIn === 'number' && typeof params.pqEOTFLwOut === 'number') {
		if (this.pqNoOOTF.setLw(params.pqEOTFLwIn, params.pqEOTFLwOut)) {
			this.changedHDR = true;
		}
		this.gammas[this.pqEOTFIdx].setLw();
	}
	if (typeof params.hlgLwIn === 'number' && typeof params.hlgLwOut === 'number') {
		if (this.hlgOOTF.setLw(params.hlgLwIn, params.hlgLwOut)) {
			this.changedHDR = true;
		}
		this.hlgOOTFNorm.setLw(params.hlgLwIn, params.hlgLwOut);
		this.gammas[this.PQ + 1].setLw();
	}
//
	if (typeof params.clipSelect === 'number') {
		switch(params.clipSelect) {
			case 0: this.clipB = false;
					this.clipW = false;
					this.clip = false;
					break;
			case 1: this.clipB = true;
					this.clipW = true;
					this.clip = true;
					break;
			case 2: this.clipB = true;
					this.clipW = false;
					this.clip = true;
					break;
			case 3: this.clipB = false;
					this.clipW = true;
					this.clip = true;
					break;
		}
		out.clipSelect = params.clipSelect;
	}
	if (typeof params.clipLegal === 'boolean') {
		this.clipL = params.clipLegal;
		out.clipLegal = this.clipL;
	}
//	if (typeof params.clip === 'boolean') {
//		this.clip = params.clip;
//		out.clip = this.clip;
//	}
	if (typeof params.bClip === 'number') {
		this.bClip = params.bClip;
		this.wClip = params.wClip;
	}
	if (typeof params.tweaks === 'boolean') {
		this.tweaks = params.tweaks;
	} else {
		this.tweaks = false;
	}
	out.twkASCCDL = this.setASCCDL(params);
	out.twkKnee = this.setKnee(params);
	out.twkBlkHi = this.setBlkHi(params);
	out.twkBlkGam = this.setBlkGam(params);
	out.twkDisplay = this.setDisplay(params);

	if (typeof params.isTrans === 'boolean') {
		this.isTrans = params.isTrans;
	}
	this.ver = params.v;
	out.v = this.ver;
	return out;
};
LUTGamma.prototype.oneDCalc = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, start: i.start, vals: i.vals, dim: i.dim};
	var eiMult = this.eiMult;
	if (typeof i.eiMult === 'number') {
		eiMult = i.eiMult;
	}
	var s = i.start;
	var max = i.vals;
	var o = new Float64Array(max*3);
	var buff = o.buffer;
	var d = i.dim -1;
	var k;
	if (this.nul) {
		for (var j=0; j<max; j++) {
			k = (s+j)/d; // between 0-1.0
			if (this.sIn) {
				k = (k*(this.sMax-this.sMin)) + this.sMin;
			}
			if (this.inL) {
				o[(j*3)] = k;
			} else {
				o[(j*3)] = ((1023*k)-64)/876;
			}
			o[(j*3)+1] = o[(j*3)];
			o[(j*3)+2] = o[(j*3)];
		}
	} else {
		var l;
		for (var j=0; j<max; j++) {
			k = (s+j)/d; // between 0-1.0
			if (this.sIn) {
				k = (k*(this.sMax-this.sMin)) + this.sMin;
			}
			if (this.inL) {
				o[(j*3)] = this.gammas[this.curIn].linFromLegal(k)*eiMult;
			} else {
				o[(j*3)] = this.gammas[this.curIn].linFromData(k)*eiMult;
			}
			o[(j*3)+1] = o[(j*3)];
			o[(j*3)+2] = o[(j*3)];
		}
		if (this.doASCCDL) {
			this.ASCCDLOut(buff);
		}
		if (this.doKnee) {
			this.kneeOut(buff);
		} else {
			this.gammas[this.curOut].linToL(buff);
		}
		if (this.doBlkHi) {
			this.blkHiOut(buff);
		}
		if (this.doBlkGam) {
			this.blkGamOut(buff);
		}
		if (this.doDisplay) {
			this.displayOut(buff);
		}
	}
	this.finalOut(buff,false);
	out.o = o.buffer;
	out.to = ['o'];
	return out;
};
LUTGamma.prototype.laCalcRGB = function(p,t,i) {
	var dim = i.dim;
	var d = dim -1;
	var m = dim*dim*dim*3;
	var c = new Float64Array(m);
	var buff = c.buffer;
	var j=0;
	for (var B=0; B<dim; B++) {
		for (var G=0; G<dim; G++) {
			for (var R=0; R<dim; R++) {
				c[ j ] = R/d;
				c[j+1] = G/d;
				c[j+2] = B/d;
				j += 3;
			}
		}
	}
	var natTF;
	switch (this.gammas[i.gamma].name) {
		case 'S-Log3':
			natTF = 0;
			break;
		case 'S-Log2':
			natTF = 1;
			break;
		case 'S-Log':
			natTF = 2;
			break;
		case 'C-Log':
			natTF = 3;
			break;
		case 'Canon C-Log2':
			natTF = 4;
			break;
		case 'Panasonic V-Log':
			natTF = 5;
			break;
		case 'REDLogFilm':
			natTF = 6;
			break;
		case 'Cineon':
			natTF = 7;
			break;
		case 'LogC (Sup 3.x & 4.x)':
			natTF = 8;
			break;
		case 'LogC (Sup 2.x)':
			natTF = 9;
			break;
		default:
			if (i.legIn) {
				this.gammas[this.SL3Idx].linFromL(buff, { rgb: true });
				this.gammas[i.gamma].linToL(buff, { rgb: true, rec: true });
			} else {
				this.gammas[this.SL3Idx].linFromD(buff, { rgb: true });
				this.gammas[i.gamma].linToD(buff, { rgb: true, rec: true });
			}
			natTF = 0;
			break;		
	}
	var out = { p: p, t: t+20, v: this.ver };
	out.dim = i.dim;
	out.legIn = i.legIn;
	out.gamma = i.gamma;
	out.gamut = i.gamut;
	out.natTF = natTF;
	out.o = buff;
	out.to = ['o'];
	return out;
};
LUTGamma.prototype.inCalcRGB = function(p,t,i) {
	var eiMult = this.eiMult;
	if (typeof i.eiMult === 'number') {
		eiMult = i.eiMult;
	}
	var out = { p: p, t: t+20, v: this.ver, R:i.R, G:i.G, B:i.B, vals: i.vals, dim: i.dim, eiMult: eiMult};
	var B = i.B;
	var max = i.dim;
	var o = new Float64Array(i.vals*3);
	var d = i.dim -1;
	if (this.nul) {
		if (this.inL) {
			if (this.outL) {
				for (var G=0; G<max; G++) {
					for (var R=0; R<max; R++) {
						var j = (R+(G*max))*3;
						if (this.sIn) {
							o[(j*3)] = ((R/d)*(this.sMax-this.sMin)) + this.sMin;
							o[(j*3)+1] = ((G/d)*(this.sMax-this.sMin)) + this.sMin;
							o[(j*3)+2] = ((B/d)*(this.sMax-this.sMin)) + this.sMin;
						} else {
							o[(j*3)] = R/d;
							o[(j*3)+1] = G/d;
							o[(j*3)+2] = B/d;
						}
					}
				}
			} else {
				for (var G=0; G<max; G++) {
					for (var R=0; R<max; R++) {
						var j = (R+(G*max))*3;
						if (this.sIn) {
							o[ j ] = ((876*(((R/d)*(this.sMax-this.sMin)) + this.sMin))+64)/1023;
							o[j+1] = ((876*(((G/d)*(this.sMax-this.sMin)) + this.sMin))+64)/1023;
							o[j+2] = ((876*(((B/d)*(this.sMax-this.sMin)) + this.sMin))+64)/1023;
						} else {
							o[ j ] = ((876*(R/d))+64)/1023;
							o[j+1] = ((876*(G/d))+64)/1023;
							o[j+2] = ((876*(B/d))+64)/1023;
						}
					}
				}
			}
		} else {
			if (this.outL) {
				for (var G=0; G<max; G++) {
					for (var R=0; R<max; R++) {
						var j = (R+(G*max))*3;
						if (this.sIn) {
							o[ j ] = ((1023*(((R/d)*(this.sMax-this.sMin)) + this.sMin))-64)/876;
							o[j+1] = ((1023*(((G/d)*(this.sMax-this.sMin)) + this.sMin))-64)/876;
							o[j+2] = ((1023*(((B/d)*(this.sMax-this.sMin)) + this.sMin))-64)/876;
						} else {
							o[ j ] = ((1023*R/d)-64)/876;
							o[j+1] = ((1023*G/d)-64)/876;
							o[j+2] = ((1023*B/d)-64)/876;
						}
					}
				}
			} else {
				for (var G=0; G<max; G++) {
					for (var R=0; R<max; R++) {
						var j = (R+(G*max))*3;
						if (this.sIn) {
							o[ j ] = ((R/d)*(this.sMax-this.sMin)) + this.sMin;
							o[j+1] = ((G/d)*(this.sMax-this.sMin)) + this.sMin;
							o[j+2] = ((B/d)*(this.sMax-this.sMin)) + this.sMin;
						} else {
							o[ j ] = R/d;
							o[j+1] = G/d;
							o[j+2] = B/d;
						}
					}
				}
			}
		}
	} else {
		if (this.inL) {
			for (var G=0; G<max; G++) {
				for (var R=0; R<max; R++) {
					var j = (R+(G*max))*3;
					if (this.sIn) {
						o[ j ] = ((R/d)*(this.sMax-this.sMin)) + this.sMin;
						o[j+1] = ((G/d)*(this.sMax-this.sMin)) + this.sMin;
						o[j+2] = ((B/d)*(this.sMax-this.sMin)) + this.sMin;
					} else {
						o[ j ] = R/d;
						o[j+1] = G/d;
						o[j+2] = B/d;
					}
				}
			}
			this.gammas[this.curIn].linFromL(o.buffer, { rgb: true });
		} else {
			for (var G=0; G<max; G++) {
				for (var R=0; R<max; R++) {
					var j = (R+(G*max))*3;
					if (this.sIn) {
						o[ j ] = ((R/d)*(this.sMax-this.sMin)) + this.sMin;
						o[j+1] = ((G/d)*(this.sMax-this.sMin)) + this.sMin;
						o[j+2] = ((B/d)*(this.sMax-this.sMin)) + this.sMin;
					} else {
						o[ j ] = R/d;
						o[j+1] = G/d;
						o[j+2] = B/d;
					}
				}
			}
			this.gammas[this.curIn].linFromD(o.buffer, { rgb: true });
		}
	}
	out.o = o.buffer;
	out.to = ['o'];
	return out;
};
LUTGamma.prototype.outCalcRGB = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, R:i.R, G:i.G, B:i.B, vals: i.vals, dim: i.dim };
	var o = new Float64Array(i.o);
	var m = o.length;
	if (!this.nul) {
		if (this.doKnee) {
			this.kneeOut(i.o);
		} else {
			this.gammas[this.curOut].linToL(i.o, { rgb: true });
		}
		if (this.doBlkHi) {
			this.blkHiOut(i.o);
		}
		if (this.doBlkGam) {
			this.blkGamOut(i.o);
		}
		if (this.doDisplay) {
			this.displayOut(i.o, { rgb: true });
		}
		if (i.doGamutLim) {
			this.gamutLimOut(i.o, i.gLimY, i.gLimL, i.og, i.gLimB);
		}
		if (i.doFC) {
			this.fcOut(i.fc,i.o);
		}
	}
	if (typeof i.cb === 'boolean') {
		this.finalOut(i.o,i.cb);
	} else {
		this.finalOut(i.o,false);
	}
	out.o = o.buffer;
	out.to = ['o'];
	return out;
};
LUTGamma.prototype.getLists = function(p,t) {
	return {
		p: p,
		t: t+20,
		v: this.ver,
		inList: this.inList,
		outList: this.outList,
		linList: this.linList,
		disList: this.disList,
		catList: this.catList,
		baseGamuts: this.gts,
		baseDisGamuts: this.disGts,
		subNames: this.subNames,
		subList: this.gammaSub,
		gammaDat: this.gammaDat,
		gammaExt: this.gammaExt,
		rec709: this.rec709,
		PQ: this.PQ,
		HLG: this.HLG,
		PQOOTF: this.pqOOTFIdx,
		PQEOTF: this.pqEOTFIdx,
		HLGOOTF: this.hlgOOTFIdx,
		ARRIList: this.arriIdxList,
		DLogM: this.DLogM,
		LA: this.LA
	};
};
LUTGamma.prototype.setLA = function(p,t,i) {
	this.gammas[this.LA].setLUT(i);
	return { p: p, t:t+20, v: this.ver, i: i.title };
};
LUTGamma.prototype.setLATitle = function(p,t,i) {
	this.gammas[this.LA].setTitle(i);
	return { p: p, t:t+20, v: this.ver, i: i };
};
LUTGamma.prototype.SL3Val = function(p,t,i) {
	var m = i.dim;
	var d = m-1;
	var c = new Float64Array(m);
	var buff = c.buffer;
	for (var j=0; j<m; j++) {
		c[j] = j/d;
	}
	this.gammas[this.SL3Idx].linFromD(buff);
	if (i.legIn) {
		this.gammas[i.gamma].linToL(buff, { rgb: false, rec: true });
	} else {
		this.gammas[i.gamma].linToD(buff, { rgb: false, rec: true });
	}
	var out = { p: p, t: t+20, v: this.ver, o: buff};
	out.dim = i.dim;
	out.legIn = i.legIn;
	out.gamma = i.gamma;
	out.to = ['o'];
	return out;
};
LUTGamma.prototype.ioNames = function(p,t) {
	var out = {};
	out.inName = this.gammas[this.curIn].name;
	out.outName = this.gammas[this.curOut].name;
	if (this.gammas[this.curIn].cat === 1) {
		out.inG = this.gammas[this.curIn].gamma;
	}
	if (this.gammas[this.curOut].cat === 1) {
		out.outG = this.gammas[this.curOut].gamma;
	}
	return {p: p, t: t+20, v: this.ver, o: out};
};
LUTGamma.prototype.chartVals = function(p,t,i) {
	var out = {p: p, t: t+20, v: this.ver};
	var m = 129;
	var d = m-1;
	var k,r,bg;
	var refX = new Float64Array(m);
	var refIn = new Float64Array(m);
	var stopX = new Float64Array(m);
	var stopIn = new Float64Array(m);
	var lutIn = new Float64Array(m);
	var lutOut = new Float64Array(m);
	var colIn = new Float64Array(m);
	var cMin,cMax;
	cMin = (this.bClip - 64)/876;
	cMax = (this.wClip - 64)/876;
	if (this.clip) {
		if (this.outL || this.clipL) {
			if (this.clipB && cMin<0) {
				cMin = 0;
			}
			if (this.clipW && cMax>1) {
				cMax = 1;
			}
		}
	}
	if (this.hdrOut && !this.doDisplay) {
		var mx = this.gammas[this.curOut].mxO;
		if (mx < cMax) {
			cMax = mx;
		}
	}
	for (var j=0; j<m; j++) {
		k = j/d;
		refX[j] = 14*k;
		refIn[j] = refX[j]/0.9;
		stopX[j] = (18*k)-9;
		stopIn[j] = Math.pow(2,stopX[j]) / 5;
		lutIn[j] = k;
		lutOut[j] = ((k*1023) - 64)/876;
		colIn[j] = k;
	}
	var stopPreVals = new Float64Array(17);
	var stopVals = new Float64Array(17);
	for (var j=0; j<17; j++) {
		stopPreVals[j] = Math.pow(2,j-8) / 5;
		stopVals[j] = Math.pow(2,j-8) / 5;
	}
	var refOut = new Float64Array(refIn);
	out.curIn = this.curIn;
	out.curOut = this.curOut;
	this.gammas[this.curIn].linToL(refIn.buffer, { rec: true });
	var stopOut = new Float64Array(stopIn);
	this.gammas[this.curIn].linToL(stopIn.buffer, { rec: true });
	this.gammas[this.curIn].linFromL(colIn.buffer, { rec: true });
	if (this.nul) {
		refOut = new Float64Array(refIn);
		stopOut = new Float64Array(stopIn);
		this.gammas[this.curIn].linToL(stopPreVals.buffer, { rec: true });
		this.gammas[this.curIn].linToL(stopVals.buffer, { rec: true });
	} else {
		this.gammas[this.curIn].linFromL(lutOut.buffer);
		for (var j=0; j<m; j++) {
			refOut[j] *= this.eiMult;
			stopOut[j] *= this.eiMult;
			lutOut[j] *= this.eiMult;
		}
		for (var j=0; j<17; j++) {
			stopPreVals[j] /= this.eiMult;
		}
		this.getLumVals(refOut.buffer);
		this.getLumVals(stopOut.buffer);
		this.getLumVals(lutOut.buffer);
		this.gammas[this.curIn].linToL(stopPreVals.buffer, { rec: true });
		this.getLumVals(stopVals.buffer);
		if (this.doBlkHi) {
			for (var j=0; j<m; j++) {
				refOut[j] = (refOut[j] * this.al) + this.bl;
				stopOut[j] = (stopOut[j] * this.al) + this.bl;
				lutOut[j] = (lutOut[j] * this.al) + this.bl;
			}
			for (var j=0; j<17; j++) {
				stopVals[j] = (stopVals[j] * this.al) + this.bl;
			}
		}
		if (this.doBlkGam) {
			for (var j=0; j<m; j++) {
				if (refOut[j] > this.blkLevel && refOut[j] <= this.blkGamUL) {
					if (refOut[j] > this.blkGamLL) {
						bg = (Math.pow((refOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
						if (refOut[j] <= bg) {
							refOut[j] = bg;
						} else {
							r = (refOut[j]-this.blkGamLL)/this.blkGamF;
							r *= r;
							refOut[j] = (r*refOut[j]) + ((1-r)*bg);
						}
					} else {
						refOut[j] = (Math.pow((refOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					}
				}
				if (stopOut[j] > this.blkLevel && stopOut[j] <= this.blkGamUL) {
					if (stopOut[j] > this.blkGamLL) {
						bg = (Math.pow((stopOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
						if (stopOut[j] <= bg) {
							stopOut[j] = bg;
						} else {
							r = (stopOut[j]-this.blkGamLL)/this.blkGamF;
							r *= r;
							stopOut[j] = (r*stopOut[j]) + ((1-r)*bg);
						}
					} else {
						stopOut[j] = (Math.pow((stopOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					}
				}
				if (lutOut[j] > this.blkLevel && lutOut[j] <= this.blkGamUL) {
					if (lutOut[j] > this.blkGamLL) {
						bg = (Math.pow((lutOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
						if (lutOut[j] <= bg) {
							lutOut[j] = bg;
						} else {
							r = (lutOut[j]-this.blkGamLL)/this.blkGamF;
							r *= r;
							lutOut[j] = (r*lutOut[j]) + ((1-r)*bg);
						}
					} else {
						lutOut[j] = (Math.pow((lutOut[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					}
				}
			}
			for (var j=0; j<17; j++) {
				if (stopVals[j] > this.blkLevel && stopVals[j] <= this.blkGamUL) {
					if (stopVals[j] > this.blkGamLL) {
						bg = (Math.pow((stopVals[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
						if (stopVals[j] <= bg) {
							stopVals[j] = bg;
						} else {
							r = (stopVals[j]-this.blkGamLL)/this.blkGamF;
							r *= r;
							stopVals[j] = (r*stopVals[j]) + ((1-r)*bg);
						}
					} else {
						stopVals[j] = (Math.pow((stopVals[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					}
				}
			}
		}
		if (this.doDisplay) {
			this.displayOut(refOut.buffer);
			this.displayOut(stopOut.buffer);
			this.displayOut(lutOut.buffer);
			this.displayOut(stopVals.buffer);
		}
// Final clipping
		for (var j=0; j<m; j++) {
			refOut[ j ] = Math.min(cMax,Math.max(cMin,refOut[ j ]));
			stopOut[ j ] = Math.min(cMax,Math.max(cMin,stopOut[ j ]));
			lutOut[ j ] = Math.min(cMax,Math.max(cMin,lutOut[ j ]));
		}
		for (var j=0; j<17; j++) {
			stopVals[ j ] = Math.min(cMax,Math.max(cMin,stopVals[ j ]));
		}
//
	}
	var table = new Float64Array([0,0.18,0.38,0.44,0.9,7.2,this.camClip]);
	for (var j=0; j<7; j++) {
		table[j] /= 0.9;
	}
	if (this.nul) {
		this.gammas[this.curIn].linToL(table.buffer, { rec: true });
	} else {
		this.getLumVals(table.buffer);
		if (this.doBlkHi) {
			for (var j=0; j<7; j++) {
				table[j] = (table[j] * this.al) + this.bl;
			}
		}
		if (this.doBlkGam) {
			for (var j=0; j<7; j++) {
				if (table[j] > this.blkLevel && table[j] <= this.blkGamUL) {
					if (table[j] > this.blkGamLL) {
						bg = (Math.pow((table[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
						if (table[j] <= bg) {
							table[j] = bg;
						} else {
							r = (table[j]-this.blkGamLL)/this.blkGamF;
							r *= r;
							table[j] = (r*table[j]) + ((1-r)*bg);
						}
					} else {
						table[j] = (Math.pow((table[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					}
				}
			}
		}
		if (this.doDisplay) {
			this.displayOut(table.buffer);
		}
	}
	out.m = m;
	out.refX = refX.buffer;
	out.refIn = refIn.buffer;
	out.refOut = refOut.buffer;
	out.stopX = stopX.buffer;
	out.stopIn = stopIn.buffer;
	out.stopOut = stopOut.buffer;
	out.stopPreVals = stopPreVals.buffer;
	out.stopVals = stopVals.buffer;
	out.lutIn = lutIn.buffer;
	out.lutOut = lutOut.buffer;
	out.colIn = colIn.buffer;
	out.colOut = colIn.buffer.slice(0);
	out.table = table.buffer;
	out.eiMult = this.eiMult;
	out.to = ['refX','refIn','refOut','stopX','stopIn','stopOut','stopPreVals','stopVals','lutIn','lutOut','colIn','table'];
	return out;
};
LUTGamma.prototype.preview = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, leg:i.leg, line:i.line, upd: i.upd };
	var eiMult = 1;
	if (typeof i.eiMult === 'number') {
		eiMult = i.eiMult;
	}
	var f = new Float64Array(i.o);
	var m = f.length;
	var o = new Uint8Array(Math.round(m*4/3));
	var l;
	// Establish Clipping Levels
	var mn,mx,mx2;
	if (typeof i.cb === 'boolean' && i.cb) {
		mn = 0;
	} else {
		mn = (this.bClip - 64)/876;
	}
	mn = Math.max(mn,-0.073);
	mx = (this.wClip - 64)/876;
	mx = Math.min(mx,1.095);
	if (this.clip) {
		if (this.outL || this.clipL) {
			if (this.clipB && mn<0) {
				mn = 0;
			}
			if (this.clipW && mx>1) {
				mx = 1;
			}
		}
	}
	if (this.hdrOut && !this.doDisplay) {
		mx = Math.min(mx, this.gammas[this.curOut].mxO);
	}
	if (i.leg) {
		mx2 = 255;
	} else {
		mx2 = mx*255/1.095;
	}
	// Calculate Output
	if (this.nul) {
		l = 0;
		var mul = 239;
		if (i.leg) {
			mul = 255;
		}
		this.gammas[this.SL3Idx].linToL(i.o);
		for (var j=0; j<m; j += 3) {
			f[ j ] = Math.min(mx,Math.max(mn,f[ j ]));
			f[j+1] = Math.min(mx,Math.max(mn,f[j+1]));
			f[j+2] = Math.min(mx,Math.max(mn,f[j+2]));
			o[ l ] = Math.min(255,Math.max(0,Math.round(f[ j ]*mul)));
			o[l+1] = Math.min(255,Math.max(0,Math.round(f[j+1]*mul)));
			o[l+2] = Math.min(255,Math.max(0,Math.round(f[j+2]*mul)));
			o[l+3] = 255;
			l += 4;
		}
	} else {
		var m = f.length;
		// Exposure Correction
		for (var j=0; j<m; j += 3) {
			f[ j ] *= eiMult;
			f[j+1] *= eiMult;
			f[j+2] *= eiMult;
		}
		// ASC-CDL
		if (this.doASCCDL && !i.threeD) {
			for (var j=0; j<m; j += 3) {
				// Red
				f[ j ] = (f[ j ]*this.asc[0])+this.asc[3];
				f[ j ] = ((f[ j ]<0)?f[ j ]:Math.pow(f[ j ],this.asc[6]));
				f[ j ] = (isNaN(f[ j ])?0:f[ j ]);
				// Green
				f[j+1] = (f[j+1]*this.asc[1])+this.asc[4];
				f[j+1] = ((f[j+1]<0)?f[j+1]:Math.pow(f[j+1],this.asc[7]));
				f[j+1] = (isNaN(f[j+1])?0:f[j+1]);
				// Blue
				f[j+2] = (f[j+2]*this.asc[2])+this.asc[5];
				f[j+2] = ((f[j+2]<0)?f[j+2]:Math.pow(f[j+2],this.asc[8]));
				f[j+2] = (isNaN(f[j+2])?0:f[j+2]);
			}
			if (doOG) {
				for (var j=0; j<m; j += 3) {
					// Red
					og[ j ] = (og[ j ]*this.asc[0])+this.asc[3];
					og[ j ] = ((og[ j ]<0)?og[ j ]:Math.pow(og[ j ],this.asc[6]));
					og[ j ] = (isNaN(og[ j ])?0:og[ j ]);
					// Green
					og[j+1] = (og[j+1]*this.asc[1])+this.asc[4];
					og[j+1] = ((og[j+1]<0)?og[j+1]:Math.pow(og[j+1],this.asc[7]));
					og[j+1] = (isNaN(og[j+1])?0:og[j+1]);
					// Blue
					og[j+2] = (og[j+2]*this.asc[2])+this.asc[5];
					og[j+2] = ((og[j+2]<0)?og[j+2]:Math.pow(og[j+2],this.asc[8]));
					og[j+2] = (isNaN(og[j+2])?0:og[j+2]);
				}
			}
		}
		// Knee
		if (this.doKnee) {
			this.kneeOut(i.o, { rgb: true });
		} else {
			this.gammas[this.curOut].linToL(i.o, { rgb: true });
		}
		// Black Level / Highlight Level
		if (this.doBlkHi) {
			this.blkHiOut(i.o);
		}
		// Black Gamma
		if (this.doBlkGam) {
			this.blkGamOut(i.o);
		}
		// Display Colourspace Conversion
		if (this.doDisplay) {
			this.displayOut(i.o, { rgb: true });
		}
		// Gamut Limiter
		if (i.doGamutLim) {
			if (typeof i.og !== 'undefined') {
				var og = new Float64Array(i.og);
				for (var j=0; j<m; j++) {
					og[ j ] *= eiMult;
				}
			}
			this.gamutLimOut(i.o, i.gLimY, i.gLimL, i.og, i.gLimB);
		}
		// Hard Clipping
		for (var j=0; j<m; j++) {
			f[ j ] = Math.min(mx,Math.max(mn,(f[ j ])));
		}
		// False Colour
		if (i.doFC) {
			this.fcOut(i.fc, i.o);
		}
		// Legal / Extended
		l = 0;
		if (i.leg) {
			for (var j=0; j<m; j += 3) {
				o[ l ] = Math.min(mx2,Math.max(0,Math.round(f[ j ]*255)));
				o[l+1] = Math.min(mx2,Math.max(0,Math.round(f[j+1]*255)));
				o[l+2] = Math.min(mx2,Math.max(0,Math.round(f[j+2]*255)));
				o[l+3] = 255;
				l += 4;
			}
		} else {
			for (var j=0; j<m; j += 3) {
				o[ l ] = Math.min(mx2,Math.max(0,Math.round(f[ j ]*239)));
				o[l+1] = Math.min(mx2,Math.max(0,Math.round(f[j+1]*239)));
				o[l+2] = Math.min(mx2,Math.max(0,Math.round(f[j+2]*239)));
				o[l+3] = 255;
				l += 4;
			}
		}
	}
	out.o = o.buffer;
	out.f = f.buffer;
	out.to = ['o','f'];
	return out;
};
LUTGamma.prototype.previewLin = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, gamma: i.gamma, gamut: i.gamut, legal: i.legal, i: i.i };
	var o = i.i.slice(0);
	if (i.legal) {
		this.gammas[i.gamma].linFromL(o, { rgb: true });
	} else {
		this.gammas[i.gamma].linFromD(o, { rgb: true });
	}
	out.o = o;
	out.to = ['i','o'];
	return out;
/*
	var input = new Float64Array(i.i);
	var max = input.length;
	var o = new Float64Array(max);
	if (i.legal) {
		for (var j=0; j<max; j++) {
			o[j] = this.gammas[i.gamma].linFromLegal(input[j]);
		}
	} else {
		for (var j=0; j<max; j++) {
			o[j] = this.gammas[i.gamma].linFromData(input[j]);
		}
	}
	out.o = o.buffer;
	out.to = ['i','o'];
	return out;
*/
};
LUTGamma.prototype.getPrimaries = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver };
	var o = i.o.slice(0);
	this.gammas[this.curOut].linToL(o, { rgb: true });
	if (typeof i.cb === 'boolean' && i.cb) {
		var c = new Float64Array(o);
		var m = c.length;
		for (var j=0; j<m; j++) {
			c[j] = Math.max(0,c[j]);
		}
	}
	out.o = o;
/*
	var c = new Float64Array(i.o);
	var o = new Float64Array(18);
	if (typeof i.cb === 'boolean' && i.cb) {
		for (var j=0; j<18; j++) {
			o[j] = Math.max(0,this.gammas[this.curOut].linToLegal(c[j]));
		}
	} else {
		for (var j=0; j<18; j++) {
			o[j] = this.gammas[this.curOut].linToLegal(c[j]);
		}
	}
	out.o = o.buffer;
*/
	return out;
};
LUTGamma.prototype.psstColours = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver };
	var b = new Float64Array(i.b);
	var a = new Float64Array(i.a);
	var m = a.length;
	var before = new Uint8Array(m);
	var after = new Uint8Array(m);
	this.gammas[this.curOut].linToL(i.b, { rgb: true });
	this.gammas[this.curOut].linToL(i.a, { rgb: true });
	if (this.doDisplay) {
		this.displayOut(i.b, { rgb: true });
		this.displayOut(i.a, { rgb: true });
	}
// doBlkGam
	if (this.doBlkHi) {
		for (var j=0; j<m; j++) {
			before[j] = Math.min(255,Math.max(0,Math.round(((b[ j ] * this.al) + this.bl)*255)));
			after[j] = Math.min(255,Math.max(0,Math.round(((a[ j ] * this.al) + this.bl)*255)));
		}
	} else {
		for (var j=0; j<m; j++) {
			before[j] = Math.min(255,Math.max(0,Math.round(b[ j ]*255)));
			after[j] = Math.min(255,Math.max(0,Math.round(a[ j ]*255)));
		}
	}
	out.b = before.buffer;
	out.a = after.buffer;
	out.to = ['b','a'];
	return out;
};
LUTGamma.prototype.multiColours = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver };
	var input = new Float64Array(i.o);
	var m = input.length;
	var o = new Uint8Array(m);
	if (!this.nul) {
		if (this.doKnee) {
			this.kneeOut(i.o, { rgb: true });
		} else {
			this.gammas[this.curOut].linToL(i.o, { rgb: true });
		}
		if (this.doBlkHi) {
			this.blkHiOut(i.o);
		}
		if (this.doBlkGam) {
			this.blkGamOut(i.o);
		}
		if (this.doDisplay) {
			this.displayOut(i.o, { rgb: true });
		}
		if (i.doGamutLim) {
			this.gamutLimOut(i.o, i.gLimY, i.gLimL, i.og, i.gLimB);
		}
	}
	for (var j=0; j<m; j++) {
		o[j] = Math.max(0,(Math.min(255,input[j]*255/1.09475)));
	}
	out.o = o.buffer;
	out.hs = i.hs;
	out.to = ['o','hs'];
	return out;	
};
LUTGamma.prototype.chartRGB = function(p,t,i) {
	var out = { p: p, t: t+20, v: this.ver, colIn: i.colIn, rIn: i.rIn, gIn: i.gIn, bIn: i.bIn, rOut: i.rOut, gOut: i.gOut, bOut: i.bOut, to: ['rIn','gIn','bIn','rOut','gOut','bOut']};
	this.gammas[this.curIn].linToD(i.rIn, { rec: true });
	this.gammas[this.curIn].linToD(i.gIn, { rec: true });
	this.gammas[this.curIn].linToD(i.bIn, { rec: true });
	this.gammas[this.curOut].linToL(i.rOut);
	this.gammas[this.curOut].linToL(i.gOut);
	this.gammas[this.curOut].linToL(i.bOut);
	var ra = new Float64Array(i.rOut);
	var ga = new Float64Array(i.gOut);
	var ba = new Float64Array(i.bOut);
	var r,bg;
	if (this.doBlkHi) {
		for (var j=0; j<m; j++) {
			ra[j] = (ra[j] * this.al) + this.bl;
			ga[j] = (ga[j] * this.al) + this.bl;
			ba[j] = (ba[j] * this.al) + this.bl;
		}
	}
	if (this.doBlkGam) {
		for (var j=0; j<m; j++) {
			if (ra[j] > this.blkLevel && ra[j] <= this.blkGamUL) {
				if (ra[j] > this.blkGamLL) {
					bg = (Math.pow((ra[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					if (ra[j] <= bg) {
						ra[j] = bg;
					} else {
						r = (ra[j]-this.blkGamLL)/this.blkGamF;
						r *= r;
						ra[j] = (r*ra[j]) + ((1-r)*bg);
					}
				} else {
					ra[j] = (Math.pow((ra[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
				}
			}
			if (ga[j] > this.blkLevel && ga[j] <= this.blkGamUL) {
				if (ga[j] > this.blkGamLL) {
					bg = (Math.pow((ga[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					if (ga[j] <= bg) {
						ga[j] = bg;
					} else {
						r = (ga[j]-this.blkGamLL)/this.blkGamF;
						r *= r;
						ga[j] = (r*ga[j]) + ((1-r)*bg);
					}
				} else {
					ga[j] = (Math.pow((ga[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
				}
			}
			if (ba[j] > this.blkLevel && ba[j] <= this.blkGamUL) {
				if (ba[j] > this.blkGamLL) {
					bg = (Math.pow((ba[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
					if (ba[j] <= bg) {
						ba[j] = bg;
					} else {
						r = (ba[j]-this.blkGamLL)/this.blkGamF;
						r *= r;
						ba[j] = (r*ba[j]) + ((1-r)*bg);
					}
				} else {
					ba[j] = (Math.pow((ba[j]-this.blkLevel)/this.blkGamR,this.blkGamP)*this.blkGamR)+this.blkLevel;
				}
			}
		}
	}
	if (typeof i.cb === 'boolean' && i.cb) {
		for (var j=0; j<m; j++) {
			ra[j] = Math.max(0,ra[j]);
			ga[j] = Math.max(0,ga[j]);
			ba[j] = Math.max(0,ba[j]);
		}
	}
	return out;
};
LUTGamma.prototype.changePQ = function(p,t,i) {
	var out = {p: p, t: t+20, v: this.ver};
//	this.gammas[this.PQ].changeLMax(i);
	out.ok = true;
	return out;
};
LUTGamma.prototype.setHDRDisplayIntent = function(p,t,i) {
	var out = {p: p, t: t+20, v: this.ver};
	if (typeof i.Lw === 'number') {
		if (typeof i.Lw === 'number') {
			this.pqOOTF.setLw(i.Lw,i.Lb);
			this.pqOOTFNorm.setLw(i.Lw,i.Lb);
		} else {
			this.pqOOTF.setLw(i.Lw,0);
			this.pqOOTFNorm.setLw(i.Lw,0);
		}
	}
	out.ok = true;
	return out;
};
// Web worker messaging functions
function LUTGammaWorker() {
	this.gammas = new LUTGamma();
	addEventListener('message', function(e) {
		var d = e.data;
		if (typeof d.t === 'undefined') {
		} else if (d.t !== 0 && d.t < 20 && d.v !== lutGammaWorker.gammas.ver) {
			postMessage({p: d.p, t: d.t, v: d.v, resend: true, d: d.d});
		} else {
			switch (d.t) {
				case 0:	lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.setParams(d.d));
						break;
				case 1: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.oneDCalc(d.p,d.t,d.d)); // Calculate 1D (gamma only) conversion from input to output
						break;
				case 2: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.laCalcRGB(d.p,d.t,d.d));
						break;
				case 3: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.inCalcRGB(d.p,d.t,d.d)); 
						break;
				case 4: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.outCalcRGB(d.p,d.t,d.d)); 
						break;
				case 5: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.getLists(d.p,d.t)); 
						break;
				case 6: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.setLA(d.p,d.t,d.d)); 
						break;
				case 7: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.setLATitle(d.p,d.t,d.d)); 
						break;
				case 8: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.SL3Val(d.p,d.t,d.d)); 
						break;
//				case 9: lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.laCalcInput(d.p,d.t,d.d)); 
//						break;
				case 10:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.ioNames(d.p,d.t));
						break;
				case 11:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.chartVals(d.p,d.t));
						break;
				case 12:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.preview(d.p,d.t,d.d));
						break;
				case 14:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.previewLin(d.p,d.t,d.d));
						break;
				case 15:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.getPrimaries(d.p,d.t,d.d));
						break;
				case 16:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.psstColours(d.p,d.t,d.d));
						break;
				case 17:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.multiColours(d.p,d.t,d.d));
						break;
				case 18:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.chartRGB(d.p,d.t,d.d));
						break;
				case 19:lutGammaWorker.sendGammaMessage(lutGammaWorker.gammas.changePQ(d.p,d.t,d.d));
						break;
			}
		}
	}, false);
}
LUTGammaWorker.prototype.sendGammaMessage = function(d) {
	if (this.gammas.isTrans && typeof d.to !== 'undefined') {
		var max = d.to.length;
		var objArray = [];
		for (var j=0; j < max; j++) {
			objArray.push(d[d.to[j]]);
		}
		postMessage(d,objArray);
	} else {
		postMessage(d);
	}
};
// Stringify for inline Web Worker
function getGammaWorkerString() {
	var out = "";
	// Main Object Function
	out += LUTGamma.toString() + "\n";
	for (var j in LUTGamma.prototype) {
		out += 'LUTGamma.prototype.' + j + '=' + LUTGamma.prototype[j].toString() + "\n";
	}
	// LUTGammaLog
	out += LUTGammaLog.toString() + "\n";
	for (var j in LUTGammaLog.prototype) {
		out += 'LUTGammaLog.prototype.' + j + '=' + LUTGammaLog.prototype[j].toString() + "\n";
	}
	// LUTGammaLogClip
	out += LUTGammaLogClip.toString() + "\n";
	for (var j in LUTGammaLogClip.prototype) {
		out += 'LUTGammaLogClip.prototype.' + j + '=' + LUTGammaLogClip.prototype[j].toString() + "\n";
	}
	// LUTGammaCineon
	out += LUTGammaCineon.toString() + "\n";
	for (var j in LUTGammaCineon.prototype) {
		out += 'LUTGammaCineon.prototype.' + j + '=' + LUTGammaCineon.prototype[j].toString() + "\n";
	}
	// LUTGammaArri
	out += LUTGammaArri.toString() + "\n";
	for (var j in LUTGammaArri.prototype) {
		out += 'LUTGammaArri.prototype.' + j + '=' + LUTGammaArri.prototype[j].toString() + "\n";
	}
	// LUTGammaLogC4
	out += LUTGammaLogC4.toString() + "\n";
	for (var j in LUTGammaLogC4.prototype) {
		out += 'LUTGammaLogC4.prototype.' + j + '=' + LUTGammaLogC4.prototype[j].toString() + "\n";
	}
	// LUTGammaCLog3
	out += LUTGammaCLog3.toString() + "\n";
	for (var j in LUTGammaCLog3.prototype) {
		out += 'LUTGammaCLog3.prototype.' + j + '=' + LUTGammaCLog3.prototype[j].toString() + "\n";
	}
	// LUTGammaNLog
	out += LUTGammaNLog.toString() + "\n";
	for (var j in LUTGammaNLog.prototype) {
		out += 'LUTGammaNLog.prototype.' + j + '=' + LUTGammaNLog.prototype[j].toString() + "\n";
	}
	// LUTGammaLogLog
	out += LUTGammaLogLog.toString() + "\n";
	for (var j in LUTGammaLogLog.prototype) {
		out += 'LUTGammaLogLog.prototype.' + j + '=' + LUTGammaLogLog.prototype[j].toString() + "\n";
	}
	// LUTGammaDaVinci
	out += LUTGammaDaVinci.toString() + "\n";
	for (var j in LUTGammaDaVinci.prototype) {
		out += 'LUTGammaDaVinci.prototype.' + j + '=' + LUTGammaDaVinci.prototype[j].toString() + "\n";
	}
	// LUTGammaAppleLog
	out += LUTGammaAppleLog.toString() + "\n";
	for (var j in LUTGammaAppleLog.prototype) {
		out += 'LUTGammaAppleLog.prototype.' + j + '=' + LUTGammaAppleLog.prototype[j].toString() + "\n";
	}


	// LUTGammaLog2
	out += LUTGammaLog2.toString() + "\n";
	for (var j in LUTGammaLog2.prototype) {
		out += 'LUTGammaLog2.prototype.' + j + '=' + LUTGammaLog2.prototype[j].toString() + "\n";
	}



	// LUTGammaGam
	out += LUTGammaGam.toString() + "\n";
	for (var j in LUTGammaGam.prototype) {
		out += 'LUTGammaGam.prototype.' + j + '=' + LUTGammaGam.prototype[j].toString() + "\n";
	}
	// LUTGammaBBCGam
	out += LUTGammaBBCGam.toString() + "\n";
	for (var j in LUTGammaBBCGam.prototype) {
		out += 'LUTGammaBBCGam.prototype.' + j + '=' + LUTGammaBBCGam.prototype[j].toString() + "\n";
	}
	// LUTGammaLin
	out += LUTGammaLin.toString() + "\n";
	for (var j in LUTGammaLin.prototype) {
		out += 'LUTGammaLin.prototype.' + j + '=' + LUTGammaLin.prototype[j].toString() + "\n";
	}
	// LUTGammaPQ
	out += LUTGammaPQ.toString() + "\n";
	for (var j in LUTGammaPQ.prototype) {
		out += 'LUTGammaPQ.prototype.' + j + '=' + LUTGammaPQ.prototype[j].toString() + "\n";
	}
	// LUTGammaHLG
	out += LUTGammaHLG.toString() + "\n";
	for (var j in LUTGammaHLG.prototype) {
		out += 'LUTGammaHLG.prototype.' + j + '=' + LUTGammaHLG.prototype[j].toString() + "\n";
	}
	// LUTGammaOOTFPQ
	out += LUTGammaOOTFPQ.toString() + "\n";
	for (var j in LUTGammaOOTFPQ.prototype) {
		out += 'LUTGammaOOTFPQ.prototype.' + j + '=' + LUTGammaOOTFPQ.prototype[j].toString() + "\n";
	}
	// LUTGammaOOTFHLG
	out += LUTGammaOOTFHLG.toString() + "\n";
	for (var j in LUTGammaOOTFHLG.prototype) {
		out += 'LUTGammaOOTFHLG.prototype.' + j + '=' + LUTGammaOOTFHLG.prototype[j].toString() + "\n";
	}
	// LUTGammaOOTFNone
	out += LUTGammaOOTFNone.toString() + "\n";
	for (var j in LUTGammaOOTFNone.prototype) {
		out += 'LUTGammaOOTFNone.prototype.' + j + '=' + LUTGammaOOTFNone.prototype[j].toString() + "\n";
	}
	// LUTGammaITUProp
	out += LUTGammaITUProp.toString() + "\n";
	for (var j in LUTGammaITUProp.prototype) {
		out += 'LUTGammaITUProp.prototype.' + j + '=' + LUTGammaITUProp.prototype[j].toString() + "\n";
	}
	// LUTGammaBBC283
	out += LUTGammaBBC283.toString() + "\n";
	for (var j in LUTGammaBBC283.prototype) {
		out += 'LUTGammaBBC283.prototype.' + j + '=' + LUTGammaBBC283.prototype[j].toString() + "\n";
	}
	// LUTGammaACEScc
	out += LUTGammaACEScc.toString() + "\n";
	for (var j in LUTGammaACEScc.prototype) {
		out += 'LUTGammaACEScc.prototype.' + j + '=' + LUTGammaACEScc.prototype[j].toString() + "\n";
	}
	// LUTGammaACESProxy
	out += LUTGammaACESProxy.toString() + "\n";
	for (var j in LUTGammaACESProxy.prototype) {
		out += 'LUTGammaACESProxy.prototype.' + j + '=' + LUTGammaACESProxy.prototype[j].toString() + "\n";
	}
	// LUTGammaGen
	out += LUTGammaGen.toString() + "\n";
	for (var j in LUTGammaGen.prototype) {
		out += 'LUTGammaGen.prototype.' + j + '=' + LUTGammaGen.prototype[j].toString() + "\n";
	}
	// LUTGammaLUTSL3
	out += LUTGammaLUTSL3.toString() + "\n";
	for (var j in LUTGammaLUTSL3.prototype) {
		out += 'LUTGammaLUTSL3.prototype.' + j + '=' + LUTGammaLUTSL3.prototype[j].toString() + "\n";
	}
	// LUTGammaLUTSimple
	out += LUTGammaLUTSimple.toString() + "\n";
	for (var j in LUTGammaLUTSimple.prototype) {
		out += 'LUTGammaLUTSimple.prototype.' + j + '=' + LUTGammaLUTSimple.prototype[j].toString() + "\n";
	}
	// LUTGammaDLog
	out += LUTGammaDLog.toString() + "\n";
	for (var j in LUTGammaDLog.prototype) {
		out += 'LUTGammaDLog.prototype.' + j + '=' + LUTGammaDLog.prototype[j].toString() + "\n";
	}
	// LUTGammaIOLUT
	out += LUTGammaIOLUT.toString() + "\n";
	for (var j in LUTGammaIOLUT.prototype) {
		out += 'LUTGammaIOLUT.prototype.' + j + '=' + LUTGammaIOLUT.prototype[j].toString() + "\n";
	}
	// LUTGammaLA
	out += LUTGammaLA.toString() + "\n";
	for (var j in LUTGammaLA.prototype) {
		out += 'LUTGammaLA.prototype.' + j + '=' + LUTGammaLA.prototype[j].toString() + "\n";
	}
	// LUTGammaNull
	out += LUTGammaNull.toString() + "\n";
	for (var j in LUTGammaNull.prototype) {
		out += 'LUTGammaNull.prototype.' + j + '=' + LUTGammaNull.prototype[j].toString() + "\n";
	}
	// LUTGammaWorker
	out += LUTGammaWorker.toString() + "\n";
	for (var j in LUTGammaWorker.prototype) {
		out += 'LUTGammaWorker.prototype.' + j + '=' + LUTGammaWorker.prototype[j].toString() + "\n";
	}
	out += 'var lutGammaWorker = new LUTGammaWorker();' + "\n";
	return out;
}
var workerGammaString = getGammaWorkerString();
/* lut.js
* LUT handling object for the LUTCalc Web App.
* 31st December 2014
*
* LUTCalc generates 1D and 3D Lookup Tables (LUTs) for video cameras that shoot log gammas, 
* principally the Sony CineAlta line.
*
* By Ben Turley, http://turley.tv
* First License: GPLv2
* Github: https://github.com/cameramanben/LUTCalc
*/
function LUTs() {
}
LUTs.prototype.newLUT = function(d) {
	var params = {};
	if (typeof d.title === 'string') {
		params.title = d.title;
	}
	if (typeof d.format === 'string') {
		params.format = d.format;
	}
	if (typeof d.dims === 'number') {
		this.dims = d.dims;
	} else {
		dims = 1;
	}
	if (typeof d.min !== 'undefined' && (d.min[0] !== 0 || d.min[1] !== 0 || d.min[2] !== 0)) {
		params.fL = d.min[0];
		params.fLR = d.min[0];
		params.fLG = d.min[1];
		params.fLB = d.min[2];
	}
	if (typeof d.max !== 'undefined' && (d.max[0] !== 1 || d.max[1] !== 1 || d.max[2] !== 1)) {
		params.fH = d.max[0];
		params.fHR = d.max[0];
		params.fHG = d.max[1];
		params.fHB = d.max[2];
	}
	if (typeof d.fL === 'number') {
		params.fL = d.fL;
	}
	if (typeof d.fH === 'number') {
		params.fH = d.fH;
	}
	if (typeof d.fLR === 'number') {
		params.fLR = d.fLR;
	}
	if (typeof d.fLG === 'number') {
		params.fLG = d.fLG;
	}
	if (typeof d.fLB === 'number') {
		params.fLB = d.fLB;
	}
	if (typeof d.fHR === 'number') {
		params.fHR = d.fHR;
	}
	if (typeof d.fHG === 'number') {
		params.fHG = d.fHG;
	}
	if (typeof d.fHB === 'number') {
		params.fHB = d.fHB;
	}
	if (typeof d.spline !== 'undefined') {
		params.inSpline = d.spline;
	}
	if (typeof d.meta !== 'undefined') {
		params.meta = d.meta;
	}
	if (d.C.length === 3) {
		params.buffR = d.C[0].slice(0);
		params.buffG = d.C[1].slice(0);
		params.buffB = d.C[2].slice(0);
		if (this.dims === 3) {
			return new LUTVolume(params);
		} else {
			return new LUTRGBSpline(params);
		}
	} else {
		params.buff = d.C[0].slice(0);
		return new LUTSpline(params);
	}
};
// LUTSpline - base spline object; forward only but with arbitrary input range
function LUTSpline(params) {
	// Metadata
	if (typeof params.title === 'string') {
		this.title = params.title;
	} else {
		this.title = '';
	}
	if (typeof params.format === 'string') {
		this.format = params.format;
	} else {
		this.format = '';
	}
	if (typeof params.meta !== 'undefined') {
		this.meta = params.meta;
	} else {
		this.meta = {};
	}
	// Precalculate forward parameters
	this.FD = new Float64Array(params.buff);
	var fm = this.FD.length;
	var mono = this.FD[fm-1]-this.FD[0];
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	this.FA = new Float64Array(fm);
	this.FB = new Float64Array(fm);
	this.FC = new Float64Array(fm);
	var FP1 = new Float64Array(fm);
	var FD1 = new Float64Array(fm);
	for (var j=0; j<fm; j++) {
		if (j === 0) {
			FP1[0] = this.FD[1];
//			this.FC[0] = (0.1*this.FD[3]) - (0.8*this.FD[2]) + (2.3*this.FD[1]) - (1.6*this.FD[0]);
//			if (this.FC[0]*mono <= 0) { // opposite slope to monotonic
				this.FC[0] = -(0.5*this.FD[2]) + (2*this.FD[1]) - (1.5*this.FD[0]);
				if (this.FC[0]*mono <= 0) { // still opposite slope to monotonic
					this.FC[0] = 0.0075 * mono / (fm-1);
				}
//			}
			FD1[0] = (this.FD[2] - this.FD[0])/2;
		} else if (j < fm-1) {
			FP1[j] = this.FD[j+1];
			this.FC[j] = (this.FD[j+1] - this.FD[j-1])/2;
			if (j === fm-2) {
//				FD1[j] = (-0.1*this.FD[j-2]) + (0.8*this.FD[j-1]) - (2.3*this.FD[j]) + (1.6*this.FD[j+1]);
//				if (FD1[j]*mono <= 0) { // opposite slope to monotonic
					FD1[j] = (0.5*this.FD[j-1]) - (2*this.FD[j]) + (1.5*this.FD[j+1]);
					if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						FD1[j] = 0.0075 * mono / (fm-1);
					}
//				}
			} else {
				FD1[j] = (this.FD[j+2] - this.FD[j])/2;
			}
		} else {
			FP1[j] = this.FD[j];
			this.FC[j] = FD1[j-1];
			FD1[j] = FD1[j-1];
		}
		this.FA[j] = (2*this.FD[j]) + this.FC[j] - (2*FP1[j]) + FD1[j];
		this.FB[j] = (-3*this.FD[j]) - (2*this.FC[j]) + (3*FP1[j]) - FD1[j];
	}
	this.FM = fm-1;
	// Set forward range
	this.fS = false;
	if (typeof params.fL === 'undefined' && typeof params.min !== 'undefined' && params.min[0] !== 0) {
		params.fL = params.min[0];
	}
	if (typeof params.fH === 'undefined' && typeof params.max !== 'undefined' && params.max[0] !== 1) {
		params.fH = params.max[0];
	}
	if (typeof params.fH === 'number') {
		this.fH = params.fH;
		if (typeof params.fL === 'number') {
			this.fL = params.fL;
		} else {
			this.fL = 0;
		}
	} else {
		this.fH = 1;
		this.fL = 0;
	}
	this.fLH = this.fH-this.fL;
	if (this.fL !== 0 || this.fH !==1) {
		this.fS = true;
	}
	// Allow for spline input (a bit nuts for 1D, but being robust)
	if (typeof params.inSpline !== 'undefined') {
		this.sin = true;
		this.ins = new LUTQSpline(params.inSpline);
	} else {
		this.sin = false;
	}
}
LUTSpline.prototype.buildL = function() {
	var fm = this.FD.length;
	var mono = this.FD[fm-1]-this.FD[0];
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	var FP1 = new Float64Array(fm);
	var FD1 = new Float64Array(fm);
	for (var j=0; j<fm; j++) {
		if (j === 0) {
			FP1[0] = this.FD[1];
				this.FC[0] = -(0.5*this.FD[2]) + (2*this.FD[1]) - (1.5*this.FD[0]);
				if (this.FC[0]*mono <= 0) { // still opposite slope to monotonic
					this.FC[0] = 0.0075 * mono / (fm-1);
				}
			FD1[0] = (this.FD[2] - this.FD[0])/2;
		} else if (j < fm-1) {
			FP1[j] = this.FD[j+1];
			this.FC[j] = (this.FD[j+1] - this.FD[j-1])/2;
			if (j === fm-2) {
					FD1[j] = (0.5*this.FD[j-1]) - (2*this.FD[j]) + (1.5*this.FD[j+1]);
					if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						FD1[j] = 0.0075 * mono / (fm-1);
					}
			} else {
				FD1[j] = (this.FD[j+2] - this.FD[j])/2;
			}
		} else {
			FP1[j] = this.FD[j];
			this.FC[j] = FD1[j-1];
			FD1[j] = FD1[j-1];
		}
		this.FA[j] = (2*this.FD[j]) + this.FC[j] - (2*FP1[j]) + FD1[j];
		this.FB[j] = (-3*this.FD[j]) - (2*this.FC[j]) + (3*FP1[j]) - FD1[j];
	}
	this.FM = fm-1;
};
LUTSpline.prototype.f = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
};
LUTSpline.prototype.df = function(L) {
	var s = this.FM;
	var o;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		o = s*this.FC[0];
	} else if (L >= s) {
		o = s*this.FC[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		o = s*((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
	}
	// Allow for nonlinear inputs
	if (this.sin) {
		var dO = this.ins.df(L);
		o *= dO;
	}
	if (this.fS) {
		o /= this.fLH;
	}
	return o;
};
LUTSpline.prototype.fCub = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
};
LUTSpline.prototype.fTet = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTSpline.prototype.fLin = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTSpline.prototype.FCub = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
		}
	}
};
LUTSpline.prototype.FTet = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTSpline.prototype.FLin = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTSpline.prototype.fRGBCub = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		L = (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		L = ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		L = (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
	return new Float64Array([L,L,L]);
};
LUTSpline.prototype.fRGBTet = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		L = (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		L = ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		L = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
	return new Float64Array([L,L,L]);
};
LUTSpline.prototype.fRGBLin = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		L = (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		L = ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		L = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
	return new Float64Array([L,L,L]);
};
LUTSpline.prototype.rgbCub = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FCub(out.buffer);
	return out;
};
LUTSpline.prototype.rgbTet = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FTet(out.buffer);
	return out;
};
LUTSpline.prototype.rgbLin = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FLin(out.buffer);
	return out;
};
LUTSpline.prototype.RGBCub = function(buff) {
	this.FCub(out);
};
LUTSpline.prototype.RGBLin = function(buff) {
	this.FTet(out);
};
LUTSpline.prototype.RGBLin = function(buff) {
	this.FLin(out);
};
LUTSpline.prototype.J = function(rgbIn) {
	// calculate the Jacobian matrix at rgbIn
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var J = new Float64Array(9);
		var s = this.FM;
		var r,l;
		if (this.fS) {
			c[0] = (c[0] - this.fL)/(this.fLH);
			c[1] = (c[1] - this.fL)/(this.fLH);
			c[2] = (c[2] - this.fL)/(this.fLH);
		}
		if (this.sin) {
			c[0] = this.ins.f(c[0]);
			c[1] = this.ins.f(c[1]);
			c[2] = this.ins.f(c[2]);
		}
		c[0] *= s;
		c[1] *= s;
		c[2] *= s;
		if (c[0] <= 0) {
			J[0] = this.FC[0];
		} else if (c[0] >= s) {
			J[0] = this.FC[s];
		} else {
			l = Math.floor(c[0]);
			r = c[0]-l;
			J[0] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[1] <= 0) {
			J[4] = this.FC[0];
		} else if (c[1] >= s) {
			J[4] = this.FC[s];
		} else {
			l = Math.floor(c[1]);
			r = c[1]-l;
			J[4] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[2] <= 0) {
			J[8] = this.FC[0];
		} else if (c[2] >= s) {
			J[8] = this.FC[s];
		} else {
			l = Math.floor(c[2]);
			r = c[2]-l;
			J[8] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		return J;
	} else {
		return false;
	}
};
LUTSpline.prototype.JInv = function(rgbIn) {
	var M = this.J(rgbIn);
	if (M[0] !== 0 && M[4] !== 0 && M[8] !== 0) {
		return new Float64Array([
			1/M[0],	0,		0,
			0,		1/M[4],	0,
			0,		0,		1/M[8]
		]);
	} else {
		return false;
	}
};
LUTSpline.prototype.getDetails = function() {
	var out = {
		title: this.title,
		format: this.format,
		dims: 1,
		s: this.FM+1,
		min: new Float64Array([this.fL,this.fL,this.fL]),
		max: new Float64Array([this.fH,this.fH,this.fH]),
		C: [this.FD.buffer],
		meta: this.meta
	};
	return out;
};
LUTSpline.prototype.getL = function() {
	return this.FD.buffer;
};
LUTSpline.prototype.getRGB = function() {
	return [this.FD.buffer];
};
LUTSpline.prototype.getSize = function() {
	return this.FM+1;
};
LUTSpline.prototype.is1D = function() {
	return true;
};
LUTSpline.prototype.is3D = function() {
	return false;
};
LUTSpline.prototype.getTitle = function() {
	return this.title;
};
LUTSpline.prototype.getMetadata = function() {
	return this.meta;
};
LUTSpline.prototype.isClamped = function() {
	if (typeof this.clamped === 'undefined') {
		var mm = this.minMax();
		if ((mm[0] === 0 && mm[1] <= 1) || (mm[0] >= 0 && mm[1] === 1)) {
			this.clamped = true;
		} else {
			this.clamped = false;
		}
	}
	return this.clamped;
};
LUTSpline.prototype.deClamp = function() {
	if (this.isClamped()) {
		var m,c,C,L,H,LH,S;
		var fL,fH,fLH;
		var FD = this.FD;
		m = FD.length;
		var C = false;
		var L = 0;
		var H = m-1;
		for (var j=0; j<m; j++) {
			if (j>0) {
				if (FD[j] === 0) {
					C = true;
					L = j+1;
				}
			}
		}
		for (var j=m-2; j>=0; j--) {
			if (FD[j] === 1) {
				C = true;
				H = j-1;
			}
		}
		if (C) {
			if (L > H) {
				var low = H;
				var H = Math.min(L-2,m-1);
				var L = Math.max(low+2,0);
			}
			var LH = H-L;
			var S = new LUTQSpline(new Float64Array(c.subarray(L,LH+1)).buffer);
			var fL = this.fL;
			var fH = this.fH;
			var fLH= fH-fL;
			for (var j=0; j<m; j++) {
				if (j===L) {
					j = H;
				}
				// pass through the splines
				FD[j] = S.fCub((j - L)/LH);
			}
		}
		this.buildL();
		this.clamped = false;
	}
};
LUTSpline.prototype.minMax = function() {
	var x = new Float64Array([
		 9999,	// Absolute min value
		-9999	// Absolute max value
	]);
	var FD = this.FD;
	var m = FD.length;
	for (var j=0; j<m; j++) {
		if (FD[j] < x[0]) {
			x[0] = FD[j];
		}
		if (FD[j] > x[1]) {
			x[1] = FD[j];
		}
	}
	return x;
};
// LUTRSpline - spline object with arbitrary input range and inverse automatically calculated
function LUTRSpline(params) {
	this.method = 0; // choose which approach to use on 'f(x)', cubic, or linear - used by brent to calculate the reverse
	// Metadata
	if (typeof params.title === 'string') {
		this.title = params.title;
	} else {
		this.title = '';
	}
	if (typeof params.format === 'string') {
		this.format = params.format;
	} else {
		this.format = '';
	}
	if (typeof params.meta !== 'undefined') {
		this.meta = params.meta;
	} else {
		this.meta = {};
	}
	// Precalculate forward parameters
	this.FD = new Float64Array(params.buff);
	var fm = this.FD.length;
	var mono = this.FD[fm-1]-this.FD[0];
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	this.FA = new Float64Array(fm);
	this.FB = new Float64Array(fm);
	this.FC = new Float64Array(fm);
	var FP1 = new Float64Array(fm);
	var FD1 = new Float64Array(fm);
	for (var j=0; j<fm; j++) {
		if (j === 0) {
			FP1[0] = this.FD[1];
//			this.FC[0] = (0.1*this.FD[3]) - (0.8*this.FD[2]) + (2.3*this.FD[1]) - (1.6*this.FD[0]);
//			if (this.FC[0]*mono <= 0) { // opposite slope to monotonic
				this.FC[0] = -(0.5*this.FD[2]) + (2*this.FD[1]) - (1.5*this.FD[0]);
				if (this.FC[0]*mono <= 0) { // still opposite slope to monotonic
					this.FC[0] = 0.0075 * mono / (fm-1);
				}
//			}
			FD1[0] = (this.FD[2] - this.FD[0])/2;
		} else if (j < fm-1) {
			FP1[j] = this.FD[j+1];
			this.FC[j] = (this.FD[j+1] - this.FD[j-1])/2;
			if (j === fm-2) {
//				FD1[j] = (-0.1*this.FD[j-2]) + (0.8*this.FD[j-1]) - (2.3*this.FD[j]) + (1.6*this.FD[j+1]);
//				if (FD1[j]*mono <= 0) { // opposite slope to monotonic
					FD1[j] = (0.5*this.FD[j-1]) - (2*this.FD[j]) + (1.5*this.FD[j+1]);
					if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						FD1[j] = 0.0075 * mono / (fm-1);
					}
//				}
			} else {
				FD1[j] = (this.FD[j+2] - this.FD[j])/2;
			}
		} else {
			FP1[j] = this.FD[j];
			this.FC[j] = FD1[j-1];
			FD1[j] = FD1[j-1];
		}
		this.FA[j] = (2*this.FD[j]) + this.FC[j] - (2*FP1[j]) + FD1[j];
		this.FB[j] = (-3*this.FD[j]) - (2*this.FC[j]) + (3*FP1[j]) - FD1[j];
	}
	this.FM = fm-1;
	// Allow for spline input (a bit nuts for 1D, but being robust)
	if (typeof params.inSpline !== 'undefined') {
		this.sin = true;
		this.ins = new LUTQSpline(params.inSpline);
	} else {
		this.sin = false;
	}
	// Set forward range
	this.fS = false;
	if (typeof params.fL === 'undefined' && typeof params.min !== 'undefined' && params.min[0] !== 0) {
		params.fL = params.min[0];
	}
	if (typeof params.fH === 'undefined' && typeof params.max !== 'undefined' && params.max[0] !== 1) {
		params.fH = params.max[0];
	}
	if (typeof params.fH === 'number') {
		this.fH = params.fH;
		if (typeof params.fL === 'number') {
			this.fL = params.fL;
		} else {
			this.fL = 0;
		}
	} else {
		this.fH = 1;
		this.fL = 0;
	}
	this.fLH = this.fH-this.fL;
	if (this.fL !== 0 || this.fH !==1) {
		this.fS = true;
	}
	// Set reverse range
	if (typeof params.rL === 'undefined' && typeof params.rmin !== 'undefined' && params.rmin[0] !== 0) {
		params.rL = params.rmin[0];
	}
	if (typeof params.rH === 'undefined' && typeof params.rmax !== 'undefined' && params.rmax[0] !== 1) {
		params.rH = params.rmax[0];
	}
	if (typeof params.rH === 'number') {
		this.rH = rH;
		if (typeof params.rL === 'number') {
			this.rL = rL;
		} else {
			this.rL = this.fL;
		}
	} else {
		this.rH = this.FD[fm - 1];
		this.rL = this.FD[0];
	}
	this.rLH = this.rH-this.rL;
	// Create reverse data points
	var rm;
	if (typeof params.minRM === 'number') {
		rm = Math.max(fm, minRM);
	} else {
		rm = Math.max(fm, 1024);
	}
	this.RM = rm-1;
	this.brent = new Brent(this);
	this.buildReverse();
}
LUTRSpline.prototype.f = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		if (this.method === 0) { // cubic
			return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
		} else { // tetrahedral or linear
			return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTRSpline.prototype.df = function(L) {
	var s = this.FM;
	var o;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		o = s*this.FC[0];
	} else if (L >= s) {
		o = s*this.FC[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		if (this.method === 0) { // cubic
			o = s*((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		} else { // tetrahedral or linear
			return s*(this.FD[l+1]-this.FD[l]);
		}
	}
	// Allow for nonlinear inputs
	if (this.sin) {
		var dO = this.ins.df(L);
		o *= dO;
	}
	if (this.fS) {
		o /= this.fLH;
	}
	return o;
};
LUTRSpline.prototype.fCub = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
};
LUTRSpline.prototype.fTet = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTRSpline.prototype.fLin = function(L) {
	var s = this.FM;
	var r,l;
	if (this.fS) {
		L = (L - this.fL)/(this.fLH);
	}
	if (this.sin) {
		L = this.ins.f(L);
	}
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTRSpline.prototype.FCub = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
		}
	}
};
LUTRSpline.prototype.FTet = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTRSpline.prototype.FLin = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - this.fL)/(this.fLH);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTRSpline.prototype.fRGBCub = function(L) {
	L = this.f(L);
	return new Float64Array([L,L,L]);
};
LUTRSpline.prototype.fRGBTet = function(L) {
	L = this.fLin(L);
	return new Float64Array([L,L,L]);
};
LUTRSpline.prototype.fRGBLin = function(L) {
	L = this.fLin(L);
	return new Float64Array([L,L,L]);
};
LUTRSpline.prototype.rgbCub = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FCub(out.buffer);
	return out;
};
LUTRSpline.prototype.rgbTet = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FLin(out.buffer);
	return out;
};
LUTRSpline.prototype.rgbLin = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FLin(out.buffer);
	return out;
};
LUTRSpline.prototype.RGBCub = function(buff) {
	this.FCub(out);
};
LUTRSpline.prototype.RGBTet = function(buff) {
	this.FLin(out);
};
LUTRSpline.prototype.RGBLin = function(buff) {
	this.FLin(out);
};
LUTRSpline.prototype.J = function(rgbIn) {
	// calculate the Jacobian matrix at rgbIn
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var J = new Float64Array(9);
		var s = this.FM;
		var r,l;
		if (this.fS) {
			c[0] = (c[0] - this.fL)/(this.fLH);
			c[1] = (c[1] - this.fL)/(this.fLH);
			c[2] = (c[2] - this.fL)/(this.fLH);
		}
		if (this.sin) {
			c[0] = this.ins.f(c[0]);
			c[1] = this.ins.f(c[1]);
			c[2] = this.ins.f(c[2]);
		}
		c[0] *= s;
		c[1] *= s;
		c[2] *= s;
		if (c[0] <= 0) {
			J[0] = this.FC[0];
		} else if (c[0] >= s) {
			J[0] = this.FC[s];
		} else {
			l = Math.floor(c[0]);
			r = c[0]-l;
			J[0] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[1] <= 0) {
			J[4] = this.FC[0];
		} else if (c[1] >= s) {
			J[4] = this.FC[s];
		} else {
			l = Math.floor(c[1]);
			r = c[1]-l;
			J[4] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[2] <= 0) {
			J[8] = this.FC[0];
		} else if (c[2] >= s) {
			J[8] = this.FC[s];
		} else {
			l = Math.floor(c[2]);
			r = c[2]-l;
			J[8] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		return J;
	} else {
		return false;
	}
};
LUTRSpline.prototype.JInv = function(rgbIn) {
	var M = this.J(rgbIn);
	if (M[0] !== 0 && M[4] !== 0 && M[8] !== 0) {
		return new Float64Array([
			1/M[0],	0,		0,
			0,		1/M[4],	0,
			0,		0,		1/M[8]
		]);
	} else {
		return false;
	}
};
LUTRSpline.prototype.getDetails = function() {
	var out = {
		title: this.title,
		format: this.format,
		dims: 1,
		s: this.FM+1,
		min: new Float64Array([this.fL,this.fL,this.fL]),
		max: new Float64Array([this.fH,this.fH,this.fH]),
		C: [this.FD.buffer],
		meta: this.meta
	};
	return out;
};
LUTRSpline.prototype.getL = function() {
	return this.FD.buffer;
};
LUTRSpline.prototype.getRGB = function() {
	return [this.FD.buffer];
};
LUTRSpline.prototype.getSize = function() {
	return this.FM+1;
};
LUTRSpline.prototype.is1D = function() {
	return true;
};
LUTRSpline.prototype.is3D = function() {
	return false;
};
LUTRSpline.prototype.getTitle = function() {
	return this.title;
};
LUTRSpline.prototype.getMetadata = function() {
	return this.meta;
};
//
LUTRSpline.prototype.r = function(L) {
	var s = this.RM;
	var r,l;
	L = s * (L - this.rL)/(this.rLH);
	if (L <= 0) {
		return (L * this.RC[0]) + this.RD[0];
	} else if (L >= s) {
		return ((L-s) * this.RC[s]) + this.RD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		if (this.method === 0) { // cubic
			return (((((this.RA[l] * r) + this.RB[l]) * r) + this.RC[l]) * r) + this.RD[l];
		} else { // tetrahedral or linear
			return ((1-r)*this.RD[l]) + (r*this.RD[l+1]);
		}
	}
};
LUTRSpline.prototype.R = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.RM;
	var r,l;
	for (var j=0; j<m; j++) {
		c[j] = s * (c[j] - this.rL)/(this.rLH);
		if (c[j] <= 0) {
			c[j] = (c[j] * this.RC[0]) + this.RD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.RC[s]) + this.RD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			if (this.method === 0) { // cubic
				c[j] = (((((this.RA[l] * r) + this.RB[l]) * r) + this.RC[l]) * r) + this.RD[l];
			} else { // tetrahedral or linear
				c[j] = ((1-r)*this.RD[l]) + (r*this.RD[l+1]);
			}
		}
	}
};
LUTRSpline.prototype.buildReverse = function() {
	var rm = this.RM + 1;
	this.RD = new Float64Array(rm);
	var x;
	for (var j=0; j<rm; j++) {
		x = ((j/(rm-1))*(this.rLH)) + this.rL;
		if (j === 0 || x <= 0 || isNaN(this.RD[j-1]) || this.RD[j-1] <= -65534 || this.RD[j-1] >= 65534) {
			this.RD[j] = this.brent.findRoot(x,x);
		} else {
			this.RD[j] = this.brent.findRoot(this.RD[j-1],x);
		}
		if (this.RD[j] < -65534) {
			this.RD[j] = -65534;
		} else if (this.RD[j] > 65534) {
			this.RD[j] = 65534;
		}
	}
	if (isNaN(this.RD[0])) {
		for (var j=0; j<rm; j++) {
			if (!isNaN(this.RD[j])) {
				this.RD[0] = this.RD[j];
				break;
			}
		}
	}
	for (var j=1; j<rm; j++) {
		if (isNaN(this.RD[j])) {
			this.RD[j] = this.RD[j-1];
		}
	}
	for (var j=1; j<rm; j++) {
		this.RD[j] = (this.RD[j] * this.fLH) + this.fL;
	}
	mono = this.RD[rm-1]-this.RD[0]; // If things are working, should be unchanged, but belt and braces....
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	// Precalculate reverse parameters
	this.RA = new Float64Array(rm);
	this.RB = new Float64Array(rm);
	this.RC = new Float64Array(rm);
	var RP1 = new Float64Array(rm);
	var RD1 = new Float64Array(rm);
	for (var j=0; j<rm; j++) {
		if (j === 0) {
			RP1[0] = this.RD[1];
//			this.RC[0] = (0.1*this.RD[3]) - (0.8*this.RD[2]) + (2.3*this.RD[1]) - (1.6*this.RD[0]);
//			if (this.RC[0]*mono <= 0) { // opposite slope to monotonic
				this.RC[0] = -(0.5*this.RD[2]) + (2*this.RD[1]) - (1.5*this.RD[0]);
				if (this.RC[0]*mono <= 0) { // still opposite slope to monotonic
					this.RC[0] = 0.0075 * mono / (rm-1);
				}
//			}
			RD1[0] = (this.RD[2] - this.RD[0])/2;
		} else if (j < rm-1) {
			RP1[j] = this.RD[j+1];
			this.RC[j] = (this.RD[j+1] - this.RD[j-1])/2
			if (j === rm-2) {
//				RD1[j] = (-0.1*this.RD[j-2]) + (0.8*this.RD[j-1]) - (2.3*this.RD[j]) + (1.6*this.RD[j+1]);
//				if (RD1[j]*mono <= 0) { // opposite slope to monotonic
					RD1[j] = (0.5*this.RD[j-1]) - (2*this.RD[j]) + (1.5*this.RD[j+1]);
					if (RD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						RD1[j] = 0.0075 * mono / (rm-1);
					}
//				}
			} else {
				RD1[j] = (this.RD[j+2] - this.RD[j])/2;
			}
		} else {
			RP1[j] = this.RD[j];
			this.RC[j] = RD1[j-1];
			RD1[j] = RD1[j-1];
		}
		this.RA[j] = (2*this.RD[j]) + this.RC[j] - (2*RP1[j]) + RD1[j];
		this.RB[j] = (-3*this.RD[j]) - (2*this.RC[j]) + (3*RP1[j]) - RD1[j];
	}
};
LUTRSpline.prototype.setMethod = function(idx) {
	if (typeof idx === 'number') {
		this.method = idx;
		this.buildReverse();
		return true;
	} else {
		return false;
	}
};
LUTRSpline.prototype.getMethod = function() {
	return this.method;
};
LUTRSpline.prototype.getReverse = function() {
	return this.RD.buffer;
};
LUTRSpline.prototype.getMinMax = function() {
	var a=0;
	var b=1;
	var m = this.RD.length;
	for (var j=0; j<m; j++) {
		if (this.RD[j] > b) {
			b = this.RD[j];
		} else if (this.RD[j] < a) {
			a = this.RD[j];
		}
	}
	return {a: a, b: b};
};
LUTRSpline.prototype.getHighLow = function() {
	return {forH:this.fH,forL:this.fL,revH:this.rH,revL:this.rL}
};
LUTRSpline.prototype.getRM = function() {
	return this.RM + 1;
};
LUTRSpline.prototype.getR = function() {
	return this.RD.buffer;
};
// LUTQSpline - spline object paired down to forward only and mesh over 0-1.0
function LUTQSpline(buff) {
	this.meta = {};
	// Precalculate forward parameters
	this.FD = new Float64Array(buff);
	var fm = this.FD.length;
	var mono = this.FD[fm-1]-this.FD[0];
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	this.FA = new Float64Array(fm);
	this.FB = new Float64Array(fm);
	this.FC = new Float64Array(fm);
	var FP1 = new Float64Array(fm);
	var FD1 = new Float64Array(fm);
	for (var j=0; j<fm; j++) {
		if (j === 0) {
			FP1[0] = this.FD[1];
//			this.FC[0] = (0.1*this.FD[3]) - (0.8*this.FD[2]) + (2.3*this.FD[1]) - (1.6*this.FD[0]);
//			if (this.FC[0]*mono <= 0) { // opposite slope to monotonic
				this.FC[0] = -(0.5*this.FD[2]) + (2*this.FD[1]) - (1.5*this.FD[0]);
				if (this.FC[0]*mono <= 0) { // still opposite slope to monotonic
					this.FC[0] = 0.0075 * mono / (fm-1);
				}
//			}
			FD1[0] = (this.FD[2] - this.FD[0])/2;
		} else if (j < fm-1) {
			FP1[j] = this.FD[j+1];
			this.FC[j] = (this.FD[j+1] - this.FD[j-1])/2;
			if (j === fm-2) {
//				FD1[j] = (-0.1*this.FD[j-2]) + (0.8*this.FD[j-1]) - (2.3*this.FD[j]) + (1.6*this.FD[j+1]);
//				if (FD1[j]*mono <= 0) { // opposite slope to monotonic
					FD1[j] = (0.5*this.FD[j-1]) - (2*this.FD[j]) + (1.5*this.FD[j+1]);
					if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						FD1[j] = 0.0075 * mono / (fm-1);
					}
//				}
			} else {
				FD1[j] = (this.FD[j+2] - this.FD[j])/2;
			}
		} else {
			FP1[j] = this.FD[j];
			this.FC[j] = FD1[j-1];
			FD1[j] = FD1[j-1];
		}
		this.FA[j] = (2*this.FD[j]) + this.FC[j] - (2*FP1[j]) + FD1[j];
		this.FB[j] = (-3*this.FD[j]) - (2*this.FC[j]) + (3*FP1[j]) - FD1[j];
	}
	this.FM = fm-1;
}
LUTQSpline.prototype.f = function(L) {
	var s = this.FM;
	var r,l;
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
};
LUTQSpline.prototype.df = function(L) {
	var s = this.FM;
	var o;
	var r,l;
	L *= s;
	if (L <= 0) {
		return s*this.FC[0];
	} else if (L >= s) {
		return s*this.FC[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return s*((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
	}
};
LUTQSpline.prototype.fCub = function(L) {
	var s = this.FM;
	var r,l;
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
	}
};
LUTQSpline.prototype.fTet = function(L) {
	var s = this.FM;
	var r,l;
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTQSpline.prototype.fLin = function(L) {
	var s = this.FM;
	var r,l;
	L *= s;
	if (L <= 0) {
		return (L * this.FC[0]) + this.FD[0];
	} else if (L >= s) {
		return ((L-s) * this.FC[s]) + this.FD[s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
	}
};
LUTQSpline.prototype.FCub = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = (((((this.FA[l] * r) + this.FB[l]) * r) + this.FC[l]) * r) + this.FD[l];
		}
	}
};
LUTQSpline.prototype.FTet = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTQSpline.prototype.FLin = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM;
	var r,l;
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[0]) + this.FD[0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[s]) + this.FD[s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[l]) + (r*this.FD[l+1]);
		}
	}
};
LUTQSpline.prototype.fRGBCub = function(L) {
	L = this.f(L);
	return new Float64Array([L,L,L]);
};
LUTQSpline.prototype.fRGBTet = function(L) {
	L = this.fLin(L);
	return new Float64Array([L,L,L]);
};
LUTQSpline.prototype.fRGBLin = function(L) {
	L = this.fLin(L);
	return new Float64Array([L,L,L]);
};
LUTQSpline.prototype.rgbCub = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FCub(out.buffer);
	return out;
};
LUTQSpline.prototype.rgbTet = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FLin(out.buffer);
	return out;
};
LUTQSpline.prototype.rgbLin = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.FLin(out.buffer);
	return out;
};
LUTQSpline.prototype.RGBCub = function(buff) {
	this.FCub(out);
};
LUTQSpline.prototype.RGBTet = function(buff) {
	this.FLin(out);
};
LUTQSpline.prototype.RGBLin = function(buff) {
	this.FLin(out);
};
LUTQSpline.prototype.J = function(rgbIn) {
	// calculate the Jacobian matrix at rgbIn
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var J = new Float64Array(9);
		var s = this.FM;
		var r,l;
		c[0] *= s;
		c[1] *= s;
		c[2] *= s;
		if (c[0] <= 0) {
			J[0] = this.FC[0];
		} else if (c[0] >= s) {
			J[0] = this.FC[s];
		} else {
			l = Math.floor(c[0]);
			r = c[0]-l;
			J[0] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[1] <= 0) {
			J[4] = this.FC[0];
		} else if (c[1] >= s) {
			J[4] = this.FC[s];
		} else {
			l = Math.floor(c[1]);
			r = c[1]-l;
			J[4] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[2] <= 0) {
			J[8] = this.FC[0];
		} else if (c[2] >= s) {
			J[8] = this.FC[s];
		} else {
			l = Math.floor(c[2]);
			r = c[2]-l;
			J[8] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		J[0] *= s;
		J[4] *= s;
		J[8] *= s;
		return J;
	} else {
		return false;
	}
};
LUTQSpline.prototype.JInv = function(rgbIn) {
	var M = this.J(rgbIn);
	if (M[0] !== 0 && M[4] !== 0 && M[8] !== 0) {
		return new Float64Array([
			1/M[0],	0,		0,
			0,		1/M[4],	0,
			0,		0,		1/M[8]
		]);
	} else {
		return false;
	}
};
LUTQSpline.prototype.getDetails = function() {
	return {
		title: '',
		format: '',
		dims: 1,
		s: this.FM+1,
		min: new Float64Array([0,0,0]),
		max: new Float64Array([1,1,1]),
		C: [this.FD.buffer],
		meta: this.meta
	};
};
LUTQSpline.prototype.getL = function() {
	return this.FD.buffer;
};
LUTQSpline.prototype.getRGB = function() {
	return [this.FD.buffer];
};
LUTQSpline.prototype.getSize = function() {
	return this.FM+1;
};
LUTQSpline.prototype.is1D = function() {
	return true;
};
LUTQSpline.prototype.is3D = function() {
	return false;
};
LUTQSpline.prototype.getTitle = function() {
	return '';
};
LUTQSpline.prototype.getMetadata = function() {
	return this.meta;
};
//
LUTQSpline.prototype.dRGB = function(rgbIn) {
	// no point in a full, square Jacobian matrix for a 1D LUT
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var o = new Float64Array(3);
		var s = this.FM;
		var r,l;
		c[0] *= s;
		c[1] *= s;
		c[2] *= s;
		if (c[0] <= 0) {
			o[0] = this.FC[0];
		} else if (c[0] >= s) {
			o[0] = this.FC[s];
		} else {
			l = Math.floor(c[0]);
			r = c[0]-l;
			o[0] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[1] <= 0) {
			o[1] = this.FC[0];
		} else if (c[1] >= s) {
			o[1] = this.FC[s];
		} else {
			l = Math.floor(c[1]);
			r = c[1]-l;
			o[1] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		if (c[2] <= 0) {
			o[2] = this.FC[0];
		} else if (c[2] >= s) {
			o[2] = this.FC[s];
		} else {
			l = Math.floor(c[2]);
			r = c[2]-l;
			o[2] = ((((3*this.FA[l] * r) + (2*this.FB[l])) * r) + this.FC[l]);
		}
		o[0] *= s;
		o[1] *= s;
		o[2] *= s;
		return o;
	} else {
		return false;
	}
};
// LUTRGBSpline - spline object with different 1D splines for each RGB channel
function LUTRGBSpline(params) {
	// Metadata
	if (typeof params.title === 'string') {
		this.title = params.title;
	} else {
		this.title = '';
	}
	if (typeof params.format === 'string') {
		this.format = params.format;
	} else {
		this.format = '';
	}
	if (typeof params.meta !== 'undefined') {
		this.meta = params.meta;
	} else {
		this.meta = {};
	}
	this.Y = new Float64Array([0.2126,0.7152,0.0722]); // Rec709 luma coefficients
	// Set forward range
	this.fL = new Float64Array(4);
	this.fH = new Float64Array(4);
	this.fS = false;
	if (typeof params.min !== 'undefined' && (params.min[0] !== 0 || params.min[1] !== 0 || params.min[2] !== 0)) {
		params.fL = params.min[0];
		params.fLR = params.min[0];
		params.fLG = params.min[1];
		params.fLB = params.min[2];
	}
	if (typeof params.max !== 'undefined' && (params.max[0] !== 1 || params.max[1] !== 1 || params.max[2] !== 1)) {
		params.fH = params.max[0];
		params.fHR = params.max[0];
		params.fHG = params.max[1];
		params.fHB = params.max[2];
	}
	if (typeof params.fH === 'number') {
		this.fH[0] = params.fH;
		this.fH[1] = params.fH;
		this.fH[2] = params.fH;
	} else {
		this.fH[0] = 1;
		this.fH[1] = 1;
		this.fH[2] = 1;
	}
	if (typeof params.fL === 'number') {
		this.fL[0] = params.fL;
		this.fL[1] = params.fL;
		this.fL[2] = params.fL;
	} else {
		this.fL[0] = 0;
		this.fL[1] = 0;
		this.fL[2] = 0;
	}
	if (typeof params.fLR === 'number' &&
		typeof params.fHR === 'number' &&
		typeof params.fLG === 'number' &&
		typeof params.fHG === 'number' &&
		typeof params.fLB === 'number' &&
		typeof params.fHB === 'number') {
		this.fL[0] = params.fLR;
		this.fH[0] = params.fHR;
		this.fL[1] = params.fLG;
		this.fH[1] = params.fHG;
		this.fL[2] = params.fLB;
		this.fH[2] = params.fHB;
	}
	this.fLH = new Float64Array([this.fH[0]-this.fL[0],this.fH[1]-this.fL[1],this.fH[2]-this.fL[2],0]);
	if (this.fL[0] !== 0 || this.fL[1] !== 0 || this.fL[2] !== 0 || this.fH[0] !== 1 || this.fH[1] !== 1 || this.fH[2] !== 1) {
		this.fS = true;
	}
	// Allow for spline input (a bit nuts for 1D, but being robust)
	if (typeof params.inSpline !== 'undefined') {
		this.sin = true;
		this.ins = new LUTQSpline(params.inSpline);
	} else {
		this.sin = false;
	}
	// Create three separate splines for the red, green and blue channels.
	this.FA = [];
	this.FB = [];
	this.FC = [];
	this.FD = [];
	this.FM = [];
	this.FD[0] = new Float64Array(params.buffR);
	this.FD[1] = new Float64Array(params.buffG);
	this.FD[2] = new Float64Array(params.buffB);
	var fm;
	for (var i=0; i<3; i++) {
		fm = this.FD[i].length;
		this.FA[i] = new Float64Array(fm);
		this.FB[i] = new Float64Array(fm);
		this.FC[i] = new Float64Array(fm);
		this.FM[i] = fm-1;
	}
	this.buildMesh();
	// Precalculate Luma arrays
	this.buildL();
}
LUTRGBSpline.prototype.buildMesh = function() {
	var buff,fm,mono;
	var FP1,FD1;
	// Precalculate forward parameters
	for (var i=0; i<3; i++) {
		fm = this.FD[i].length;
		mono = this.FD[i][fm-1]-this.FD[i][0];
		if (mono >= 0) {
			mono = 1;
		} else if (mono < 0) {
			mono = -1;
		}
		FP1 = new Float64Array(fm);
		FD1 = new Float64Array(fm);
		for (var j=0; j<fm; j++) {
			if (j === 0) {
				FP1[0] = this.FD[i][1];
//				this.FC[i][0] = (0.1*this.FD[i][3]) - (0.8*this.FD[i][2]) + (2.3*this.FD[i][1]) - (1.6*this.FD[i][0]);
//				if (this.FC[i][0]*mono <= 0) { // opposite slope to monotonic
					this.FC[i][0] = -(0.5*this.FD[i][2]) + (2*this.FD[i][1]) - (1.5*this.FD[i][0]);
					if (this.FC[i][0]*mono <= 0) { // still opposite slope to monotonic
						this.FC[i][0] = 0.0075 * mono / (fm-1);
					}
//				}
				FD1[0] = (this.FD[i][2] - this.FD[i][0])/2;
			} else if (j < fm-1) {
				FP1[j] = this.FD[i][j+1];
				this.FC[i][j] = (this.FD[i][j+1] - this.FD[i][j-1])/2;
				if (j === fm-2) {
//					FD1[j] = (-0.1*this.FD[i][j-2]) + (0.8*this.FD[i][j-1]) - (2.3*this.FD[i][j]) + (1.6*this.FD[i][j+1]);
//					if (FD1[j]*mono <= 0) { // opposite slope to monotonic
						FD1[j] = (0.5*this.FD[i][j-1]) - (2*this.FD[i][j]) + (1.5*this.FD[i][j+1]);
						if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
							FD1[j] = 0.0075 * mono / (fm-1);
						}
//					}
				} else {
					FD1[j] = (this.FD[i][j+2] - this.FD[i][j])/2;
				}
			} else {
				FP1[j] = this.FD[i][j];
				this.FC[i][j] = FD1[j-1];
				FD1[j] = FD1[j-1];
			}
			this.FA[i][j] = (2*this.FD[i][j]) + this.FC[i][j] - (2*FP1[j]) + FD1[j];
			this.FB[i][j] = (-3*this.FD[i][j]) - (2*this.FC[i][j]) + (3*FP1[j]) - FD1[j];
		}
	}
};
LUTRGBSpline.prototype.buildL = function() {
	this.fL[3] = Math.min(this.fL[0],this.fL[1],this.fL[2]);
	this.fH[3] = Math.max(this.fH[0],this.fH[1],this.fH[2]);
	this.fLH[3]= this.fH[3]-this.fL[3];
	this.FM[3] = Math.max(this.FM[0],this.FM[1],this.FM[2]);
	if (this.FM[3] < 64) {
		this.FM[3] = 64;
	}
	var m = this.FM[3] + 1;
	this.FD[3] = new Float64Array(m);
	var input,L,s,r,l,mono;
	// First build array of luma values from RGB splines
	for (var j=0; j<m; j++) {
		input = (j*(this.fLH[3])/(m-1))+this.fL[3];
		for (var i=0; i<3; i++) {
			s = this.FM[i];
			L = (input - this.fL[i])/(this.fLH[i]);
			if (this.sin) {
				L = this.ins.f(L);
			}
			L *= s;
			if (L <= 0) {
				L = (L * this.FC[i][0]) + this.FD[i][0];
			} else if (L >= s) {
				L = ((L-s) * this.FC[i][s]) + this.FD[i][s];
			} else {
				l = Math.floor(L);
				r = L-l;
				L = (((((this.FA[i][l] * r) + this.FB[i][l]) * r) + this.FC[i][l]) * r) + this.FD[i][l];
			}
			this.FD[3][j] += L * this.Y[i];
		}
	}
	// Now precalculate forward parameters
	this.FA[3] = new Float64Array(m);
	this.FB[3] = new Float64Array(m);
	this.FC[3] = new Float64Array(m);
	var FP1 = new Float64Array(m);
	var FD1 = new Float64Array(m);
	mono = this.FD[3][m-1]-this.FD[3][0];
	if (mono >= 0) {
		mono = 1;
	} else if (mono < 0) {
		mono = -1;
	}
	for (var j=0; j<m; j++) {
		if (j === 0) {
			FP1[0] = this.FD[3][1];
//			this.FC[3][0] = (0.1*this.FD[3][3]) - (0.8*this.FD[3][2]) + (2.3*this.FD[3][1]) - (1.6*this.FD[3][0]);
//			if (this.FC[3][0]*mono <= 0) { // opposite slope to monotonic
				this.FC[3][0] = -(0.5*this.FD[3][2]) + (2*this.FD[3][1]) - (1.5*this.FD[3][0]);
				if (this.FC[3][0]*mono <= 0) { // still opposite slope to monotonic
					this.FC[3][0] = 0.0075 * mono / (m-1);
				}
//			}
			FD1[0] = (this.FD[3][2] - this.FD[3][0])/2;
		} else if (j < m-1) {
			FP1[j] = this.FD[3][j+1];
			this.FC[3][j] = (this.FD[3][j+1] - this.FD[3][j-1])/2;
			if (j === m-2) {
//				FD1[j] = (-0.1*this.FD[3][j-2]) + (0.8*this.FD[3][j-1]) - (2.3*this.FD[3][j]) + (1.6*this.FD[3][j+1]);
//				if (FD1[j]*mono <= 0) { // opposite slope to monotonic
					FD1[j] = (0.5*this.FD[3][j-1]) - (2*this.FD[3][j]) + (1.5*this.FD[3][j+1]);
					if (FD1[j]*mono <= 0) { // still opposite slope to monotonic - give up!
						FD1[j] = 0.0075 * mono / (m-1);
					}
//				}
			} else {
				FD1[j] = (this.FD[3][j+2] - this.FD[3][j])/2;
			}
		} else {
			FP1[j] = this.FD[3][j];
			this.FC[3][j] = FD1[j-1];
			FD1[j] = FD1[j-1];
		}
		this.FA[3][j] = (2*this.FD[3][j]) + this.FC[3][j] - (2*FP1[j]) + FD1[j];
		this.FB[3][j] = (-3*this.FD[3][j]) - (2*this.FC[3][j]) + (3*FP1[j]) - FD1[j];
	}
};
LUTRGBSpline.prototype.f = function(L) {
	var s = this.FM[3];
	var r,l;
	if (this.fS) {
		L = s * (L - this.fL[3])/(this.fLH[3]);
	} else {
		L *= s;
	}
	if (L <= 0) {
		return (L * this.FC[3][0]) + this.FD[3][0];
	} else if (L >= s) {
		return ((L-s) * this.FC[3][s]) + this.FD[3][s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[3][l] * r) + this.FB[3][l]) * r) + this.FC[3][l]) * r) + this.FD[3][l];
	}
};
LUTRGBSpline.prototype.df = function(L) {
	var s = this.FM[3];
	var o;
	var r,l;
	if (this.fS) {
		L = s * (L - this.fL[3])/(this.fLH[3]);
	} else {
		L *= s;
	}
	if (L <= 0) {
		o = s*this.FC[3][0];
	} else if (L >= s) {
		o = s*this.FC[3][s];
	} else {
		l = Math.floor(L);
		r = L-l;
		o = s*((((3*this.FA[3][l] * r) + (2*this.FB[3][l])) * r) + this.FC[3][l]);
	}
	// Allow for scaled inputs
	if (this.fS) {
		o /= this.fLH[3];
	}
	return o;
};
LUTRGBSpline.prototype.fCub = function(L) {
	var s = this.FM[3];
	var r,l;
	if (this.fS) {
		L = s * (L - this.fL[3])/(this.fLH[3]);
	} else {
		L *= s;
	}
	if (L <= 0) {
		return (L * this.FC[3][0]) + this.FD[3][0];
	} else if (L >= s) {
		return ((L-s) * this.FC[3][s]) + this.FD[3][s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return (((((this.FA[3][l] * r) + this.FB[3][l]) * r) + this.FC[3][l]) * r) + this.FD[3][l];
	}
};
LUTRGBSpline.prototype.fTet = function(L) {
	var s = this.FM[3];
	var r,l;
	if (this.fS) {
		L = s * (L - this.fL[3])/(this.fLH[3]);
	} else {
		L *= s;
	}
	if (L <= 0) {
		return (L * this.FC[3][0]) + this.FD[3][0];
	} else if (L >= s) {
		return ((L-s) * this.FC[3][s]) + this.FD[3][s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[3][l]) + (r*this.FD[3][l+1]);
	}
};
LUTRGBSpline.prototype.fLin = function(L) {
	var s = this.FM[3];
	var r,l;
	if (this.fS) {
		L = s * (L - this.fL[3])/(this.fLH[3]);
	} else {
		L *= s;
	}
	if (L <= 0) {
		return (L * this.FC[3][0]) + this.FD[3][0];
	} else if (L >= s) {
		return ((L-s) * this.FC[3][s]) + this.FD[3][s];
	} else {
		l = Math.floor(L);
		r = L-l;
		return ((1-r)*this.FD[3][l]) + (r*this.FD[3][l+1]);
	}
};
LUTRGBSpline.prototype.FCub = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM[3];
	var fL = this.fL[3];
	var fLH = this.fLH[3];
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = (c[j] - fL)/(fLH);
		}
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[3][0]) + this.FD[3][0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[3][s]) + this.FD[3][s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = (((((this.FA[3][l] * r) + this.FB[3][l]) * r) + this.FC[3][l]) * r) + this.FD[3][l];
		}
	}
};
LUTRGBSpline.prototype.FTet = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM[3];
	var fL = this.fL[3];
	var fLH = this.fLH[3];
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = s * (c[j] - fL)/(fLH);
		}
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[3][0]) + this.FD[3][0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[3][s]) + this.FD[3][s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[3][l]) + (r*this.FD[3][l+1]);
		}
	}
};
LUTRGBSpline.prototype.FLin = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var s = this.FM[3];
	var fL = this.fL[3];
	var fLH = this.fLH[3];
	var r,l;
	if (this.fS) {
		for (var j=0; j<m; j++) {
			c[j] = s * (c[j] - fL)/(fLH);
		}
	}
	for (var j=0; j<m; j++) {
		c[j] *= s;
		if (c[j] <= 0) {
			c[j] = (c[j] * this.FC[3][0]) + this.FD[3][0];
		} else if (c[j] >= s) {
			c[j] = ((c[j]-s) * this.FC[3][s]) + this.FD[3][s];
		} else {
			l = Math.floor(c[j]);
			r = c[j]-l;
			c[j] = ((1-r)*this.FD[3][l]) + (r*this.FD[3][l+1]);
		}
	}
};
LUTRGBSpline.prototype.fRGBCub = function(L) {
	var s;
	var r,l;
	var o = new Float64Array(3);
	if (this.fS) {
		o[0] = (L - this.fL[0])/(this.fLH[0]);
		o[1] = (L - this.fL[1])/(this.fLH[1]);
		o[2] = (L - this.fL[2])/(this.fLH[2]);
	}
	if (this.sin) {
		this.ins.FCub(o.buffer);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		o[i] *= s;
		if (o[i] <= 0) {
			o[i] = (o[i] * this.FC[i][0]) + this.FD[i][0];
		} else if (o[i] >= s) {
			o[i] = ((o[i]-s) * this.FC[i][s]) + this.FD[i][s];
		} else {
			l = Math.floor(o[i]);
			r = o[i]-l;
			o[i] = (((((this.FA[i][l] * r) + this.FB[i][l]) * r) + this.FC[i][l]) * r) + this.FD[i][l];
		}
	}
	return o;
};
LUTRGBSpline.prototype.fRGBTet = function(L) {
	var s;
	var r,l;
	var o = new Float64Array(3);
	if (this.fS) {
		o[0] = (L - this.fL[0])/(this.fLH[0]);
		o[1] = (L - this.fL[1])/(this.fLH[1]);
		o[2] = (L - this.fL[2])/(this.fLH[2]);
	}
	if (this.sin) {
		this.ins.FCub(o.buffer);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		o[i] *= s;
		if (o[i] <= 0) {
			o[i] = (o[i] * this.FC[i][0]) + this.FD[i][0];
		} else if (o[i] >= s) {
			o[i] = ((o[i]-s) * this.FC[i][s]) + this.FD[i][s];
		} else {
			l = Math.floor(o[i]);
			r = o[i]-l;
			o[j] = ((1-r)*this.FD[i][l]) + (r*this.FD[i][l+1]);
		}
	}
	return o;
};
LUTRGBSpline.prototype.fRGBLin = function(L) {
	var s;
	var r,l;
	var o = new Float64Array(3);
	if (this.fS) {
		o[0] = (L - this.fL[0])/(this.fLH[0]);
		o[1] = (L - this.fL[1])/(this.fLH[1]);
		o[2] = (L - this.fL[2])/(this.fLH[2]);
	}
	if (this.sin) {
		this.ins.FCub(o.buffer);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		o[i] *= s;
		if (o[i] <= 0) {
			o[i] = (o[i] * this.FC[i][0]) + this.FD[i][0];
		} else if (o[i] >= s) {
			o[i] = ((o[i]-s) * this.FC[i][s]) + this.FD[i][s];
		} else {
			l = Math.floor(o[i]);
			r = o[i]-l;
			o[j] = ((1-r)*this.FD[i][l]) + (r*this.FD[i][l+1]);
		}
	}
	return o;
};
LUTRGBSpline.prototype.rgbCub = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.RGBCub(out.buffer);
	return out;
};
LUTRGBSpline.prototype.rgbTet = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.RGBLin(out.buffer);
	return out;
};
LUTRGBSpline.prototype.rgbLin = function(rgb) {
	var out = new Float64Array(rgb.buffer.slice(0));
	this.RGBLin(out.buffer);
	return out;
};
LUTRGBSpline.prototype.RGBCub = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var fL = this.fL;
	var fLH = this.fLH;
	var s,k,l,r;
	if (this.fS) {
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		for (var j=0; j<m; j+=3) {
			k = j+i;
			c[k] *= s;
			if (c[k] <= 0) {
				c[k] = (c[k] * this.FC[i][0]) + this.FD[i][0];
			} else if (c[k] >= s) {
				c[k] = ((c[k]-s) * this.FC[i][s]) + this.FD[i][s];
			} else {
				l = Math.floor(c[k]);
				r = c[k]-l;
				c[k] = (((((this.FA[i][l] * r) + this.FB[i][l]) * r) + this.FC[i][l]) * r) + this.FD[i][l];
			}
		}
	}
};
LUTRGBSpline.prototype.RGBTet = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var fL = this.fL;
	var fLH = this.fLH;
	var s,k,l,r;
	if (this.fS) {
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		for (var j=0; j<m; j+=3) {
			k = j+i;
			c[k] *= s;
			if (c[k] <= 0) {
				c[k] = (c[k] * this.FC[i][0]) + this.FD[i][0];
			} else if (c[k] >= s) {
				c[k] = ((c[k]-s) * this.FC[i][s]) + this.FD[i][s];
			} else {
				l = Math.floor(c[k]);
				r = c[k]-l;
				c[j] = ((1-r)*this.FD[i][l]) + (r*this.FD[i][l+1]);
			}
		}
	}
};
LUTRGBSpline.prototype.RGBLin = function(buff) {
	var c = new Float64Array(buff);
	var m = c.length;
	var fL = this.fL;
	var fLH = this.fLH;
	var s,k,l,r;
	if (this.fS) {
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var i=0; i<3; i++) {
		s = this.FM[i];
		for (var j=0; j<m; j+=3) {
			k = j+i;
			c[k] *= s;
			if (c[k] <= 0) {
				c[k] = (c[k] * this.FC[i][0]) + this.FD[i][0];
			} else if (c[k] >= s) {
				c[k] = ((c[k]-s) * this.FC[i][s]) + this.FD[i][s];
			} else {
				l = Math.floor(c[k]);
				r = c[k]-l;
				c[j] = ((1-r)*this.FD[i][l]) + (r*this.FD[i][l+1]);
			}
		}
	}
};
LUTRGBSpline.prototype.J = function(rgbIn) {
	// calculate the Jacobian matrix at rgbIn
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var J = new Float64Array(9);
		var s;
		var r,l;
		if (this.fS) {
			c[0] = (c[0] - this.fL[0])/(this.fLH[0]);
			c[1] = (c[1] - this.fL[1])/(this.fLH[1]);
			c[2] = (c[2] - this.fL[2])/(this.fLH[2]);
		}
		if (this.sin) {
			c[0] = this.ins.f(c[0]);
			c[1] = this.ins.f(c[1]);
			c[2] = this.ins.f(c[2]);
		}
		s = this.FM[0];
		c[0] *= s;
		if (c[0] <= 0) {
			J[0] = this.FC[0][0];
		} else if (c[0] >= s) {
			J[0] = this.FC[0][s];
		} else {
			l = Math.floor(c[0]);
			r = c[0]-l;
			J[0] = ((((3*this.FA[0][l] * r) + (2*this.FB[0][l])) * r) + this.FC[0][l]);
		}
		s = this.FM[1];
		c[1] *= s;
		if (c[1] <= 0) {
			J[4] = this.FC[1][0];
		} else if (c[1] >= s) {
			J[4] = this.FC[1][s];
		} else {
			l = Math.floor(c[1]);
			r = c[1]-l;
			J[4] = ((((3*this.FA[1][l] * r) + (2*this.FB[1][l])) * r) + this.FC[1][l]);
		}
		s = this.FM[2];
		c[2] *= s;
		if (c[2] <= 0) {
			J[8] = this.FC[2][0];
		} else if (c[2] >= s) {
			J[8] = this.FC[2][s];
		} else {
			l = Math.floor(c[2]);
			r = c[2]-l;
			J[8] = ((((3*this.FA[2][l] * r) + (2*this.FB[2][l])) * r) + this.FC[2][l]);
		}
		// Scale to 0-1 range (from 0-s)
		J[0] *= s;
		J[1] *= s;
		J[2] *= s;
		J[3] *= s;
		J[4] *= s;
		J[5] *= s;
		J[6] *= s;
		J[7] *= s;
		J[8] *= s;
		if (this.sin) {
			var dRGB = this.ins.dRGB(rgbIn.buffer);
			J[0] *= dRGB[0];
			J[1] *= dRGB[1];
			J[2] *= dRGB[2];
			J[3] *= dRGB[0];
			J[4] *= dRGB[1];
			J[5] *= dRGB[2];
			J[6] *= dRGB[0];
			J[7] *= dRGB[1];
			J[8] *= dRGB[2];
		}
		if (this.fS) {
			J[0] /= fLH[0];
			J[1] /= fLH[1];
			J[2] /= fLH[2];
			J[3] /= fLH[0];
			J[4] /= fLH[1];
			J[5] /= fLH[2];
			J[6] /= fLH[0];
			J[7] /= fLH[1];
			J[8] /= fLH[2];
		}
		return J;
	} else {
		return false;
	}
};
LUTRGBSpline.prototype.JInv = function(rgbIn) {
	var M = this.J(rgbIn);
	if (M[0] !== 0 && M[4] !== 0 && M[8] !== 0) {
		return new Float64Array([
			1/M[0],	0,		0,
			0,		1/M[4],	0,
			0,		0,		1/M[8]
		]);
	} else {
		return false;
	}
};
LUTRGBSpline.prototype.getDetails = function(L) {
	var out;
	if (typeof L !== 'undefined' && L ) {
		out = {
			title: this.title,
			format: this.format,
			dims: 1,
			s: this.FM[3]+1,
			min: new Float64Array([this.fL[3],this.fL[3],this.fL[3]]),
			max: new Float64Array([this.fH[3],this.fH[3],this.fH[3]]),
			C: [this.FD[3].buffer],
			meta: this.meta
		};
	} else {
		out = {
			title: this.title,
			format: this.format,
			dims: 1,
			s: this.FM[3]+1,
			min: new Float64Array([this.fL[0],this.fL[1],this.fL[2]]),
			max: new Float64Array([this.fH[0],this.fH[1],this.fH[2]]),
			C: [this.FD[0].buffer,this.FD[1].buffer,this.FD[2].buffer],
			meta: this.meta
		};
	}
	return out;
};
LUTRGBSpline.prototype.getL = function() {
	return this.FD[3].buffer;
};
LUTRGBSpline.prototype.getRGB = function() {
	return [this.FD[0].buffer,this.FD[1].buffer,this.FD[2].buffer];
};
LUTRGBSpline.prototype.getSize = function() {
	return this.FM[3]+1;
};
LUTRGBSpline.prototype.is1D = function() {
	return true;
};
LUTRGBSpline.prototype.is3D = function() {
	return false;
};
LUTRGBSpline.prototype.getTitle = function() {
	return this.title;
};
LUTRGBSpline.prototype.getMetadata = function() {
	return this.meta;
};
LUTRGBSpline.prototype.isClamped = function() {
	if (typeof this.clamped === 'undefined') {
		var mm = this.minMax();
		var min = Math.min(mm[0],mm[1],mm[2]);
		var max = Math.max(mm[3],mm[4],mm[5]);
		if ((min === 0 && max <= 1) || (min >= 0 && max === 1)) {
			this.clamped = true;
		} else {
			this.clamped = false;
		}
	}
	return this.clamped;
};
LUTRGBSpline.prototype.deClamp = function() {
	if (this.isClamped()) {
		var m,c,C,L,H,LH,S;
		var fL,fH,fLH;
		for (var i=0; i<3; i++) {
			c = this.FD[i];
			m = c.length;
			C = false;
			L = 0;
			H = m-1;
			for (var j=0; j<m; j++) {
				if (j>0) {
					if (c[j] === 0) {
						C = true;
						L = j+1;
					}
				}
			}
			for (var j=m-2; j>=0; j--) {
				if (c[j] === 1) {
					C = true;
					H = j-1;
				}
			}
			if (C) {
				if (L > H) {
					var low = H;
					H = Math.min(L-2,m-1);
					L = Math.max(low+2,0);
				}
				LH = H-L;
				S = new LUTQSpline(new Float64Array(c.subarray(L,LH+1)).buffer);
				fL = this.fL[i];
				fH = this.fH[i];
				fLH= fH-fL;
				for (var j=0; j<m; j++) {
					if (j===L) {
						j = H;
					}
					// pass through the splines
					c[j] = S.fCub((j - L)/LH);
				}
			}
		}
		this.buildMesh();
		this.buildL();
		this.clamped = false;
	}
};
//
LUTRGBSpline.prototype.getColourSpace = function() {
	var d = this.d;
	var fL = this.fL;
	var fH = this.fH;
	var fLH = this.fLH;
	var out = {
		title: this.title + 'CS',
		format: this.format,
		fLR: fL[0],
		fLG: fL[1],
		fLB: fL[2],
		fHR: fH[0],
		fHG: fH[1],
		fHB: fH[2]
	};
	var reverse = new LUTRSpline({ buff:this.L.getL(), fH:fH[3], fL:fL[3] });
	var base = this.getRGB();
	reverse.R(base[0]);
	reverse.R(base[1]);
	reverse.R(base[2]);
	out.buffR = base[0];
	out.buffG = base[1];
	out.buffB = base[2];
	return new LUTRGBSpline(out);
};
LUTRGBSpline.prototype.compare = function(tgtBuff,tstBuff,method) {
	// returns the RMS differences in the red channels between a target dataset (tgt) and a test dataset (tst) which 'compare' passes through the lut
	// method sets the interpolation method used on the test set, currently trilinear (1, 'lin' or 'linear') or tricubic (anything else or the default if 'method' is not present.
	var tgt = new Float64Array(tgtBuff.slice(0));
	var tst = new Float64Array(tstBuff.slice(0));
	var m = tgt.length;
	if (m !== tst.length) {
		return false;
	}
	if (typeof method !== 'undefined') {
		method = method.toString().toLowerCase();
		if (method === '1' || method === 'tet') {
			this.RGBTet(tst.buffer);
		} else if (method === '2' || method === 'lin') {
			this.RGBLin(tst.buffer);
		} else {
			this.RGBCub(tst.buffer);
		}
	} else {
		this.RGBCub(tst.buffer);
	} 
	var e = new Float64Array(3);
	for (var j=0; j<m; j += 3) {
		e[0]  += Math.pow(tst[ j ] - tgt[ j ],2);
		e[1]  += Math.pow(tst[j+1] - tgt[j+1],2);
		e[2]  += Math.pow(tst[j+2] - tgt[j+2],2);
	}
	e[0] = Math.pow(e[0]*3/m,0.5);
	e[1] = Math.pow(e[1]*3/m,0.5);
	e[2] = Math.pow(e[2]*3/m,0.5);
	return e;
};
LUTRGBSpline.prototype.minMax = function() {
	var x = new Float64Array([
		 9999, 9999, 9999,	// Absolute min values
		-9999,-9999,-9999	// Absolute max values
	]);
	var c,m;
	for (var i=0; i<3; i++) {
		c = this.FD[i];
		m = c.length;
		for (var j=0; j<m; j++) {
			if (c[j] < x[i]) {
				x[i] = c[j];
			}
			if (c[j] > x[i+3]) {
				x[i+3] = c[j];
			}
		}
	}
	return x;
};
// LUTVolume - 3D mesh object
function LUTVolume(params) {
	// Metadata
	if (typeof params.title === 'string') {
		this.title = params.title;
	} else {
		this.title = '';
	}
	if (typeof params.format === 'string') {
		this.format = params.format;
	} else {
		this.format = '';
	}
	if (typeof params.meta !== 'undefined') {
		this.meta = params.meta;
	} else {
		this.meta = {};
	}
	this.Y = new Float64Array([0.2126,0.7152,0.0722]); // Rec709 luma coefficients
	// Set forward range
	this.fL = new Float64Array(4);
	this.fH = new Float64Array(4);
	this.fS = false;
	if (typeof params.min !== 'undefined' && (params.min[0] !== 0 || params.min[1] !== 0 || params.min[2] !== 0)) {
		params.fL = params.min[0];
		params.fLR = params.min[0];
		params.fLG = params.min[1];
		params.fLB = params.min[2];
	}
	if (typeof params.max !== 'undefined' && (params.max[0] !== 1 || params.max[1] !== 1 || params.max[2] !== 1)) {
		params.fH = params.max[0];
		params.fHR = params.max[0];
		params.fHG = params.max[1];
		params.fHB = params.max[2];
	}
	if (typeof params.fH === 'number') {
		this.fH[0] = params.fH;
		this.fH[1] = params.fH;
		this.fH[2] = params.fH;
	} else {
		this.fH[0] = 1;
		this.fH[1] = 1;
		this.fH[2] = 1;
	}
	if (typeof params.fL === 'number') {
		this.fL[0] = params.fL;
		this.fL[1] = params.fL;
		this.fL[2] = params.fL;
	} else {
		this.fL[0] = 0;
		this.fL[1] = 0;
		this.fL[2] = 0;
	}
	if (typeof params.fLR === 'number' &&
		typeof params.fHR === 'number' &&
		typeof params.fLG === 'number' &&
		typeof params.fHG === 'number' &&
		typeof params.fLB === 'number' &&
		typeof params.fHB === 'number') {
		this.fL[0] = params.fLR;
		this.fH[0] = params.fHR;
		this.fL[1] = params.fLG;
		this.fH[1] = params.fHG;
		this.fL[2] = params.fLB;
		this.fH[2] = params.fHB;
	}
	this.fL[3] = Math.min(this.fL[0],this.fL[1],this.fL[2]);
	this.fH[3] = Math.max(this.fH[0],this.fH[1],this.fH[2]);
	this.fLH = new Float64Array([this.fH[0]-this.fL[0],this.fH[1]-this.fL[1],this.fH[2]-this.fL[2],0]);
	if (this.fL[0] !== 0 || this.fL[1] !== 0 || this.fL[2] !== 0 || this.fH[0] !== 1 || this.fH[1] !== 1 || this.fH[2] !== 1) {
		this.fS = true;
	}
	// Allow for spline input (a bit nuts for 1D, but being robust)
	if (typeof params.inSpline !== 'undefined') {
		this.sin = true;
		this.ins = new LUTQSpline(params.inSpline);
	} else {
		this.sin = false;
	}
	// create a 'mesh' object to do the 3D interpolation
	this.pR = new Float64Array(4);
	this.pG = new Float64Array(4);
	this.pB = new Float64Array(4);
	this.buildMesh(params.buffR,params.buffG,params.buffB);
	// Precalculate Luma arrays
	this.buildL();
	// Store some typed arrays for repeat use to minimise garbage collection
	this.extVars= {
		dc: new Float64Array(this.d),
		r: new Float64Array(this.d),
		J: new Float64Array(this.d*3),
		JtJ: new Float64Array(9),
		JtJI: new Float64Array(9),
		Jtr: new Float64Array(3),
		del: new Float64Array(3)
	};
	this.ABab = new Float64Array([1,0,1,0]);
}
LUTVolume.prototype.buildMesh = function(buffR,buffG,buffB) {
	var red = new Float64Array(buffR);
	var green = new Float64Array(buffG);
	var blue = new Float64Array(buffB);
	var Y = new Float64Array([0.2126,0.7152,0.0722]); // Rec709 luma coefficients
	this.d = Math.round(Math.pow(red.length,1/3)); // dimensions of the base mesh
	var d = this.d;
	this.s = d-1;
	var d2 = d*d;
	var d3 = red.length;
	var nd = d + 2;
	this.nd = nd;
	var nd2 = nd * nd;
	var nd3 = nd2 * nd;
	var sG = nd3;
	var sB = 2 * sG;
	this.mesh = new Float64Array(nd3*3); // the new mesh is two points larger per side, with all three channels in one array for speed
	var k = nd2 + nd + 1; // first point in the new mesh at which to place mesh values
	var l=0;
	// create 4x4x4 array of offsets for quickly getting cubic control points;
	this.off = new Float64Array(64);
	for (var b=0; b<4; b++) {
		for (var g=0; g<4; g++) {
			for (var r=0; r<4; r++) {
				this.off[r + (g*4) + (b*16)] = r + (g*nd) + (b*nd2);
			}
		}
	}
	// populate the core of the new mesh with the old one
	for (var b=0; b<d; b++) {
		for (var g=0; g<d; g++) {
			for (var r=0; r<d; r++) { // typedarray slice and copywithin would allow block copying, but are not generally available in IE and Safari JS
				this.mesh[ k  ] = red[l];
				this.mesh[k+sG] = green[l];
				this.mesh[k+sB] = blue[l];
				l++;
				k++;
			}
			k += 2;
		}
		k += 2 * nd;
	}
	// Fill in the gaps around the larger mesh for quicker extrapolation
	this.fillEdges();
	// create object-scope typed arrays to minimise garbage collection
	this.rgb = new Float64Array(18);
	this.R = new Float64Array(8);
	this.G = new Float64Array(8);
	this.B = new Float64Array(8);
};
LUTVolume.prototype.buildL = function() {
	var fL = this.fL[3];
	var fH = this.fH[3];
	var fLH= fH-fL;
	var m = this.getSize();
	if (m < 65) {
		m = 65;
	}
	var FD = new Float64Array(m);
	var rgb = new Float64Array(m*3);
	var m2 = rgb.length;
	var k;
	for (var j=0; j<m; j++) { // create rgb array of input values
		k = j*3;
		rgb[ k ] = (j*(fLH)/(m-1))+fL;
		rgb[k+1] = rgb[k];
		rgb[k+2] = rgb[k];
	}
	// apply input scaling as required
	if (this.fS) {
		for (var j=0; j<m2; j += 3) {
			rgb[ j ] = (rgb[ j ] - this.fL[0])/(this.fLH[0]);
			rgb[j+1] = (rgb[j+1] - this.fL[1])/(this.fLH[1]);
			rgb[j+2] = (rgb[j+2] - this.fL[2])/(this.fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(rgb.buffer);
	}
	this.RGBCub(rgb.buffer); // calculate output rgb values
	for (var j=0; j<m; j++) {
		k = j*3;
		FD[j] = (rgb[ k ]*this.Y[0]) + (rgb[k+1]*this.Y[1]) + (rgb[k+2]*this.Y[2]);
	}
	this.L = new LUTSpline({ buff:FD.buffer, fH:fH, fL:fL });
};
LUTVolume.prototype.f = function(L) {
	return this.L.f(L);
};
LUTVolume.prototype.df = function(L) {
	return this.L.df(L);
};
LUTVolume.prototype.fCub = function(L) {
	return this.L.fCub(L);
};
LUTVolume.prototype.fTet = function(L) {
	return this.L.fLin(L);
};
LUTVolume.prototype.fLin = function(L) {
	return this.L.fLin(L);
};
LUTVolume.prototype.FCub = function(buff) {
	this.L.FCub(buff);
};
LUTVolume.prototype.FTet = function(buff) {
	this.L.FLin(buff);
};
LUTVolume.prototype.FLin = function(buff) {
	this.L.FLin(buff);
};
LUTVolume.prototype.fRGBCub = function(L) {
	var o = new Float64Array([L,L,L]);
	this.RGBCub(o.buffer);
	return o;
};
LUTVolume.prototype.fRGBTet = function(L) {
	var o = new Float64Array([L,L,L]);
	this.RGBTet(o.buffer);
	return o;
};
LUTVolume.prototype.fRGBLin = function(L) {
	var o = new Float64Array([L,L,L]);
	this.RGBLin(o.buffer);
	return o;
};
LUTVolume.prototype.rgbCub = function(rgbIn) {
	var rgb = new Float64Array(rgbIn.buffer.slice(0));
	this.RGBCub(rgb.buffer);
	return rgb;
};
LUTVolume.prototype.rgbTet = function(rgbIn) {
	var rgb = new Float64Array(rgbIn.buffer.slice(0));
	this.RGBTet(rgb.buffer);
	return rgb;
};
LUTVolume.prototype.rgbLin = function(rgbIn) {
	var rgb = new Float64Array(rgbIn.buffer.slice(0));
	this.RGBLin(rgb.buffer);
	return rgb;
};
LUTVolume.prototype.RGBCub = function(buff) {
	var c = new Float64Array(buff);
	var p = this.mesh;
	var o = this.off;
	var rgb = this.rgb;
	var m = c.length;
	var mm = Math.round(this.mesh.length/3);
	var s = this.s;
	var nd = s + 2;
	var nd1 = nd + 1;
	var k,b;
	var R = this.R;
	var G = this.G;
	var B = this.B;
	var E = false;
	var rE = false;
	var gE = false;
	var bE = false;
	if (this.fS) {
		var fL = this.fL;
		var fLH = this.fLH;
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j +=3) {
		c[ j ] *= s;
		c[j+1] *= s;
		c[j+2] *= s;
		rgb[ 9] = Math.max(0,Math.min(s-1,Math.floor(c[ j ])));
		rgb[10] = Math.max(0,Math.min(s-1,Math.floor(c[j+1])));
		rgb[11] = Math.max(0,Math.min(s-1,Math.floor(c[j+2])));
		c[ j ] -= rgb[ 9];
		c[j+1] -= rgb[10];
		c[j+2] -= rgb[11];
		// clamp values between 0-1.0 for interpolation
		rgb[0] = Math.max(0,Math.min(1,c[ j ]));
		rgb[1] = Math.max(0,Math.min(1,c[j+1]));
		rgb[2] = Math.max(0,Math.min(1,c[j+2]));
		// note that extrapolation will be needed if values were clamped
		if (rgb[0] !== c[ j ]) {
			rE = true;
			E = true;
		}
		if (rgb[1] !== c[j+1]) {
			gE = true;
			E = true;
		}
		if (rgb[2] !== c[j+2]) {
			bE = true;
			E = true;
		}
		// Prep all the squares, cubes and cubics
		rgb[3] = rgb[0]*rgb[0];
		rgb[4] = rgb[1]*rgb[1];
		rgb[5] = rgb[2]*rgb[2];
		rgb[6] = rgb[3]*rgb[0];
		rgb[7] = rgb[4]*rgb[1];
		rgb[8] = rgb[5]*rgb[2];
		R[0] = (-0.5*rgb[6]) + rgb[3] - (0.5*rgb[0]);
		R[1] = (1.5*rgb[6]) - (2.5*rgb[3]) + 1;
		R[2] = (-1.5*rgb[6]) + (2*rgb[3]) + (0.5*rgb[0]);
		R[3] = (0.5*rgb[6]) - (0.5*rgb[3]);
		G[0] = (-0.5*rgb[7]) + rgb[4] - (0.5*rgb[1]);
		G[1] = (1.5*rgb[7]) - (2.5*rgb[4]) + 1;
		G[2] = (-1.5*rgb[7]) + (2*rgb[4]) + (0.5*rgb[1]);
		G[3] = (0.5*rgb[7]) - (0.5*rgb[4]);
		B[0] = (-0.5*rgb[8]) + rgb[5] - (0.5*rgb[2]);
		B[1] = (1.5*rgb[8]) - (2.5*rgb[5]) + 1;
		B[2] = (-1.5*rgb[8]) + (2*rgb[5]) + (0.5*rgb[2]);
		B[3] = (0.5*rgb[8]) - (0.5*rgb[5]);
		// if any or all channels need extrapolation find out the scaling
		if (rE) {
			rgb[12] = c[ j ] - rgb[0];
		}
		if (gE) {
			rgb[13] = c[j+1] - rgb[1];
		}
		if (bE) {
			rgb[14] = c[j+2] - rgb[2];
		}
		// set value for first control point in the mesh - P[-1,-1,-1]
		b = (rgb[9]) + ((rgb[10] + (rgb[11]*nd1))*nd1);
		k = b;
		// multiply and add the cubics and the control points
		c[ j ]  = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[0])+
				  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[3]);
		k += mm;
		c[j+1]  = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[0])+
				  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[3]);
		k += mm;
		c[j+2]  = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[0])+
				  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[3]);
		// find slopes and perform extrapolation as needed
		if (E) {
			if (rE) {
				R[4] = (-1.5*rgb[3]) + (2*rgb[0]) - 0.5;
				R[5] = (4.5*rgb[3]) - (5*rgb[0]);
				R[6] = (-4.5*rgb[3]) + (4*rgb[0]) + 0.5;
				R[7] = (1.5*rgb[3] - rgb[0]);
				k = b;
				rgb[15] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
							(((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
							(((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
							(((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
				  		  (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
							(((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
							(((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
							(((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
						  (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
							(((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
							(((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
							(((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
						  (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
							(((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
							(((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
							(((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
				k += mm;
				rgb[16] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
							(((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
							(((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
							(((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
				  		  (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
							(((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
							(((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
							(((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
						  (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
							(((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
							(((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
							(((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
						  (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
							(((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
							(((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
							(((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
				k += mm;
				rgb[27] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
							(((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
							(((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
							(((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
				  		  (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
							(((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
							(((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
							(((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
						  (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
							(((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
							(((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
							(((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
						  (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
							(((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
							(((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
							(((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
				c[ j ] += rgb[12] * rgb[15];
				c[j+1] += rgb[12] * rgb[16];
				c[j+2] += rgb[12] * rgb[17];
			}
			if (gE) {
				G[4] = (-1.5*rgb[4]) + (2*rgb[1]) - 0.5;
				G[5] = (4.5*rgb[4]) - (5*rgb[1]);
				G[6] = (-4.5*rgb[4]) + (4*rgb[1]) + 0.5;
				G[7] = (1.5*rgb[4] - rgb[1]);
				k = b;
				rgb[15] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
				k += mm;
				rgb[16] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
				k += mm;
				rgb[17] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
				c[ j ] += rgb[13] * rgb[15];
				c[j+1] += rgb[13] * rgb[16];
				c[j+2] += rgb[13] * rgb[17];
			}
			if (bE) {
				B[4] = (-1.5*rgb[5]) + (2*rgb[2]) - 0.5;
				B[5] = (4.5*rgb[5]) - (5*rgb[2]);
				B[6] = (-4.5*rgb[5]) + (4*rgb[2]) + 0.5;
				B[7] = (1.5*rgb[5] - rgb[2]);
				k = b;
				rgb[15] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
				k += mm;
				rgb[16] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
				k += mm;
				rgb[17] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
							(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
							(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
							(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
				  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
							(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
							(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
							(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
						  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
							(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
							(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
							(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
						  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
							(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
							(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
							(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
				c[ j ] += rgb[14] * rgb[15];	
				c[j+1] += rgb[14] * rgb[16];
				c[j+2] += rgb[14] * rgb[17];
			}
			E = false;
			rE = false;
			gE = false;
			bE = false;
		}
	}
};
LUTVolume.prototype.RGBTet = function(buff) {
	var c = new Float64Array(buff);
	var p = this.mesh;
	var o = this.off;
	var rgb = this.rgb;
	var m = c.length;
	var mm = Math.round(this.mesh.length/3);
	var s = this.s;
	var nd = s + 2;
	var nd1 = nd + 1;
	var k,b;
	var R = this.R;
	var G = this.G;
	var B = this.B;
	var E = false;
	var rE = false;
	var gE = false;
	var bE = false;
	if (this.fS) {
		var fL = this.fL;
		var fLH = this.fLH;
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j +=3) {
		c[ j ] *= s;
		c[j+1] *= s;
		c[j+2] *= s;
		rgb[ 9] = Math.max(0,Math.min(s-1,Math.floor(c[ j ])));
		rgb[10] = Math.max(0,Math.min(s-1,Math.floor(c[j+1])));
		rgb[11] = Math.max(0,Math.min(s-1,Math.floor(c[j+2])));
		c[ j ] -= rgb[ 9];
		c[j+1] -= rgb[10];
		c[j+2] -= rgb[11];
		// clamp values between 0-1.0 for interpolation
		rgb[0] = Math.max(0,Math.min(1,c[ j ]));
		rgb[1] = Math.max(0,Math.min(1,c[j+1]));
		rgb[2] = Math.max(0,Math.min(1,c[j+2]));
		// note that extrapolation will be needed if values were clamped
		if (rgb[0] !== c[ j ]) {
			rE = true;
			E = true;
		}
		if (rgb[1] !== c[j+1]) {
			gE = true;
			E = true;
		}
		if (rgb[2] !== c[j+2]) {
			bE = true;
			E = true;
		}
		// if any or all channels need extrapolation find out the scaling
		if (rE) {
			rgb[12] = c[ j ] - rgb[0];
		}
		if (gE) {
			rgb[13] = c[j+1] - rgb[1];
		}
		if (bE) {
			rgb[14] = c[j+2] - rgb[2];
		}
		// set value for first control point in the mesh - P[-1,-1,-1]
		b = (rgb[9]) + ((rgb[10] + (rgb[11]*nd1))*nd1);
		k = b;
		// find which tetrahedron to use
		var tet = (rgb[0]>rgb[1]) + ((rgb[1]>rgb[2])*2) + ((rgb[2]>rgb[0])*4);
		// perform tetrahedral interpolation
		switch (tet) {
			case 0: // rgb[0] === rgb[1] === rgb[2] so straight linear interpolation
				c[ j ] = ((1-rgb[0])*p[k+o[21]]) + (rgb[0]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[1])*p[k+o[21]]) + (rgb[1]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[2])*p[k+o[21]]) + (rgb[2]*p[k+o[42]]);
				break;
			case 1:
				c[ j ] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[2])*p[k+o[22]]) + ((rgb[2]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[2])*p[k+o[22]]) + ((rgb[2]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[2])*p[k+o[22]]) + ((rgb[2]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				break;
			case 2:
				c[ j ] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[0])*p[k+o[25]]) + ((rgb[0]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[0])*p[k+o[25]]) + ((rgb[0]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[0])*p[k+o[25]]) + ((rgb[0]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				break;
			case 3:
				c[ j ] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[1])*p[k+o[22]]) + ((rgb[1]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[1])*p[k+o[22]]) + ((rgb[1]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[0])*p[k+o[21]]) + ((rgb[0]-rgb[1])*p[k+o[22]]) + ((rgb[1]-rgb[2])*p[k+o[26]]) + (rgb[2]*p[k+o[42]]);
				break;
			case 4:
				c[ j ] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[1])*p[k+o[37]]) + ((rgb[1]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[1])*p[k+o[37]]) + ((rgb[1]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[1])*p[k+o[37]]) + ((rgb[1]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				break;
			case 5:
				c[ j ] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[0])*p[k+o[37]]) + ((rgb[0]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[0])*p[k+o[37]]) + ((rgb[0]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[2])*p[k+o[21]]) + ((rgb[2]-rgb[0])*p[k+o[37]]) + ((rgb[0]-rgb[1])*p[k+o[38]]) + (rgb[1]*p[k+o[42]]);
				break;
			case 6:
				c[ j ] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[2])*p[k+o[25]]) + ((rgb[2]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				k += mm;
				c[j+1] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[2])*p[k+o[25]]) + ((rgb[2]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				k += mm;
				c[j+2] = ((1-rgb[1])*p[k+o[21]]) + ((rgb[1]-rgb[2])*p[k+o[25]]) + ((rgb[2]-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]);
				break;
			default: // shouldn't be possible, but include fallback to trilinear interpolation
				c[ j ]  = ((((((1-rgb[0])*p[k+o[21]]) + (rgb[0]*p[k+o[22]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[25]]) + (rgb[0]*p[k+o[26]]))*rgb[1]))*(1-rgb[2]))+
						  ((((((1-rgb[0])*p[k+o[37]]) + (rgb[0]*p[k+o[38]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]))*rgb[1]))*rgb[2]);
				k += mm;
				c[j+1]  = ((((((1-rgb[0])*p[k+o[21]]) + (rgb[0]*p[k+o[22]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[25]]) + (rgb[0]*p[k+o[26]]))*rgb[1]))*(1-rgb[2]))+
						  ((((((1-rgb[0])*p[k+o[37]]) + (rgb[0]*p[k+o[38]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]))*rgb[1]))*rgb[2]);
				k += mm;
				c[j+2]  = ((((((1-rgb[0])*p[k+o[21]]) + (rgb[0]*p[k+o[22]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[25]]) + (rgb[0]*p[k+o[26]]))*rgb[1]))*(1-rgb[2]))+
						  ((((((1-rgb[0])*p[k+o[37]]) + (rgb[0]*p[k+o[38]]))*(1-rgb[1])) + ((((1-rgb[0])*p[k+o[41]]) + (rgb[0]*p[k+o[42]]))*rgb[1]))*rgb[2]);
		}
		// find slopes and perform extrapolation as needed
		// Actually use Trilinear for EXTRAPOLATION, as tends to be smoother than tetrahedral
		if (E) {
			R[0] = 1-rgb[0];
			R[1] = rgb[0];
			G[0] = 1-rgb[1];
			G[1] = rgb[1];
			B[0] = 1-rgb[2];
			B[1] = rgb[2];
			if (rE) {
				k = b;
				rgb[15] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				k += mm;
				rgb[16] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				k += mm;
				rgb[17] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				c[ j ] += rgb[12] * rgb[15];
				c[j+1] += rgb[12] * rgb[16];
				c[j+2] += rgb[12] * rgb[17];
			}
			if (gE) {
				k = b;
				rgb[15] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				k += mm;
				rgb[16] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				k += mm;
				rgb[17] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				c[ j ] += rgb[13] * rgb[15];
				c[j+1] += rgb[13] * rgb[16];
				c[j+2] += rgb[13] * rgb[17];
			}
			if (bE) {
				k = b;
				rgb[15] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				k += mm;
				rgb[16] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				k += mm;
				rgb[17] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				c[ j ] += rgb[14] * rgb[15];	
				c[j+1] += rgb[14] * rgb[16];
				c[j+2] += rgb[14] * rgb[17];
			}
			E = false;
			rE = false;
			gE = false;
			bE = false;
		}
/* Tetrahedral EXTRAPOLATION is not great - LUTCalc currently uses Trilinear. The following is tetrahedral code
		if (E) {
			// check for and perform extrapolation
			if (rE) {
				k=b;
				switch (tet) {
					case 0: // rgb[0] === rgb[1] === rgb[2]
						rgb[15] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[21]];
						break;
					case 1:
						rgb[15] = p[k+o[22]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[22]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[22]]-p[k+o[21]];
						break;
					case 2:
						rgb[15] = p[k+o[26]]-p[k+o[25]];
						k += mm;
						rgb[16] = p[k+o[26]]-p[k+o[25]];
						k += mm;
						rgb[17] = p[k+o[26]]-p[k+o[25]];
						break;
					case 3:
						rgb[15] = p[k+o[22]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[22]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[22]]-p[k+o[21]];
						break;
					case 4:
						rgb[15] = p[k+o[42]]-p[k+o[41]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[41]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[41]];
						break;
					case 5:
						rgb[15] = p[k+o[38]]-p[k+o[37]];
						k += mm;
						rgb[16] = p[k+o[38]]-p[k+o[37]];
						k += mm;
						rgb[17] = p[k+o[38]]-p[k+o[37]];
						break;
					case 6:
						rgb[15] = p[k+o[42]]-p[k+o[41]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[41]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[41]];
						break;
					default: // shouldn't be possible, but include fallback to trilinear interpolation
						rgb[15] = ((((p[k+o[22]]-p[k+o[21]])*(1-rgb[1])) + ((p[k+o[26]]-p[k+o[25]])*rgb[1]))*(1-rgb[2]))+
								  ((((p[k+o[38]]-p[k+o[37]])*(1-rgb[1])) + ((p[k+o[42]]-p[k+o[41]])*rgb[1]))*rgb[2]);
						k += mm;
						rgb[16] = ((((p[k+o[22]]-p[k+o[21]])*(1-rgb[1])) + ((p[k+o[26]]-p[k+o[25]])*rgb[1]))*(1-rgb[2]))+
								  ((((p[k+o[38]]-p[k+o[37]])*(1-rgb[1])) + ((p[k+o[42]]-p[k+o[41]])*rgb[1]))*rgb[2]);
						k += mm;
						rgb[17] = ((((p[k+o[22]]-p[k+o[21]])*(1-rgb[1])) + ((p[k+o[26]]-p[k+o[25]])*rgb[1]))*(1-rgb[2]))+
								  ((((p[k+o[38]]-p[k+o[37]])*(1-rgb[1])) + ((p[k+o[42]]-p[k+o[41]])*rgb[1]))*rgb[2]);
				}
				c[ j ] += rgb[12] * rgb[15];
				c[j+1] += rgb[12] * rgb[16];
				c[j+2] += rgb[12] * rgb[17];
			}
			if (gE) {
				k = b;
				switch (tet) {
					case 0: // rgb[0] === rgb[1] === rgb[2]
						rgb[15] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[21]];
						break;
					case 1:
						rgb[15] = p[k+o[42]]-p[k+o[38]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[38]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[38]];
						break;
					case 2:
						rgb[15] = p[k+o[25]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[25]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[25]]-p[k+o[21]];
						break;
					case 3:
						rgb[15] = p[k+o[26]]-p[k+o[22]];
						k += mm;
						rgb[16] = p[k+o[26]]-p[k+o[22]];
						k += mm;
						rgb[17] = p[k+o[26]]-p[k+o[22]];
						break;
					case 4:
						rgb[15] = p[k+o[41]]-p[k+o[37]];
						k += mm;
						rgb[16] = p[k+o[41]]-p[k+o[37]];
						k += mm;
						rgb[17] = p[k+o[41]]-p[k+o[37]];
						break;
					case 5:
						rgb[15] = p[k+o[42]]-p[k+o[38]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[38]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[38]];
						break;
					case 6:
						rgb[15] = p[k+o[25]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[25]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[25]]-p[k+o[21]];
						break;
					default: // shouldn't be possible, but include fallback to trilinear interpolation
						rgb[15] = ((((p[k+o[25]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[26]]-p[k+o[22]])*rgb[0]))*(1-rgb[2]))+
								  ((((p[k+o[41]]-p[k+o[37]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[38]])*rgb[0]))*rgb[2]);
						k += mm;
						rgb[16] = ((((p[k+o[25]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[26]]-p[k+o[22]])*rgb[0]))*(1-rgb[2]))+
								  ((((p[k+o[41]]-p[k+o[37]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[38]])*rgb[0]))*rgb[2]);
						k += mm;
						rgb[17] = ((((p[k+o[25]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[26]]-p[k+o[22]])*rgb[0]))*(1-rgb[2]))+
								  ((((p[k+o[41]]-p[k+o[37]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[38]])*rgb[0]))*rgb[2]);
				}
				c[ j ] += rgb[13] * rgb[15];
				c[j+1] += rgb[13] * rgb[16];
				c[j+2] += rgb[13] * rgb[17];
			}
			if (bE) {
				k = b;
				switch (tet) {
					case 0: // rgb[0] === rgb[1] === rgb[2]
						rgb[15] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[21]];
						break;
					case 1:
						rgb[15] = p[k+o[38]]-p[k+o[22]];
						k += mm;
						rgb[16] = p[k+o[38]]-p[k+o[22]];
						k += mm;
						rgb[17] = p[k+o[38]]-p[k+o[22]];
						break;
					case 2:
						rgb[15] = p[k+o[42]]-p[k+o[26]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[26]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[26]];
						break;
					case 3:
						rgb[15] = p[k+o[42]]-p[k+o[26]];
						k += mm;
						rgb[16] = p[k+o[42]]-p[k+o[26]];
						k += mm;
						rgb[17] = p[k+o[42]]-p[k+o[26]];
						break;
					case 4:
						rgb[15] = p[k+o[37]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[37]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[37]]-p[k+o[21]];
						break;
					case 5:
						rgb[15] = p[k+o[37]]-p[k+o[21]];
						k += mm;
						rgb[16] = p[k+o[37]]-p[k+o[21]];
						k += mm;
						rgb[17] = p[k+o[37]]-p[k+o[21]];
						break;
					case 6:
						rgb[15] = p[k+o[41]]-p[k+o[25]];
						k += mm;
						rgb[16] = p[k+o[41]]-p[k+o[25]];
						k += mm;
						rgb[17] = p[k+o[41]]-p[k+o[25]];
						break;
					default: // shouldn't be possible, but include fallback to trilinear interpolation
						rgb[15] = ((((p[k+o[37]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[38]]-p[k+o[22]])*rgb[0]))*(1-rgb[1]))+
								  ((((p[k+o[41]]-p[k+o[25]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[26]])*rgb[0]))*rgb[1]);
						k += mm;
						rgb[16] = ((((p[k+o[37]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[38]]-p[k+o[22]])*rgb[0]))*(1-rgb[1]))+
								  ((((p[k+o[41]]-p[k+o[25]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[26]])*rgb[0]))*rgb[1]);
						k += mm;
						rgb[17] = ((((p[k+o[37]]-p[k+o[21]])*(1-rgb[0])) + ((p[k+o[38]]-p[k+o[22]])*rgb[0]))*(1-rgb[1]))+
								  ((((p[k+o[41]]-p[k+o[25]])*(1-rgb[0])) + ((p[k+o[42]]-p[k+o[26]])*rgb[0]))*rgb[1]);
				}
				c[ j ] += rgb[14] * rgb[15];	
				c[j+1] += rgb[14] * rgb[16];
				c[j+2] += rgb[14] * rgb[17];
			}
			E = false;
			rE = false;
			gE = false;
			bE = false;
		}
*/
	}
};
LUTVolume.prototype.RGBLin = function(buff) {
	var c = new Float64Array(buff);
	var p = this.mesh;
	var o = this.off;
	var rgb = this.rgb;
	var m = c.length;
	var mm = Math.round(this.mesh.length/3);
	var s = this.s;
	var nd = s + 2;
	var nd1 = nd + 1;
	var k,b;
	var R = this.R;
	var G = this.G;
	var B = this.B;
	var E = false;
	var rE = false;
	var gE = false;
	var bE = false;
	if (this.fS) {
		var fL = this.fL;
		var fLH = this.fLH;
		for (var j=0; j<m; j+=3) {
			c[ j ] = (c[ j ] - fL[0])/(fLH[0]);
			c[j+1] = (c[j+1] - fL[1])/(fLH[1]);
			c[j+2] = (c[j+2] - fL[2])/(fLH[2]);
		}
	}
	if (this.sin) {
		this.ins.FCub(buff);
	}
	for (var j=0; j<m; j +=3) {
		c[ j ] *= s;
		c[j+1] *= s;
		c[j+2] *= s;
		rgb[ 9] = Math.max(0,Math.min(s-1,Math.floor(c[ j ])));
		rgb[10] = Math.max(0,Math.min(s-1,Math.floor(c[j+1])));
		rgb[11] = Math.max(0,Math.min(s-1,Math.floor(c[j+2])));
		c[ j ] -= rgb[ 9];
		c[j+1] -= rgb[10];
		c[j+2] -= rgb[11];
		// clamp values between 0-1.0 for interpolation
		rgb[0] = Math.max(0,Math.min(1,c[ j ]));
		rgb[1] = Math.max(0,Math.min(1,c[j+1]));
		rgb[2] = Math.max(0,Math.min(1,c[j+2]));
		// note that extrapolation will be needed if values were clamped
		if (rgb[0] !== c[ j ]) {
			rE = true;
			E = true;
		}
		if (rgb[1] !== c[j+1]) {
			gE = true;
			E = true;
		}
		if (rgb[2] !== c[j+2]) {
			bE = true;
			E = true;
		}
		// Prep all the squares, cubes and cubics
		R[0] = 1-rgb[0];
		R[1] = rgb[0];
		G[0] = 1-rgb[1];
		G[1] = rgb[1];
		B[0] = 1-rgb[2];
		B[1] = rgb[2];
		// if any or all channels need extrapolation find out the scaling
		if (rE) {
			rgb[12] = c[ j ] - rgb[0];
		}
		if (gE) {
			rgb[13] = c[j+1] - rgb[1];
		}
		if (bE) {
			rgb[14] = c[j+2] - rgb[2];
		}
		// set value for first control point in the mesh - P[-1,-1,-1]
		b = (rgb[9]) + ((rgb[10] + (rgb[11]*nd1))*nd1);
		k = b;
		// multiply and add the cubics and the control points
		c[ j ]  = (((((R[0]*p[k+o[21]]) + (R[1]*p[k+o[22]]))*G[0]) + (((R[0]*p[k+o[25]]) + (R[1]*p[k+o[26]]))*G[1]))*B[0])+
				  (((((R[0]*p[k+o[37]]) + (R[1]*p[k+o[38]]))*G[0]) + (((R[0]*p[k+o[41]]) + (R[1]*p[k+o[42]]))*G[1]))*B[1]);
		k += mm;
		c[j+1]  = (((((R[0]*p[k+o[21]]) + (R[1]*p[k+o[22]]))*G[0]) + (((R[0]*p[k+o[25]]) + (R[1]*p[k+o[26]]))*G[1]))*B[0])+
				  (((((R[0]*p[k+o[37]]) + (R[1]*p[k+o[38]]))*G[0]) + (((R[0]*p[k+o[41]]) + (R[1]*p[k+o[42]]))*G[1]))*B[1]);
		k += mm;
		c[j+2]  = (((((R[0]*p[k+o[21]]) + (R[1]*p[k+o[22]]))*G[0]) + (((R[0]*p[k+o[25]]) + (R[1]*p[k+o[26]]))*G[1]))*B[0])+
				  (((((R[0]*p[k+o[37]]) + (R[1]*p[k+o[38]]))*G[0]) + (((R[0]*p[k+o[41]]) + (R[1]*p[k+o[42]]))*G[1]))*B[1]);
		// find slopes and perform extrapolation as needed
		if (E) {
			if (rE) {
				k = b;
				rgb[15] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				k += mm;
				rgb[16] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				k += mm;
				rgb[17] = ((((p[k+o[22]]-p[k+o[21]])*G[0]) + ((p[k+o[26]]-p[k+o[25]])*G[1]))*B[0])+
						  ((((p[k+o[38]]-p[k+o[37]])*G[0]) + ((p[k+o[42]]-p[k+o[41]])*G[1]))*B[1]);
				c[ j ] += rgb[12] * rgb[15];
				c[j+1] += rgb[12] * rgb[16];
				c[j+2] += rgb[12] * rgb[17];
			}
			if (gE) {
				k = b;
				rgb[15] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				k += mm;
				rgb[16] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				k += mm;
				rgb[17] = ((((p[k+o[25]]-p[k+o[21]])*R[0]) + ((p[k+o[26]]-p[k+o[22]])*R[1]))*B[0])+
						  ((((p[k+o[41]]-p[k+o[37]])*R[0]) + ((p[k+o[42]]-p[k+o[38]])*R[1]))*B[1]);
				c[ j ] += rgb[13] * rgb[15];
				c[j+1] += rgb[13] * rgb[16];
				c[j+2] += rgb[13] * rgb[17];
			}
			if (bE) {
				k = b;
				rgb[15] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				k += mm;
				rgb[16] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				k += mm;
				rgb[17] = ((((p[k+o[37]]-p[k+o[21]])*R[0]) + ((p[k+o[38]]-p[k+o[22]])*R[1]))*G[0])+
						 ((((p[k+o[41]]-p[k+o[25]])*R[0]) + ((p[k+o[42]]-p[k+o[26]])*R[1]))*G[1]);
				c[ j ] += rgb[14] * rgb[15];	
				c[j+1] += rgb[14] * rgb[16];
				c[j+2] += rgb[14] * rgb[17];
			}
			E = false;
			rE = false;
			gE = false;
			bE = false;
		}
	}
};
LUTVolume.prototype.J = function(rgbIn) {
	// calculate the Jacobian matrix at rgbIn
	if (rgbIn.length === 3) {
		var c = new Float64Array(rgbIn.buffer.slice(0));
		var J = new Float64Array(9);
		var p = this.mesh;
		var o = this.off;
		var s = this.s;
		var rgb = this.rgb;
		var R = this.R;
		var G = this.G;
		var B = this.B;
		var nd = s + 2;
		var nd1 = nd + 1;
		var b,k;
		var fL = this.fL;
		var fLH = this.fLH;
		if (this.fS) {
			for (var j=0; j<m; j+=3) {
				c[0] = (c[0] - fL[0])/(fLH[0]);
				c[1] = (c[1] - fL[1])/(fLH[1]);
				c[2] = (c[2] - fL[2])/(fLH[2]);
			}
		}
		if (this.sin) {
			this.ins.FCub(c.buffer);
		}
		c[0] *= s;
		c[1] *= s;
		c[2] *= s;
		rgb[ 9] = Math.max(0,Math.min(s-1,Math.floor(c[ j ])));
		rgb[10] = Math.max(0,Math.min(s-1,Math.floor(c[j+1])));
		rgb[11] = Math.max(0,Math.min(s-1,Math.floor(c[j+2])));
		c[0] -= rgb[ 9];
		c[1] -= rgb[10];
		c[2] -= rgb[11];
		// clamp values between 0-1.0 for interpolation
		rgb[0] = Math.max(0,Math.min(1,c[0]));
		rgb[1] = Math.max(0,Math.min(1,c[1]));
		rgb[2] = Math.max(0,Math.min(1,c[2]));
		// Prep all the squares, cubes and cubics
		rgb[3] = rgb[0]*rgb[0];
		rgb[4] = rgb[1]*rgb[1];
		rgb[5] = rgb[2]*rgb[2];
		rgb[6] = rgb[3]*rgb[0];
		rgb[7] = rgb[4]*rgb[1];
		rgb[8] = rgb[5]*rgb[2];
		R[0] = (-0.5*rgb[6]) + rgb[3] - (0.5*rgb[0]);
		R[1] = (1.5*rgb[6]) - (2.5*rgb[3]) + 1;
		R[2] = (-1.5*rgb[6]) + (2*rgb[3]) + (0.5*rgb[0]);
		R[3] = (0.5*rgb[6]) - (0.5*rgb[3]);
		G[0] = (-0.5*rgb[7]) + rgb[4] - (0.5*rgb[1]);
		G[1] = (1.5*rgb[7]) - (2.5*rgb[4]) + 1;
		G[2] = (-1.5*rgb[7]) + (2*rgb[4]) + (0.5*rgb[1]);
		G[3] = (0.5*rgb[7]) - (0.5*rgb[4]);
		B[0] = (-0.5*rgb[8]) + rgb[5] - (0.5*rgb[2]);
		B[1] = (1.5*rgb[8]) - (2.5*rgb[5]) + 1;
		B[2] = (-1.5*rgb[8]) + (2*rgb[5]) + (0.5*rgb[2]);
		B[3] = (0.5*rgb[8]) - (0.5*rgb[5]);
		// set value for first control point in the mesh - P[-1,-1,-1]
		b = (rgb[9]) + ((rgb[10] + (rgb[11]*nd1))*nd1);
		// d/dR
		R[4] = (-1.5*rgb[3]) + (2*rgb[0]) - 0.5;
		R[5] = (4.5*rgb[3]) - (5*rgb[0]);
		R[6] = (-4.5*rgb[3]) + (4*rgb[0]) + 0.5;
		R[7] = (1.5*rgb[3] - rgb[0]);
		k = b;
		J[0] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
				 (((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
				 (((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
				 (((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
			   (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
				 (((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
				 (((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
				 (((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
			   (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
				 (((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
				 (((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
				 (((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
			   (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
				 (((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
				 (((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
				 (((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
		k += mm;
		J[3] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
				 (((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
				 (((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
				 (((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
			   (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
				 (((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
				 (((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
				 (((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
			   (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
				 (((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
				 (((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
				 (((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
			   (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
				 (((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
				 (((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
				 (((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
		k += mm;
		J[6] = (((((R[4]*p[k+o[ 0]])+(R[5]*p[k+o[ 1]])+(R[6]*p[k+o[ 2]])+(R[7]*p[k+o[ 3]]))*G[0])+
				 (((R[4]*p[k+o[ 4]])+(R[5]*p[k+o[ 5]])+(R[6]*p[k+o[ 6]])+(R[7]*p[k+o[ 7]]))*G[1])+
				 (((R[4]*p[k+o[ 8]])+(R[5]*p[k+o[ 9]])+(R[6]*p[k+o[10]])+(R[7]*p[k+o[11]]))*G[2])+
				 (((R[4]*p[k+o[12]])+(R[5]*p[k+o[13]])+(R[6]*p[k+o[14]])+(R[7]*p[k+o[15]]))*G[3]))*B[0])+
			   (((((R[4]*p[k+o[16]])+(R[5]*p[k+o[17]])+(R[6]*p[k+o[18]])+(R[7]*p[k+o[19]]))*G[0])+
				 (((R[4]*p[k+o[20]])+(R[5]*p[k+o[21]])+(R[6]*p[k+o[22]])+(R[7]*p[k+o[23]]))*G[1])+
				 (((R[4]*p[k+o[24]])+(R[5]*p[k+o[25]])+(R[6]*p[k+o[26]])+(R[7]*p[k+o[27]]))*G[2])+
				 (((R[4]*p[k+o[28]])+(R[5]*p[k+o[29]])+(R[6]*p[k+o[30]])+(R[7]*p[k+o[31]]))*G[3]))*B[1])+
			   (((((R[4]*p[k+o[32]])+(R[5]*p[k+o[33]])+(R[6]*p[k+o[34]])+(R[7]*p[k+o[35]]))*G[0])+
				 (((R[4]*p[k+o[36]])+(R[5]*p[k+o[37]])+(R[6]*p[k+o[38]])+(R[7]*p[k+o[39]]))*G[1])+
				 (((R[4]*p[k+o[40]])+(R[5]*p[k+o[41]])+(R[6]*p[k+o[42]])+(R[7]*p[k+o[43]]))*G[2])+
				 (((R[4]*p[k+o[44]])+(R[5]*p[k+o[45]])+(R[6]*p[k+o[46]])+(R[7]*p[k+o[47]]))*G[3]))*B[2])+
			   (((((R[4]*p[k+o[48]])+(R[5]*p[k+o[49]])+(R[6]*p[k+o[50]])+(R[7]*p[k+o[51]]))*G[0])+
				 (((R[4]*p[k+o[52]])+(R[5]*p[k+o[53]])+(R[6]*p[k+o[54]])+(R[7]*p[k+o[55]]))*G[1])+
				 (((R[4]*p[k+o[56]])+(R[5]*p[k+o[57]])+(R[6]*p[k+o[58]])+(R[7]*p[k+o[59]]))*G[2])+
				 (((R[4]*p[k+o[60]])+(R[5]*p[k+o[61]])+(R[6]*p[k+o[62]])+(R[7]*p[k+o[63]]))*G[3]))*B[3]);
		// d/dG
		G[4] = (-1.5*rgb[4]) + (2*rgb[1]) - 0.5;
		G[5] = (4.5*rgb[4]) - (5*rgb[1]);
		G[6] = (-4.5*rgb[4]) + (4*rgb[1]) + 0.5;
		G[7] = (1.5*rgb[4] - rgb[1]);
		k = b;
		J[1] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
		  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
		k += mm;
		J[4] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
		 		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
		k += mm;
		J[7] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[4])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[5])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[6])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[7]))*B[0])+
		  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[4])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[5])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[6])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[7]))*B[1])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[4])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[5])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[6])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[7]))*B[2])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[4])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[5])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[6])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[7]))*B[3]);
		// d/dB
		B[4] = (-1.5*rgb[5]) + (2*rgb[2]) - 0.5;
		B[5] = (4.5*rgb[5]) - (5*rgb[2]);
		B[6] = (-4.5*rgb[5]) + (4*rgb[2]) + 0.5;
		B[7] = (1.5*rgb[5] - rgb[2]);
		k = b;
		J[2] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
		  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
		k += mm;
		J[5] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
		  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
		k += mm;
		J[8] = (((((R[0]*p[k+o[ 0]])+(R[1]*p[k+o[ 1]])+(R[2]*p[k+o[ 2]])+(R[3]*p[k+o[ 3]]))*G[0])+
					(((R[0]*p[k+o[ 4]])+(R[1]*p[k+o[ 5]])+(R[2]*p[k+o[ 6]])+(R[3]*p[k+o[ 7]]))*G[1])+
					(((R[0]*p[k+o[ 8]])+(R[1]*p[k+o[ 9]])+(R[2]*p[k+o[10]])+(R[3]*p[k+o[11]]))*G[2])+
					(((R[0]*p[k+o[12]])+(R[1]*p[k+o[13]])+(R[2]*p[k+o[14]])+(R[3]*p[k+o[15]]))*G[3]))*B[4])+
		  		  (((((R[0]*p[k+o[16]])+(R[1]*p[k+o[17]])+(R[2]*p[k+o[18]])+(R[3]*p[k+o[19]]))*G[0])+
					(((R[0]*p[k+o[20]])+(R[1]*p[k+o[21]])+(R[2]*p[k+o[22]])+(R[3]*p[k+o[23]]))*G[1])+
					(((R[0]*p[k+o[24]])+(R[1]*p[k+o[25]])+(R[2]*p[k+o[26]])+(R[3]*p[k+o[27]]))*G[2])+
					(((R[0]*p[k+o[28]])+(R[1]*p[k+o[29]])+(R[2]*p[k+o[30]])+(R[3]*p[k+o[31]]))*G[3]))*B[5])+
				  (((((R[0]*p[k+o[32]])+(R[1]*p[k+o[33]])+(R[2]*p[k+o[34]])+(R[3]*p[k+o[35]]))*G[0])+
					(((R[0]*p[k+o[36]])+(R[1]*p[k+o[37]])+(R[2]*p[k+o[38]])+(R[3]*p[k+o[39]]))*G[1])+
					(((R[0]*p[k+o[40]])+(R[1]*p[k+o[41]])+(R[2]*p[k+o[42]])+(R[3]*p[k+o[43]]))*G[2])+
					(((R[0]*p[k+o[44]])+(R[1]*p[k+o[45]])+(R[2]*p[k+o[46]])+(R[3]*p[k+o[47]]))*G[3]))*B[6])+
				  (((((R[0]*p[k+o[48]])+(R[1]*p[k+o[49]])+(R[2]*p[k+o[50]])+(R[3]*p[k+o[51]]))*G[0])+
					(((R[0]*p[k+o[52]])+(R[1]*p[k+o[53]])+(R[2]*p[k+o[54]])+(R[3]*p[k+o[55]]))*G[1])+
					(((R[0]*p[k+o[56]])+(R[1]*p[k+o[57]])+(R[2]*p[k+o[58]])+(R[3]*p[k+o[59]]))*G[2])+
					(((R[0]*p[k+o[60]])+(R[1]*p[k+o[61]])+(R[2]*p[k+o[62]])+(R[3]*p[k+o[63]]))*G[3]))*B[7]);
		// Scale to 0-1 range (from 0-s)
		J[0] *= s;
		J[1] *= s;
		J[2] *= s;
		J[3] *= s;
		J[4] *= s;
		J[5] *= s;
		J[6] *= s;
		J[7] *= s;
		J[8] *= s;
		if (this.sin) {
			var dRGB = this.ins.dRGB(rgbIn.buffer);
			J[0] *= dRGB[0];
			J[1] *= dRGB[1];
			J[2] *= dRGB[2];
			J[3] *= dRGB[0];
			J[4] *= dRGB[1];
			J[5] *= dRGB[2];
			J[6] *= dRGB[0];
			J[7] *= dRGB[1];
			J[8] *= dRGB[2];
		}
		if (this.fS) {
			J[0] /= fLH[0];
			J[1] /= fLH[1];
			J[2] /= fLH[2];
			J[3] /= fLH[0];
			J[4] /= fLH[1];
			J[5] /= fLH[2];
			J[6] /= fLH[0];
			J[7] /= fLH[1];
			J[8] /= fLH[2];
		}
		return J;
	} else {
		return false;
	}
};
LUTVolume.prototype.JInv = function(rgbIn) {
	var M = this.J(rgbIn);
	var det =	(M[0]*((M[4]*M[8]) - (M[5]*M[7]))) -
				(M[1]*((M[3]*M[8]) - (M[5]*M[6]))) +
				(M[2]*((M[3]*M[7]) - (M[4]*M[6])));
	if (det === 0) {
		return false;
	}
	return new Float64Array([
		((M[4]*M[8])-(M[5]*M[7]))/det, ((M[2]*M[7])-(M[1]*M[8]))/det, ((M[1]*M[5])-(M[2]*M[4]))/det,
		((M[5]*M[6])-(M[3]*M[8]))/det, ((M[0]*M[8])-(M[2]*M[6]))/det, ((M[2]*M[3])-(M[0]*M[5]))/det,
		((M[3]*M[7])-(M[4]*M[6]))/det, ((M[1]*M[6])-(M[0]*M[7]))/det, ((M[0]*M[4])-(M[1]*M[3]))/det
	]);
};
LUTVolume.prototype.getDetails = function() {
	var out = {
		title: this.title,
		format: this.format,
		dims: 3,
		s: this.d,
		min: new Float64Array([this.fL[0],this.fL[1],this.fL[2]]),
		max: new Float64Array([this.fH[0],this.fH[1],this.fH[2]]),
		C: this.getRGB(),
		meta: this.meta
	};
	return out;
};
LUTVolume.prototype.getL = function() {
	return this.L.getL();
};
LUTVolume.prototype.getRGB = function() {
	var d = this.d;
	var nd = d+2;
	var m = d*d*d;
	var nm = nd*nd*nd;
	var R = new Float64Array(m);
	var G = new Float64Array(m);
	var B = new Float64Array(m);
	var k,l;
	var p = this.mesh;
	for (var b=0; b<d; b++) {
		for (var g=0; g<d; g++) {
			for (var r=0; r<d; r++) {
				k = r + ((g + (b*d))*d);
				l = (r+1) + (((g+1) + ((b+1)*nd))*nd);
				R[k] = p[l];
				l += nm;
				G[k] = p[l];
				l += nm;
				B[k] = p[l];
			}
		}
	}
	return [R.buffer,G.buffer,B.buffer];
};
LUTVolume.prototype.getSize = function() {
	return this.d;
};
LUTVolume.prototype.is1D = function() {
	return false;
};
LUTVolume.prototype.is3D = function() {
	return true;
};
LUTVolume.prototype.getTitle = function() {
	return this.title;
};
LUTVolume.prototype.getMetadata = function() {
	return this.meta;
};
LUTVolume.prototype.isClamped = function() {
	if (typeof this.clamped === 'undefined') {
		var mm = this.minMax();
		var min = Math.min(mm[0],mm[1],mm[2]);
		var max = Math.max(mm[3],mm[4],mm[5]);
		if ((min === 0 && max <= 1) || (min >= 0 && max === 1)) {
			this.clamped = true;
		} else {
			this.clamped = false;
		}
	}
	return this.clamped;
};
LUTVolume.prototype.deClamp = function() {
	if (this.isClamped()) {
		this.deClamp1D();
		this.deClamp3D();
	}
};
//
LUTVolume.prototype.getColourSpace = function() {
	var d = this.d;
	var fL = this.fL;
	var fH = this.fH;
	var fLH = this.fLH;
	var out = {
		title: this.title + 'CS',
		format: this.format,
		fLR: fL[0],
		fLG: fL[1],
		fLB: fL[2],
		fHR: fH[0],
		fHG: fH[1],
		fHB: fH[2]
	};
	var reverse = new LUTRSpline({ buff:this.L.getL(), fH:fH[3], fL:fL[3] });
	var base = this.getRGB();
	reverse.R(base[0]);
	reverse.R(base[1]);
	reverse.R(base[2]);
	out.buffR = base[0];
	out.buffG = base[1];
	out.buffB = base[2];
	return new LUTVolume(out);
};
LUTVolume.prototype.deClamp1D = function() {
	var m = this.d;
	var r = new Float64Array(m);
	var g = new Float64Array(m);
	var b = new Float64Array(m);
	var rL = 0;
	var gL = 0;
	var bL = 0;
	var rH = m-1;
	var gH = m-1;
	var bH = m-1;
	var nd = this.d + 2;
	var nm = nd*nd*nd;
	var k;
	var M = this.mesh;
	var rC = false;
	var gC = false;
	var bC = false;
	var fL = Math.min(this.fL[0],this.fL[1],this.fL[2]);
	var fH = Math.max(this.fH[0],this.fH[1],this.fH[2]);
	var fLH= fH-fL;
	// Fill three arrays with values from the gray diagonal of the mesh, and find the index where the values are not 0 or 1
	for (var j=0; j<m; j++) {
		k = (j+1) + (((j+1) + ((j+1)*nd))*nd);
		r[j] = M[k];
		k += nm;
		g[j] = M[k];
		k += nm;
		b[j] = M[k];
		if (j>0) {
//			if (r[j] === 0 && r[j-1] === 0) {
			if (r[j] === 0) {
				rC = true;
				rL = j+1;
			}
//			if (g[j] === 0 && g[j-1] === 0) {
			if (g[j] === 0) {
				gC = true;
				gL = j+1;
			}
//			if (b[j] === 0 && b[j-1] === 0) {
			if (b[j] === 0) {
				bC = true;
				bL = j+1;
			}
		}
	}
	for (var j=m-2; j>=0; j--) {
//		if (r[j] === 1 && (r[j+1] === 1 || rC)) {
		if (r[j] === 1) {
			rC = true;
			rH = j-1;
		}
//		if (g[j] === 1 && (g[j+1] === 1 || gC)) {
		if (g[j] === 1) {
			gC = true;
			gH = j-1;
		}
//		if (b[j] === 1 && (b[j+1] === 1 || bC)) {
		if (b[j] === 1) {
			bC = true;
			bH = j-1;
		}
	}
	// if the 0 index is greater than 0 or the 1 index less than m-1, make a spline to fill in the gaps
	if (rC || gC || bC) {
		var low;
		if (rL > rH) {
			low = rH;
			rH = Math.min(rL-2,m-1);
			rL = Math.max(low+2,0);
		}
		if (gL > gH) {
			low = gH;
			gH = Math.min(gL-2,m-1);
			gL = Math.max(low+2,0);
		}
		if (bL > bH) {
			low = bH;
			bH = Math.min(bL-2,m-1);
			bL = Math.max(low+2,0);
		}
		var rS,gS,bS;
		if (rC) {
			rS = new LUTQSpline(new Float64Array(r.subarray(rL,rH-rL+1)).buffer);
		} else {
			rS = new LUTQSpline(r.buffer);
		}
		if (gC) {
			gS = new LUTQSpline(new Float64Array(g.subarray(gL,gH-gL+1)).buffer);
		} else {
			gS = new LUTQSpline(g.buffer);
		}
		if (bC) {
			bS = new LUTQSpline(new Float64Array(b.subarray(bL,bH-bL+1)).buffer);
		} else {
			bS = new LUTQSpline(b.buffer);
		}
		// Now built an array to replace the 'L' spline from this.buildL()
		var m2 = m;
		if (m < 65) {
			m2 = 65;
		}
		var FD = new Float64Array(m2);
		var rI = new Float64Array(m2);
		for (var j=0; j<m2; j++) { // create rgb array of input values
			rI[j] = (j*(fLH)/(m2-1))+fL;
		}
		var gI = new Float64Array(rI);
		var bI = new Float64Array(rI);
		// apply input scaling as required
		if (this.fS) {
			for (var j=0; j<m2; j++) {
				rI[j] = (rI[j] - this.fL[0])/(this.fLH[0]);
				gI[j] = (gI[j] - this.fL[1])/(this.fLH[1]);
				bI[j] = (bI[j] - this.fL[2])/(this.fLH[2]);
			}
		}
		if (this.sin) {
			this.ins.FCub(rI.buffer);
			this.ins.FCub(gI.buffer);
			this.ins.FCub(bI.buffer);
		}
		// scale for any clamped splines
		for (var j=0; j<m2; j++) {
			rI[j] = ((rI[j]*(m-1)) - rL)/(rH-rL);
			gI[j] = ((gI[j]*(m-1)) - gL)/(gH-gL);
			bI[j] = ((bI[j]*(m-1)) - bL)/(bH-bL);
		}
		// pass through the splines
		rS.FCub(rI.buffer);
		gS.FCub(gI.buffer);
		bS.FCub(bI.buffer);
		// bring together the results to make the L array
		for (var j=0; j<m2; j++) {
			rI[j] = (rI[j]*this.Y[0]) + (gI[j]*this.Y[1]) + (bI[j]*this.Y[2]);
		}
		// replace the 'L' spline - make it reversible as that will be needed for 3D declamping
		this.L = new LUTSpline({ buff:rI.buffer, fH:fH, fL:fL });
		this.clamped = false;
		return true;
	} else {
		return false;
	}
};
LUTVolume.prototype.deClamp3D = function() {
	var d = this.d;
	var d3 = 3*d;
	var nd = d+2;
	var nd2 = nd * nd;
	var nm = nd*nd*nd;
	var sG = nd2 * nd;
	var sB = 2 * sG;
	var M = this.mesh;
	var r = new Float64Array(d);
	var g = new Float64Array(d);
	var b = new Float64Array(d);
	var l,k;
	var rC,gC,bC;
	var rL,gL,bL;
	var rH,gH,bH;
	var low;
	var minMax = this.minMax();
	var lo = Math.min(0, Math.min(minMax[0],minMax[1],minMax[2])); // 0, or the lowest value in the mesh, whichever the lesser
	var hi = Math.max(1, Math.max(minMax[3],minMax[4],minMax[5])); // 1.0, or the highest value in the mesh, whichever the greater
	var min = lo - 0.1; // 10% below the 'lo' value
	var max = hi + 0.175; // 17.5% above 'hi' value
	var limits = new Float64Array([lo,hi,min,max]);
	// First sort out inner splines
	for (var x=0; x<d; x++) {
		for (var y=0; y<d; y++) {
			rL = 0;
			gL = 0;
			bL = 0;
			rH = d-1;
			gH = d-1;
			bH = d-1;
			rC = false;
			gC = false;
			bC = false;
			for (var z=0; z<d; z++) {
				l = (z+1) + (((y+1) + ((x+1)*nd))*nd);
				r[z] = M[l];
				l = (y+1) + (((z+1) + ((x+1)*nd))*nd) + nm;
				g[z] = M[l];
				l = (y+1) + (((x+1) + ((z+1)*nd))*nd) + (2*nm);
				b[z] = M[l];
				if (z>0) {
//					if (r[z] === 0 && r[z-1] === 0) {
					if (r[z] === 0) {
						rC = true;
						rL = z+1;
					}
//					if (g[z] === 0 && g[z-1] === 0) {
					if (g[z] === 0) {
						gC = true;
						gL = z+1;
					}
//					if (b[z] === 0 && b[z-1] === 0) {
					if (b[z] === 0) {
						bC = true;
						bL = z+1;
					}
				}
			}
			for (var z=d-2; z>=0; z--) {
//				if (r[z] === 1 && (r[z+1] === 1 || rC)) {
				if (r[z] === 1) {
					rC = true;
					rH = z-1;
				}
//				if (g[z] === 1 && (g[z+1] === 1 || gC)) {
				if (g[z] === 1) {
					gC = true;
					gH = z-1;
				}
//				if (b[z] === 1 && (b[z+1] === 1 || bC)) {
				if (b[z] === 1) {
					bC = true;
					bH = z-1;
				}
			}
			if (rC) {
				if (rL > rH) {
					low = rH;
					rH = Math.min(rL-2,m-1);
					rL = Math.max(low+2,0);
				}
				this.extrap(r,rL,rH,limits);
				for (var z=0; z<d; z++) {
					if (z === rL) {
						z = rH;
					}
					l = (z+1) + (((y+1) + ((x+1)*nd))*nd);
					M[l] = r[z];
				}
			}
			if (gC) {
				if (gL > gH) {
					low = gH;
					gH = Math.min(gL-2,m-1);
					gL = Math.max(low+2,0);
				}
				this.extrap(g,gL,gH,limits);
				for (var z=0; z<d; z++) {
					if (z === gL) {
						z = gH;
					}
					l = (y+1) + (((z+1) + ((x+1)*nd))*nd) + nm;
					M[l] = g[z];
				}
			}
			if (bC) {
				if (bL > bH) {
					low = bH;
					bH = Math.min(bL-2,m-1);
					bL = Math.max(low+2,0);
				}
				this.extrap(b,bL,bH,limits);
				for (var z=0; z<d; z++) {
					if (z === bL) {
						z = bH;
					}
					l = (y+1) + (((x+1) + ((z+1)*nd))*nd) + (2*nm);
					M[l] = b[z];
				}
			}
		}
	}
	// Now fill in the edges and corners as with this.fillEdges()
	d--;
	for (var x=1; x<(d); x++) {
		for (var y=0; y<d; y++) {
			this.n3b( x, y, 0);
			this.n3b( x, y, d);
			this.n3b( x, 0, y);
			this.n3b( x, d, y);
			this.n3b( 0, x, y);
			this.n3b( d, x, y);
		}
		this.n3b( x, 0, 0);
		this.n3b( x, 0, d);
		this.n3b( x, d, 0);
		this.n3b( x, d, d);
		this.n3b( 0, x, 0);
		this.n3b( 0, x, d);
		this.n3b( d, x, 0);
		this.n3b( d, x, d);
		this.n3b( 0, 0, x);
		this.n3b( 0, d, x);
		this.n3b( d, 0, x);
		this.n3b( d, d, x);
	}
	this.n3b( 0, 0, 0);
	this.n3b( 0, 0, d);
	this.n3b( 0, d, 0);
	this.n3b( 0, d, d);
	this.n3b( d, 0, 0);
	this.n3b( d, 0, d);
	this.n3b( d, d, 0);
	this.n3b( d, d, d);
	// Repopulate the outer edges of the mesh
	this.fillEdges();
	this.clamped = false;
};
LUTVolume.prototype.extrap = function(c,L,H,limits) {
	var m = c.length;
	var dcLo,dcHi;
	if (H-L > 2) { // more than four points
		dcLo = (0.1*c[L+3]) - (0.8*c[L+2]) + (2.3*c[L+1]) - (1.6*c[L]);
		dcHi = (-0.1*c[H-3]) + (0.8*c[H-2]) - (2.3*c[H-1]) + (1.6*c[H]);
	} else if (H-L > 1) { // three points
		dcLo = 1;
		dcHi = 1;
	} else { // two points
		dcLo = c[L+1] - c[L];
		dcHi = c[H] - c[H-1];
	}
	if (L > 0) {
		for (var j=0; j<L; j++) {
			c[j] = c[L] + ((j-L)*dcLo);
		}
	}
	if (H < m-1) {
		for (var j=H+1; j<m; j++) {
			c[j] = c[H] + ((j-H)*dcHi);
		}
	}
	if (typeof limits !== 'undefined') {
		var lo = limits[0];
		var hi = limits[1];
		var min = limits[2];
		var max = limits[3];
		var numLo = Math.pow(min-lo,2);
		var denLo = min-lo;
		var numHi = Math.pow(max-hi,2);
		var denHi = max-hi;
		for (var j=0; j<m; j++) {
			if (j === L) {
				j = H+1;
			}
			if (c[j] < lo) {
				c[j] = min - (numLo/((dcLo*(c[j]-lo))+denLo));
			} else if (c[j] > hi) {
				c[j] = max - (numHi/((dcHi*(c[j]-hi))+denHi));
			}
		}
	}
};
LUTVolume.prototype.fillEdges = function() {
	var d = this.d;
	// fill in the gaps in the new mesh
	for (var x=0; x<d; x++) {
		for (var y=0; y<d; y++) {
			this.n3( x, y,-1);
			this.n3( x, y, d);
			this.n3( x,-1, y);
			this.n3( x, d, y);
			this.n3(-1, x, y);
			this.n3( d, x, y);
		}
		this.n3( x,-1,-1);
		this.n3( x,-1, d);
		this.n3( x, d,-1);
		this.n3( x, d, d);
		this.n3(-1, x,-1);
		this.n3(-1, x, d);
		this.n3( d, x,-1);
		this.n3( d, x, d);
		this.n3(-1,-1, x);
		this.n3(-1, d, x);
		this.n3( d,-1, x);
		this.n3( d, d, x);
	}
	this.n3(-1,-1,-1);
	this.n3(-1,-1, d);
	this.n3(-1, d,-1);
	this.n3(-1, d, d);
	this.n3( d,-1,-1);
	this.n3( d,-1, d);
	this.n3( d, d,-1);
	this.n3( d, d, d);
};
LUTVolume.prototype.setP = function(rM,gM,bM,rgb) {
	// setP is used to change an individual mesh point. The inputs rM, gM, bM are zero-indexed coordinates on the base mesh
	// rgb is a Float64Array of the r, g and b values to be set at the specified mesh point
	// setP returns a Float64Array of the rgb value before changing
	var M = this.mesh;
	var d = this.d-1;
	var s = d-4;
	var nd = this.nd;
	var nd2 = nd*nd;
	var sG = nd2*nd;
	var sB = 2 * sG;
	var k = (rM + 1) + ((gM + 1)*nd) + ((bM + 1)*nd2);
	var o = new Float64Array([M[ k ], M[k+sG], M[k+sB]]);
	M[ k ] = rgb[0];
	M[k+sG] = rgb[1];
	M[k+sB] = rgb[2];
	// recalculate any edges, faces or corners in the extended mesh affected by the value change
	if (rM < 4) {
		// faces
		this.n3(-1,gM,bM);
		// edges
		if (gM ===   rM) { this.n3(-1,-1,bM); }
		if (gM === s-rM) { this.n3(-1, d,bM); }
		if (bM ===   rM) { this.n3(-1,gM,-1); }
		if (bM === s-rM) { this.n3(-1,gM, d); }
		// corners
		if (gM ===   rM && bM ===   rM) { this.n3(-1,-1,-1); }
		if (gM === s-rM && bM ===   rM) { this.n3(-1, d,-1); }
		if (gM === s-rM && bM === s-rM) { this.n3(-1, d, d); }
		if (gM ===   rM && bM === s-rM) { this.n3(-1,-1, d); }
	}
	if (rM > s) {
		// faces
		this.n3( d,gM,bM);
		// edges
		if (gM ===   rM) { this.n3( d, d,bM); }
		if (gM === rM-s) { this.n3( d,-1,bM); }
		if (bM ===   rM) { this.n3( d,gM, d); }
		if (bM === rM-s) { this.n3( d,gM,-1); }
		// corners
		if (gM ===   rM && bM ===   rM) { this.n3( d, d, d); }
		if (gM === rM-s && bM ===   rM) { this.n3( d,-1, d); }
		if (gM === rM-s && bM === rM-s) { this.n3( d,-1,-1); }
		if (gM ===   rM && bM === rM-s) { this.n3( d, d,-1); }
	}
	if (gM < 4) {
		// faces
		this.n3(rM,-1,bM);
		// edges
		if (bM ===   gM) { this.n3(rM,-1,-1); }
		if (bM === s-gM) { this.n3(rM,-1, d); }
	}
	if (gM > s) {
		// faces
		this.n3(rM, d,bM);
		// edges
		if (bM ===   gM) { this.n3(rM, d,-1); }
		if (bM === gM-s) { this.n3(rM, d, d); }
	}
	if (bM < 4) { this.n3(rM,gM,-1); }
	if (bM > s) { this.n3(rM,gM, d); }
	return o;
};
LUTVolume.prototype.getP = function(rM,gM,bM) {
	var M = this.mesh;
	var nd = this.nd;
	var nd2 = nd*nd;
	var sG = nd2*nd;
	var sB = 2 * sG;
	var k = (rM + 1) + ((gM + 1)*nd) + ((bM + 1)*nd2);
	return new Float64Array([M[ k ],M[k+sG],M[k+sB]]);
};
LUTVolume.prototype.n3 = function(rM,gM,bM,mono) {
	// 3D extrapolation - calculates all colour channels at once
	// rM, gM and bM are mesh point coordinates relative to the base mesh, not the extended, precalculated one
	// ie -1 means the bottom edge of the extended mesh, this.d the top edge
	var rD,gD,bD;
	var d = this.d - 1;
	var pR = this.pR;
	var pG = this.pG;
	var pB = this.pB;
	var o,m;
	// Get the array position on the extended mesh that we are going to fill
	var nd = this.nd;
	var nd2 = nd*nd
	var k = (rM+1) + ((gM + 1)*nd) + ((bM + 1)*nd2);
	// Establish which way the points need to go, and from what base
	if (rM < 0) {
		rD = 1;
	} else if (rM > d) {
		rD = -1;
	} else {
		rD = 0;
	}
	if (gM < 0) {
		gD = 1;
	} else if (gM > d) {
		gD = -1;
	} else {
		gD = 0;
	}
	if (bM < 0) {
		bD = 1;
	} else if (bM > d) {
		bD = -1;
	} else {
		bD = 0;
	}
	// Fill in the points to be extrapolated
	var M = this.mesh;
	var sG = nd2*nd;
	var sB = 2 * sG;
	var l = k + rD + (gD*nd) + (bD*nd2);
	pR[3] = M[l];
	pG[3] = M[l + sG];
	pB[3] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[2] = M[l];
	pG[2] = M[l + sG];
	pB[2] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[1] = M[l];
	pG[1] = M[l + sG];
	pB[1] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[0] = M[l];
	pG[0] = M[l + sG];
	pB[0] = M[l + sB];
	// Now calculate the values
	// Red
	m = 0;
	if (pR[3] === pR[1]) {
		M[k] = pR[2];
//	} else if (typeof mono !== 'undefined') {
//		m = -mono*rD;
	} else if (pR[3] > pR[1]) {
		m = 1;
	} else {
		m = -1;
	}

	if (m !== 0) {
		o = (-0.4*pR[0]) + (2.2*pR[1]) - (4.2*pR[2]) + (3.4*pR[3]);
		if ((o-pR[2])*m <= 0) { // make sure that the slope at y(1) doesn't change sign
			o = pR[1] - (3*pR[2]) + (3*pR[3]);
			if ((o-pR[2])*m <= 0) { // if it is still swapping signs, use a slope of 0, ie y(2) = y(1)
				o = pR[2]; // this allows for a completely flat extrapolation, ie slope = 0 at y(1)
			}
		}
		M[k] = o;
	}
	// Green
	m = 0;
	if (pG[3] === pG[1]) {
		M[k + sG] = pG[2];
//	} else if (typeof mono !== 'undefined') {
//		m = -mono*gD;
	} else if (pG[3] > pG[1]) {
		m = 1;
	} else {
		m = -1;
	}
	if (m !== 0) {
		o = (-0.4*pG[0]) + (2.2*pG[1]) - (4.2*pG[2]) + (3.4*pG[3]);
		if ((o-pG[2])*m <= 0) { // make sure that the slope at y(1) doesn't change sign
			o = pG[1] - (3*pG[2]) + (3*pG[3]);
			if ((o-pG[2])*m <= 0) { // if it is still swapping signs, use a slope of 0, ie y(2) = y(1)
				o = pG[2]; // this allows for a completely flat extrapolation, ie slope = 0 at y(1)
			}
		}
		M[k + sG] = o;
	}
	// Blue
	m = 0;
	if (pB[3] === pB[1]) {
		M[k + sB] = pB[2];
//	} else if (typeof mono !== 'undefined') {
//		m = -mono*bD;
	} else if (pB[3] > pB[1]) {
		m = 1;
	} else {
		m = -1;
	}
	if (m !== 0) {
		o = (-0.4*pB[0]) + (2.2*pB[1]) - (4.2*pB[2]) + (3.4*pB[3]);
		if ((o-pB[2])*m <= 0) { // make sure that the slope at y(1) doesn't change sign
			o = pB[1] - (3*pB[2]) + (3*pB[3]);
			if ((o-pB[2])*m <= 0) { // if it is still swapping signs, use a slope of 0, ie y(2) = y(1)
				o = pB[2]; // this allows for a completely flat extrapolation, ie slope = 0 at y(1)
			}
		}
		M[k + sB] = o;
	}
};
LUTVolume.prototype.n3b = function(rM,gM,bM) {
	// 3D extrapolation - calculates all colour channels at once
	// rM, gM and bM are mesh point coordinates relative to the base mesh, not the extended, precalculated one
	// this differs from the basic n3 as it is for filling in the edges, corners and faces of the base mesh
	// after a declamp, to allow for interaction of colour channels, ie 0 is to bottom, this.d-1 the top.
	var rD,gD,bD;
	var d = this.d - 1;
	var pR = this.pR;
	var pG = this.pG;
	var pB = this.pB;
	var o,m;
	// Get the array position on the extended mesh that we are going to fill
	var nd = this.nd;
	var nd2 = nd*nd
	var k = (rM+1) + ((gM + 1)*nd) + ((bM + 1)*nd2);
	// Establish which way the points need to go, and from what base
	if (rM <= 0) {
		rD = 1;
	} else if (rM >= d) {
		rD = -1;
	} else {
		rD = 0;
	}
	if (gM <= 0) {
		gD = 1;
	} else if (gM >= d) {
		gD = -1;
	} else {
		gD = 0;
	}
	if (bM <= 0) {
		bD = 1;
	} else if (bM >= d) {
		bD = -1;
	} else {
		bD = 0;
	}
	// Fill in the points to be extrapolated
	var M = this.mesh;
	var sG = nd2*nd;
	var sB = 2 * sG;
	var l = k + rD + (gD*nd) + (bD*nd2);
	pR[3] = M[l];
	pG[3] = M[l + sG];
	pB[3] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[2] = M[l];
	pG[2] = M[l + sG];
	pB[2] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[1] = M[l];
	pG[1] = M[l + sG];
	pB[1] = M[l + sB];
	l += rD + (gD*nd) + (bD*nd2);
	pR[0] = M[l];
	pG[0] = M[l + sG];
	pB[0] = M[l + sB];
	// Now calculate the values
	M[ k  ] = - (0.1*pR[0]) + (0.8*pR[1]) - (2.3*pR[2]) + (2.6*pR[3]);
	M[k+sG] = - (0.1*pG[0]) + (0.8*pG[1]) - (2.3*pG[2]) + (2.6*pG[3]);
	M[k+sB] = - (0.1*pB[0]) + (0.8*pB[1]) - (2.3*pB[2]) + (2.6*pB[3]);
};
LUTVolume.prototype.compare = function(tgtBuff,tstBuff,method) {
	// returns the RMS differences in the red channels between a target dataset (tgt) and a test dataset (tst) which 'compare' passes through the lut
	// method sets the interpolation method used on the test set, currently trilinear (1, 'lin' or 'linear') or tricubic (anything else or the default if 'method' is not present.
	var tgt = new Float64Array(tgtBuff.slice(0));
	var tst = new Float64Array(tstBuff.slice(0));
	var m = tgt.length;
	if (m !== tst.length) {
		return false;
	}
	if (typeof method !== 'undefined') {
		method = method.toString().toLowerCase();
		if (method === '1' || method === 'tet') {
			this.RGBTet(tst.buffer);
		} else if (method === '2' || method === 'lin') {
			this.RGBLin(tst.buffer);
		} else {
			this.RGBCub(tst.buffer);
		}
	} else {
		this.RGBCub(tst.buffer);
	} 
	var e = new Float64Array(3);
	for (var j=0; j<m; j += 3) {
		e[0]  += Math.pow(tst[ j ] - tgt[ j ],2);
		e[1]  += Math.pow(tst[j+1] - tgt[j+1],2);
		e[2]  += Math.pow(tst[j+2] - tgt[j+2],2);
	}
	e[0] = Math.pow(e[0]*3/m,0.5);
	e[1] = Math.pow(e[1]*3/m,0.5);
	e[2] = Math.pow(e[2]*3/m,0.5);
	return e;
};
LUTVolume.prototype.NR3D = function(tgt,tolerence,maxIterations,seed) { // Multivariate (3D) Newton-Raphson
	if (tgt.length === 3) {
		var tol,m,x;
		if (typeof tolerence === 'number') { // tolerence for what is considered close enough
			tol = tolerence;
		} else {
			tol = 0.00000001;
		}
		tol *= tol; // saves putting a square root into the convergence test
		if (typeof maxItrss === 'number') { // maximum number of iterations before giving up (ie poor convergence)
			m = maxItrs;
		} else {
			m = 50;
		}
		if (typeof seed !== 'undefined' && seed.length === 3) { // initial 'seed' value - if none given use the target
			x = new Float64Array([seed[0],seed[1],seed[2]],0);
		} else {
			x = new Float64Array([tgt[0],tgt[1],tgt[2]],0);
		}
		var f,Jinv,d;
		for (var j=0; j<m; j++) {
			f = this.rgbCub(x);
			JInv = this.JInv(x);
			if (JInv) {
				// Newton-Raphson is a root (0) finder, so subtract the target values
				f[0] -= tgt[0];
				f[1] -= tgt[1];
				f[2] -= tgt[2];
				// Test for convergence
				x[3] = (f[0]*f[0]) + (f[1]*f[1]) + (f[2]*f[2]);
				if (x[3] < tol) {
					x[3] = 0;
					return x;
				} else if (j === m-1) { // last pass - it's not converging
					x[3] = Math.pow(x[3],0.5); // distance from target 
					return x;
				} else {
					x[0] -= (Jinv[0]*f[0]) + (JInv[1]*f[1]) + (JInv[2]*f[2]);
					x[1] -= (Jinv[3]*f[0]) + (JInv[4]*f[1]) + (JInv[5]*f[2]);
					x[2] -= (Jinv[6]*f[0]) + (JInv[7]*f[1]) + (JInv[8]*f[2]);
				}
			} else {
				return false;
			}
		}
	} else {
		return false
	}
};
LUTVolume.prototype.minMax = function() {
	var p = this.mesh;
	var x = new Float64Array([
		 9999, 9999, 9999,	// Absolute min values
		-9999,-9999,-9999	// Absolute max values
	]);
	var rgb = new Float64Array(3);
	var m = this.d;
	var nd = this.d+2;
	var nm = nd*nd*nd;
	var l;
	// First find the minimum and maximum values in the mesh, independent of each other
	for (var b=0; b<m; b++) {
		for (var g=0; g<m; g++) {
			for (var r=0; r<m; r++) {
				l = (r+1) + (((g+1) + ((b+1)*nd))*nd);
				if (p[l] < x[0]) {
					x[0] = p[l];
				} else if (p[l] > x[3]) {
					x[3] = p[l];
				}
				l += nm;
				if (p[l] < x[1]) {
					x[1] = p[l];
				} else if (p[l] > x[4]) {
					x[4] = p[l];
				}
				l += nm;
				if (p[l] < x[2]) {
					x[2] = p[l];
				} else if (p[l] > x[5]) {
					x[5] = p[l];
				}
			}
		}
	}
	return x;
};
LUTVolume.prototype.getLimits = function(minMax) {
	var p = this.mesh;
	var x;
	if (typeof minMax !== 'undefined') {
		x = minMax;
	} else {
		x = this.minMax();
	}
	var o = new Float64Array([
		 9999, 9999, 9999,	// Black
		-9999, 9999, 9999,	// Red
		-9999,-9999, 9999,	// Yellow
		 9999,-9999, 9999,	// Green
		 9999,-9999,-9999,	// Cyan
		 9999, 9999,-9999,	// Blue
		-9999, 9999,-9999,	// Magenta
		-9999,-9999,-9999	// White
	]);
	var i = new Float64Array(24);
	var d = new Float64Array([
		9999,9999,9999,9999,9999,9999,9999,9999
	]);
	var rgb = new Float64Array(3);
	var m = this.d;
	var nd = this.d+2;
	var nm = nd*nd*nd;
	var s = m-1;
	var D;
	var l;
	// Now go back through the mesh, comparing distances from the absolute corners
	for (var b=0; b<m; b++) {
		for (var g=0; g<m; g++) {
			for (var r=0; r<m; r++) {
				l = (r+1) + (((g+1) + ((b+1)*nd))*nd);
				rgb[0] = p[l];
				l += nm;
				rgb[1] = p[l];
				l += nm;
				rgb[2] = p[l];
				D = Math.pow(rgb[0]-x[0],2)+Math.pow(rgb[1]-x[1],2)+Math.pow(rgb[2]-x[2],2);	// Black
				if (D < d[0]) {
					o[ 0] = rgb[0];
					o[ 1] = rgb[1];
					o[ 2] = rgb[2];
					i[ 0] = r;
					i[ 1] = g;
					i[ 2] = b;
					d[0] = D;
				}
				D = Math.pow(rgb[0]-x[3],2)+Math.pow(rgb[1]-x[1],2)+Math.pow(rgb[2]-x[2],2);	// Red
				if (D < d[1]) {
					o[ 3] = rgb[0];
					o[ 4] = rgb[1];
					o[ 5] = rgb[2];
					i[ 3] = r;
					i[ 4] = g;
					i[ 5] = b;
					d[1] = D;
				}
				D = Math.pow(rgb[0]-x[3],2)+Math.pow(rgb[1]-x[4],2)+Math.pow(rgb[2]-x[2],2);	// Yellow
				if (D < d[2]) {
					o[ 6] = rgb[0];
					o[ 7] = rgb[1];
					o[ 8] = rgb[2];
					i[ 6] = r;
					i[ 7] = g;
					i[ 8] = b;
					d[2] = D;
				}
				D = Math.pow(rgb[0]-x[0],2)+Math.pow(rgb[1]-x[4],2)+Math.pow(rgb[2]-x[2],2);	// Green
				if (D < d[3]) {
					o[ 9] = rgb[0];
					o[10] = rgb[1];
					o[11] = rgb[2];
					i[ 9] = r;
					i[10] = g;
					i[11] = b;
					d[3] = D;
				}
				D = Math.pow(rgb[0]-x[0],2)+Math.pow(rgb[1]-x[4],2)+Math.pow(rgb[2]-x[5],2);	// Cyan
				if (D < d[4]) {
					o[12] = rgb[0];
					o[13] = rgb[1];
					o[14] = rgb[2];
					i[12] = r;
					i[13] = g;
					i[14] = b;
					d[4] = D;
				}
				D = Math.pow(rgb[0]-x[0],2)+Math.pow(rgb[1]-x[1],2)+Math.pow(rgb[2]-x[5],2);	// Blue
				if (D < d[5]) {
					o[15] = rgb[0];
					o[16] = rgb[1];
					o[17] = rgb[2];
					i[15] = r;
					i[16] = g;
					i[17] = b;
					d[5] = D;
				}
				D = Math.pow(rgb[0]-x[3],2)+Math.pow(rgb[1]-x[1],2)+Math.pow(rgb[2]-x[5],2);	// Magenta
				if (D < d[6]) {
					o[18] = rgb[0];
					o[19] = rgb[1];
					o[20] = rgb[2];
					i[18] = r;
					i[19] = g;
					i[20] = b;
					d[6] = D;
				}
				D = Math.pow(rgb[0]-x[3],2)+Math.pow(rgb[1]-x[4],2)+Math.pow(rgb[2]-x[5],2);	// White
				if (D < d[7]) {
					o[21] = rgb[0];
					o[22] = rgb[1];
					o[23] = rgb[2];
					i[21] = r;
					i[22] = g;
					i[23] = b;
					d[7] = D;
				}
			}
		}
	}
	for (var j=0; j<24; j++) {
		i[j] /= s
	}
	if (this.sin) {
		var rev = new LUTRSpline({
			buff: this.ins.getL()
		});
		rev.R(i.buffer);
	}
	if (this.fS) {
		var fL = this.fL;
		var fLH = this.fLH;
		for (var j=0; j<24; j += 3) {
			i[ j ] = (i[ j ]*fLH[0]) + fL[0];
			i[j+1] = (i[j+1]*fLH[1]) + fL[1];
			i[j+2] = (i[j+2]*fLH[2]) + fL[2];
		}
	}
	return {minMax:x, i:i, o:o};
};
// Stringify for inline Web Workers
function getLUTString() {
	var out = "";
	// LUTs
	out += LUTs.toString() + "\n";
	for (var j in LUTs.prototype) {
		out += 'LUTs.prototype.' + j + '=' + LUTs.prototype[j].toString() + "\n";
	}
	// LUTSpline
	out += LUTSpline.toString() + "\n";
	for (var j in LUTSpline.prototype) {
		out += 'LUTSpline.prototype.' + j + '=' + LUTSpline.prototype[j].toString() + "\n";
	}
	// LUTRGBSpline
	out += LUTRGBSpline.toString() + "\n";
	for (var j in LUTRGBSpline.prototype) {
		out += 'LUTRGBSpline.prototype.' + j + '=' + LUTRGBSpline.prototype[j].toString() + "\n";
	}
	// LUTRSpline
	out += LUTRSpline.toString() + "\n";
	for (var j in LUTRSpline.prototype) {
		out += 'LUTRSpline.prototype.' + j + '=' + LUTRSpline.prototype[j].toString() + "\n";
	}
	// LUTQSpline
	out += LUTQSpline.toString() + "\n";
	for (var j in LUTQSpline.prototype) {
		out += 'LUTQSpline.prototype.' + j + '=' + LUTQSpline.prototype[j].toString() + "\n";
	}
	// LUTVolume
	out += LUTVolume.toString() + "\n";
	for (var j in LUTVolume.prototype) {
		out += 'LUTVolume.prototype.' + j + '=' + LUTVolume.prototype[j].toString() + "\n";
	}
	return out;
}
var workerLUTString = getLUTString();
